<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"mst123.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="学习记录">
<meta property="og:type" content="website">
<meta property="og:title" content="博客">
<meta property="og:url" content="https://mst123.github.io/page/8/index.html">
<meta property="og:site_name" content="博客">
<meta property="og:description" content="学习记录">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="马农">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://mst123.github.io/page/8/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/8/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">博客</h1>
      <i class="logo-line"></i>
    </a>
      <img class="custom-logo-image" src="/images/gintama.jpg" alt="博客">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="马农"
      src="/images/luopo.gif">
  <p class="site-author-name" itemprop="name">马农</p>
  <div class="site-description" itemprop="description">学习记录</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">105</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">125</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%A6%82%E8%A7%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%A6%82%E8%A7%88/" class="post-title-link" itemprop="url">数据类型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-24 00:00:00" itemprop="dateCreated datePublished" datetime="2021-03-24T00:00:00+08:00">2021-03-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-13 13:13:37" itemprop="dateModified" datetime="2024-07-13T13:13:37+08:00">2024-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" itemprop="url" rel="index"><span itemprop="name">数据类型</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ul>
<li>基本数据类型<ul>
<li>Undefined</li>
<li>Null</li>
<li>Boolean</li>
<li>Number</li>
<li>String</li>
<li>Symbol</li>
</ul>
</li>
<li>复杂类型：<ul>
<li>Object</li>
</ul>
</li>
</ul>
<h1 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h1><p>对一个值使用 typeof 操作符会返回下列字符串之一：</p>
<ul>
<li>“undefined”表示值未定义</li>
<li>“boolean”表示值为布尔值</li>
<li>“string”表示值为字符串</li>
<li>“number”表示值为数值</li>
<li>“object”表示值为对象（而不是函数）或 null</li>
<li>“function”表示值为函数</li>
<li>“symbol”表示值为符号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let message = &quot;some string&quot;; </span><br><span class="line">console.log(typeof message);    // &quot;string&quot; </span><br><span class="line">console.log(typeof(message));   // &quot;string&quot; </span><br><span class="line">console.log(typeof 95);         // &quot;number&quot; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>typeof 是一个操作符而不是函数，所以不需要参数（但可以使用参数）</p>
</blockquote>
<h1 id="数据类型简介"><a href="#数据类型简介" class="headerlink" title="数据类型简介"></a>数据类型简介</h1><h2 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h2><p>Undefined 类型只有一个值，就是特殊值 undefined。<br>包含 undefined 值的变量跟未定义变量是有区别的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let message;    // 这个变量被声明了，只是值为 undefined </span><br><span class="line">// 确保没有声明过这个变量 // let age </span><br><span class="line">console.log(message); // &quot;undefined&quot; </span><br><span class="line">console.log(age);     // 报错</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是 <code>typeof</code> 操作符返回的结果是没有区别的,都是”undefined”</p>
</blockquote>
<h2 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h2><p>Null 类型同样只有一个值，即特殊值 null。逻辑上讲，null 值表示一个空对象指针，这也是给 typeof 传一个 null 会返回”object”的原因<br>undefined 值是由 null 值派生而来的，因此 ECMA-262将它们定义为表面上相等，如下面的例子所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(null == undefined);  // true </span><br><span class="line">console.log(null === undefined);  // false </span><br></pre></td></tr></table></figure>

<h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><p>Boolean（布尔值）类型有两个字面值：true 和 false。<br>虽然布尔值只有两个，但所有其他 ECMAScript类型的值都有相应布尔值的等价形式。要将一个其他类型的值转换为布尔值，可以调用特定的 Boolean()转型函数：<br>转换规则如下：  </p>
<p><img src="/assets/%E6%A6%82%E8%A7%88/Dingtalk_20210407163159.jpg" alt="Dingtalk_20210407163159"></p>
<h2 id="number"><a href="#number" class="headerlink" title="number"></a>number</h2><p>Number 类型使用的是双精度浮点型，也就是其他语言中的double类型。而双精度浮点数使用64 bit来进行存储</p>
<p><img src="/assets/%E6%A6%82%E8%A7%88/16144bd12f9b3376~tplv-t2oaga2asx-watermark.gif" alt="img"></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903557326454791">双精度浮点数详细介绍</a></p>
<h3 id="三种基本类型"><a href="#三种基本类型" class="headerlink" title="三种基本类型"></a>三种基本类型</h3><h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><p>最基本的数值字面量格式是<strong>十进制整数</strong>，直接写出来即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let intNum = 55; // 整数 </span><br></pre></td></tr></table></figure>

<p>整数也可以用<strong>八进制</strong>（以 8 为基数）或<strong>十六进制</strong>（以 16 为基数）字面量表示。</p>
<p>如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let octalNum1 = 070; // 八进制的 56  </span><br><span class="line">let octalNum2 = 079; // 无效的八进制值，当成 79 处理 </span><br><span class="line">let octalNum3 = 08; // 无效的八进制值，当成 8 处理 </span><br></pre></td></tr></table></figure>

<p>八进制字面量在严格模式下是无效的，会导致 JavaScript 引擎抛出语法错误。</p>
<p>要创建十六进制字面量，必须让真正的数值前缀 0x（区分大小写），</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let hexNum1 = 0xA; // 十六进制 10  </span><br><span class="line">let hexNum2 = 0x1f; // 十六进制 31  </span><br></pre></td></tr></table></figure>

<p>使用八进制和十六进制格式创建的数值在所有数学操作中都被视为十进制数值。</p>
<h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。</p>
<p>因为存储浮点值使用的内存空间是存储整数值的两倍，所以 ECMAScript 总是想方设法把值转换为 整数。</p>
<p><strong>如下例所示：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let floatNum1 = 1.; // 小数点后面没有数字，当成整数 1 处理</span><br><span class="line">let floatNum2 = 10.0; // 小数点后面是零，当成整数 10 处理</span><br></pre></td></tr></table></figure>

<p>浮点值的精确度最高可达 17 位小数，但在算术计算中远不如整数精确。例如，0.1 加 0.2 得到的不 是 0.3，而是 0.300 000 000 000 000 04。</p>
<h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p>有一个特殊的数值叫 NaN，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作 失败了（而不是抛出错误）。</p>
<p>NaN 有几个独特的属性：</p>
<ul>
<li><p>任何涉及 NaN 的操作始终返回 NaN（如 NaN&#x2F;10）</p>
</li>
<li><p>NaN 不等于包括 NaN 在内的任何值</p>
<ul>
<li>ECMAScript 提供了 isNaN()函数</li>
</ul>
<blockquote>
<p>把一个值传给 isNaN()后，该函数会尝试把它转换为数值。（使用哪种转换规则未知）<strong>待补充</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(isNaN(NaN)); // true </span><br><span class="line">console.log(isNaN(10)); // false，10 是数值</span><br><span class="line">console.log(isNaN(&quot;10&quot;)); // false，可以转换为数值 10 </span><br><span class="line">console.log(isNaN(&quot;blue&quot;)); // true，不可以转换为数值</span><br><span class="line">console.log(isNaN(true)); // false，可以转换为数值 1 </span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><p><code>Number()</code>、<code>parseInt()</code>和 <code>parseFloat()</code></p>
<p><strong>Number()是 转型函数，可用于<em>任何数据类型</em>。后两个函数主要用于将<em>字符串</em>转换为数值</strong></p>
<h4 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h4><p>Number()是 转型函数，可用于任何数据类型。</p>
<p>Number()函数基于如下规则执行转换(<strong>一元加操作符</strong>与 Number()函数遵循相同的转换规则)。</p>
<ul>
<li>布尔值，true 转换为 1，false 转换为 0。</li>
<li>数值，直接返回。</li>
<li>null，返回 0。</li>
<li>undefined，返回 NaN。</li>
<li><h2 id="字符串，应用以下规则。-如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。-因此，Number-“1”-返回-1，Number-“123”-返回-123，Number-“011”-返回-11（忽略前面-的零）。-如果字符串包含有效的浮点值格式如”1-1”，则会转换为相应的浮点值（同样，忽略前面的零）。-如果字符串包含有效的十六进制格式如”0xf”，则会转换为与该十六进制值对应的十进制整-数值。-如果是空字符串（不包含字符），则返回-0。-如果字符串包含除上述情况之外的其他字符，则返回-NaN。"><a href="#字符串，应用以下规则。-如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。-因此，Number-“1”-返回-1，Number-“123”-返回-123，Number-“011”-返回-11（忽略前面-的零）。-如果字符串包含有效的浮点值格式如”1-1”，则会转换为相应的浮点值（同样，忽略前面的零）。-如果字符串包含有效的十六进制格式如”0xf”，则会转换为与该十六进制值对应的十进制整-数值。-如果是空字符串（不包含字符），则返回-0。-如果字符串包含除上述情况之外的其他字符，则返回-NaN。" class="headerlink" title="字符串，应用以下规则。- 如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。 因此，Number(“1”)返回 1，Number(“123”)返回 123，Number(“011”)返回 11（忽略前面 的零）。- 如果字符串包含有效的浮点值格式如”1.1”，则会转换为相应的浮点值（同样，忽略前面的零）。- 如果字符串包含有效的十六进制格式如”0xf”，则会转换为与该十六进制值对应的十进制整 数值。- 如果是空字符串（不包含字符），则返回 0。- 如果字符串包含除上述情况之外的其他字符，则返回 NaN。"></a>字符串，应用以下规则。<br>- 如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。 因此，Number(“1”)返回 1，Number(“123”)返回 123，Number(“011”)返回 11（忽略前面 的零）。<br>- 如果字符串包含有效的浮点值格式如”1.1”，则会转换为相应的浮点值（同样，忽略前面的零）。<br>- 如果字符串包含有效的十六进制格式如”0xf”，则会转换为与该十六进制值对应的十进制整 数值。<br>- 如果是空字符串（不包含字符），则返回 0。<br>- <strong>如果字符串包含除上述情况之外的其他字符，则返回 NaN。</strong></h2><ul>
<li></li>
<li><pre><code>Number(&quot;a1&quot;); NaN
let num1 = Number(&quot;Hello world!&quot;); // NaN 
let num2 = Number(&quot;&quot;); // 0 
let num3 = Number(&quot;000011&quot;); // 11 
let num4 = Number(true); // 1 
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 对象，调用 valueOf()方法，并按照上述规则转换返回的值。如果转换结果是 NaN，则调用 toString()方法，再按照转换字符串的规则转换。</span><br><span class="line"></span><br><span class="line">#### parseInit()</span><br><span class="line"></span><br><span class="line">parseInt()函数更专注于字符串是否包含数值模式，接收第二个参数，用于指定**底数（进制数）**。。</span><br><span class="line"></span><br><span class="line">parseInt()函数基于如下规则执行转换</span><br><span class="line"></span><br><span class="line">- 字符串最前面的空格会被 忽略，从第一个非空格字符开始转换</span><br><span class="line">- 如果第一个字符不是数值字符、加号或减号，parseInt()立即 返回 NaN</span><br><span class="line">- 如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，**直到字符串末尾，或碰到非数值字符**</span><br><span class="line">- 字符串以&quot;0x&quot;开头，就会被解释为十六进制整数。如果字符串以&quot;0&quot; 开头，且紧跟着数值字符，在**非严格模式**下会被**某些实现**解释为八进制整数</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>let num1 &#x3D; parseInt(“1234blue”); &#x2F;&#x2F; 1234<br>let num2 &#x3D; parseInt(“”); &#x2F;&#x2F; NaN<br>let num3 &#x3D; parseInt(“0xA”); &#x2F;&#x2F; 10，解释为十六进制整数<br>let num4 &#x3D; parseInt(22.5); &#x2F;&#x2F; 22<br>let num5 &#x3D; parseInt(“70”); &#x2F;&#x2F; 70，解释为十进制值<br>let num6 &#x3D; parseInt(“0xf”); &#x2F;&#x2F; 15，解释为十六进制整数<br>let num1 &#x3D; parseInt(“AF”, 16); &#x2F;&#x2F; 175<br>let num2 &#x3D; parseInt(“AF”); &#x2F;&#x2F; NaN </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### parseFloat()</span><br><span class="line"></span><br><span class="line">parseFloat()函数的工作方式跟 parseInt()函数类似，但是**只能解析十进制值**</span><br><span class="line"></span><br><span class="line">- 始终忽略字符串开头的零</span><br><span class="line"></span><br><span class="line">- 解析到字符串末尾或者解析到一个无效的浮点数值字符为止</span><br><span class="line"></span><br><span class="line">  &gt; 第一次出现的小数点是有 效的，但第二次出现的小数点就无效 &quot;22.34.5&quot;将转换 成 22.34</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>let num1 &#x3D; parseFloat(“1234blue”); &#x2F;&#x2F; 1234，按整数解析<br>let num2 &#x3D; parseFloat(“0xA”); &#x2F;&#x2F; 0<br>let num3 &#x3D; parseFloat(“22.5”); &#x2F;&#x2F; 22.5<br>let num4 &#x3D; parseFloat(“22.34.5”); &#x2F;&#x2F; 22.34<br>let num5 &#x3D; parseFloat(“0908.5”); &#x2F;&#x2F; 908.5<br>let num6 &#x3D; parseFloat(“3.125e7”); &#x2F;&#x2F; 31250000 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Srting</span><br><span class="line"></span><br><span class="line">String（字符串）数据类型表示零或多个 16 位 Unicode 字符序列。</span><br><span class="line"></span><br><span class="line">&gt; ECMAScript 中的字符串是不可变的，要修改 某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量,**所有字符串方法都不会影响原字符串，无一例外**</span><br><span class="line"></span><br><span class="line">### 转换为字符串</span><br><span class="line"></span><br><span class="line">几乎所有值都有的 `toString()`方法。这个方法唯 一的用途就是返回当前值的字符串等价物。</span><br><span class="line"></span><br><span class="line">&gt; 用加号操作符给一个值加上一个空字符串&quot;&quot;也可以将其转换为字符串</span><br><span class="line"></span><br><span class="line">toString()方法可见于数值、布尔值、对象和字符串值。null 和 undefined 值没有 toString()方法（直接返回这两个值的字面量文本）</span><br><span class="line"></span><br><span class="line">&gt; 没错，字符串值也有 toString()方法， 该方法只是简单地返回自身的一个副本。</span><br><span class="line"></span><br><span class="line">&gt; 多数情况下，toString()不接收任何参数。不过，在对数值调用这个方法时，toString()可以接受以什么底数来输出数值的字符串表示</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>let num &#x3D; 10;<br>console.log(num.toString()); &#x2F;&#x2F; “10”<br>console.log(num.toString(2)); &#x2F;&#x2F; “1010”<br>console.log(num.toString(8)); &#x2F;&#x2F; “12”<br>console.log(num.toString(10)); &#x2F;&#x2F; “10”<br>console.log(num.toString(16)); &#x2F;&#x2F; “a”<br>&#96;&#96;</p>
<pre><code>
</code></pre>
</blockquote>
<blockquote>
<p>详细见js高程第四版 5.3.3</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/get&post/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/get&post/" class="post-title-link" itemprop="url">get post</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-17 00:00:00" itemprop="dateCreated datePublished" datetime="2021-03-17T00:00:00+08:00">2021-03-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-17 10:47:32" itemprop="dateModified" datetime="2024-07-17T10:47:32+08:00">2024-07-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">零散知识</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="POST提交数据时四种常见的数据格式"><a href="#POST提交数据时四种常见的数据格式" class="headerlink" title="POST提交数据时四种常见的数据格式"></a>POST提交数据时四种常见的数据格式</h2><ul>
<li><p>application&#x2F;x-www-form-urlencoded<br> 浏览器的原生 表单，如果不设置 enctype 属性，那么最终就会以 application&#x2F;x-www-form-urlencoded方式提交数据。</p>
</li>
<li><p>multipart&#x2F;form-data<br> 我们使用表单上传文件时，必须让 表单的 enctype 等于 multipart&#x2F;form-data</p>
</li>
<li><p>application&#x2F;json<br>JSON 格式支持比键值对复杂得多的结构化数据</p>
</li>
<li><p>text&#x2F;xml<br>XML-RPC（XML Remote Procedure Call）,它是一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范。</p>
</li>
</ul>
<hr>
<h2 id="get的编码类型-仅有-application-x-www-form-urlencoded"><a href="#get的编码类型-仅有-application-x-www-form-urlencoded" class="headerlink" title="get的编码类型 仅有 application&#x2F;x-www-form-urlencoded"></a>get的编码类型 仅有 application&#x2F;x-www-form-urlencoded</h2><h2 id="W3C列出的HTTP方法-POST和GET的区别"><a href="#W3C列出的HTTP方法-POST和GET的区别" class="headerlink" title="W3C列出的HTTP方法 POST和GET的区别"></a>W3C列出的HTTP方法 POST和GET的区别</h2><p><img src="/assets/get&post/post-bg1.png" alt="区别">  </p>
<h2 id="常见解答-get-post的区别"><a href="#常见解答-get-post的区别" class="headerlink" title="常见解答 get post的区别"></a>常见解答 get post的区别</h2><ul>
<li>1.GET请求的数据会附在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，POST把提交的数据则放置在是HTTP包的包体中。</li>
<li>2.GET的长度受限于url的长度，而url的长度限制是特定的浏览器和服务器设置的，理论上GET的长度可以无限长。</li>
<li>3.POST是没有大小限制的，HTTP协议规范也没有进行大小限制，起限制作用的是服务器的处理程序的处理能力</li>
<li>4.在ASP中，服务端获取GET请求参数用Request.QueryString，获取POST请求参数用Request.Form。</li>
<li>5.POST的安全性要比GET的安全性高application json 与form表单的区别?瀏覽器默認的提交方式就是表單。首先，Content-Type 被指定为 application&#x2F;x-www-form-urlencoded，jQuery的Ajax请求默认方式，其次，数据以键值对形式？key1&#x3D;value1&amp;key2&#x3D;value2的方式发送到服务器</li>
<li>6.就是语义上的区别，get用于获取数据，post用于提交数据</li>
</ul>
<h3 id="post和get的选择？"><a href="#post和get的选择？" class="headerlink" title="post和get的选择？"></a>post和get的选择？</h3><p>私密性的信息请求使用post。查询信息和可以想要通过url分享的信息使用get。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/promise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/promise/" class="post-title-link" itemprop="url">Promise A+规范</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-17 00:00:00" itemprop="dateCreated datePublished" datetime="2021-03-17T00:00:00+08:00">2021-03-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-17 10:57:03" itemprop="dateModified" datetime="2024-07-17T10:57:03+08:00">2024-07-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">零散知识</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="promiseA-规范"><a href="#promiseA-规范" class="headerlink" title="promiseA+规范"></a>promiseA+规范</h1><blockquote>
<p>转载自<a target="_blank" rel="noopener" href="https://www.ituring.com.cn/article/66566">图灵社区</a></p>
</blockquote>
<p><strong>译者序：</strong>一年前曾译过 Promise&#x2F;A+ 规范，适时完全不懂 Promise 的思想，纯粹将翻译的过程当作学习，旧文译下来诘屈聱牙，读起来十分不顺畅。谁知这样一篇拙译，一年之间竟然点击数千，成为谷歌搜索的头条。今日在理解之后重译此规范，以飨读者。</p>
<p><strong>一个开放、健全且通用的 JavaScript Promise 标准。由开发者制定，供开发者参考。</strong></p>
<hr>
<p><strong>译文术语</strong></p>
<ul>
<li><strong>解决（fulfill）</strong>：指一个 promise 成功时进行的一系列操作，如状态的改变、回调的执行。虽然规范中用 <code>fulfill</code> 来表示解决，但在后世的 promise 实现多以 <code>resolve</code> 来指代之。</li>
<li><strong>拒绝（reject）</strong>：指一个 promise 失败时进行的一系列操作。</li>
<li><strong>终值（eventual value）</strong>：所谓终值，指的是 promise 被<strong>解决</strong>时传递给解决回调的值，由于 promise 有<strong>一次性</strong>的特征，因此当这个值被传递时，标志着 promise 等待态的结束，故称之终值，有时也直接简称为值（value）。</li>
<li><strong>据因（reason）</strong>：也就是拒绝原因，指在 promise 被<strong>拒绝</strong>时传递给拒绝回调的值。</li>
</ul>
<hr>
<p>Promise 表示一个异步操作的最终结果，与之进行交互的方式主要是 <code>then</code> 方法，该方法注册了两个回调函数，用于接收 promise 的终值或本 promise 不能执行的原因。</p>
<p>本规范详细列出了 <code>then</code> 方法的执行过程，所有遵循 Promises&#x2F;A+ 规范实现的 promise 均可以本标准作为参照基础来实施 <code>then</code> 方法。因而本规范是十分稳定的。尽管 Promise&#x2F;A+ 组织有时可能会修订本规范，但主要是为了处理一些特殊的边界情况，且这些改动都是微小且向下兼容的。如果我们要进行大规模不兼容的更新，我们一定会在事先进行谨慎地考虑、详尽的探讨和严格的测试。</p>
<p>从历史上说，本规范实际上是把之前 <a target="_blank" rel="noopener" href="http://wiki.commonjs.org/wiki/Promises/A">Promise&#x2F;A 规范</a> 中的建议明确成为了行为标准：我们一方面扩展了原有规范约定俗成的行为，一方面删减了原规范的一些特例情况和有问题的部分。</p>
<p>最后，核心的 Promises&#x2F;A+ 规范不设计如何创建、解决和拒绝 promise，而是专注于提供一个通用的 <code>then</code> 方法。上述对于 promises 的操作方法将来在其他规范中可能会提及。</p>
<hr>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>promise 是一个拥有 <code>then</code> 方法的对象或函数，其行为符合本规范；</p>
<h2 id="thenable"><a href="#thenable" class="headerlink" title="thenable"></a>thenable</h2><p>是一个定义了 <code>then</code> 方法的对象或函数，文中译作“拥有 <code>then</code> 方法”；</p>
<h2 id="值（value）"><a href="#值（value）" class="headerlink" title="值（value）"></a>值（value）</h2><p>指任何 JavaScript 的合法值（包括 <code>undefined</code> , thenable 和 promise）；</p>
<h2 id="异常（exception）"><a href="#异常（exception）" class="headerlink" title="异常（exception）"></a>异常（exception）</h2><p>是使用 <code>throw</code> 语句抛出的一个值。</p>
<h2 id="据因（reason）"><a href="#据因（reason）" class="headerlink" title="据因（reason）"></a>据因（reason）</h2><p>表示一个 promise 的拒绝原因。</p>
<h1 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h1><hr>
<h2 id="Promise-的状态"><a href="#Promise-的状态" class="headerlink" title="Promise 的状态"></a>Promise 的状态</h2><p>一个 Promise 的当前状态必须为以下三种状态中的一种：<strong>等待态（Pending）</strong>、**执行态（Fulfilled）**和**拒绝态（Rejected）**。</p>
<h3 id="等待态（Pending）"><a href="#等待态（Pending）" class="headerlink" title="等待态（Pending）"></a>等待态（Pending）</h3><p>处于等待态时，promise 需满足以下条件：</p>
<ul>
<li>可以迁移至执行态或拒绝态</li>
</ul>
<h3 id="执行态（Fulfilled）"><a href="#执行态（Fulfilled）" class="headerlink" title="执行态（Fulfilled）"></a>执行态（Fulfilled）</h3><p>处于执行态时，promise 需满足以下条件：</p>
<ul>
<li>不能迁移至其他任何状态</li>
<li>必须拥有一个<strong>不可变</strong>的终值</li>
</ul>
<h3 id="拒绝态（Rejected）"><a href="#拒绝态（Rejected）" class="headerlink" title="拒绝态（Rejected）"></a>拒绝态（Rejected）</h3><p>处于拒绝态时，promise 需满足以下条件：</p>
<ul>
<li>不能迁移至其他任何状态</li>
<li>必须拥有一个<strong>不可变</strong>的据因</li>
</ul>
<p>这里的不可变指的是恒等（即可用 <code>===</code> 判断相等），而不是意味着更深层次的不可变（<strong>译者注：</strong>盖指当 value 或 reason 不是基本值时，只要求其引用地址相等，但属性值可被更改）。</p>
<h2 id="Then-方法"><a href="#Then-方法" class="headerlink" title="Then 方法"></a><strong>Then 方法</strong></h2><p>一个 promise 必须提供一个 <code>then</code> 方法以访问其当前值、终值和据因。</p>
<p>promise 的 <code>then</code> 方法接受两个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure>

<h3 id="参数可选"><a href="#参数可选" class="headerlink" title="参数可选"></a>参数可选</h3><p><code>onFulfilled</code> 和 <code>onRejected</code> 都是可选参数。</p>
<ul>
<li>如果 <code>onFulfilled</code> 不是函数，其必须被忽略</li>
<li>如果 <code>onRejected</code> 不是函数，其必须被忽略</li>
</ul>
<h3 id="onFulfilled-特性"><a href="#onFulfilled-特性" class="headerlink" title="onFulfilled 特性"></a><code>onFulfilled</code> 特性</h3><p>如果 <code>onFulfilled</code> 是函数：</p>
<ul>
<li>当 <code>promise</code> 执行结束后其必须被调用，其第一个参数为 <code>promise</code> 的终值</li>
<li>在 <code>promise</code> 执行结束前其不可被调用</li>
<li>其调用次数不可超过一次</li>
</ul>
<h3 id="onRejected-特性"><a href="#onRejected-特性" class="headerlink" title="onRejected 特性"></a><code>onRejected</code> 特性</h3><p>如果 <code>onRejected</code> 是函数：</p>
<ul>
<li>当 <code>promise</code> 被拒绝执行后其必须被调用，其第一个参数为 <code>promise</code> 的据因</li>
<li>在 <code>promise</code> 被拒绝执行前其不可被调用</li>
<li>其调用次数不可超过一次</li>
</ul>
<h3 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h3><p><code>onFulfilled</code> 和 <code>onRejected</code> 只有在<a target="_blank" rel="noopener" href="http://es5.github.io/#x10.3">执行环境</a>堆栈仅包含<strong>平台代码</strong>时才可被调用 <a target="_blank" rel="noopener" href="https://www.ituring.com.cn/article/66566#note-1">注1</a></p>
<h3 id="调用要求"><a href="#调用要求" class="headerlink" title="调用要求"></a>调用要求</h3><p><code>onFulfilled</code> 和 <code>onRejected</code> 必须被作为函数调用（即没有 <code>this</code> 值）[注2][2]</p>
<h3 id="多次调用"><a href="#多次调用" class="headerlink" title="多次调用"></a>多次调用</h3><p><code>then</code> 方法可以被同一个 <code>promise</code> 调用多次</p>
<ul>
<li>当 <code>promise</code> 成功执行时，所有 <code>onFulfilled</code> 需按照其注册顺序依次回调</li>
<li>当 <code>promise</code> 被拒绝执行时，所有的 <code>onRejected</code> 需按照其注册顺序依次回调</li>
</ul>
<h3 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h3><p><code>then</code> 方法必须返回一个 <code>promise</code> 对象 [注3][3]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise2 = promise1.then(onFulfilled, onRejected);   </span><br></pre></td></tr></table></figure>

<ul>
<li>如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 返回一个值 <code>x</code> ，则运行下面的 <strong>Promise 解决过程</strong>：<code>[[Resolve]](promise2, x)</code></li>
<li>如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 抛出一个异常 <code>e</code> ，则 <code>promise2</code> 必须拒绝执行，并返回拒因 <code>e</code></li>
<li>如果 <code>onFulfilled</code> 不是函数且 <code>promise1</code> 成功执行， <code>promise2</code> 必须成功执行并返回相同的值</li>
<li>如果 <code>onRejected</code> 不是函数且 <code>promise1</code> 拒绝执行， <code>promise2</code> 必须拒绝执行并返回相同的据因</li>
</ul>
<p><strong>译者注：</strong>理解上面的“返回”部分非常重要，即：<strong>不论 <code>promise1</code> 被 reject 还是被 resolve 时 <code>promise2</code>都会被 resolve，只有出现异常时才会被 rejected</strong>。</p>
<h2 id="Promise-解决过程"><a href="#Promise-解决过程" class="headerlink" title="Promise 解决过程"></a><strong>Promise 解决过程</strong></h2><p><strong>Promise 解决过程</strong>是一个抽象的操作，其需输入一个 <code>promise</code> 和一个值，我们表示为 <code>[[Resolve]](promise, x)</code>，如果 <code>x</code> 有 <code>then</code> 方法且看上去像一个 Promise ，解决程序即尝试使 <code>promise</code> 接受 <code>x</code> 的状态；否则其用 <code>x</code> 的值来执行 <code>promise</code> 。</p>
<p>这种 <em>thenable</em> 的特性使得 Promise 的实现更具有通用性：只要其暴露出一个遵循 Promise&#x2F;A+ 协议的 <code>then</code>方法即可；这同时也使遵循 Promise&#x2F;A+ 规范的实现可以与那些不太规范但可用的实现能良好共存。</p>
<p>运行 <code>[[Resolve]](promise, x)</code> 需遵循以下步骤：</p>
<h3 id="x-与-promise-相等"><a href="#x-与-promise-相等" class="headerlink" title="x 与 promise 相等"></a><code>x</code> 与 <code>promise</code> 相等</h3><p>如果 <code>promise</code> 和 <code>x</code> 指向同一对象，以 <code>TypeError</code> 为据因拒绝执行 <code>promise</code></p>
<h3 id="x-为-Promise"><a href="#x-为-Promise" class="headerlink" title="x 为 Promise"></a><code>x</code> 为 Promise</h3><p>如果 <code>x</code> 为 Promise ，则使 <code>promise</code> 接受 <code>x</code> 的状态 [注4][4]：</p>
<ul>
<li>如果 <code>x</code> 处于等待态， <code>promise</code> 需保持为等待态直至 <code>x</code> 被执行或拒绝</li>
<li>如果 <code>x</code> 处于执行态，用相同的值执行 <code>promise</code></li>
<li>如果 <code>x</code> 处于拒绝态，用相同的据因拒绝 <code>promise</code></li>
</ul>
<h3 id="x-为对象或函数"><a href="#x-为对象或函数" class="headerlink" title="x 为对象或函数"></a><code>x</code> 为对象或函数</h3><p>如果 <code>x</code> 为对象或者函数：</p>
<ul>
<li><p>把 <code>x.then</code> 赋值给 <code>then</code> [注5][5]</p>
</li>
<li><p>如果取 <code>x.then</code> 的值时抛出错误 <code>e</code> ，则以 <code>e</code> 为据因拒绝 <code>promise</code></p>
</li>
<li><p>如果<code>then</code>是函数，将<code>x</code>作为函数的作用域this调用之。传递两个回调函数作为参数，第一个参数叫做</p>
<p><code>resolvePromise</code>，第二个参数叫做<code>rejectPromise</code>:</p>
<ul>
<li><p>如果 <code>resolvePromise</code> 以值 <code>y</code> 为参数被调用，则运行 <code>[[Resolve]](promise, y)</code></p>
</li>
<li><p>如果 <code>rejectPromise</code> 以据因 <code>r</code> 为参数被调用，则以据因 <code>r</code> 拒绝 <code>promise</code></p>
</li>
<li><p>如果 <code>resolvePromise</code> 和 <code>rejectPromise</code> 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用</p>
</li>
<li><p>如果调用<code>then</code>方法抛出了异常<code>e</code>：</p>
<ul>
<li>如果 <code>resolvePromise</code> 或 <code>rejectPromise</code> 已经被调用，则忽略之</li>
<li>否则以 <code>e</code> 为据因拒绝 <code>promise</code></li>
</ul>
</li>
<li><p>如果 <code>then</code> 不是函数，以 <code>x</code> 为参数执行 <code>promise</code></p>
</li>
</ul>
</li>
<li><p>如果 <code>x</code> 不为对象或者函数，以 <code>x</code> 为参数执行 <code>promise</code></p>
</li>
</ul>
<p>如果一个 promise 被一个循环的 <em>thenable</em> 链中的对象解决，而 <code>[[Resolve]](promise, thenable)</code> 的递归性质又使得其被再次调用，根据上述的算法将会陷入无限递归之中。算法虽不强制要求，但也鼓励施者检测这样的递归是否存在，若检测到存在则以一个可识别的 <code>TypeError</code> 为据因来拒绝 <code>promise</code> [注6][6]。</p>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><hr>
<ul>
<li><p><strong>注1</strong> 这里的<strong>平台代码</strong>指的是引擎、环境以及 promise 的实施代码。实践中要确保 <code>onFulfilled</code> 和 <code>onRejected</code> 方法异步执行，且应该在 <code>then</code> 方法被调用的那一轮事件循环之后的新执行栈中执行。这个事件队列可以采用“宏任务（macro-task）”机制或者“微任务（micro-task）”机制来实现。由于 promise 的实施代码本身就是平台代码（<strong>译者注：</strong>即都是 JavaScript），故代码自身在处理在处理程序时可能已经包含一个任务调度队列。</p>
<p><strong>译者注：</strong>这里提及了 macrotask 和 microtask 两个概念，这表示异步任务的两种分类。在挂起任务时，JS 引擎会将所有任务按照类别分到这两个队列中，首先在 macrotask 的队列（这个队列也被叫做 task queue）中取出第一个任务，执行完毕后取出 microtask 队列中的所有任务顺序执行；之后再取 macrotask 任务，周而复始，直至两个队列的任务都取完。</p>
<p>两个类别的具体分类如下：</p>
<ul>
<li><strong>macro-task:</strong> script（整体代码）, <code>setTimeout</code>, <code>setInterval</code>, <code>setImmediate</code>, I&#x2F;O, UI rendering</li>
<li><strong>micro-task:</strong> <code>process.nextTick</code>, <code>Promises</code>（这里指浏览器实现的原生 Promise）, <code>Object.observe</code>, <code>MutationObserver</code></li>
</ul>
<p>详见 <a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/25915634/difference-between-microtask-and-macrotask-within-an-event-loop-context">stackoverflow 解答</a> 或 <a target="_blank" rel="noopener" href="http://wengeezhang.com/?p=11">这篇博客</a></p>
</li>
<li><p><strong>注2</strong> 也就是说在<strong>严格模式（strict）</strong>中，函数 <code>this</code> 的值为 <code>undefined</code> ；在非严格模式中其为全局对象。</p>
</li>
<li><p><strong>注3</strong> 代码实现在满足所有要求的情况下可以允许 <code>promise2 === promise1</code> 。每个实现都要文档说明其是否允许以及在何种条件下允许 <code>promise2 === promise1</code> 。</p>
</li>
<li><p><strong>注4</strong> 总体来说，如果 <code>x</code> 符合当前实现，我们才认为它是真正的 <em>promise</em> 。这一规则允许那些特例实现接受符合已知要求的 Promises 状态。</p>
</li>
<li><p><strong>注5</strong> 这步我们先是存储了一个指向 <code>x.then</code> 的引用，然后测试并调用该引用，以避免多次访问 <code>x.then</code>属性。这种预防措施确保了该属性的一致性，因为其值可能在检索调用时被改变。</p>
</li>
<li><p><strong>注6</strong> 实现不应该对 <em>thenable</em> 链的深度设限，并假定超出本限制的递归就是无限循环。只有真正的循环递归才应能导致 <code>TypeError</code> 异常；如果一条无限长的链上 <em>thenable</em> 均不相同，那么递归下去永远是正确的行为。</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/css/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/css/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/" class="post-title-link" itemprop="url">层叠上下文-张鑫旭</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-28 00:00:00" itemprop="dateCreated datePublished" datetime="2021-02-28T00:00:00+08:00">2021-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-19 14:47:59" itemprop="dateModified" datetime="2024-07-19T14:47:59+08:00">2024-07-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/css/" itemprop="url" rel="index"><span itemprop="name">css</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>转载于  <a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/">张鑫旭</a></p>
</blockquote>
<h3 id="简短总结"><a href="#简短总结" class="headerlink" title="简短总结"></a>简短总结</h3><h4 id="什么是层叠上下文"><a href="#什么是层叠上下文" class="headerlink" title="什么是层叠上下文"></a>什么是层叠上下文</h4><p> 层叠上下文，英文称作”stacking context”. 是HTML中的一个三维的概念。简单来说就是一个容器，比普通元素高一个层级</p>
<p>如何产生一个层叠上下文</p>
<h4 id="如何创建层叠上下文-MDN"><a href="#如何创建层叠上下文-MDN" class="headerlink" title="如何创建层叠上下文(MDN)"></a>如何创建<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context?spm=taofed.bloginfo.blog.3.19585ac8FPDXDu">层叠上下文(MDN)</a></h4><ol>
<li>文档根元素（<code>&lt;html&gt;</code>）；</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position"><code>position</code></a> 值为 <code>absolute</code>（绝对定位）或 <code>relative</code>（相对定位）且 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index"><code>z-index</code></a> 值不为 <code>auto</code> 的元素；</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position"><code>position</code></a> 值为 <code>fixed</code>（固定定位）或 <code>sticky</code>（粘滞定位）的元素（沾滞定位适配所有移动设备上的浏览器，但老的桌面浏览器不支持）；</li>
<li>flex (<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flexbox"><code>flexbox</code></a>) 容器的子元素，且 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index"><code>z-index</code></a> 值不为 <code>auto</code>；</li>
<li>grid (<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid"><code>grid</code></a>) 容器的子元素，且 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index"><code>z-index</code></a> 值不为 <code>auto</code>；</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/opacity"><code>opacity</code></a> 属性值小于 <code>1</code> 的元素（参见 <a target="_blank" rel="noopener" href="http://www.w3.org/TR/css3-color/#transparency">the specification for opacity</a>）；</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/mix-blend-mode"><code>mix-blend-mode</code></a> 属性值不为 <code>normal</code> 的元素；</li>
<li>以下任意属性值不为<code>none</code>的元素：<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform"><code>transform</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter"><code>filter</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/perspective"><code>perspective</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clip-path"><code>clip-path</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/mask"><code>mask</code></a> &#x2F; <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/mask-image"><code>mask-image</code></a> &#x2F; <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/mask-border"><code>mask-border</code></a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/isolation"><code>isolation</code></a> 属性值为 <code>isolate</code> 的元素；</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/-webkit-overflow-scrolling"><code>-webkit-overflow-scrolling</code></a> 属性值为 <code>touch</code> 的元素；</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/will-change"><code>will-change</code></a> 值设定了任一属性而该属性在 non-initial 值时会创建层叠上下文的元素（参考<a target="_blank" rel="noopener" href="http://dev.opera.com/articles/css-will-change-property/">这篇文章</a>）；</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/contain"><code>contain</code></a> 属性值为 <code>layout</code>、<code>paint</code> 或包含它们其中之一的合成值（比如 <code>contain: strict</code>、<code>contain: content</code>）的元素。</li>
</ol>
<h4 id="层叠上下文内部元素的顺序"><a href="#层叠上下文内部元素的顺序" class="headerlink" title="层叠上下文内部元素的顺序"></a>层叠上下文内部元素的顺序</h4><p><img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/2016-01-09_211116.png" alt="更完整的7阶层叠顺序图"></p>
<h4 id="不同层叠上下文的层叠顺序"><a href="#不同层叠上下文的层叠顺序" class="headerlink" title="不同层叠上下文的层叠顺序"></a>不同层叠上下文的层叠顺序</h4><ol>
<li>如果层叠上下文元素不依赖<code>z-index</code>数值，则其层叠顺序是<code>z-index:auto</code>可看成<code>z:index:0</code>级别；</li>
<li>如果层叠上下文元素依赖<code>z-index</code>数值，则其层叠顺序由<code>z-index</code>值决定。</li>
<li>后写的居上</li>
</ol>
<h4 id="拓展：层叠图层和复合图层有什么区别和联系呢"><a href="#拓展：层叠图层和复合图层有什么区别和联系呢" class="headerlink" title="拓展：层叠图层和复合图层有什么区别和联系呢"></a>拓展：层叠图层和复合图层有什么区别和联系呢</h4><h5 id="了解层"><a href="#了解层" class="headerlink" title="了解层"></a>了解层</h5><p>首先说明，这里讨论的是 WebKit，描述的是 Chrome 的实现细节，而并非是 web 平台的功能，因此这里介绍的内容不一定适用于其他浏览器。</p>
<ul>
<li>Chrome 拥有两套不同的渲染路径(rendering path)：硬件加速路径和旧软件路径(older software path)</li>
<li>Chrome 中有不同类型的层： RenderLayer(渲染层)和GraphicsLayer(图形层，也称复合图层)，只有 GraphicsLayer 是作为纹理(texture)上传给GPU的。</li>
</ul>
<p>浏览器中图层一般包含两大类：渲染图层（普通图层）以及复合图层</p>
<ul>
<li>渲染图层，是页面普通的<a target="_blank" rel="noopener" href="https://blog.csdn.net/wangfeijiu/article/details/106563074">文档流</a>。我们<strong>虽然可以通过绝对定位，相对定位，浮动定位脱离文档流</strong>，但它<strong>仍然属于默认渲染图层</strong>，共用同一个绘图上下文对象（GraphicsContext）。<ul>
<li>满足形成层叠上下文条件的 LayoutObject 一定会<strong>为其创建新的独立的渲染层</strong></li>
</ul>
</li>
<li>复合图层，又称图形层。它会单独分配系统资源，每个复合图层都有一个独立的<strong>GraphicsContext</strong>。（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://fed.taobao.org/blog/taofed/do71ct/performance-composite/">淘宝的文章描述的很清楚</a></p>
</blockquote>
<hr>
<h3 id="以下是转载原文"><a href="#以下是转载原文" class="headerlink" title="以下是转载原文"></a>以下是转载原文</h3><p>在这个世界上，凡事都有个先后顺序，凡物都有个论资排辈。比方说食堂排队打饭，对吧，讲求先到先得，总不可能一拥而上。再比如说话语权，老婆的话永远是对的，领导的话永远是对的。</p>
<p>在CSS届，也是如此。只是，一般情况下，大家歌舞升平，看不出什么差异，即所谓的众生平等。但是，当发生冲突发生纠葛的时候，显然，是不可能做到完全等同的，先后顺序，身份差异就显现出来了。例如，杰克和罗斯，只能一人浮在木板上，此时，出现了冲突，结果大家都知道的。那对于CSS世界中的元素而言，所谓的“冲突”指什么呢，其中，很重要的一个层面就是“层叠显示冲突”。</p>
<p>默认情况下，网页内容是没有偏移角的垂直视觉呈现，当内容发生层叠的时候，一定会有一个前后的层叠顺序产生，有点类似于真实世界中论资排辈的感觉。</p>
<p>而要理解网页中元素是如何“论资排辈”的，就需要深入理解CSS中的层叠上下文和层叠顺序。</p>
<p>我们大家可能都熟悉CSS中的<code>z-index</code>属性，需要跟大家讲的是，<code>z-index</code>实际上只是CSS层叠上下文和层叠顺序中的一叶小舟。</p>
<h3 id="一、什么是层叠上下文"><a href="#一、什么是层叠上下文" class="headerlink" title="一、什么是层叠上下文"></a>一、什么是层叠上下文</h3><p>层叠上下文，英文称作”stacking context”. 是HTML中的一个三维的概念。如果一个元素含有层叠上下文，我们可以理解为这个元素在z轴上就“高人一等”。</p>
<p>这里出现了一个名词-<strong>z轴</strong>，指的是什么呢？</p>
<p>表示的是用户与屏幕的这条看不见的垂直线（参见下图示意-红线）：<br><img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/z-aris.png" alt="网页中z轴示意"></p>
<p>层叠上下文是一个概念，跟「<a target="_blank" rel="noopener" href="http://www.zhangxinxu.com/wordpress/?p=4588">块状格式化上下文(BFC)</a>」类似。然而，概念这个东西是比较虚比较抽象的，要想轻松理解，我们需要将其具象化。</p>
<p>怎么个具象化法呢？</p>
<p>你可以<strong>把「层叠上下文」理解为当官</strong>：网页中有很多很多的元素，我们可以看成是真实世界的芸芸众生。真实世界里，我们大多数人是普通老百姓们，还有一部分人是做官的官员。OK，这里的“官员”就可以理解为网页中的层叠上下文元素。</p>
<p>换句话说，页面中的元素有了层叠上下文，就好比我们普通老百姓当了官，一旦当了官，相比普通老百姓而言，离皇帝更近了，对不对，就等同于网页中元素级别更高，离我们用户更近了。</p>
<p><img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/point.gif" alt="你懂的"></p>
<h3 id="二、什么是层叠水平"><a href="#二、什么是层叠水平" class="headerlink" title="二、什么是层叠水平"></a>二、什么是层叠水平</h3><p>再来说说层叠水平。“层叠水平”英文称作”stacking level”，决定了同一个层叠上下文中元素在z轴上的显示顺序。level这个词很容易让我们联想到我们真正世界中的三六九等、论资排辈。真实世界中，每个人都是独立的个体，包括同卵双胞胎，有差异就有区分。例如，双胞胎虽然长得像Ctrl+C&#x2F;Ctrl+V得到的，但实际上，出生时间还是有先后顺序的，先出生的那个就大，大哥或大姐。网页中的元素也是如此，页面中的每个元素都是独立的个体，他们一定是会有一个类似的排名排序的情况存在。而这个排名排序、论资排辈就是我们这里所说的“层叠水平”。层叠上下文元素的层叠水平可以理解为官员的职级，1品2品，县长省长之类；对于普通元素，这个嘛……你自己随意理解。</p>
<p>于是，显而易见，所有的元素都有层叠水平，包括层叠上下文元素，层叠上下文元素的层叠水平可以理解为官员的职级，1品2品，县长省长之类。然后，对于普通元素的层叠水平，我们的探讨仅仅局限在当前层叠上下文元素中。为什么呢？因为否则没有意义。</p>
<p>这么理解吧~ 上面提过元素具有层叠上下文好比当官，大家都知道的，这当官的家里都有丫鬟啊保镖啊管家啊什么的。所谓打狗看主人，A官员家里的管家和B官员家里的管家做PK实际上是没有意义的，因为他们牛不牛逼完全由他们的主子决定的。一人得道鸡犬升天，你说这和珅家里的管家和七侠镇娄知县县令家里的管家有可比性吗？李总理的秘书是不是分分钟灭了你村支部书记的秘书（如果有）。</p>
<p>翻译成术语就是：普通元素的层叠水平优先由层叠上下文决定，因此，层叠水平的比较只有在当前层叠上下文元素中才有意义。</p>
<p><img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/point.gif" alt="你懂的"></p>
<p>需要注意的是，诸位千万不要把层叠水平和CSS的z-index属性混为一谈。没错，某些情况下z-index确实可以影响层叠水平，但是，只限于定位元素以及flex盒子的孩子元素；而层叠水平所有的元素都存在。</p>
<h3 id="三、什么是层叠顺序"><a href="#三、什么是层叠顺序" class="headerlink" title="三、什么是层叠顺序"></a>三、什么是层叠顺序</h3><p>再来说说层叠顺序。“层叠顺序”英文称作”stacking order”. 表示元素发生层叠时候有着特定的垂直显示顺序，注意，这里跟上面两个不一样，上面的<strong>层叠上下文和层叠水平是概念</strong>，而这里的<strong>层叠顺序是规则</strong>。</p>
<p>在CSS2.1的年代，在CSS3还没有出现的时候（注意这里的前提），层叠顺序规则遵循下面这张图：<br><img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/2016-01-07_223349.png" alt="层叠顺序"></p>
<p>有人可能有见过类似图，那个图是很多很多年前老外绘制的，英文内容。而是更关键的是国内估计没有同行进行过验证与实践，实际上很多关键信息缺失。上面是我自己手动重绘的中文版同时补充很多其他地方绝对没有的重要知识信息。如果想要无水印高清大图，点击这里购买(0.5元)。</p>
<p>缺失的关键信息包括：</p>
<ol>
<li>位于最低水平的<code>border</code>&#x2F;<code>background</code>指的是层叠上下文元素的边框和背景色。每一个层叠顺序规则适用于一个完整的层叠上下文元素。</li>
<li>原图没有呈现inline-block的层叠顺序，实际上，inline-block和inline水平元素是同等level级别。</li>
<li>z-index:0实际上和z-index:auto单纯从层叠水平上看，是可以看成是一样的。注意这里的措辞——“单纯从层叠水平上看”，实际上，两者在层叠上下文领域有着根本性的差异。</li>
</ol>
<p>下面我要向大家发问了，大家有没有想过，为什么内联元素的层叠顺序要比浮动元素和块状元素都高？<br><img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/ask.gif" alt="疑问"></p>
<p>为什么呢？我明明感觉浮动元素和块状元素要更屌一点啊。</p>
<p>嘿嘿嘿，我就不卖关子了，直接看下图的标注说明：<br><img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/2016-01-07_235108.png" alt="层叠顺序元素的标注说明"></p>
<p>诸如<code>border</code>&#x2F;<code>background</code>一般为装饰属性，而浮动和块状元素一般用作布局，而内联元素都是内容。网页中最重要的是什么？当然是内容了哈，对不对！</p>
<p>因此，一定要让内容的层叠顺序相当高，当发生层叠是很好，重要的文字啊图片内容可以优先暴露在屏幕上。例如，文字和浮动图片重叠的时候：</p>
<p><img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/2016-01-07_235830.jpg" alt="浮动和文字重叠"></p>
<p>上面说的这些层叠顺序规则还是老时代的，如果把CSS3也牵扯进来，科科，事情就不一样了。</p>
<h3 id="四、务必牢记的层叠准则"><a href="#四、务必牢记的层叠准则" class="headerlink" title="四、务必牢记的层叠准则"></a>四、务必牢记的层叠准则</h3><p>下面这两个是层叠领域的黄金准则。当元素发生层叠的时候，其覆盖关系遵循下面2个准则：</p>
<ol>
<li><strong>谁大谁上：</strong>当具有明显的层叠水平标示的时候，如识别的z-indx值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。通俗讲就是官大的压死官小的。</li>
<li><strong>后来居上：</strong>当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。</li>
</ol>
<p>在CSS和HTML领域，只要元素发生了重叠，都离不开上面这两个黄金准则。因为后面会有多个实例说明，这里就到此为止。</p>
<h3 id="五、层叠上下文的特性"><a href="#五、层叠上下文的特性" class="headerlink" title="五、层叠上下文的特性"></a>五、层叠上下文的特性</h3><p>层叠上下文元素有如下特性：</p>
<ul>
<li>层叠上下文的层叠水平要比普通元素高（原因后面会说明）；</li>
<li>层叠上下文可以阻断元素的混合模式（见<a target="_blank" rel="noopener" href="http://www.zhangxinxu.com/wordpress/?p=5155">此文第二部分说明</a>）；</li>
<li>层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的层叠上下文。</li>
<li>每个层叠上下文和兄弟元素独立，也就是当进行层叠变化或渲染的时候，只需要考虑后代元素。</li>
<li>每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。</li>
</ul>
<p>翻译成真实世界语言就是：</p>
<ul>
<li>当官的比老百姓更有机会面见圣上；</li>
<li>领导下去考察，会被当地官员阻隔只看到繁荣看不到真实民情；</li>
<li>一个家里，爸爸可以当官，孩子也是可以同时当官的。但是，孩子这个官要受爸爸控制。</li>
<li>自己当官，兄弟不占光。有什么福利或者变故只会影响自己的孩子们。</li>
<li>每个当官的都有属于自己的小团体，当家眷管家发生摩擦磕碰的时候（包括和其他官员的家眷管家），都是要优先看当官的也就是主子的脸色。</li>
</ul>
<h3 id="六、层叠上下文的创建"><a href="#六、层叠上下文的创建" class="headerlink" title="六、层叠上下文的创建"></a>六、层叠上下文的创建</h3><p>卖了这么多文字，到底层叠上下文是个什么鬼，倒是拿出来瞅瞅啊！</p>
<p>哈哈。如同块状格式化上下文，层叠上下文也基本上是有一些特定的CSS属性创建的。我将其总结为3个流派，也就是做官的3种途径：</p>
<ol>
<li><strong>皇亲国戚</strong>派：页面根元素天生具有层叠上下文，称之为“根层叠上下文”。</li>
<li><strong>科考入选</strong>派：z-index值为数值的定位元素的传统层叠上下文。</li>
<li><strong>其他当官途径</strong>：其他CSS3属性。</li>
</ol>
<p>&#x2F;&#x2F;zxx: 下面很多例子是实时CSS效果，建议您去<a target="_blank" rel="noopener" href="http://www.zhangxinxu.com/wordpress/?p=5115">原地址浏览</a>，以便预览更准确的效果。</p>
<p><strong>①. 根层叠上下文</strong><br>指的是页面根元素，也就是滚动条的默认的始作俑者<code>&lt;html&gt;</code>元素。这就是为什么，绝对定位元素在<code>left</code>&#x2F;<code>top</code>等值定位的时候，如果没有其他定位元素限制，会相对浏览器窗口定位的原因。</p>
<p><strong>②. 定位元素与传统层叠上下文</strong><br>对于包含有<code>position:relative</code>&#x2F;<code>position:absolute</code>的定位元素，以及FireFox&#x2F;IE浏览器（不包括Chrome等webkit内核浏览器）（目前，也就是2016年初是这样）下含有<code>position:fixed</code>声明的定位元素，当其<code>z-index</code>值不是<code>auto</code>的时候，会创建层叠上下文。</p>
<p>知道了这一点，有些现象就好理解了。</p>
<p>如下HTML代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;position:relative; z-index:auto;&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;mm1.jpg&quot; style=&quot;position:absolute; z-index:2;&quot;&gt;    &lt;-- 横妹子 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div style=&quot;position:relative; z-index:auto;&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;mm2.jpg&quot; style=&quot;position:relative; z-index:1;&quot;&gt;    &lt;-- 竖妹子 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm1.jpg" alt="img"></p>
<p><img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm2.jpg" alt="img"></p>
<p>大家会发现，竖着的妹子(mm2)被横着的妹子(mm1)给覆盖了。</p>
<p>下面，我们对父级简单调整下，把<code>z-index:auto</code>改成层叠水平一致的<code>z-index:0</code>, 代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;position:relative; z-index:0;&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;mm1.jpg&quot; style=&quot;position:absolute; z-index:2;&quot;&gt;    &lt;-- 横妹子 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div style=&quot;position:relative; z-index:0;&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;mm2.jpg&quot; style=&quot;position:relative; z-index:1;&quot;&gt;    &lt;-- 竖妹子 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm1.jpg" alt="img"></p>
<p><img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm2.jpg" alt="img"></p>
<p>大家会发现，尼玛反过来了，竖着的妹子(mm2)这回趴在了横着的妹子(mm1)身上。</p>
<p><img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/2016-01-08_220622.jpg" alt="百合大法好"></p>
<p>为什么小小的改变会有想法的结果呢？<br><img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/think-2.gif" alt="思考"></p>
<p>差别就在于，<code>z-index:0</code>所在的<code>&lt;div&gt;</code>元素是层叠上下文元素，而<code>z-index:auto</code>所在的<code>&lt;div&gt;</code>元素是一个普通的元素，于是，里面的两个<code>&lt;img&gt;</code>妹子的层叠比较就不受父级的影响，两者直接套用层叠黄金准则，这里，两者有着明显不一的<code>z-index</code>值，因此，遵循“<strong>谁大谁上</strong>”的准则，于是，<code>z-index</code>为<code>2</code>的那个横妹子，就趴在了<code>z-index</code>为<code>1</code>的竖妹子身上。</p>
<p>而<code>z-index</code>一旦变成数值，哪怕是<code>0</code>，都会创建一个层叠上下文。此时，层叠规则就发生了变化。层叠上下文的特性里面最后一条——自成体系。两个<code>&lt;img&gt;</code>妹子的层叠顺序比较变成了优先比较其父级层叠上下文元素的层叠顺序。这里，由于两者都是<code>z-index:0</code>，层叠顺序这一块两者一样大，此时，遵循层叠黄金准则的另外一个准则“<strong>后来居上</strong>”，根据在DOM流中的位置决定谁在上面，于是，位于后面的竖着的妹子就自然而然趴在了横着的妹子身上。对，没错，<code>&lt;img&gt;</code>元素上的<code>z-index</code>打酱油了！</p>
<p>有时候，我们在网页重构的时候，会发现，<code>z-index</code>嵌套错乱，看看是不是受父级的层叠上下文元素干扰了。然后，可能没多大意义了，但我还是提一下，算是祭奠下，IE6&#x2F;IE7浏览器有个bug，就是<code>z-index:auto</code>的定位元素也会创建层叠上下文。这就是为什么在过去，IE6&#x2F;IE7的<code>z-index</code>会搞死人的原因。</p>
<p>然后，我再提一下<code>position:fixed</code>, 在过去，<code>position:fixed</code>和<code>relative/absolute</code>在层叠上下文这一块是一路货色，都是需要<code>z-index</code>为数值才行。但是，不知道什么时候起，Chrome等webkit内核浏览器，<code>position:fixed</code>元素天然层叠上下文元素，无需<code>z-index</code>为数值。根据我的测试，目前，IE以及FireFox仍是老套路。</p>
<p><strong>③. CSS3与新时代的层叠上下文</strong><br>CSS3的出现除了带来了新属性，同时还对过去的很多规则发出了挑战。例如，CSS3 <code>transform</code><a target="_blank" rel="noopener" href="http://www.zhangxinxu.com/wordpress/2015/05/css3-transform-affect/">对overflow隐藏对position:fixed定位的影响</a>等。而这里，层叠上下文这一块的影响要更加广泛与显著。</p>
<p>如下：</p>
<ol>
<li><code>z-index</code>值不为<code>auto</code>的<code>flex</code>项(父元素<code>display:flex|inline-flex</code>).</li>
<li>元素的<code>opacity</code>值不是<code>1</code>.</li>
<li>元素的<code>transform</code>值不是<code>none</code>.</li>
<li>元素<code>mix-blend-mode</code>值不是<code>normal</code>.</li>
<li>元素的<code>filter</code>值不是<code>none</code>.</li>
<li>元素的<code>isolation</code>值是<code>isolate</code>.</li>
<li><code>will-change</code>指定的属性值为上面任意一个。</li>
<li>元素的<code>-webkit-overflow-scrolling</code>设为<code>touch</code>.</li>
</ol>
<p>基本上每一项都有很多槽点。</p>
<p><strong>1. display:flex|inline-flex与层叠上下文</strong><br>注意，这里的规则有些<del>负责</del>复杂。要满足两个条件才能形成层叠上下文：条件1是父级需要是<code>display:flex</code>或者<code>display:inline-flex</code>水平，条件2是子元素的z-index不是<code>auto</code>，必须是数值。此时，这个子元素为层叠上下文元素，没错，注意了，是子元素，不是flex父级元素。</p>
<p>眼见为实，给大家上例子吧。</p>
<p>如下HTML和CSS代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">     &lt;img src=&quot;mm1.jpg&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">.box &#123;  &#125;</span><br><span class="line">.box &gt; div &#123; background-color: blue; z-index: 1; &#125;    /* 此时该div是普通元素，z-index无效 */</span><br><span class="line">.box &gt; div &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1; right: -150px;     /* 注意这里是负值z-index */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm1.jpg" alt="img"></p>
<p>会发现，妹子跑到蓝色背景的下面了。为什么呢？层叠顺序图可以找到答案，如下：<br><img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/2016-01-08_235511.png" alt="负值z-index的层叠顺序"></p>
<p>从上图可以看出负值z-index的层叠顺序在block水平元素的下面，而蓝色背景<code>div</code>元素是个普通元素，因此，妹子直接穿越过去，在蓝色背景后面的显示了。</p>
<p>现在，我们CSS微调下，增加<code>display:flex</code>, 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.box &#123; display: flex; &#125;</span><br><span class="line">.box &gt; div &#123; background-color: blue; z-index: 1; &#125;    /* 此时该div是层叠上下文元素，同时z-index生效 */</span><br><span class="line">.box &gt; div &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1; right: -150px;     /* 注意这里是负值z-index */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm1.jpg" alt="img"></p>
<p>会发现，妹子在蓝色背景上面显示了，为什么呢？层叠顺序图可以找到答案，如下：<br><img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/2016-01-08_235217.png" alt="img"></p>
<p>从上图可以看出负值<code>z-index</code>的层叠顺序在当前第一个父层叠上下文元素的上面，而此时，那个<code>z-index</code>值为<code>1</code>的蓝色背景<code>&lt;div&gt;</code>的父元素的<code>display</code>值是<code>flex</code>，一下子升官发财变成层叠上下文元素了，于是，图片在蓝色背景上面显示了。这个现象也证实了层叠上下文元素是<code>flex</code>子元素，而不是<code>flex</code>容器元素。</p>
<p>另外，另外，这个例子也颠覆了我们传统的对<code>z-index</code>的理解。在CSS2.1时代，<code>z-index</code>属性必须和定位元素一起使用才有作用，但是，在CSS3的世界里，非定位元素也能和<code>z-index</code>愉快地搞基。</p>
<p><strong>2. opacity与层叠上下文</strong><br>我们直接看代码，原理和上面例子一样，就不解释了。</p>
<p>如下HTML和CSS代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;mm1.jpg&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">.box &#123; background-color: blue;  &#125;</span><br><span class="line">.box &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1; right: -150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm1.jpg" alt="img"></p>
<p>然后价格透明度，例如50%透明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box &#123; background-color: blue; opacity: 0.5;  &#125;</span><br><span class="line">.box &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1; right: -150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm1.jpg" alt="img"></p>
<p>原因就是半透明元素具有层叠上下文，妹子图片的<code>z-index:-1</code>无法穿透，于是，在蓝色背景上面乖乖显示了。</p>
<p><strong>3. transform与层叠上下文</strong><br>应用了<a target="_blank" rel="noopener" href="http://www.zhangxinxu.com/wordpress/2010/11/css3-transitions-transforms-animation-introduction/">transform变换</a>的元素同样具有菜单上下文。</p>
<p>我们直接看应用后的结果，如下CSS代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box &#123; background-color: blue; transform: rotate(15deg);  &#125;</span><br><span class="line">.box &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1; right: -150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm1.jpg" alt="img"></p>
<p>妹子同样在蓝色背景之上。</p>
<p><strong>4. mix-blend-mode与层叠上下文</strong><br><code>mix-blend-mode</code>类似于PS中的混合模式，之前专门有文章介绍-“<a target="_blank" rel="noopener" href="http://www.zhangxinxu.com/wordpress/2015/05/css3-mix-blend-mode-background-blend-mode/">CSS3混合模式mix-blend-mode简介</a>”。</p>
<p>元素和白色背景混合。无论哪种模式，要么全白，要么没有任何变化。为了让大家有直观感受，因此，下面例子我特意加了个原创平铺背景：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box &#123; background-color: blue; mix-blend-mode: darken;  &#125;</span><br><span class="line">.box &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1; right: -150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm1.jpg" alt="img"></p>
<p>需要注意的是，目前，IE浏览器(包括IE14)还不支持<code>mix-blend-mode</code>，因此，要想看到妹子在背景色之上，请使用Chrome或FireFox。</p>
<p>同样的，因为蓝色背景元素升级成了层叠上下文，因此，<code>z-index:-1</code>无法穿透，在蓝色背景上显示了。</p>
<p><strong>5. filter与层叠上下文</strong><br>此处说的<code>filter</code>是CSS3中规范的滤镜，不是旧IE时代私有的那些，虽然目的类似。同样的，我之前有提过，例如<a target="_blank" rel="noopener" href="http://www.zhangxinxu.com/wordpress/2012/08/css-svg-filter-image-grayscale/">图片的灰度</a>或者<a target="_blank" rel="noopener" href="http://www.zhangxinxu.com/wordpress/2013/11/css-svg-image-blur/">图片的毛玻璃效果</a>等。</p>
<p>我们使用常见的模糊效果示意下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box &#123; background-color: blue; filter: blur(5px);  &#125;</span><br><span class="line">.box &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1; right: -150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm1.jpg" alt="img"></p>
<p>好吧，果然被你猜对了，妹子蓝色床上躺着，只是你眼镜摘了，看得有些不够真切罢了。</p>
<p><strong>6. isolation:isolate与层叠上下文</strong><br><code>isolation:isolate</code>这个声明是<code>mix-blend-mode</code>应运而生的。默认情况下，<code>mix-blend-mode</code>会混合z轴所有层叠在下面的元素，要是我们不希望某个层叠的元素参与混合怎么办呢？就是使用<code>isolation:isolate</code>。由于一言难尽，我特意为此写了篇文章：“<a target="_blank" rel="noopener" href="http://www.zhangxinxu.com/wordpress/?p=5155">理解CSS3 isolation: isolate的表现和作用</a>”，解释了其阻隔混合模式的原理，建议大家看下。</p>
<p>要演示这个效果，我需要重新设计下，如下HTML结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;img/mm2.jpg&quot; class=&quot;mode&quot;&gt;</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;mm1.jpg&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>CSS主要代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.mode &#123;</span><br><span class="line">  /* 竖妹子绝对定位，同时混合模式 */</span><br><span class="line">  position: absolute; mix-blend-mode: darken;</span><br><span class="line">&#125;    </span><br><span class="line">.box &#123;</span><br><span class="line">  background: blue;         </span><br><span class="line">&#125;</span><br><span class="line">.box &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构如下：</p>
<p><img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm2.jpg" alt="img"></p>
<p><img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm1.jpg" alt="img"></p>
<p>会发现，横妹子被混合模式了。此时，我们给妹子所在容器增加<code>isolation:isolate</code>，如下CSS所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.mode &#123;</span><br><span class="line">  /* 竖妹子绝对定位，同时混合模式 */</span><br><span class="line">  position: absolute; mix-blend-mode: darken;</span><br><span class="line">&#125;    </span><br><span class="line">.box &#123;</span><br><span class="line">  background: blue; isolation:isolate;         </span><br><span class="line">&#125;</span><br><span class="line">.box &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<p><img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm2.jpg" alt="img"></p>
<p><img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm1.jpg" alt="img"></p>
<p>会发现横着的妹子跑到蓝色背景上面了。这表明确实创建了层叠上下文。</p>
<p><strong>7. will-change与层叠上下文</strong><br>关于<code>will-change</code>，如果有同学还不了解，可以参见我之前写的文章：“<a target="_blank" rel="noopener" href="http://www.zhangxinxu.com/wordpress/2015/11/css3-will-change-improve-paint/">使用CSS3 will-change提高页面滚动、动画等渲染性能</a>”。</p>
<p>都是类似的演示代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box &#123; background-color: blue; will-change: transform;  &#125;</span><br><span class="line">.box &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1; right: -150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm1.jpg" alt="img"></p>
<p>果然不出所料，妹子上了蓝色的背景。</p>
<h3 id="七、层叠上下文与层叠顺序"><a href="#七、层叠上下文与层叠顺序" class="headerlink" title="七、层叠上下文与层叠顺序"></a>七、层叠上下文与层叠顺序</h3><p>本文多次提到，一旦普通元素具有了层叠上下文，其层叠顺序就会变高。那它的层叠顺序究竟在哪个位置呢？</p>
<p>这里需要分两种情况讨论：</p>
<ol>
<li>如果层叠上下文元素不依赖<code>z-index</code>数值，则其层叠顺序是<code>z-index:auto</code>可看成<code>z:index:0</code>级别；</li>
<li>如果层叠上下文元素依赖<code>z-index</code>数值，则其层叠顺序由<code>z-index</code>值决定。</li>
</ol>
<p>于是乎，我们上面提供的层叠顺序表，实际上还是缺少其他重要信息。我又花功夫重新绘制了一个更完整的7阶层叠顺序图（同样的版权所有，商业请购买，可得无水印大图）：</p>
<p><img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/2016-01-09_211116.png" alt="更完整的7阶层叠顺序图"></p>
<p>大家知道为什么定位元素会层叠在普通元素的上面吗？</p>
<p>其根本原因就在于，元素一旦成为定位元素，其<code>z-index</code>就会自动生效，此时其<code>z-index</code>就是默认的<code>auto</code>，也就是<code>0</code>级别，根据上面的层叠顺序表，就会覆盖<code>inline</code>或<code>block</code>或<code>float</code>元素。</p>
<p>而不支持z-index的层叠上下文元素天然<code>z-index:auto</code>级别，也就意味着，层叠上下文元素和定位元素是一个层叠顺序的，于是当他们发生层叠的时候，遵循的是“后来居上”准则。</p>
<p>我们可以速度测试下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;mm1&quot; style=&quot;position:relative&quot;&gt;</span><br><span class="line">&lt;img src=&quot;mm2&quot; style=&quot;transform:scale(1);&quot;&gt;</span><br><span class="line">&lt;img src=&quot;mm2&quot; style=&quot;transform:scale(1);&quot;&gt;</span><br><span class="line">&lt;img src=&quot;mm1&quot; style=&quot;position:relative&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm1.jpg" alt="img"><img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm2.jpg" alt="img"><br><img src="/assets/https:/image.zhangxinxu.com/image/study/s/s256/mm2.jpg" alt="img"><img src="/assets/https:/image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p>
<p>会发现，两者样式一模一样，仅仅是在DOM流中的位置不一样，导致他们的层叠表现不一样，后面的妹子趴在了前面妹子的身上。这也说明了，层叠上下文元素的层叠顺序就是<code>z-index:auto</code>级别。</p>
<p><strong>z-index值与层叠顺序</strong><br>如果元素支持z-index值，则层叠顺序就要好理解些了，比较数值大小嘛，小盆友都会，本质上是应用的“谁大谁上”的准则。在以前，我们只需要关心定位元素的z-index就好，但是，在CSS3时代，flex子项也支持<code>z-index</code>，使得我们面对的情况比以前要负复杂。然而，好的是，规则都是一样的，对于<code>z-index</code>的使用和表现也是如此，套用上面的7阶层叠顺序表就可以了。</p>
<p>同样，举个简单例子，看下<code>z-index:-1</code>和<code>z-index:1</code>变化对层叠表现的影响，如下两段HTML：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;display:flex; background:blue;&quot;&gt;</span><br><span class="line">   &lt;img src=&quot;mm1.jpg&quot; style=&quot;z-index:-1;&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div style=&quot;display:flex; background:blue;&quot;&gt;</span><br><span class="line">   &lt;img src=&quot;mm1.jpg&quot; style=&quot;z-index:1;&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>最后，会发现，<code>z-index:-1</code>跑到了背景色小面，而<code>z-index:1</code>高高在上。</p>
<p><img src="/assets/https:/image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p>
<p><img src="/assets/https:/image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p>
<p><strong>一个与层叠上下文相关的有趣的显示现象</strong><br>在实际项目中，我们可能会渐进使用CSS3的fadeIn淡入animation效果增强体验，于是，我们可能就会遇到类似下面的现象：</p>
<p>您可以狠狠地点击这里：<a target="_blank" rel="noopener" href="http://www.zhangxinxu.com/study/201601/css3-fadein-animation-stacking-context.html">CSS3 fadeIn淡入animation动画有趣现象</a></p>
<p>有一个绝对定位的黑色半透明层覆盖在图片上，默认显示是这样的：</p>
<p><img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/2018-01-09_004641.png" alt="文字在妹子上"></p>
<p>但是，一旦图片开始走fadeIn淡出的CSS3动画，文字跑到图片后面去了<img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/36.gif" alt="img">：</p>
<p><img src="/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/2018-01-09_004654.png" alt="文字跑到图片后面"></p>
<p>为什么会这样？</p>
<p>实际上，学了本文的内容，就很简单了！fadeIn动画本质是<code>opacity</code>透明度的变化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@keyframes fadeIn &#123;</span><br><span class="line">  0% &#123; </span><br><span class="line">    opacity: 0;</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    opacity: 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要知道，<code>opacity</code>的值不是<code>1</code>的时候，是具有层叠上下文的，层叠顺序是<code>z-index:auto</code>级别，跟没有<code>z-index</code>值的<code>absolute</code>绝对定位元素是平起平坐的。而本demo中的文字元素在图片元素的前面，于是，当CSS3动画只要不是最终一瞬间的<code>opacity: 1</code>，位于DOM流后面的图片就会遵循“后来居上”准则，覆盖文字。</p>
<p>这就是原因，于是，我们想要解决这个问题就很简单。</p>
<p>\1. 调整DOM流的先后顺序；<br>\2. 提高文字的层叠顺序，例如，设置<code>z-index:1</code>;</p>
<h3 id="八、结束语"><a href="#八、结束语" class="headerlink" title="八、结束语"></a>八、结束语</h3><p>只要元素发生层叠，要解释其表现，基本上就本文的这些内容了。</p>
<p>我发现很多重构小伙伴都有z-index滥用，或者使用不规范的问题。我觉得最主要的原因还是对理解层叠上下文以及层叠顺序这些概念都不了解。例如，只要使用了定位元素，尤其<code>absolute</code>绝对定位，都离不开设置一个<code>z-index</code>值；或者只要元素被其他元素覆盖了，例如变成定位元素或者增加<code>z-index</code>值升级。页面一复杂，必然搞得乱七八糟。</p>
<p>实际上，在我看来，觉得多数常见，z-index根本就没有出现的必要。知道了内联元素的层叠水平比块状元素高，于是，某条线你想覆盖上去的时候，需要设置<code>position:relative</code>吗？不需要，<code>inline-block</code>化就可以。因为IE6&#x2F;IE7 <code>position:relative</code>会创建层叠上下文，很烦的。</p>
<p>OK，本文已经够长了，就不多啰嗦了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/css/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/css/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/" class="post-title-link" itemprop="url">层叠上下文-淘宝团队</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-28 00:00:00" itemprop="dateCreated datePublished" datetime="2021-02-28T00:00:00+08:00">2021-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-19 14:48:06" itemprop="dateModified" datetime="2024-07-19T14:48:06+08:00">2024-07-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/css/" itemprop="url" rel="index"><span itemprop="name">css</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>一个 Web 页面的展示，简单来说可以认为经历了以下下几个步骤。</p>
<p><img src="/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1eabOLpXXXXX3XFXXXXXXXXXX-1093-167.jpg_720x720.jpg" alt="img"></p>
<ul>
<li><p>JavaScript：一般来说，我们会使用 JavaScript 来实现一些视觉变化的效果。比如做一个动画或者往页面里添加一些 DOM 元素等。</p>
</li>
<li><p>Style：计算样式，这个过程是根据 CSS 选择器，对每个 DOM 元素匹配对应的 CSS 样式。这一步结束之后，就确定了每个 DOM 元素上该应用什么 CSS 样式规则。</p>
</li>
<li><p>Layout：布局，上一步确定了每个 DOM 元素的样式规则，这一步就是具体计算每个 DOM 元素最终在屏幕上显示的大小和位置。web 页面中元素的布局是相对的，因此一个元素的布局发生变化，会联动地引发其他元素的布局发生变化。比如，<code>&lt;body&gt;</code> 元素的宽度的变化会影响其子元素的宽度，其子元素宽度的变化也会继续对其孙子元素产生影响。因此对于浏览器来说，布局过程是经常发生的。</p>
</li>
<li><p>Paint：绘制，本质上就是填充像素的过程。包括绘制文字、颜色、图像、边框和阴影等，也就是一个 DOM 元素所有的可视效果。一般来说，这个绘制过程是在多个层上完成的。</p>
</li>
<li><p>Composite：渲染层合并，由上一步可知，对页面中 DOM 元素的绘制是在多个层上进行的。在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上。对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常。</p>
</li>
</ul>
<p>当然，本文我们只来关注 Composite 部分。</p>
<h2 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h2><p>在讨论 Composite 之前，有必要先简单了解下一些浏览器（本文只是针对 Chrome 来说）的渲染原理，方便对之后一些概念的理解。更多详细的内容可以参阅 <a target="_blank" rel="noopener" href="http://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome">GPU Accelerated Compositing in Chrome</a></p>
<p>注：由于 Chrome 对 Blank 引擎某些实现的修改，某些我们之前熟知的类名有了变化，比如 RenderObject 变成了 LayoutObject，RenderLayer 变成了 PaintLayer。感兴趣的看以参阅 <a target="_blank" rel="noopener" href="https://www.chromium.org/blink/slimming-paint">Slimming Paint</a>。</p>
<p>在浏览器中，页面内容是存储为由 Node 对象组成的树状结构，也就是 DOM 树。每一个 HTML element 元素都有一个 Node 对象与之对应，DOM 树的根节点永远都是 Document Node。这一点相信大家都很熟悉了，但其实，从 DOM 树到最后的渲染，需要进行一些转换映射。</p>
<p><img src="/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1VFRDMXXXXXahXpXXXXXXXXXX-814-320.png_720x720.jpg" alt="img"></p>
<h3 id="从-Nodes-到-LayoutObjects"><a href="#从-Nodes-到-LayoutObjects" class="headerlink" title="从 Nodes 到 LayoutObjects"></a>从 Nodes 到 LayoutObjects</h3><p>DOM 树中得每个 Node 节点都有一个对应的 LayoutObject 。LayoutObject 知道如何在屏幕上 paint Node 的内容。</p>
<h3 id="从-LayoutObjects-到-PaintLayers"><a href="#从-LayoutObjects-到-PaintLayers" class="headerlink" title="从 LayoutObjects 到 PaintLayers"></a>从 LayoutObjects 到 PaintLayers</h3><p>一般来说，拥有相同的坐标空间的 LayoutObjects，属于同一个渲染层（PaintLayer）。PaintLayer 最初是用来实现 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context">stacking contest（层叠上下文）</a>，以此来保证页面元素以正确的顺序合成（composite），这样才能正确的展示元素的重叠以及半透明元素等等。因此满足形成层叠上下文条件的 LayoutObject 一定会为其创建新的渲染层，当然还有其他的一些特殊情况，为一些特殊的 LayoutObjects 创建一个新的渲染层，比如 <code>overflow != visible</code> 的元素。根据创建 PaintLayer 的原因不同，可以将其分为常见的 3 类：</p>
<ul>
<li><p>NormalPaintLayer</p>
</li>
<li><p>根元素（HTML）</p>
</li>
<li><p>有明确的定位属性（relative、fixed、sticky、absolute）</p>
</li>
<li><p>透明的（opacity 小于 1）</p>
</li>
<li><p>有 CSS 滤镜（fliter）</p>
</li>
<li><p>有 CSS mask 属性</p>
</li>
<li><p>有 CSS mix-blend-mode 属性（不为 normal）</p>
</li>
<li><p>有 CSS transform 属性（不为 none）</p>
</li>
<li><p>backface-visibility 属性为 hidden</p>
</li>
<li><p>有 CSS reflection 属性</p>
</li>
<li><p>有 CSS column-count 属性（不为 auto）或者 有 CSS column-width 属性（不为 auto）</p>
</li>
<li><p>当前有对于 opacity、transform、fliter、backdrop-filter 应用动画</p>
</li>
<li><p>OverflowClipPaintLayer</p>
</li>
<li><p>overflow 不为 visible</p>
</li>
<li><p>NoPaintLayer</p>
</li>
<li><p>不需要 paint 的 PaintLayer，比如一个没有视觉属性（背景、颜色、阴影等）的空 div。</p>
</li>
</ul>
<p>满足以上条件的 LayoutObject 会拥有独立的渲染层，而其他的 LayoutObject 则和其第一个拥有渲染层的父元素共用一个。</p>
<h3 id="从-PaintLayers-到-GraphicsLayers"><a href="#从-PaintLayers-到-GraphicsLayers" class="headerlink" title="从 PaintLayers 到 GraphicsLayers"></a>从 PaintLayers 到 GraphicsLayers</h3><p><strong>某些特殊的渲染层会被认为是合成层（Compositing Layers），合成层拥有单独的 GraphicsLayer，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 父层公用一个</strong>。</p>
<p>每个 GraphicsLayer 都有一个 GraphicsContext，GraphicsContext 会负责输出该层的位图，位图是存储在共享内存中，作为纹理上传到 GPU 中，最后由 GPU 将多个位图进行合成，然后 draw 到屏幕上，此时，我们的页面也就展现到了屏幕上。</p>
<p>渲染层提升为合成层的原因有一下几种：</p>
<p>注：渲染层提升为合成层有一个先决条件，<strong>该渲染层必须是 SelfPaintingLayer（基本可认为是上文介绍的 NormalPaintLayer）</strong>。以下所讨论的渲染层提升为合成层的情况都是在该渲染层为 SelfPaintingLayer 前提下的。</p>
<ul>
<li><p>直接原因（direct reason）</p>
</li>
<li><p>硬件加速的 iframe 元素（比如 iframe 嵌入的页面中有合成层）<a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/direct/iframe.html">demo</a></p>
</li>
<li><p>video 元素</p>
</li>
<li><p>覆盖在 video 元素上的视频控制栏</p>
</li>
<li><p>3D 或者 硬件加速的 2D Canvas 元素</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/direct/canvas.html">demo：普通 2D Canvas 不会提升为合成层</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/direct/webgl.html">demo：3D Canvas 提升为合成层</a></p>
</li>
<li><p>硬件加速的插件，比如 flash 等等</p>
</li>
<li><p>在 DPI 较高的屏幕上，fix 定位的元素会自动地被提升到合成层中。但在 DPI 较低的设备上却并非如此，因为这个渲染层的提升会使得字体渲染方式由子像素变为灰阶（详细内容请参考：<a target="_blank" rel="noopener" href="http://www.html5rocks.com/en/tutorials/internals/antialiasing-101/?redirect_from_locale=zh#toc-text-rendering">Text Rendering</a>）</p>
</li>
<li><p>有 3D transform</p>
</li>
<li><p>backface-visibility 为 hidden</p>
</li>
<li><p>对 opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition（需要是 active 的 animation 或者 transition，当 animation 或者 transition 效果未开始或结束后，提升合成层也会失效）</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/direct/animation.html">demo：animation</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/direct/transition.html">demo：transition</a></p>
</li>
</ul>
<p><img src="/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1XMzqMXXXXXXsXFXXXXXXXXXX-959-370.jpg" alt="img"></p>
<ul>
<li><p>will-change 设置为 opacity、transform、top、left、bottom、right（其中 top、left 等需要设置明确的定位属性，如 relative 等）<a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/direct/will-change.html">demo</a></p>
</li>
<li><p>后代元素原因</p>
</li>
<li><p>有合成层后代同时本身有 transform、opactiy（小于 1）、mask、fliter、reflection 属性 <a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/descendant/combo.html">demo</a></p>
</li>
<li><p>有合成层后代同时本身 overflow 不为 visible（如果本身是因为明确的定位因素产生的 SelfPaintingLayer，则需要 z-index 不为 auto） <a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/descendant/overflow.html">demo</a></p>
</li>
<li><p>有合成层后代同时本身 fixed 定位 <a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/descendant/fixed.html">demo</a></p>
</li>
<li><p>有 3D transfrom 的合成层后代同时本身有 preserves-3d 属性 <a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/descendant/preserves-3d.html">demo</a></p>
</li>
<li><p>有 3D transfrom 的合成层后代同时本身有 perspective 属性 <a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/descendant/perspective.html">demo</a></p>
</li>
<li><p>overlap 重叠原因<br>为什么会因为重叠原因而产生合成层呢？举个简单的栗子。<br><img src="/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1sZbvMXXXXXXlXXXXXXXXXXXX-491-300.jpg" alt="img"><br>蓝色的矩形重叠在绿色矩形之上，同时它们的父元素是一个 GraphicsLayer。此时假设绿色矩形为一个 GraphicsLayer，如果 overlap 无法提升合成层的话，那么蓝色矩形不会提升为合成层，也就会和父元素公用一个 GraphicsLayer。<br><img src="/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1qzzmMXXXXXX1XpXXXXXXXXXX-491-300.jpg" alt="img"><br>此时，渲染顺序就会发生错误，因此为保证渲染顺序，overlap 也成为了合成层产生的原因，也就是如下的正常情形。<br><img src="/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB13cYmMXXXXXaXXpXXXXXXXXXX-491-300.jpg" alt="img"><br>当然 overlap 的原因也会细分为几类，接下来我们会详细看下。</p>
</li>
<li><p>重叠或者说部分重叠在一个合成层之上。<br>那如何算是重叠呢，最常见和容易理解的就是元素的 border box（content + padding + border） 和合成层的有重叠，比如：<a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/overlap/normal.html">demo</a>，当然 margin area 的重叠是无效的（<a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/overlap/margin.html">demo</a>）。其他的还有一些不常见的情况，也算是同合成层重叠的条件，如下：</p>
</li>
<li><p>filter 效果同合成层重叠 <a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/overlap/filter.html">demo</a></p>
</li>
<li><p>transform 变换后同合成层重叠 <a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/overlap/transform.html">demo</a></p>
</li>
<li><p>overflow scroll 情况下同合成层重叠。即如果一个 overflow scroll（不管 <code>overflow:auto</code> 还是 <code>overflow:scrill</code>，只要是能 scroll 即可） 的元素同一个合成层重叠，则其可视子元素也同该合成层重叠 <a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/overlap/overflow.html">demo</a></p>
</li>
<li><p>假设重叠在一个合成层之上（assumedOverlap）。<br>这个原因听上去有点虚，什么叫假设重叠？其实也比较好理解，比如一个元素的 CSS 动画效果，动画运行期间，元素是有可能和其他元素有重叠的。针对于这种情况，于是就有了 assumedOverlap 的合成层产生原因，示例可见：<a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/overlap/animation.html">demo</a>。在本 demo 中，动画元素视觉上并没有和其兄弟元素重叠，但因为 assumedOverlap 的原因，其兄弟元素依然提升为了合成层。<br>需要注意的是该原因下，有一个很特殊的情况：<br>如果合成层有内联的 transform 属性，会导致其兄弟渲染层 assume overlap，从而提升为合成层。比如：<a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/overlap/inline.html">demo</a>。</p>
</li>
</ul>
<h4 id="层压缩"><a href="#层压缩" class="headerlink" title="层压缩"></a>层压缩</h4><p>基本上常见的一些合成层的提升原因如上所说，你会发现，由于重叠的原因，可能随随便便就会产生出大量合成层来，而每个合成层都要消耗 CPU 和内存资源，岂不是严重影响页面性能。这一点浏览器也考虑到了，因此就有了层压缩（Layer Squashing）的处理。如果多个渲染层同一个合成层重叠时，这些渲染层会被压缩到一个 GraphicsLayer 中，以防止由于重叠原因导致可能出现的“层爆炸”。具体可以看如下 <a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/squash/squash-hover.html">demo</a>。一开始，蓝色方块由于<br><code>translateZ</code> 提升为了合成层，其他的方块元素因为重叠的原因，被压缩了一起，大小就是包含这 3 个方块的矩形大小。</p>
<p><img src="/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1yslCMXXXXXahaXXXXXXXXXXX-755-406.png_720x720.jpg" alt="img"></p>
<p>当我们 hover 绿色方块时，会给其设置 <code>translateZ</code> 属性，导致绿色方块也被提升为合成层，则剩下的两个被压缩到了一起，大小就缩小为包含这 2 个方块的矩形大小。</p>
<p><img src="/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1xxh1MXXXXXX_XXXXXXXXXXXX-755-406.png_720x720.jpg" alt="img"></p>
<p>当然，浏览器的自动的层压缩也不是万能的，有很多特定情况下，浏览器是无法进行层压缩的，如下所示，而这些情况也是我们应该尽量避免的。（注：以下情况都是基于重叠原因而言）</p>
<ul>
<li><p>无法进行会打破渲染顺序的压缩（squashingWouldBreakPaintOrder）</p>
<p>示例如下：</p>
<p>demo</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  #ancestor &#123;</span><br><span class="line">    -webkit-mask-image: -webkit-linear-gradient(rgba(0,0,0,1), rgba(0,0,0,0));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  #composited &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100%;</span><br><span class="line">    transform: translateZ(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  #container &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    width: 400px;</span><br><span class="line">    height: 60px;</span><br><span class="line">    border: 1px solid black;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  #overlap-child &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 0;</span><br><span class="line">    top: 0 ;</span><br><span class="line">    bottom: 0px;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 60px;</span><br><span class="line">    background-color: orange;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;composited&quot;&gt;Text behind the orange box.&lt;/div&gt;</span><br><span class="line">  &lt;div id=&quot;ancestor&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;overlap-child&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>在本例中，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#overlap-child</span><br></pre></td></tr></table></figure>

<p>同合成层重叠，如果进行压缩，会导致渲染顺序的改变，其父元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#ancestor</span><br></pre></td></tr></table></figure>

<p>的 mask 属性将失效，因此类似这种情况下，是无法进行层压缩的。目前常见的产生这种原因的情况有两种，一种是上述的祖先元素使用 mask 属性的情况，另一种是祖先元素使用 filter 属性的情况（</p>
<p>demo</p>
<p>）。</p>
</li>
<li><p>video 元素的渲染层无法被压缩同时也无法将别的渲染层压缩到 video 所在的合成层上（squashingVideoIsDisallowed）<a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/squash/video.html">demo</a></p>
</li>
<li><p>iframe、plugin 的渲染层无法被压缩同时也无法将别的渲染层压缩到其所在的合成层上（squashingLayoutPartIsDisallowed）<a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/squash/layoutpart.html">demo</a></p>
</li>
<li><p>无法压缩有 reflection 属性的渲染层（squashingReflectionDisallowed）<a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/squash/reflection.html">demo</a></p>
</li>
<li><p>无法压缩有 blend mode 属性的渲染层（squashingBlendingDisallowed）<a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/squash/blend-mode.html">demo</a></p>
</li>
<li><p>当渲染层同合成层有不同的裁剪容器（clipping container）时，该渲染层无法压缩（squashingClippingContainerMismatch）。</p>
<p>示例如下：</p>
<p>demo</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  .clipping-container &#123;</span><br><span class="line"></span><br><span class="line">    overflow: hidden;</span><br><span class="line">    height: 10px; </span><br><span class="line">    background-color: blue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .composited &#123;</span><br><span class="line"></span><br><span class="line">    transform: translateZ(0); </span><br><span class="line">    height: 10px; </span><br><span class="line">    background-color: red;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .target &#123;</span><br><span class="line"></span><br><span class="line">    position:absolute; </span><br><span class="line">    top: 0px; </span><br><span class="line">    height:100px; </span><br><span class="line">    width:100px; </span><br><span class="line">    background-color: green;</span><br><span class="line">    color: #fff;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;clipping-container&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;composited&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;target&quot;&gt;不会被压缩到 composited div 上&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>本例中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.target</span><br></pre></td></tr></table></figure>

<p>同 合成层</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.composited</span><br></pre></td></tr></table></figure>

<p>重叠，但是由于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.composited</span><br></pre></td></tr></table></figure>

<p>在一个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">overflow: hidden</span><br></pre></td></tr></table></figure>

<p>的容器中，导致</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.target</span><br></pre></td></tr></table></figure>

<p>和合成层有不同的裁剪容器，从而</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.target</span><br></pre></td></tr></table></figure>

<p>无法被压缩。</p>
</li>
<li><p>相对于合成层滚动的渲染层无法被压缩（scrollsWithRespectToSquashingLayer）</p>
<p>示例如下：</p>
<p>demo</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  body &#123;</span><br><span class="line">    height: 1500px;</span><br><span class="line">    overflow-x: hidden;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .composited &#123;</span><br><span class="line"></span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    background-color: red;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 50px;</span><br><span class="line">    top: 400px;</span><br><span class="line">    transform: translateZ(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .overlap &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background-color: green;</span><br><span class="line">    position: fixed;</span><br><span class="line">    left: 0px;</span><br><span class="line">    top: 0px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;composited&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;overlap&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>本例中，红色的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.composited</span><br></pre></td></tr></table></figure>

<p>提升为了合成层，绿色的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.overlap</span><br></pre></td></tr></table></figure>

<p>fix 在页面顶部，一开始只有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.composited</span><br></pre></td></tr></table></figure>

<p>合成层。</p>
<p>当滑动页面，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.overlap</span><br></pre></td></tr></table></figure>

<p>重叠到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.composited</span><br></pre></td></tr></table></figure>

<p>上时，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.overlap</span><br></pre></td></tr></table></figure>

<p>会因重叠原因提升为合成层，同时，因为相对于合成层滚动，因此无法被压缩。</p>
</li>
<li><p>当渲染层同合成层有不同的具有 opacity 的祖先层（一个设置了 opacity 且小于 1，一个没有设置 opacity，也算是不同）时，该渲染层无法压缩（squashingOpacityAncestorMismatch，同 squashingClippingContainerMismatch）<a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/squash/squashingOpacityAncestorMismatch.html">demo</a></p>
</li>
<li><p>当渲染层同合成层有不同的具有 transform 的祖先层时，该渲染层无法压缩（squashingTransformAncestorMismatch，同上） <a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/squash/squashingTransformAncestorMismatch.html">demo</a></p>
</li>
<li><p>当渲染层同合成层有不同的具有 filter 的祖先层时，该渲染层无法压缩（squashingFilterAncestorMismatch，同上）<a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/squash/squashingFilterAncestorMismatch.html">demo</a></p>
</li>
<li><p>当覆盖的合成层正在运行动画时，该渲染层无法压缩（squashingLayerIsAnimating），当动画未开始或者运行完毕以后，该渲染层才可以被压缩 <a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/squash/animating.html">demo</a><br><img src="/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1mJjwMXXXXXajXpXXXXXXXXXX-960-391.jpg" alt="img"></p>
</li>
</ul>
<h2 id="如何查看合成层"><a href="#如何查看合成层" class="headerlink" title="如何查看合成层"></a>如何查看合成层</h2><p>使用 Chrome DevTools 工具来查看页面中合成层的情况。</p>
<p>比较简单的方法是打开 DevTools，勾选上 <code>Show layer borders</code></p>
<p><img src="/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1dZG.MXXXXXX2XVXXXXXXXXXX-276-164.png" alt="img"></p>
<p>其中，页面上的合成层会用黄色边框框出来。</p>
<p><img src="/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1EQu4MXXXXXXiaXXXXXXXXXXX-709-717.png_600x600.jpg" alt="img"></p>
<p>当然，更加详细的信息可以通过 Timeline 来查看。</p>
<p>每一个单独的帧，看到每个帧的渲染细节：</p>
<p><img src="/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1.uznMXXXXXbcXFXXXXXXXXXX-325-195.jpg" alt="img"></p>
<p>点击之后，你就会在视图中看到一个新的选项卡：Layers。</p>
<p><img src="/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1uCgsLpXXXXXNXFXXXXXXXXXX-333-260.jpg" alt="img"></p>
<p>点击这个 Layers 选项卡，你会看到一个新的视图。在这个视图中，你可以对这一帧中的所有合成层进行扫描、缩放等操作，同时还能看到每个渲染层被创建的原因。</p>
<p><img src="/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB163nGMXXXXXatXXXXXXXXXXXX-1440-756.jpg_720x720.jpg" alt="img"></p>
<p>有了这个视图，你就能知道页面中到底有多少个合成层。如果你在对页面滚动或渐变效果的性能分析中发现 Composite 过程耗费了太多时间，那么你可以从这个视图里看到页面中有多少个渲染层，它们为何被创建，从而对合成层的数量进行优化。</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>提升为合成层简单说来有以下几点好处：</p>
<ul>
<li><p>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</p>
</li>
<li><p>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</p>
</li>
<li><p>对于 transform 和 opacity 效果，不会触发 layout 和 paint</p>
</li>
</ul>
<p>利用合成层对于提升页面性能方面有很大的作用，因此我们也总结了一下几点优化建议。</p>
<h3 id="提升动画效果的元素"><a href="#提升动画效果的元素" class="headerlink" title="提升动画效果的元素"></a>提升动画效果的元素</h3><p>合成层的好处是不会影响到其他元素的绘制，因此，为了减少动画元素对其他元素的影响，从而减少 paint，我们需要把动画效果中的元素提升为合成层。</p>
<p>提升合成层的最好方式是使用 CSS 的 will-change 属性。从上一节合成层产生原因中，可以知道 will-change 设置为 opacity、transform、top、left、bottom、right 可以将元素提升为合成层。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#target &#123;</span><br><span class="line">  will-change: transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其兼容如下所示：</p>
<p><img src="/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1_6P9LpXXXXblXXXXXXXXXXXX-1252-284.png_720x720.jpg" alt="img"></p>
<p>对于那些目前还不支持 will-change 属性的浏览器，目前常用的是使用一个 3D transform 属性来强制提升为合成层：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#target &#123;</span><br><span class="line">  transform: translateZ(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但需要注意的是，不要创建太多的渲染层。因为每创建一个新的渲染层，就意味着新的内存分配和更复杂的层的管理。之后我们会详细讨论。</p>
<p>如果你已经把一个元素放到一个新的合成层里，那么可以使用 Timeline 来确认这么做是否真的改进了渲染性能。别盲目提升合成层，一定要分析其实际性能表现。</p>
<h3 id="使用-transform-或者-opacity-来实现动画效果"><a href="#使用-transform-或者-opacity-来实现动画效果" class="headerlink" title="使用 transform 或者 opacity 来实现动画效果"></a>使用 transform 或者 opacity 来实现动画效果</h3><p>文章最开始，我们讲到了页面呈现出来所经历的渲染流水线，其实从性能方面考虑，最理想的渲染流水线是没有布局和绘制环节的，只需要做合成层的合并即可：</p>
<p><img src="/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB14YwvLpXXXXXGXFXXXXXXXXXX-1093-167.jpg_720x720.jpg" alt="img"></p>
<p>为了实现上述效果，就需要只使用那些仅触发 Composite 的属性。目前，只有两个属性是满足这个条件的：transforms 和 opacity。更详细的信息可以查看 <a target="_blank" rel="noopener" href="http://csstriggers.com/">CSS Triggers</a>。</p>
<p>注意：元素提升为合成层后，transform 和 opacity 才不会触发 paint，如果不是合成层，则其依然会触发 paint。具体见如下两个 demo。</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/paint/promote-element/no-promote-transform.html">demo 1：transform</a><br><img src="/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1XsAVLpXXXXbzXpXXXXXXXXXX-712-411.png_640x640.jpg" alt="img"></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/paint/promote-element/no-promote-opacity.html">demo 2：opacity</a><br><img src="/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1j9M7LpXXXXaiXXXXXXXXXXXX-713-424.png_640x640.jpg" alt="img"></p>
</li>
</ul>
<p>可以看到未提升 target element 为合成层，transform 和 opacity 依然会触发 paint。</p>
<h3 id="减少绘制区域"><a href="#减少绘制区域" class="headerlink" title="减少绘制区域"></a>减少绘制区域</h3><p>对于不需要重新绘制的区域应尽量避免绘制，以减少绘制区域，比如一个 fix 在页面顶部的固定不变的导航 header，在页面内容某个区域 repaint 时，整个屏幕包括 fix 的 header 也会被重绘，见 <a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/paint/reduce/no-reduce.html">demo</a>，结果如下：</p>
<p><img src="/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1SK_9LpXXXXcaaXXXXXXXXXXX-699-304.png" alt="img"></p>
<p>而对于固定不变的区域，我们期望其并不会被重绘，因此可以通过之前的方法，将其提升为独立的合成层。</p>
<p>减少绘制区域，需要仔细分析页面，区分绘制区域，减少重绘区域甚至避免重绘。</p>
<h3 id="合理管理合成层"><a href="#合理管理合成层" class="headerlink" title="合理管理合成层"></a>合理管理合成层</h3><p>看完上面的文章，你会发现提升合成层会达到更好的性能。这看上去非常诱人，但是问题是，创建一个新的合成层并不是免费的，它得消耗额外的内存和管理资源。实际上，在内存资源有限的设备上，合成层带来的性能改善，可能远远赶不上过多合成层开销给页面性能带来的负面影响。同时，由于每个渲染层的纹理都需要上传到 GPU 处理，因此我们还需要考虑 CPU 和 GPU 之间的带宽问题、以及有多大内存供 GPU 处理这些纹理的问题。</p>
<p>对于合成层占用内存的问题，我们简单做了几个 demo 进行了验证。</p>
<p><a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/memory/multi-layers-expect.html">demo 1</a> 和 <a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/memory/multi-layers.html">demo 2</a> 中，会创建 2000 个同样的 div 元素，不同的是 <a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/memory/multi-layers.html">demo 2</a> 中的元素通过 will-change 都提升为了合成层，而两个 demo 页面的内存消耗却有很明显的差别。</p>
<p><img src="/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1EMYKMXXXXXcUXXXXXXXXXXXX-972-480.jpg" alt="img"></p>
<h4 id="防止层爆炸"><a href="#防止层爆炸" class="headerlink" title="防止层爆炸"></a>防止层爆炸</h4><p>通过之前的介绍，我们知道同合成层重叠也会使元素提升为合成层，虽然有浏览器的层压缩机制，但是也有很多无法进行压缩的情况。也就是说除了我们显式的声明的合成层，还可能由于重叠原因不经意间产生一些不在预期的合成层，极端一点可能会产生大量的额外合成层，出现层爆炸的现象。我们简单写了一个极端点但其实在我们的页面中比较常见的 <a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/memory/layer-explode.html">demo</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  @-webkit-keyframes slide &#123;</span><br><span class="line">    from &#123; transform: none; &#125;</span><br><span class="line">    to &#123; transform: translateX(100px); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .animating &#123;</span><br><span class="line">    </span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 30px;</span><br><span class="line">    background-color: orange;</span><br><span class="line">    color: #fff;</span><br><span class="line">      -webkit-animation: slide 5s alternate linear infinite;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ul &#123;</span><br><span class="line"></span><br><span class="line">    padding: 5px;</span><br><span class="line">    border: 1px solid #000;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    .box &#123;</span><br><span class="line"></span><br><span class="line">    width: 600px;</span><br><span class="line">    height: 30px;</span><br><span class="line">    margin-bottom: 5px;</span><br><span class="line">    background-color: blue;</span><br><span class="line">    color: #fff;</span><br><span class="line">    position: relative;</span><br><span class="line">    /* 会导致无法压缩：squashingClippingContainerMismatch */</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .inner &#123;</span><br><span class="line">      position: absolute;</span><br><span class="line">      top: 2px;</span><br><span class="line">      left: 2px;</span><br><span class="line">      font-size: 16px;</span><br><span class="line">      line-height: 16px;</span><br><span class="line">      padding: 2px;</span><br><span class="line">      margin: 0;</span><br><span class="line">      background-color: green;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动画合成层 --&gt;</span><br><span class="line">&lt;div class=&quot;animating&quot;&gt;composited animating&lt;/div&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;!-- assume overlap --&gt;</span><br><span class="line">  &lt;li class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;!-- assume overlap --&gt;</span><br><span class="line">    &lt;p class=&quot;inner&quot;&gt;asume overlap, 因为 squashingClippingContainerMismatch 无法压缩&lt;/p&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/memory/layer-explode.html">demo</a> 中，<code>.animating</code> 的合成层在运行动画，会导致 <code>.inner</code> 元素因为上文介绍过的 assumedOverlap 的原因，而被提升为合成层，同时，<code>.inner</code> 的父元素 <code>.box</code> 设置了 <code>overflow: hidden</code>，导致 <code>.inner</code> 的合成层因为 squashingClippingContainerMismatch 的原因，无法压缩，就出现了层爆炸的问题。</p>
<p><img src="/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1E7PEMXXXXXbAXpXXXXXXXXXX-1390-778.jpg_720x720.jpg" alt="img"></p>
<p>这种情况平时在我们的业务中还是很常见的，比如 slider + list 的结构，一旦满足了无法进行层压缩的情况，就很容易出现层爆炸的问题。</p>
<p>解决层爆炸的问题，最佳方案是打破 overlap 的条件，也就是说让其他元素不要和合成层元素重叠。对于上述的示例，我们可以将 <code>.animation</code> 的 z-index 提高。修改后 <a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/memory/layer-explode-zIndex.html">demo</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.animating &#123;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  /* 让其他元素不和合成层重叠 */</span><br><span class="line">  position: relative;</span><br><span class="line">  z-index: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，就只有 <code>.animating</code> 提升为合成层，如下：</p>
<p><img src="/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1LxrnMXXXXXcIXVXXXXXXXXXX-1366-777.jpg_720x720.jpg" alt="img"></p>
<p>同时，内存占用比起之前也降低了很多。</p>
<p><img src="/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1FoDwMXXXXXc2XFXXXXXXXXXX-947-485.jpg" alt="img"></p>
<p>如果受限于视觉需要等因素，其他元素必须要覆盖在合成层之上，那应该尽量避免无法层压缩情况的出现。针对上述示例中，无法层压缩的情况（squashingClippingContainerMismatch），我们可以将 <code>.box</code> 的 <code>overflow: hidden</code> 去掉，这样就可以利用浏览器的层压缩了。修改后 <a target="_blank" rel="noopener" href="http://taobaofed.github.io/demo/performance-composite-demo/memory/layer-explode-squash.html">demo</a></p>
<p>此时，由于第一个 <code>.box</code> 因为 squashingLayerIsAnimating 的原因无法压缩，其他的都被压缩到了一起。</p>
<p><img src="/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1OE6uMXXXXXc8XFXXXXXXXXXX-1368-774.jpg_720x720.jpg" alt="img"></p>
<p>同时，内存占用比起之前也降低了很多。</p>
<p><img src="/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1eYvqMXXXXXbJXVXXXXXXXXXX-936-480.jpg" alt="img"></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>之前无线开发时，大多数人都很喜欢使用 <code>translateZ(0)</code> 来进行所谓的硬件加速，以提升性能，但是性能优化并没有所谓的“银弹”，<code>translateZ(0)</code> 不是，本文列出的优化建议也不是。抛开了对页面的具体分析，任何的性能优化都是站不住脚的，盲目的使用一些优化措施，结果可能会适得其反。因此切实的去分析页面的实际性能表现，不断的改进测试，才是正确的优化途径。</p>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>转载至淘宝，防止原链接失效</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/http3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/http3/" class="post-title-link" itemprop="url">第 3 章　HTTP 报文内的 HTTP 信息</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-24 00:00:00" itemprop="dateCreated datePublished" datetime="2021-02-24T00:00:00+08:00">2021-02-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-18 11:03:49" itemprop="dateModified" datetime="2024-07-18T11:03:49+08:00">2024-07-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/" itemprop="url" rel="index"><span itemprop="name">图解HTTP</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>HTTP 通信过程包括从客户端发往服务器端的请求及从服务器端返回客户端的响应。</p>
<h2 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h2><p>用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的 HTTP 报文叫做请求报文，响应端（服务器端）的叫做响应报文。 HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。<br>HTTP 报文大致可分为<strong>报文首部</strong>和<strong>报文主体</strong>两块。两者由最初出现的空行（CR+LF）来划分。通常，并不一定要有报文主体。<br><img src="/assets/http3/http3-bg1.png" alt="实例1">  </p>
<p>图：HTTP 报文的结构</p>
<h2 id="请求报文及响应报文的结构"><a href="#请求报文及响应报文的结构" class="headerlink" title="请求报文及响应报文的结构"></a>请求报文及响应报文的结构</h2><p>我们来看一下请求报文和响应报文的结构。<br><img src="/assets/http3/http3-bg2.png" alt="实例1"><br>图：请求报文（上）和响应报文（下）的结构<br><img src="/assets/http3/http3-bg3.png" alt="实例1"><br>图：请求报文（上）和响应报文（下）的实例  </p>
<p>请求报文和响应报文的<strong>首部内容</strong>由以下数据组成。现在出现的各种首部字段及状态码稍后会进行阐述。</p>
<ul>
<li>请求行<br>包含用于请求的方法，请求 URI 和 HTTP 版本。</li>
<li>状态行<br>包含表明响应结果的状态码，原因短语和 HTTP 版本。</li>
<li>首部字段<br>包含表示请求和响应的各种条件和属性的各类首部。<br>一般有 4 种首部，分别是：通用首部、请求首部、响应首部和实体首部。</li>
<li>其他<br>可能包含 HTTP 的 RFC 里未定义的首部（Cookie 等）。</li>
</ul>
<h2 id="编码提升传输速率"><a href="#编码提升传输速率" class="headerlink" title="编码提升传输速率"></a>编码提升传输速率</h2><p>HTTP 在传输数据时可以按照数据原貌直接传输，但也可以在传输过 程中通过编码提升传输速率。通过在传输时编码，能有效地处理大量 的访问请求。但是，编码的操作需要计算机来完成，因此会消耗更多的 CPU 等资源。</p>
<h3 id="报文主体和实体主体的差异"><a href="#报文主体和实体主体的差异" class="headerlink" title="报文主体和实体主体的差异"></a>报文主体和实体主体的差异</h3><ul>
<li>报文（message）<br>是 HTTP 通信中的基本单位，由 8 位组字节流（octet sequence， 其中 octet 为 8 个比特）组成，通过 HTTP 通信传输。</li>
<li>实体（entity）<br>作为请求或响应的有效载荷数据（补充项）被传输，其内容由实 体首部和实体主体组成。</li>
</ul>
<blockquote>
<p>通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体 主体的内容发生变化，才导致它和报文主体产生差异。</p>
</blockquote>
<h3 id="压缩传输的内容编码"><a href="#压缩传输的内容编码" class="headerlink" title="压缩传输的内容编码"></a>压缩传输的内容编码</h3><p>HTTP 协议中有一种被称为<strong>内容编码</strong>的功能也能进行类似的操作。内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。<br><img src="/assets/http3/http3-bg4.png" alt="实例1"><br>图：内容编码<br>常用的内容编码有以下几种。</p>
<ul>
<li>gzip（GNU zip）</li>
<li>compress（UNIX 系统的标准压缩）</li>
<li>deflate（zlib）</li>
<li>identity（不进行编码）</li>
</ul>
<h2 id="分割发送的分块传输编码"><a href="#分割发送的分块传输编码" class="headerlink" title="分割发送的分块传输编码"></a>分割发送的分块传输编码</h2><p>在传输大容量数据时，通过把数据分割成多块，这种把实体主体分块的功能称为分块传输编码（Chunked Transfer Coding）。<br><img src="/assets/http3/http3-bg5.png" alt="实例1"><br>图：分块传输编码<br>分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六 进制来标记块的大小，而实体主体的最后一块会使用<code>0(CR+LF)</code>来标记。<br>使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码前的实体主体。  </p>
<blockquote>
<p>HTTP&#x2F;1.1 中存在一种称为<strong>传输编码</strong>（Transfer Coding）的机制，它可 以在通信时按某种编码方式传输，但只定义作用于分块传输编码中。</p>
</blockquote>
<h2 id="发送多种数据的多部分对象集合"><a href="#发送多种数据的多部分对象集合" class="headerlink" title="发送多种数据的多部分对象集合"></a>发送多种数据的多部分对象集合</h2><p>HTTP 协议中也采纳了多部分对象集合，发送的一份报文主 体内可含有多类型实体。通常是在图片或文本文件等上传时使用。</p>
<ul>
<li>multipart&#x2F;form-data 在 Web 表单文件上传时使用。</li>
<li>multipart&#x2F;byteranges 状态码 206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用。</li>
</ul>
<h2 id="获取部分内容的范围请求"><a href="#获取部分内容的范围请求" class="headerlink" title="获取部分内容的范围请求"></a>获取部分内容的范围请求</h2><p>以前，用户不能使用现在这种高速的带宽访问互联网，当时，下载一个尺寸稍大的图片或文件就已经很吃力了。如果下载过程中遇到网络 中断的情况，那就必须重头开始。为了解决上述问题，需要一种可恢复的机制。所谓恢复是指能从之前下载中断处恢复下载。<br>要实现该功能需要指定下载的实体范围。像这样，指定范围发送的请 求叫做范围请求（Range Request）。  </p>
<p>对一份 10000 字节大小的资源，如果使用范围请求，可以只请求 5001~10 000 字节内的资源。<br><img src="/assets/http3/http3-bg6.png" alt="实例1"><br>执行范围请求时，会用到首部字段 Range 来指定资源的 byte 范围。</p>
<h2 id="内容协商返回最合适的内容"><a href="#内容协商返回最合适的内容" class="headerlink" title="内容协商返回最合适的内容"></a>内容协商返回最合适的内容</h2><p>当浏览器的默认语言为英语或中文，访问相同 URI 的 Web 页面时， 则会显示对应的英语版或中文版的 Web 页面。这样的机制称为内容 协商（Content Negotiation）。<br>包含在请求报文中的某些首部字段（如下）就是判断的基准。这些首 部字段的详细说明请参考下一章。</p>
<ul>
<li>Accept Accept-Charset</li>
<li>Accept-Encoding</li>
<li>Accept-Language</li>
<li>Content-Language<br>内容协商技术有以下 3 种类型。</li>
<li>服务器驱动协商（Server-driven Negotiation）<br>由服务器端进行内容协商。以请求的首部字段为参考，在服务器端自 动处理。但对用户来说，以浏览器发送的信息作为判定的依据，并不一定能筛选出最优内容。</li>
<li>客户端驱动协商（Agent-driven Negotiation）<br>由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手 动选择。还可以利用 JavaScript 脚本在 Web 页面上自动进行上述选 择。比如按 OS 的类型或浏览器类型，自行切换成 PC 版页面或手机 版页面。</li>
<li>透明协商（Transparent Negotiation）<br>是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进 行内容协商的一种方法。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/Macro&MicroTask/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/Macro&MicroTask/" class="post-title-link" itemprop="url">MacroTask（宏任务）和MicroTask（微任务）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-22 00:00:00" itemprop="dateCreated datePublished" datetime="2021-02-22T00:00:00+08:00">2021-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-17 10:53:10" itemprop="dateModified" datetime="2024-07-17T10:53:10+08:00">2024-07-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">零散知识</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>这个直接看浏览器原理 V8 第18节 有更详细的讲解<br><a href="/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%8F%8A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">时间循环及消息队列</a></p>
</blockquote>
<p>micro-task和macro-task就是两种不同的任务队列</p>
<ul>
<li>macro-task:<ul>
<li>script(script标签里面的整体代码)</li>
<li>setTimeout</li>
<li>setInterval</li>
<li>setImmediate</li>
<li>MessageChannel（vue nextTick 以前应该是<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/reactivity.html">备选方案</a>）</li>
<li>I&#x2F;O</li>
<li>UI rendering</li>
<li>requestAnimationFrame</li>
</ul>
</li>
<li>micro-task:<ul>
<li>process.nextTick</li>
<li>Promise</li>
<li>Object.observe(已废弃)</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver">MutationObserver</a> (接口提供了监视对DOM树所做更改的能力)</li>
</ul>
</li>
</ul>
<p>JS开发人员应该对这些方法都不会太陌生——都是些常见的异步操作。但这些方法在执行时有什么区别呢？通俗来说，macrotasks和microtasks最大的区别在它们会被放置在不同的任务调度队列中。我在网上找了一张图，如下所示：</p>
<ul>
<li><strong>每个宏任务都会对应一个微任务列表</strong></li>
<li><strong>微任务列表存储在环境变量中</strong></li>
<li>结论来自于v8原理 18节</li>
</ul>
<p><img src="/assets/Macro&MicroTask/MacroTask1.jpg" alt="示意图"><br>每一次事件循环中，主进程都会先执行一个macroTask任务，这个任务就来自于所谓的MacroTask Queue队列；当该macroTask结束前，Event loop会立马<strong>调用microTask队列的任务，直到消费完所有的microtask，再继续下一个事件循环</strong>。</p>
<blockquote>
<p>管中窥豹，microTask调用优先级较高于macroTask.<br>先看一个demo</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;main start&#x27;);</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;setTimeout&#x27;);</span><br><span class="line">  process.nextTick(() =&gt; console.log(&#x27;process.nextTick 3&#x27;));</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">process.nextTick(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;process.nextTick 1&#x27;);</span><br><span class="line">  process.nextTick(() =&gt; console.log(&#x27;process.nextTick 2&#x27;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&#x27;main end&#x27;);</span><br></pre></td></tr></table></figure>

<p>看看它们的执行顺序是怎么样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1   main start</span><br><span class="line">2   main end</span><br><span class="line">3   process.nextTick 1</span><br><span class="line">4   process.nextTick 2</span><br><span class="line">5   setTimeout</span><br><span class="line">6   process.nextTick 3</span><br></pre></td></tr></table></figure>

<p>大致流程如下所示：</p>
<ol>
<li><p>先运行主程序（事实上主程序本身就是一个macroTask），主程序把setTimeout和process.nextTick分别放入MacroTask Queue和MicroTask Queue</p>
</li>
<li><p>主程序结束，这时候我们看到了第一二条的打印结果main start、main end</p>
</li>
<li><p>如上面所提到的，每一个macroTask结束后会开始消费microTask。这时的MicroTask Queue里有一个process.nextTick，然后发现它本身也调用了一个process.nextTick，所以继续把这个内层的任务加入MicroTask Queue。</p>
</li>
<li><p>线程消费掉所有MicroTask Queue里的任务（这时只有两个任务），我们得到了第三四条结果process.nextTick 1和process.nextTick 2</p>
</li>
<li><p>当MicroTask Queue清空后，Event Loop进入下一个循环：执行MacroTask Queue的setTimeout任务，然后得到了第五条输出setTimeout，之后它还会把又一个process.nextTick放入MicroTask Queue</p>
</li>
<li><p>继续如4所示过程，Event Loop在Current MacroTask执行完成后消费MicroTask Queue，这时候我们有了最后一条输出process.nextTick 3</p>
</li>
</ol>
<p><strong>下面也是一道经常考的面试题,可以更好的理解async await</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">async function async1() &#123;</span><br><span class="line">  console.log(&#x27;async1 start&#x27;); // 2</span><br><span class="line">  await async2(); // 微任务 1</span><br><span class="line">  console.log(&#x27;async1 end&#x27;); // 微任务 1 6</span><br><span class="line">&#125;</span><br><span class="line">async function async2() &#123;</span><br><span class="line">  console.log(&#x27;async2&#x27;); // 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&#x27;script start&#x27;);  // 1</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(&#x27;setTimeout&#x27;); // 宏任务 1 8</span><br><span class="line">&#125;, 0)</span><br><span class="line"></span><br><span class="line">async1(); </span><br><span class="line"></span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">  console.log(&#x27;promise1&#x27;); // 4</span><br><span class="line">  resolve(); // 微任务 2</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">  console.log(&#x27;promise2&#x27;); // 微任务 2 7</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&#x27;script end&#x27;); // 5</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/" class="post-title-link" itemprop="url">前端安全</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-17 00:00:00" itemprop="dateCreated datePublished" datetime="2021-02-17T00:00:00+08:00">2021-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-13 14:29:27" itemprop="dateModified" datetime="2024-07-13T14:29:27+08:00">2024-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">零散知识</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903685122703367">美团安全系列-XSS</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903689702866952">美团安全系列-CSRF</a></p>
<h2 id="1-XSS攻击"><a href="#1-XSS攻击" class="headerlink" title="1. XSS攻击"></a>1. XSS攻击</h2><p>XSS(Cross-Site Scripting，<strong>跨站脚本攻击</strong>)是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当被攻击者登陆网站时就会执行这些恶意代码，这些脚本可以读取 cookie，session tokens，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。</p>
<p>XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，利用这些信息冒充用户向网站发起攻击者定义的请求。</p>
<blockquote>
<p>XSS分类</p>
</blockquote>
<p>根据攻击的来源，XSS攻击可以分为存储型(持久性)、反射型(非持久型)和DOM型三种。下面我们来详细了解一下这三种XSS攻击：</p>
<h3 id="1-1-反射型XSS"><a href="#1-1-反射型XSS" class="headerlink" title="1.1 反射型XSS"></a>1.1 反射型XSS</h3><p>当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。Web服务器将注入脚本，比如一个错误信息，搜索结果等，未进行过滤直接返回到用户的浏览器上。</p>
<blockquote>
<p>反射型 XSS 的攻击步骤：</p>
</blockquote>
<ol>
<li>攻击者构造出特殊的 <code>URL</code>，其中包含恶意代码。</li>
<li>用户打开带有恶意代码的 <code>URL</code> 时，网站服务端将恶意代码从 <code>URL</code> 中取出，拼接在 HTML 中返回给浏览器。</li>
<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>
</ol>
<p>反射型 XSS 漏洞常见于通过 <code>URL</code> 传递参数的功能，如网站搜索、跳转等。由于需要用户主动打开恶意的 <code>URL</code> 才能生效，攻击者往往会结合多种手段诱导用户点击。</p>
<p>POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。</p>
<p>注意<code>Chrome</code> 和 <code>Safari</code> 能够检测到 <code>url</code> 上的xss攻击，将网页拦截掉，但是其它浏览器不行，如<code>Firefox</code></p>
<p>如果不希望被前端拿到cookie，后端可以设置 <code>httpOnly</code> (不过这不是 <code>XSS攻击</code> 的解决方案，只能降低受损范围)</p>
<blockquote>
<p>如何防范反射型XSS攻击</p>
</blockquote>
<p><strong>对字符串进行编码。</strong></p>
<p>对url的查询参数进行转义后再输出到页面。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#x27;/welcome&#x27;, function(req, res) &#123;</span><br><span class="line">    //对查询参数进行编码，避免反射型 XSS攻击</span><br><span class="line">    res.send(`$&#123;encodeURIComponent(req.query.type)&#125;`); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="1-2-DOM-型-XSS"><a href="#1-2-DOM-型-XSS" class="headerlink" title="1.2 DOM 型 XSS"></a>1.2 DOM 型 XSS</h3><p>DOM 型 XSS 攻击，实际上就是前端 <code>JavaScript</code> 代码不够严谨，把不可信的内容插入到了页面。在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>.appendChild</code>、<code>document.write()</code>等API时要特别小心，不要把不可信的数据作为 HTML 插到页面上，尽量使用 <code>.innerText</code>、<code>.textContent</code>、<code>.setAttribute()</code> 等。</p>
<blockquote>
<p>DOM 型 XSS 的攻击步骤：</p>
</blockquote>
<ol>
<li>攻击者构造出特殊数据，其中包含恶意代码。</li>
<li>用户浏览器执行了恶意代码。</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>
</ol>
<blockquote>
<p>如何防范 DOM 型 XSS 攻击</p>
</blockquote>
<p>防范 DOM 型 XSS 攻击的核心就是对输入内容进行转义(DOM 中的内联事件监听器和链接跳转都能把字符串作为代码运行，需要对其内容进行检查)。</p>
<p>1.对于<code>url</code>链接(例如图片的<code>src</code>属性)，那么直接使用 <code>encodeURIComponent</code> 来转义。</p>
<p>2.非<code>url</code>，我们可以这样进行编码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function encodeHtml(str) &#123;</span><br><span class="line">    return str.replace(/&quot;/g, &#x27;&amp;quot;&#x27;)</span><br><span class="line">            .replace(/&#x27;/g, &#x27;&amp;apos;&#x27;)</span><br><span class="line">            .replace(/&lt;/g, &#x27;&amp;lt;&#x27;)</span><br><span class="line">            .replace(/&gt;/g, &#x27;&amp;gt;&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞。</p>
<h3 id="1-3-存储型XSS"><a href="#1-3-存储型XSS" class="headerlink" title="1.3 存储型XSS"></a>1.3 存储型XSS</h3><p>恶意脚本永久存储在目标服务器上。当浏览器请求数据时，脚本从服务器传回并执行，影响范围比反射型和DOM型XSS更大。存储型XSS攻击的原因仍然是没有做好数据过滤：前端提交数据至服务端时，没有做好过滤；服务端在接受到数据时，在存储之前，没有做过滤；前端从服务端请求到数据，没有过滤输出。</p>
<blockquote>
<p>存储型 XSS 的攻击步骤：</p>
</blockquote>
<ol>
<li>攻击者将恶意代码提交到目标网站的数据库中。</li>
<li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</li>
<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>
</ol>
<p>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</p>
<blockquote>
<p>如何防范存储型XSS攻击：</p>
</blockquote>
<ol>
<li>前端数据传递给服务器之前，先转义&#x2F;过滤(防范不了抓包修改数据的情况)</li>
<li>服务器接收到数据，在存储到数据库之前，进行转义&#x2F;过滤</li>
<li>前端接收到服务器传递过来的数据，在展示到页面前，先进行转义&#x2F;过滤</li>
</ol>
<h3 id="1-4-防范XSS攻击"><a href="#1-4-防范XSS攻击" class="headerlink" title="1.4 防范XSS攻击"></a>1.4 防范XSS攻击</h3><ul>
<li><p>XSS（Cross-Site Scripting）攻击是一种常见的Web应用程序安全漏洞，攻击者利用漏洞在网站上注入恶意脚本或代码，以获取用户的敏感信息或控制用户的浏览器。为了防范XSS攻击，可以采取以下方法：</p>
<ol>
<li>输入检查：在用户输入数据时，对数据进行检查和过滤，过滤掉特殊字符和脚本代码。比如可以使用HTML实体编码对特殊字符进行转义，比如&lt;转义为&lt;。</li>
<li>输出转义：在输出数据到页面上时，对数据进行转义。比如使用HTML实体编码将特殊字符转义成文本，这样就可以避免浏览器将其解析成HTML标签。比如将&lt;转义为&lt;。</li>
<li>CSP（Content Security Policy）：设置CSP响应头，限制页面中允许加载的资源类型，禁止内联脚本执行等，这样可以减少XSS攻击的影响。</li>
<li>Cookie安全策略：使用HttpOnly和Secure属性，限制Cookie只能通过HTTP协议传输，防止Cookie被盗取。</li>
<li>防止DOM操作：对于不可信的数据，应该避免直接将其插入到DOM中，可以使用textContent或者innerText等属性插入数据，这样可以避免执行脚本。</li>
<li>HTTPS传输：使用HTTPS协议传输数据，加密传输数据，防止数据被拦截和篡改。</li>
<li>前端框架的防护：一些前端框架（如Angular、React、Vue等）在渲染模板时会自动转义输出的内容，可以减少XSS攻击的风险。</li>
</ol>
<p>综上所述，防范XSS攻击需要综合采用多种方法，不同的方法可以在不同的层面上增强网站的安全性。</p>
</li>
</ul>
<h3 id="1-5-XSS-检测"><a href="#1-5-XSS-检测" class="headerlink" title="1.5 XSS 检测"></a>1.5 XSS 检测</h3><p>读到这儿，相信大家已经知道了什么是XSS攻击，XSS攻击的类型，以及如何去防范XSS攻击。但是有一个非常重要的问题是：我们如何去检测XSS攻击，怎么知道自己的页面是否存在XSS漏洞？</p>
<p>很多大公司，都有专门的安全部门负责这个工作，但是如果没有安全部门，作为开发者本身，该如何去检测呢？</p>
<p>1.使用通用 XSS 攻击字串手动检测 XSS 漏洞</p>
<p>如:<br><code>jaVasCript:/*-/*</code>&#x2F;*`&#x2F;*’&#x2F;*”&#x2F;**&#x2F;(&#x2F;* *&#x2F;oNcliCk&#x3D;alert() )&#x2F;&#x2F;%0D%0A%0d%0a&#x2F;&#x2F;&lt;&#x2F;stYle&#x2F;&lt;&#x2F;titLe&#x2F;&lt;&#x2F;teXtarEa&#x2F;&lt;&#x2F;scRipt&#x2F;–!&gt;\x3csVg&#x2F;&lt;sVg&#x2F;oNloAd&#x3D;alert()&#x2F;&#x2F;&gt;\x3e&#96;</p>
<p>能够检测到存在于 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等多种上下文中的 XSS 漏洞，也能检测 eval()、setTimeout()、setInterval()、Function()、innerHTML、document.write() 等 DOM 型 XSS 漏洞，并且能绕过一些 XSS 过滤器。</p>
<p><code>&lt;img src=1 onerror=alert(1)&gt;</code></p>
<p>2.使用第三方工具进行扫描</p>
<hr>
<h2 id="2-CSRF"><a href="#2-CSRF" class="headerlink" title="2. CSRF"></a>2. CSRF</h2><p>CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p>
<blockquote>
<p>典型的CSRF攻击流程：</p>
</blockquote>
<ol>
<li>受害者登录A站点，并保留了登录凭证（Cookie）。</li>
<li>攻击者诱导受害者访问了站点B。</li>
<li><strong>站点B向站点A发送了一个请求，浏览器会默认携带站点A的Cookie信息</strong>。</li>
<li>站点A接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是无辜的受害者发送的请求。</li>
<li>站点A以受害者的名义执行了站点B的请求。</li>
<li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者完成了攻击。</li>
</ol>
<blockquote>
<p>CSRF的特点</p>
</blockquote>
<p>1.攻击通常在第三方网站发起，如图上的站点B，站点A无法防止攻击发生。</p>
<p>2.攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；并不会去获取cookie信息(cookie有同源策略)</p>
<p>3.跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等(来源不明的链接，不要点击)</p>
<h3 id="CSRF-攻击防御"><a href="#CSRF-攻击防御" class="headerlink" title="CSRF 攻击防御"></a>CSRF 攻击防御</h3><p><strong>1. 添加验证码(体验不好)</strong></p>
<p>验证码能够防御CSRF攻击，但是我们不可能每一次交互都需要验证码，否则用户的体验会非常差，但是我们可以在转账，交易等操作时，增加验证码，确保我们的账户安全。</p>
<p><strong>2. 判断请求的来源：检测Referer(并不安全，Referer可以被更改)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`Referer` 可以作为一种辅助手段，来判断请求的来源是否是安全的，但是鉴于 `Referer` 本身是可以被修改的，因为不能仅依赖于  `Referer`</span><br></pre></td></tr></table></figure>

<p><strong>3. 使用Token(主流)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开。跟验证码类似，只是用户无感知。</span><br><span class="line"></span><br><span class="line">- 服务端给用户生成一个token，加密后传递给用户</span><br><span class="line">- 用户在提交请求时，需要携带这个token</span><br><span class="line">- 服务端验证token是否正确</span><br></pre></td></tr></table></figure>

<p><strong>4. Samesite Cookie属性</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html">阮一峰samesite</a></p>
<p>为了从源头上解决这个问题，Google起草了一份草案来改进HTTP协议，为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax。</p>
<p>部署简单，并能有效防御CSRF攻击，但是存在兼容性问题。</p>
<p><strong>Samesite&#x3D;Strict</strong></p>
<p><code>Samesite=Strict</code> 被称为是严格模式,表明这个 Cookie 在任何情况都不可能作为第三方的 Cookie，有能力阻止所有CSRF攻击。此时，我们在B站点下发起对A站点的任何请求，A站点的 Cookie 都不会包含在cookie请求头中。</p>
<p><strong>Samesite&#x3D;Lax</strong></p>
<p><code>Samesite=Lax</code> 被称为是宽松模式，与 Strict 相比，放宽了限制，允许发送安全 HTTP 方法带上 Cookie，如 <code>Get</code> &#x2F; <code>OPTIONS</code> 、<code>HEAD</code> 请求.</p>
<p>但是不安全 HTTP 方法，如： <code>POST</code>, <code>PUT</code>, <code>DELETE</code> 请求时，不能作为第三方链接的 Cookie</p>
<p>为了更好的防御CSRF攻击，我们可以组合使用以上防御手段。</p>
<h2 id="3-点击劫持"><a href="#3-点击劫持" class="headerlink" title="3. 点击劫持"></a>3. 点击劫持</h2><p>点击劫持是指在一个Web页面中隐藏了一个透明的iframe，用外层假页面诱导用户点击，实际上是在隐藏的frame上触发了点击事件进行一些用户不知情的操作。</p>
<h4 id="典型点击劫持攻击流程"><a href="#典型点击劫持攻击流程" class="headerlink" title="典型点击劫持攻击流程"></a>典型点击劫持攻击流程</h4><ol>
<li>攻击者构建了一个非常有吸引力的网页</li>
<li>将被攻击的页面放置在当前页面的 <code>iframe</code> 中</li>
<li>使用样式将 iframe 叠加到非常有吸引力内容的上方</li>
<li>将iframe设置为100%透明</li>
<li>你被诱导点击了网页内容，你以为你点击的是***，而实际上，你成功被攻击了。</li>
</ol>
<h4 id="点击劫持防御"><a href="#点击劫持防御" class="headerlink" title="点击劫持防御"></a>点击劫持防御</h4><p><strong>1. frame busting</strong></p>
<p>Frame busting</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ( top.location != window.location )&#123;</span><br><span class="line">    top.location = window.location</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是: HTML5中iframe的 <code>sandbox</code> 属性、IE中iframe的<code>security</code> 属性等，都可以限制iframe页面中的JavaScript脚本执行，从而可以使得 frame busting 失效。</p>
<p><strong>2. X-Frame-Options</strong></p>
<p>X-FRAME-OPTIONS是微软提出的一个http头，专门用来防御利用iframe嵌套的点击劫持攻击。并且在IE8、Firefox3.6、Chrome4以上的版本均能很好的支持。</p>
<p>可以设置为以下值:</p>
<ul>
<li>DENY: 拒绝任何域加载</li>
<li>SAMEORIGIN: 允许同源域下加载</li>
<li>ALLOW-FROM: 可以定义允许frame加载的页面地址</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E5%A4%9A%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E5%A4%9A%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">类的多种继承方式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-17 00:00:00" itemprop="dateCreated datePublished" datetime="2021-02-17T00:00:00+08:00">2021-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-02-17 15:42:44" itemprop="dateModified" datetime="2022-02-17T15:42:44+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="url" rel="index"><span itemprop="name">面向对象</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>转载自<a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog">github</a> 参考JS高程</p>
<p>本文讲解JavaScript各种继承方式和优缺点。</p>
<p>但是注意：</p>
<p>这篇文章更像是笔记，哎，再让我感叹一句：《JavaScript高级程序设计》写得真是太好了！</p>
<h2 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1.原型链继承"></a>1.原型链继承</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Parent () &#123;</span><br><span class="line">    this.name = &#x27;kevin&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child () &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = new Parent();</span><br><span class="line"></span><br><span class="line">var child1 = new Child();</span><br><span class="line"></span><br><span class="line">console.log(child1.getName()) // kevin</span><br></pre></td></tr></table></figure>

<p>问题：</p>
<p>1.引用类型的属性被所有实例共享，举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Parent () &#123;</span><br><span class="line">    this.names = [&#x27;kevin&#x27;, &#x27;daisy&#x27;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child () &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = new Parent();</span><br><span class="line"></span><br><span class="line">var child1 = new Child();</span><br><span class="line"></span><br><span class="line">child1.names.push(&#x27;yayu&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(child1.names); // [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span><br><span class="line"></span><br><span class="line">var child2 = new Child();</span><br><span class="line"></span><br><span class="line">console.log(child2.names); // [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span><br></pre></td></tr></table></figure>

<p>2.在创建 Child 的实例时，不能向Parent传参</p>
<h2 id="2-借用构造函数-经典继承"><a href="#2-借用构造函数-经典继承" class="headerlink" title="2.借用构造函数(经典继承)"></a>2.借用构造函数(经典继承)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Parent () &#123;</span><br><span class="line">    this.names = [&#x27;kevin&#x27;, &#x27;daisy&#x27;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child () &#123;</span><br><span class="line">    Parent.call(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var child1 = new Child();</span><br><span class="line"></span><br><span class="line">child1.names.push(&#x27;yayu&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(child1.names); // [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span><br><span class="line"></span><br><span class="line">var child2 = new Child();</span><br><span class="line"></span><br><span class="line">console.log(child2.names); // [&quot;kevin&quot;, &quot;daisy&quot;]</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<p>1.避免了引用类型的属性被所有实例共享</p>
<p>2.可以在 Child 中向 Parent 传参</p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Parent (name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child (name) &#123;</span><br><span class="line">    Parent.call(this, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var child1 = new Child(&#x27;kevin&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(child1.name); // kevin</span><br><span class="line"></span><br><span class="line">var child2 = new Child(&#x27;daisy&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(child2.name); // daisy</span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<p>方法都在构造函数中定义，每次创建实例都会创建一遍方法。</p>
<h2 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3.组合继承"></a>3.组合继承</h2><p>原型链继承和经典继承双剑合璧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function Parent (name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child (name, age) &#123;</span><br><span class="line"></span><br><span class="line">    Parent.call(this, name);</span><br><span class="line">    </span><br><span class="line">    this.age = age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = new Parent();</span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line"></span><br><span class="line">var child1 = new Child(&#x27;kevin&#x27;, &#x27;18&#x27;);</span><br><span class="line"></span><br><span class="line">child1.colors.push(&#x27;black&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(child1.name); // kevin</span><br><span class="line">console.log(child1.age); // 18</span><br><span class="line">console.log(child1.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</span><br><span class="line"></span><br><span class="line">var child2 = new Child(&#x27;daisy&#x27;, &#x27;20&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(child2.name); // daisy</span><br><span class="line">console.log(child2.age); // 20</span><br><span class="line">console.log(child2.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</span><br></pre></td></tr></table></figure>

<p>优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。</p>
<h2 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4.原型式继承"></a>4.原型式继承</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function createObj(o) &#123;</span><br><span class="line">    function F()&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    return new F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。</p>
<p>缺点：</p>
<p>包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &#x27;kevin&#x27;,</span><br><span class="line">    friends: [&#x27;daisy&#x27;, &#x27;kelly&#x27;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 = createObj(person);</span><br><span class="line">var person2 = createObj(person);</span><br><span class="line"></span><br><span class="line">person1.name = &#x27;person1&#x27;;</span><br><span class="line">console.log(person2.name); // kevin</span><br><span class="line"></span><br><span class="line">person1.firends.push(&#x27;taylor&#x27;);</span><br><span class="line">console.log(person2.friends); // [&quot;daisy&quot;, &quot;kelly&quot;, &quot;taylor&quot;]</span><br></pre></td></tr></table></figure>

<p>注意：修改<code>person1.name</code>的值，<code>person2.name</code>的值并未发生改变，并不是因为<code>person1</code>和<code>person2</code>有独立的 name 值，而是因为<code>person1.name = &#39;person1&#39;</code>，给<code>person1</code>添加了 name 值，并非修改了原型上的 name 值。</p>
<h2 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5. 寄生式继承"></a>5. 寄生式继承</h2><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function createObj (o) &#123;</span><br><span class="line">    var clone = Object.create(o);</span><br><span class="line">    clone.sayName = function () &#123;</span><br><span class="line">        console.log(&#x27;hi&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    return clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。</p>
<h2 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6. 寄生组合式继承"></a>6. 寄生组合式继承</h2><p>为了方便大家阅读，在这里重复一下组合继承的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Parent (name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child (name, age) &#123;</span><br><span class="line">    Parent.call(this, name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = new Parent();</span><br><span class="line"></span><br><span class="line">var child1 = new Child(&#x27;kevin&#x27;, &#x27;18&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(child1)</span><br></pre></td></tr></table></figure>

<p>组合继承最大的缺点是会调用两次父构造函数。</p>
<p>一次是设置子类型实例的原型的时候：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Child.prototype = new Parent();</span><br></pre></td></tr></table></figure>

<p>一次在创建子类型实例的时候：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var child1 = new Child(&#x27;kevin&#x27;, &#x27;18&#x27;);</span><br></pre></td></tr></table></figure>

<p>回想下 new 的模拟实现，其实在这句中，我们会执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Parent.call(this, name);</span><br></pre></td></tr></table></figure>

<p>在这里，我们又会调用了一次 Parent 构造函数。</p>
<p>所以，在这个例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为<code>colors</code>，属性值为<code>[&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;]</code>。</p>
<p>那么我们该如何精益求精，避免这一次重复调用呢？</p>
<p>如果我们不使用 Child.prototype &#x3D; new Parent() ，而是间接的让 Child.prototype 访问到 Parent.prototype 呢？</p>
<p>看看如何实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function inheritPrototype(subType, superType) &#123;</span><br><span class="line">    let prototype = object(superType.prototype); // 创建对象</span><br><span class="line">    prototype.constructor = subType; // 增强对象 </span><br><span class="line">    subType.prototype = prototype; // 赋值对象</span><br><span class="line">  &#125;</span><br><span class="line">  function object(o) &#123; </span><br><span class="line">    function F() &#123;&#125; </span><br><span class="line">    F.prototype = o; </span><br><span class="line">    return new F(); </span><br><span class="line">  &#125;</span><br><span class="line">  function SuperType(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">  &#125;</span><br><span class="line">  SuperType.prototype.sayName = function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  function SubType(name, age) &#123;</span><br><span class="line">    SuperType.call(this, name);</span><br><span class="line">    this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  inheritPrototype(SubType, SuperType);</span><br><span class="line">  SubType.prototype.sayAge = function () &#123;</span><br><span class="line">    console.log(this.age);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>引用《JavaScript高级程序设计》中对寄生组合式继承的夸赞就是：</p>
<p>这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/vuex/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/vuex/" class="post-title-link" itemprop="url">vuex源码分析-简易流程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-09 00:00:00" itemprop="dateCreated datePublished" datetime="2021-02-09T00:00:00+08:00">2021-02-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-18 16:48:41" itemprop="dateModified" datetime="2024-07-18T16:48:41+08:00">2024-07-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">源码分析</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="/assets/vuex/image-20220214140159456.png" alt="image-20220214140159456"></p>
<p>先放一张store的代码结构图</p>
<p><img src="/assets/vuex/image-20210929161132720.png" alt="image-20210929161132720"></p>
<h2 id="vuex初始化"><a href="#vuex初始化" class="headerlink" title="vuex初始化"></a>vuex初始化</h2><p>Vuex 存在一个静态的 <code>install</code> 方法，在beforeCreate混入了vuexInit，我们只看关键逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function vuexInit () &#123;</span><br><span class="line">    const options = this.$options</span><br><span class="line">    // store injection</span><br><span class="line">    if (options.store) &#123;</span><br><span class="line">      this.$store = typeof options.store === &#x27;function&#x27;</span><br><span class="line">        ? options.store()</span><br><span class="line">        : options.store</span><br><span class="line">    &#125; else if (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class="line">      this.$store = options.parent.$store</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>通过声明周期函数，将store挂载到每一个组件上</p>
<h2 id="Store实例化"><a href="#Store实例化" class="headerlink" title="Store实例化"></a>Store实例化</h2><p>我们把 <code>Store</code> 的实例化过程拆成 3 个部分，分别是</p>
<ul>
<li>初始化模块</li>
<li>安装模块</li>
<li>初始化 <code>store._vm</code></li>
</ul>
<h3 id="初始化模块"><a href="#初始化模块" class="headerlink" title="初始化模块"></a>初始化模块</h3><h4 id="构建module树"><a href="#构建module树" class="headerlink" title="构建module树"></a>构建module树</h4><p>其实就是处理用户输入的配置，重点在于通过module层级建立联系，如下图所示</p>
<p><img src="/assets/vuex/image-20210929161649181.png" alt="image-20210929161649181"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">_modules</span> = <span class="keyword">new</span> <span class="title class_">ModuleCollection</span>(options)</span><br></pre></td></tr></table></figure>

<p><code>ModuleCollection</code> 实例化的过程就是执行了 <code>register</code> 方法，register方法递归遍历所有module，生成<code>module</code>实例，并通过<code>_children</code>属性与path和建立下级关系</p>
<blockquote>
<p>建立关联的代码很精妙，建议结合源码回忆</p>
</blockquote>
<h3 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h3><pre><code>installModule(this, state, [], this._modules.root)
</code></pre>
<p>递归执行，它的目标就是对各个模块中的 state、getters、mutations、actions 做初始化工作</p>
<p><strong>installModule</strong>函数主要做了下述几个事情：</p>
<h4 id="挂载子module-state到rootState"><a href="#挂载子module-state到rootState" class="headerlink" title="挂载子module state到rootState"></a>挂载子module state到rootState</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f (!isRoot &amp;&amp; !hot) &#123;</span><br><span class="line">    const parentState = getNestedState(rootState, path.slice(0, -1))</span><br><span class="line">    const moduleName = path[path.length - 1]</span><br><span class="line">    store._withCommit(() =&gt; &#123;</span><br><span class="line">      Vue.set(parentState, moduleName, module.state)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="根据namespace配置构建module映射"><a href="#根据namespace配置构建module映射" class="headerlink" title="根据namespace配置构建module映射"></a>根据namespace配置构建module映射</h4><p>为了根据命名空间快速查找到对应的module</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (module.namespaced) &#123;</span><br><span class="line">    store._modulesNamespaceMap[namespace] = module</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="构造模块上下文环境"><a href="#构造模块上下文环境" class="headerlink" title="构造模块上下文环境"></a>构造模块上下文环境</h4><p><img src="/assets/vuex/image-20210929171104463.png" alt="image-20210929171104463"></p>
<p>构造了一个模块上下文环境：保证模块内两种方法的正确运行和两种数据的正常访问</p>
<blockquote>
<p>例如 模块内的dispatch(“B”) 会映射到 rootStore.dispatch(“A&#x2F;B”)</p>
</blockquote>
<h4 id="注册mutation-action-getter"><a href="#注册mutation-action-getter" class="headerlink" title="注册mutation action getter"></a>注册mutation action getter</h4><p>其实就是把三个属性对应用户输入挂载到rootStore上去，这里也用到了<strong>模块上下文</strong></p>
<p>举一个mutation的例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> module.forEachMutation((mutation, key) =&gt; &#123;</span><br><span class="line">    const namespacedType = namespace + key</span><br><span class="line">    // 在root module下 注册了 命名空间 mutation 下同</span><br><span class="line">    registerMutation(store, namespacedType, mutation, local)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  function registerMutation (store, type, handler, local) &#123;</span><br><span class="line">    const entry = store._mutations[type] || (store._mutations[type] = [])</span><br><span class="line">    // 数组  说明 同一 type 的 _mutations 可以对应多个方法</span><br><span class="line">    entry.push(function wrappedMutationHandler(payload) &#123;</span><br><span class="line">      // store 对应模块的store  </span><br><span class="line">    handler.call(store, local.state, payload)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这里就可以看出，所有的mutations都是挂载在根store的_mutations中，并且同名mutation不会覆盖，而且推入一个队列，顺序执行，下图是实际的代码</p>
<p><img src="/assets/vuex/image-20210929172730903.png" alt="image-20210929172730903"></p>
<p>可以看出来，开启命名空间实际上就是在mutation事件名前拼接了一个路径</p>
<p>这个地方也解除了我对vuex官方文档一段话的不解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">默认情况下，模块内部的 action、mutation 和 getter 是注册在**全局命名空间**的——这样使得多个模块能够对同一 mutation 或 action 作出响应。</span><br><span class="line"></span><br><span class="line">如果希望你的模块具有更高的封装度和复用性，你可以通过添加 `namespaced: true` 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：</span><br></pre></td></tr></table></figure>

<h3 id="初始化-store-vm"><a href="#初始化-store-vm" class="headerlink" title="初始化 store._vm"></a>初始化 <code>store._vm</code></h3><p><code>Store</code> 实例化的最后一步，就是执行初始化 <code>store._vm</code> 的逻辑，它的入口代码是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">resetStoreVM</span>(<span class="variable language_">this</span>, state)</span><br></pre></td></tr></table></figure>

<p><strong><code>resetStoreVM</code> 的作用实际上是想建立 <code>getters</code> 和 <code>state</code> 的联系</strong></p>
<p>利用vue的data和computed机制实现联系，关键代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const wrappedGetters = store._wrappedGetters</span><br><span class="line"> const computed = &#123;&#125;</span><br><span class="line"> forEachValue(wrappedGetters, (fn, key) =&gt; &#123;</span><br><span class="line">   // use computed to leverage its lazy-caching mechanism</span><br><span class="line">   computed[key] = () =&gt; fn(store)</span><br><span class="line">   Object.defineProperty(store.getters, key, &#123;</span><br><span class="line">     get: () =&gt; store._vm[key],</span><br><span class="line">     enumerable: true // for local getters</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"> // use a Vue instance to store the state tree</span><br><span class="line"> // suppress warnings just in case the user has added</span><br><span class="line"> // some funky global mixins</span><br><span class="line"> const silent = Vue.config.silent</span><br><span class="line"> Vue.config.silent = true</span><br><span class="line"> store._vm = new Vue(&#123;</span><br><span class="line">   data: &#123;</span><br><span class="line">     $$state: state</span><br><span class="line">   &#125;,</span><br><span class="line">   computed</span><br><span class="line"> &#125;)</span><br><span class="line"> Vue.config.silent = silent</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">马农</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
