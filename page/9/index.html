<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"mst123.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="学习记录">
<meta property="og:type" content="website">
<meta property="og:title" content="博客">
<meta property="og:url" content="https://mst123.github.io/page/9/index.html">
<meta property="og:site_name" content="博客">
<meta property="og:description" content="学习记录">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="马农">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://mst123.github.io/page/9/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/9/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">博客</h1>
      <i class="logo-line"></i>
    </a>
      <img class="custom-logo-image" src="/images/gintama.jpg" alt="博客">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="马农"
      src="/images/luopo.gif">
  <p class="site-author-name" itemprop="name">马农</p>
  <div class="site-description" itemprop="description">学习记录</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">105</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">125</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/http2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/http2/" class="post-title-link" itemprop="url">第 2 章　简单的 HTTP 协议</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-02 00:00:00" itemprop="dateCreated datePublished" datetime="2021-02-02T00:00:00+08:00">2021-02-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-18 11:03:12" itemprop="dateModified" datetime="2024-07-18T11:03:12+08:00">2024-07-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/" itemprop="url" rel="index"><span itemprop="name">图解HTTP</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本章将针对 HTTP 协议结构进行讲解</p>
<h2 id="HTTP-协议用于客户端和服务器端之间的通信"><a href="#HTTP-协议用于客户端和服务器端之间的通信" class="headerlink" title="HTTP 协议用于客户端和服务器端之间的通信"></a>HTTP 协议用于客户端和服务器端之间的通信</h2><p>HTTP 协议和 TCP&#x2F;IP 协议族内的其他众多的协议相同，用于客户端和服务器之间的通信。<br>请求访问文本或图像等资源的一端称为客户端，而提供资源响应的一端称为服务器端。</p>
<h3 id="通过请求和响应的交换达成通信"><a href="#通过请求和响应的交换达成通信" class="headerlink" title="通过请求和响应的交换达成通信"></a>通过请求和响应的交换达成通信</h3><p>HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有 接收到请求之前不会发送响应。<br>下面，我们来看一个具体的示例。<br><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http2/http2-bg1.png" alt="实例1">  </p>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http2/http2-bg2.png" alt="实例2"><br>图：请求报文的构成  </p>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http2/http2-bg3.png" alt="实例3"><br>图：响应报文的构成  </p>
<h2 id="HTTP-是不保存状态的协议"><a href="#HTTP-是不保存状态的协议" class="headerlink" title="HTTP 是不保存状态的协议"></a>HTTP 是不保存状态的协议</h2><p><strong>HTTP 是一种不保存状态，即无状态（stateless）协议</strong>。HTTP 协议自 身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。<br>这是为了<strong>更快地处理大量事务，确保协议的可伸缩性</strong>，而特意把 HTTP 协议设 计成如此简单的。</p>
<blockquote>
<p>HTTP&#x2F;1.1 虽然是无状态协议，但为了实现期望的保持状态功能，于 是引入了 Cookie 技术。</p>
</blockquote>
<h2 id="请求-URI-定位资源"><a href="#请求-URI-定位资源" class="headerlink" title="请求 URI 定位资源"></a>请求 URI 定位资源</h2><p>HTTP 协议使用 URI 定位互联网上的资源。<br><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http2/http2-bg4.png" alt="URI 定位资源"><br>图：以 <a target="_blank" rel="noopener" href="http://hackr.jp/index.htm">http://hackr.jp/index.htm</a> 作为请求的例子<br>除此之外，如果不是访问特定资源而是对服务器本身发起请求，可以 用一个 *来代替请求 URI。下面这个例子是查询 HTTP 服务器端支持 的 HTTP 方法种类。</p>
<blockquote>
<p>OPTIONS* HTTP&#x2F;1.1</p>
</blockquote>
<h2 id="告知服务器意图的-HTTP-方法"><a href="#告知服务器意图的-HTTP-方法" class="headerlink" title="告知服务器意图的 HTTP 方法"></a>告知服务器意图的 HTTP 方法</h2><ul>
<li><p>GET ：获取资源<br>GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器 端解析后返回响应内容。</p>
</li>
<li><p>POST：传输实体主体<br>虽然用 GET 方法也可以传输实体的主体，但一般不用 GET 方法进行 传输，而是用 POST 方法。虽说 POST 的功能与 GET 很相似，但 POST 的主要目的并不是获取响应的主体内容。</p>
</li>
<li><p>PUT：传输文件<br>PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请 求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。<br>鉴于 HTTP&#x2F;1.1 的 PUT 方法自身不带验证机制，任何人都可以 上传文件 , 存在安全性问题，因此一般的 Web 网站不使用该方法。若 配合 Web 应用程序的验证机制，或架构设计采用 REST（REpresentational State Transfer，表征状态转移）标准的同类 Web 网站，就可能会开放使用 PUT 方法。</p>
</li>
<li><p>HEAD：获得报文首部<br>HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等。</p>
</li>
<li><p>DELETE：删除文件<br>DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按 请求 URI 删除指定的资源。<br>HTTP&#x2F;1.1 的 DELETE 方法本身和 PUT 方法一样不带验证机 制，所以一般的 Web 网站也不使用 DELETE 方法。当配合 Web 应用 程序的验证机制，或遵守 REST 标准时还是有可能会开放使用的</p>
</li>
<li><p>OPTIONS：询问支持的方法<br>OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法<br><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http2/http2-bg6.png" alt="OPTIONS"></p>
</li>
<li><p>TRACE：追踪路径<br>TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方 法。<br>客户端通过 TRACE 方法可以查询发送出去的请求是怎样被加工修改 &#x2F; 篡改的。这是因为，请求想要连接到源目标服务器可能会通过代理 中转，TRACE 方法就是用来确认连接过程中发生的一系列操作。 但是，TRACE 方法本来就不怎么常用，再加上它容易引发 XST（Cross-Site Tracing，跨站追踪）攻击，通常就更不会用到了。</p>
</li>
<li><p>CONNECT：要求用隧道协议连接代理<br>CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。<br>HTTP&#x2F;1.0 和 HTTP&#x2F;1.1 支持的方法<br><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http2/http2-bg5.png" alt="HTTP/1.0 和 HTTP/1.1 支持的方法"></p>
</li>
</ul>
<h2 id="持久连接节省通信量"><a href="#持久连接节省通信量" class="headerlink" title="持久连接节省通信量"></a>持久连接节省通信量</h2><p>HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接。<br><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http2/http2-bg7.png" alt="持久连接节省通信量"><br>使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请求该 HTML 页面里包含的 其他资源。因此，每次的请求都会造成无谓的 TCP 连接建立和断开，增加通信量的开销。<br><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http2/http2-bg8.png" alt="持久连接节省通信量">  </p>
<h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>为解决上述 TCP 连接的问题，HTTP&#x2F;1.1 和一部分的 HTTP&#x2F;1.0 想出了持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或 HTTP connection reuse）的方法。持久连接的特点是，<strong>只要任意一端 没有明确提出断开连接，则保持 TCP 连接状态</strong>。<br><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http2/http2-bg9.png" alt="持久连接节省通信量"><br>图：持久连接旨在建立 1 次 TCP 连接后进行多次请求和响应的交互</p>
<blockquote>
<p>持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额 外开销，减轻了服务器端的负载<br>在 HTTP&#x2F;1.1 中，所有的连接默认都是持久连接</p>
</blockquote>
<h3 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h3><p>持久连接使得多数请求以管线化（pipelining）方式发送成为可能<br>从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。<br><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http2/http2-bg10.png" alt="持久连接节省通信量"><br>图：不等待响应，直接发送下一个请求</p>
<h2 id="使用-Cookie-的状态管理"><a href="#使用-Cookie-的状态管理" class="headerlink" title="使用 Cookie 的状态管理"></a>使用 Cookie 的状态管理</h2><p>保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入了 Cookie 技术。Cookie 技术通过在请求和响应报文中写入 Cookie 信 息来控制客户端的状态。<br>Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的 首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器 发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。<br>服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。<br><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http2/http2-bg11.png" alt="持久连接节省通信量"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/vue-router/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/vue-router/" class="post-title-link" itemprop="url">vue-router源码分析-简易流程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-01 00:00:00" itemprop="dateCreated datePublished" datetime="2021-02-01T00:00:00+08:00">2021-02-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-18 16:48:36" itemprop="dateModified" datetime="2024-07-18T16:48:36+08:00">2024-07-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">源码分析</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="简易流程"><a href="#简易流程" class="headerlink" title="简易流程"></a>简易流程</h3><p>vue-router的整体流程不难理解，难点在于一些功能的实现。</p>
<p><img src="/_posts/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/assets/vue-router/image-20220213105205628.png" alt="image-20220213105205628"></p>
<p>首先初始化vue-router实例，然后vue.use，再然后根vue初始化，作为配置传入</p>
<ul>
<li><p>vue.use vue-router</p>
</li>
<li><p>Vue-router install</p>
<ul>
<li><p>混入，根组件保存router和route属性，通过混入<code>beforeCreated</code> 子组件递归持有根组件(Vue)</p>
<ul>
<li><pre><code class="javascript">Object.defineProperty(Vue.prototype, &#39;$route&#39;, &#123;
  // 混入beforeCreated 保证所有组件都能访问到 _routerRoot vue根实例
  get () &#123; return this._routerRoot._route &#125;
&#125;)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">- ```</span><br><span class="line">  // 非根组件递归持有根组件Vue</span><br><span class="line">  this._routerRoot = (this.$parent &amp;&amp; this.$parent._routerRoot) || this</span><br></pre></td></tr></table></figure>

&gt; 所有的组件都持有_RouterRoot属性(Vue)，Vue根实例持有_route和router属性
</code></pre>
</li>
</ul>
</li>
<li><p>vue-router 初始化</p>
<ul>
<li>首先生成实例，执行constructor<ul>
<li>生成matcher，createMatcher<ul>
<li>根据routes创建一个路由映射表 {pathList, pathMap, nameMap}</li>
<li>提供match方法</li>
</ul>
</li>
<li>根据mode，初始化相应history</li>
</ul>
</li>
<li>执行init方法-vue根实例初始化的时候执行<ul>
<li>history.transitionTo 根据当前路径渲染组件<ul>
<li>const route &#x3D; this.router.match(location, this.current) 匹配路由</li>
</ul>
</li>
<li>History.listen 定义 history.cb  在多种情况下更新 vue._route，保证其正确性，方便被watch</li>
</ul>
</li>
</ul>
</li>
<li><p>Vue.util.defineReactive(this, <code>_route</code>, this._router.history.current) 定义响应式</p>
</li>
<li><p>registerInstance router-view相关 主要是在route.instance保存当前rv实例</p>
</li>
<li><p>Object.defineProperty(Vue.prototype, <code>$router</code>和<code>$route</code>）方便组件内使用</p>
</li>
<li><p>Vue.component <code>RouterView</code>, <code>RouterLink</code></p>
</li>
<li><p>定义合并策略</p>
</li>
</ul>
</li>
</ul>
<h3 id="重要部分介绍"><a href="#重要部分介绍" class="headerlink" title="重要部分介绍"></a>重要部分介绍</h3><h4 id="mather介绍"><a href="#mather介绍" class="headerlink" title="mather介绍"></a>mather介绍</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function createMatcher (</span><br><span class="line">  routes: Array&lt;RouteConfig&gt;,</span><br><span class="line">  router: VueRouter</span><br><span class="line">): Matcher</span><br></pre></td></tr></table></figure>

<ul>
<li><p>createRouteMap 根据传入的routes配置，创建一个路由映射表 {pathList, pathMap, nameMap}</p>
<blockquote>
<p><code>pathList</code> 存储所有的 <code>path</code></p>
<p><code>pathMap</code> 表示一个 <code>path</code> 到 <code>RouteRecord</code> 的映射关系</p>
<p><code>nameMap</code> 表示 <code>name</code> 到 <code>RouteRecord</code> 的映射关系</p>
</blockquote>
<ul>
<li><p>遍历routes数组，调用addRouteRecord</p>
<ul>
<li><p>根据routes创建相关映射表,如果存在children，则递归处理，保证每一个路由地址都有一个与之对应的routeRecord，这条记录还会包含子路由所有层级的父record记录</p>
</li>
<li><pre><code>RouteRecord
const record: RouteRecord = &#123;
    path: normalizedPath,
    // path 解析成一个正则表达式
    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),
    components: route.components || &#123; default: route.component &#125;,
    alias: route.alias
      ? typeof route.alias === &#39;string&#39;
        ? [route.alias]
        : route.alias
      : [],
    instances: &#123;&#125;, // 表示rv组件的实例
    enteredCbs: &#123;&#125;,
    name,
    parent, // 表示父的 RouteRecord 只能向上寻找
    matchAs,
    redirect: route.redirect,
    beforeEnter: route.beforeEnter,
    meta: route.meta || &#123;&#125;,
    props:
      route.props == null
        ? &#123;&#125;
        : route.components
          ? route.props
          : &#123; default: route.props &#125;
  &#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 保证*匹配符保持在最后</span><br><span class="line"></span><br><span class="line">- match方法解析 匹配出对应的record，然后通过`createRoute`创建`Route`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>function match (<br>  raw: RawLocation(string | location),<br>  currentRoute?: Route,<br>  redirectedFrom?: Location<br>): Route</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- createRoute函数, `createRoute` 可以根据 `record` 和 `location` 创建出来，最终返回的是一条 `Route` 路径</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>export function createRoute (<br>  record: ?RouteRecord,<br>  location: Location,<br>  redirectedFrom?: ?Location,<br>  router?: VueRouter<br>): Route {<br>  const stringifyQuery &#x3D; router &amp;&amp; router.options.stringifyQuery</p>
<p>  let query: any &#x3D; location.query || {}<br>  try {<br>    query &#x3D; clone(query)<br>  } catch (e) {}</p>
<p>  const route: Route &#x3D; {<br>    name: location.name || (record &amp;&amp; record.name),<br>    meta: (record &amp;&amp; record.meta) || {},<br>    path: location.path || ‘&#x2F;‘,<br>    hash: location.hash || ‘’,<br>    query,<br>    params: location.params || {},<br>    fullPath: getFullPath(location, stringifyQuery),<br>    matched: record ? formatMatch(record) : []<br>  }<br>  if (redirectedFrom) {<br>    route.redirectedFrom &#x3D; getFullPath(redirectedFrom, stringifyQuery)<br>  }<br>  return Object.freeze(route)<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - `Route` 对象中有一个非常重要属性是 `matched`，它通过 `formatMatch(record)` 计算而来：</span><br><span class="line"></span><br><span class="line">    ````</span><br><span class="line">    function formatMatch (record: ?RouteRecord): Array&lt;RouteRecord&gt; &#123;</span><br><span class="line">      const res = []</span><br><span class="line">      while (record) &#123;</span><br><span class="line">        res.unshift(record)</span><br><span class="line">        record = record.parent</span><br><span class="line">      &#125;</span><br><span class="line">      return res</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ````</span><br><span class="line"></span><br><span class="line">    可以看它是通过 `record` 循环向上找 `parent`，直到找到最外层，并把所有的 `record` 都 push 到一个数组中，最终返回的就是 `record` 的数组，它记录了一条线路上的所有 `record`。==`matched` 属性非常有用，它为之后渲染组件提供了依据==。</span><br><span class="line"></span><br><span class="line">#### 路径切换 history.transitonTo</span><br><span class="line"></span><br><span class="line">- 点击 `router-link` 的时候，实际上最终会执行 `router.push`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>push (location: RawLocation, onComplete?: Function, onAbort?: Function) {<br>  this.history.push(location, onComplete, onAbort)<br>}<br>push (location: RawLocation, onComplete?: Function, onAbort?: Function) {<br>  const { current: fromRoute } &#x3D; this<br>  this.transitionTo(location, route &#x3D;&gt; {<br>   &#x2F;&#x2F;<br>   &#x2F;&#x2F; <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/35036172">https://zhuanlan.zhihu.com/p/35036172</a><br>    pushHash(route.fullPath)<br>    handleScroll(this.router, route, fromRoute, false)<br>    onComplete &amp;&amp; onComplete(route)<br>  }, onAbort)<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 在history的初始化中，针对历史栈做了一个监听</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>window.addEventListener(supportsPushState ? ‘popstate’ : ‘hashchange’….</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  之所以做监听，是为了用户在使用前进后退时，渲染正确的组件</span><br><span class="line"></span><br><span class="line">- Router-view</span><br><span class="line"></span><br><span class="line">  当我们执行 `transitionTo` 来更改路由线路后，组件是如何重新渲染的呢</span><br><span class="line"></span><br><span class="line">- Router-Link</span><br><span class="line"></span><br><span class="line">### 附录：源码重要类-类型注解</span><br><span class="line"></span><br><span class="line">- history类 src/history/*.js</span><br><span class="line"></span><br><span class="line">  ````javascript</span><br><span class="line">  router: Router</span><br><span class="line">    base: string</span><br><span class="line">    current: Route</span><br><span class="line">    pending: ?Route</span><br><span class="line">    cb: (r: Route) =&gt; void</span><br><span class="line">    ready: boolean</span><br><span class="line">    readyCbs: Array&lt;Function&gt;</span><br><span class="line">    readyErrorCbs: Array&lt;Function&gt;</span><br><span class="line">    errorCbs: Array&lt;Function&gt;</span><br><span class="line">    listeners: Array&lt;Function&gt;</span><br><span class="line">    cleanupListeners: Function</span><br><span class="line">  </span><br><span class="line">    // implemented by sub-classes</span><br><span class="line">    +go: (n: number) =&gt; void</span><br><span class="line">    +push: (loc: RawLocation, onComplete?: Function, onAbort?: Function) =&gt; void</span><br><span class="line">    +replace: (</span><br><span class="line">      loc: RawLocation,</span><br><span class="line">      onComplete?: Function,</span><br><span class="line">      onAbort?: Function</span><br><span class="line">    ) =&gt; void</span><br><span class="line">    +ensureURL: (push?: boolean) =&gt; void</span><br><span class="line">    +getCurrentLocation: () =&gt; string</span><br><span class="line">    +setupListeners: Function</span><br><span class="line">  ````</span><br><span class="line"></span><br><span class="line">- matcher类 src/create-matcher.js</span><br><span class="line"></span><br><span class="line">  ```javascript</span><br><span class="line">  export type Matcher = &#123;</span><br><span class="line">    match: (raw: RawLocation, current?: Route, redirectedFrom?: Location) =&gt; Route;</span><br><span class="line">    addRoutes: (routes: Array&lt;RouteConfig&gt;) =&gt; void;</span><br><span class="line">    addRoute: (parentNameOrRoute: string | RouteConfig, route?: RouteConfig) =&gt; void;</span><br><span class="line">    getRoutes: () =&gt; Array&lt;RouteRecord&gt;;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>createRouteMap src&#x2F;creat-route-map</p>
<ul>
<li><code>createRouteMap</code> 函数的目标是把用户的路由配置转换成一张路由映射表，它包含 3 个部分，<ul>
<li><code>pathList</code> 存储所有的 <code>path</code>，</li>
<li><code>pathMap</code> 表示一个 <code>path</code> 到 <code>RouteRecord</code> 的映射关系，</li>
<li><code>nameMap</code> 表示 <code>name</code> 到 <code>RouteRecord</code> 的映射关系。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export function createRouteMap (</span><br><span class="line">  routes: Array&lt;RouteConfig&gt;,</span><br><span class="line">  oldPathList?: Array&lt;string&gt;,</span><br><span class="line">  oldPathMap?: Dictionary&lt;RouteRecord&gt;,</span><br><span class="line">  oldNameMap?: Dictionary&lt;RouteRecord&gt;,</span><br><span class="line">  parentRoute?: RouteRecord</span><br><span class="line">): &#123;</span><br><span class="line">  pathList: Array&lt;string&gt;,</span><br><span class="line">  pathMap: Dictionary&lt;RouteRecord&gt;,</span><br><span class="line">  nameMap: Dictionary&lt;RouteRecord&gt;</span><br><span class="line">&#125; &#123;...&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>addRouterRecord 生成并添加一条routerRecord</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function addRouteRecord (</span><br><span class="line">  pathList: Array&lt;string&gt;,</span><br><span class="line">  pathMap: Dictionary&lt;RouteRecord&gt;,</span><br><span class="line">  nameMap: Dictionary&lt;RouteRecord&gt;,</span><br><span class="line">  route: RouteConfig,</span><br><span class="line">  parent?: RouteRecord,</span><br><span class="line">  matchAs?: string</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Location RawLocation</p>
<ul>
<li>Vue-Router 中定义的 <code>Location</code> 数据结构和浏览器提供的 <code>window.location</code> 部分结构有点类似，它们都是对 <code>url</code> 的结构化描述。举个例子：<code>/abc?foo=bar&amp;baz=qux#hello</code>，它的 <code>path</code> 是 <code>/abc</code>，<code>query</code> 是 <code>&#123;foo:&#39;bar&#39;,baz:&#39;qux&#39;&#125;</code>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">declare type <span class="title class_">Location</span> = &#123;</span><br><span class="line">  _normalized?: boolean;</span><br><span class="line">  name?: string;</span><br><span class="line">  path?: string;</span><br><span class="line">  hash?: string;</span><br><span class="line">  query?: <span class="title class_">Dictionary</span>&lt;string&gt;;</span><br><span class="line">  params?: <span class="title class_">Dictionary</span>&lt;string&gt;;</span><br><span class="line">  append?: boolean;</span><br><span class="line">  replace?: boolean;</span><br><span class="line">&#125;</span><br><span class="line">declare type <span class="title class_">RawLocation</span> = string | <span class="title class_">Location</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Route</p>
<ul>
<li><code>Route</code> 表示的是路由中的一条线路，它除了描述了类似 <code>Loctaion</code> 的 <code>path</code>、<code>query</code>、<code>hash</code> 这些概念，还有 <code>matched</code> 表示匹配到的所有的 <code>RouteRecord</code>。<code>Route</code> 的其他属性我们之后会介绍。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> <span class="title class_">Route</span> = &#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">name</span>: ?<span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">hash</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">query</span>: <span class="title class_">Dictionary</span>&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line">  <span class="attr">params</span>: <span class="title class_">Dictionary</span>&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line">  <span class="attr">fullPath</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">matched</span>: <span class="title class_">Array</span>&lt;<span class="title class_">RouteRecord</span>&gt;;</span><br><span class="line">  redirectedFrom?: <span class="built_in">string</span>;</span><br><span class="line">  meta?: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以说location 经过了match之后变成了routerRecord，routerRecord经过<code>_createRoute</code>变成了<code>route</code></p>
<p>这样比较好理解</p>
</blockquote>
</li>
<li><p>RouterRecord</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">declare type RouteRecord = &#123;</span><br><span class="line">  path: string;</span><br><span class="line">  alias: Array&lt;string&gt;;</span><br><span class="line">  regex: RouteRegExp;</span><br><span class="line">  components: Dictionary&lt;any&gt;;</span><br><span class="line">  instances: Dictionary&lt;any&gt;;</span><br><span class="line">  enteredCbs: Dictionary&lt;Array&lt;Function&gt;&gt;;</span><br><span class="line">  name: ?string;</span><br><span class="line">  parent: ?RouteRecord;</span><br><span class="line">  redirect: ?RedirectOption;</span><br><span class="line">  matchAs: ?string;</span><br><span class="line">  beforeEnter: ?NavigationGuard;</span><br><span class="line">  meta: any;</span><br><span class="line">  props: boolean | Object | Function | Dictionary&lt;boolean | Object | Function&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="其他重要内容"><a href="#其他重要内容" class="headerlink" title="其他重要内容"></a>其他重要内容</h3><ul>
<li><p>当我们执行 <code>transitionTo</code> 来更改路由线路后，组件是如何重新渲染的呢</p>
<blockquote>
<p>由于我们把根 Vue 实例的 <code>_route</code> 属性定义成响应式的，我们在每个 <code>&lt;router-view&gt;</code> 执行 <code>render</code> 函数的时候，都会访问 <code>parent.$route</code>，如我们之前分析会访问 <code>this._routerRoot._route</code>，触发了它的 <code>getter</code>，相当于 <code>&lt;router-view&gt;</code> 对它有依赖，然后再执行完 <code>transitionTo</code> 后，修改 <code>app._route</code> 的时候，又触发了<code>setter</code>，因此会通知 <code>&lt;router-view&gt;</code> 的渲染 <code>watcher</code> 更新，重新渲染组件。</p>
</blockquote>
</li>
<li><p>所有组件都是访问到的<code>$router</code>和<code>$router</code>是怎么来的</p>
<p>1.设置Vue根实例的_routerRoot属性为Vue根实例</p>
<p>2.混入Vue生命周期，beforeCreate函数层层传递_routerRoot属性，是所有组件都可以通过<code>_routerRoot</code>访问到Vue根实例</p>
<p>3.定义Vue的原型属性<code>$route</code> <code>$router</code>的getter方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;$router&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">get</span> () &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_routerRoot</span>.<span class="property">_router</span> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>非常经典的异步函数队列化执行的模式，这也就是为什么官方文档会说只有执行 <code>next</code> 方法来 <code>resolve</code> 这个钩子函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function runQueue (queue, fn, cb) &#123;</span><br><span class="line">  const step = index =&gt; &#123;</span><br><span class="line">    if (index &gt;= queue.length) &#123;</span><br><span class="line">      cb()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (queue[index]) &#123;</span><br><span class="line">        fn(queue[index], () =&gt; &#123;</span><br><span class="line">          step(index + 1)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        step(index + 1)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  step(0)</span><br><span class="line">&#125;</span><br><span class="line">// 代表一个个hooks函数</span><br><span class="line">const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line"></span><br><span class="line">const iterator = (hook, next) =&gt; &#123;</span><br><span class="line">  console.log(hook);</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br><span class="line">runQueue(arr, iterator, () =&gt; &#123;</span><br><span class="line">  console.log(&quot;遍历完了&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">// 1 2 3 4 5 6 7 8 9 遍历完了</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/http1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/http1/" class="post-title-link" itemprop="url">第 1 章 了解 Web 及网络基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-24 00:00:00" itemprop="dateCreated datePublished" datetime="2021-01-24T00:00:00+08:00">2021-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-18 16:51:06" itemprop="dateModified" datetime="2024-07-18T16:51:06+08:00">2024-07-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/" itemprop="url" rel="index"><span itemprop="name">图解HTTP</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>为了理解 HTTP，我们有必要事先了解一下 TCP&#x2F;IP 协议族</p>
<h2 id="网络基础-TCP-IP"><a href="#网络基础-TCP-IP" class="headerlink" title="网络基础 TCP&#x2F;IP"></a>网络基础 TCP&#x2F;IP</h2><p>通常使用的网络（包括互联网）是在 TCP&#x2F;IP 协议族的基础上运作 的。而 HTTP 属于它内部的一个子集。</p>
<h3 id="TCP-IP-协议族"><a href="#TCP-IP-协议族" class="headerlink" title="TCP&#x2F;IP 协议族"></a>TCP&#x2F;IP 协议族</h3><p>计算机与网络设备要相互通信，双方就必须基于相同的方法。比如， 如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通 信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之 间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为 协议（protocol）。  </p>
<p>TCP&#x2F;IP 是互联网相关的各类协议族的总称</p>
<h3 id="TCP-IP-的分层管理"><a href="#TCP-IP-的分层管理" class="headerlink" title="TCP&#x2F;IP 的分层管理"></a>TCP&#x2F;IP 的分层管理</h3><p>TCP&#x2F;IP 协议族里重要的一点就是分层。TCP&#x2F;IP 协议族按层次分别分 为以下 4 层：应用层、传输层、网络层和数据链路层。</p>
<ul>
<li>应用层<br>应用层决定了向用户提供应用服务时通信的活动。<br>TCP&#x2F;IP 协议族内预存了各类通用的应用服务。比如，FTP（File Transfer Protocol，文件传输协议）和 DNS（Domain Name System，域 名系统）服务就是其中两类。 HTTP 协议也处于该层。</li>
<li>传输层<br>传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据 传输。<br>在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报 协议）。</li>
<li>网络层（又名网络互连层）<br>网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数 据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计 算机，并把数据包传送给对方。<br>与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所 起的作用就是在众多的选项内选择一条传输路线。</li>
<li>链路层（又名数据链路层，网络接口层）<br>用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱 动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等 物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在 链路层的作用范围之内。</li>
</ul>
<h3 id="TCP-IP-通信传输流"><a href="#TCP-IP-通信传输流" class="headerlink" title="TCP&#x2F;IP 通信传输流"></a>TCP&#x2F;IP 通信传输流</h3><p><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http1/tcp-bg1.png" alt="通信传输流"><br>利用 TCP&#x2F;IP 协议族进行网络通信时，会通过分层顺序与对方进行通 信。发送端从应用层往下走，接收端则往应用层往上走。<br>我们用 HTTP 举例来说明，首先作为发送端的客户端在应用层 （HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。 接着，为了传输方便，在传输层（TCP 协议）把从应用层处收到的数 据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端 口号后转发给网络层。  </p>
<p>在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链 路层。这样一来，发往网络的通信请求就准备齐全了。<br>接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用 层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP 请求。<br><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http1/tcp-bg2.png" alt="封装"><br>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该 层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层 时会把对应的首部消去。<br>这种把数据信息包装起来的做法称为<strong>封装</strong>（encapsulate）。</p>
<h2 id="与-HTTP-关系密切的协议-IP、TCP-和-DNS"><a href="#与-HTTP-关系密切的协议-IP、TCP-和-DNS" class="headerlink" title="与 HTTP 关系密切的协议 : IP、TCP 和 DNS"></a>与 HTTP 关系密切的协议 : IP、TCP 和 DNS</h2><h3 id="负责传输的-IP-协议"><a href="#负责传输的-IP-协议" class="headerlink" title="负责传输的 IP 协议"></a>负责传输的 IP 协议</h3><p>IP（Internet Protocol 网际协议）协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。<br>其中两个重要的条件是</p>
<ul>
<li>IP 地址</li>
<li>MAC 地址（Media Access Control Address）<br>IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定 地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC 地址基本上不会更改。</li>
</ul>
<h3 id="确保可靠性的-TCP-协议"><a href="#确保可靠性的-TCP-协议" class="headerlink" title="确保可靠性的 TCP 协议"></a>确保可靠性的 TCP 协议</h3><p>按层次分，TCP 位于传输层，提供可靠的字节流服务。<br>所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。一言以蔽之， TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。<br>为了准确无误地将数据送达目标处，TCP 协议采用了三次握手 （three-way handshaking）策略。<br>握手过程中使用了 TCP 的标志（flag） —— SYN（synchronize） 和 ACK（acknowledgement）。发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后， 回传一个带有 SYN&#x2F;ACK 标志的数据包以示传达确认信息。最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。 若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发 送相同的数据包。<br><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http1/tcp-bg3.png" alt="三次握手"><br>除了上述三次握手，TCP 协议还有其他各种手段来保证通信的可靠性。</p>
<h2 id="负责域名解析的-DNS-服务"><a href="#负责域名解析的-DNS-服务" class="headerlink" title="负责域名解析的 DNS 服务"></a>负责域名解析的 DNS 服务</h2><p>DNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务。<br>DNS 协议提供通过域名 查找 IP 地址，或逆向从 IP 地址反查域名的服务</p>
<h2 id="各种协议与-HTTP-协议的关系"><a href="#各种协议与-HTTP-协议的关系" class="headerlink" title="各种协议与 HTTP 协议的关系"></a>各种协议与 HTTP 协议的关系</h2><p><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http1/tcp-bg4.png" alt="三次握手"></p>
<h2 id="URI-和-URL"><a href="#URI-和-URL" class="headerlink" title="URI 和 URL"></a>URI 和 URL</h2><p>与 URI（统一资源标识符）相比，我们更熟悉 URL（Uniform Resource Locator，统一资源定位符）。</p>
<h3 id="统一资源标识符"><a href="#统一资源标识符" class="headerlink" title="统一资源标识符"></a>统一资源标识符</h3><p>URI 是 Uniform Resource Identifier 的缩写。RFC2396 分别对这 3 个单词进行了如下定义。</p>
<ul>
<li>Uniform</li>
</ul>
<blockquote>
<p>规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式。另外，加入新增的协议方案（如 http: 或 ftp:）也更容易。</p>
</blockquote>
<ul>
<li>Resource</li>
</ul>
<blockquote>
<p>资源的定义是“可标识的任何东西”。除了文档文件、图像或服务（例如当天的天气预报）等能够区别于其他类型的，全都可作为资源。另外，资源不仅可以是单一的，也可以是多数的集合体。</p>
</blockquote>
<ul>
<li>Identifier</li>
</ul>
<blockquote>
<p>表示可标识的对象。也称为标识符。  </p>
</blockquote>
<p>综上所述，URI 就是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。<br>采用 HTTP 协议时，协议方案就是 http。除此之外，还有 ftp、mailto、telnet、file 等。</p>
<h3 id="URI-格式"><a href="#URI-格式" class="headerlink" title="URI 格式"></a>URI 格式</h3><p>表示指定的 URI，要使用涵盖全部必要信息的绝对 URI、绝对 URL 以及相对 URL。相对 URL，是指从浏览器中基本 URI 处指定的 URL， 形如 &#x2F;image&#x2F;logo.gif。<br>让我们先来了解一下<strong>绝对 URI 的格式</strong>。  </p>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http1/tcp-bg5.png" alt="URI 格式"></p>
<ul>
<li>协议方案<br>使用 http: 或 https: 等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号（:）。 也可使用 data: 或 javascript: 这类指定数据或脚本程序的方案名。</li>
<li>登录信息（认证）<br>指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份  认证）。此项是可选项。</li>
<li>服务器地址<br>使用绝对 URI 必须指定待访问的服务器地址。地址可以是类似 hackr.jp 这种 DNS 可解析的名称，或是 192.168.1.1 这类 IPv4 地址名，还可以是 [0:0:0:0:0:0:0:1] 这样用方括号括起来的 IPv6 地址名。</li>
<li>服务器端口号<br>指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动 使用默认端口号。</li>
<li>带层次的文件路径<br>指定服务器上的文件路径来定位特指的资源。这与 UNIX 系统的文件目录结构相似。</li>
<li>查询字符串<br>针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。此项可选。</li>
<li>片段标识符<br>使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置）。但在 RFC 中并没有明确规定其使用方法。该项也为可选项。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E8%AF%B4%E6%98%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E8%AF%B4%E6%98%8E/" class="post-title-link" itemprop="url">vue源码分析说明</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-20 00:00:00" itemprop="dateCreated datePublished" datetime="2021-01-20T00:00:00+08:00">2021-01-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-18 16:48:33" itemprop="dateModified" datetime="2024-07-18T16:48:33+08:00">2024-07-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">源码分析</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>文章只是简易的记录下源码里比较重要的节点，方便压缩信息，进行二次记忆。<br>在github中fork仓库里有当时学习的注释，建议结合<a target="_blank" rel="noopener" href="https://ustbhuangyi.github.io/vue-analysis/v2/vuex/init.html">黄轶的源码分析</a>加源码加深记忆</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/javascript/%E5%8E%9F%E5%9E%8B%E9%93%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/javascript/%E5%8E%9F%E5%9E%8B%E9%93%BE/" class="post-title-link" itemprop="url">简单的阐述原型链</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-19 00:00:00" itemprop="dateCreated datePublished" datetime="2021-01-19T00:00:00+08:00">2021-01-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-13 14:53:43" itemprop="dateModified" datetime="2024-07-13T14:53:43+08:00">2024-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h2><p>我们先使用构造函数创建一个对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var person = new Person();</span><br><span class="line">person.name = &#x27;Kevin&#x27;;</span><br><span class="line">console.log(person.name) // Kevin</span><br></pre></td></tr></table></figure>

<p>在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。</p>
<p>很简单吧，接下来进入正题：</p>
<h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>每个函数都有一个 prototype 属性，就是我们经常在各种例子中看到的那个 prototype ，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 虽然写在注释里，但是你要注意：</span><br><span class="line">// prototype是函数才会有的属性</span><br><span class="line">Person.prototype.name = &#x27;Kevin&#x27;;</span><br><span class="line">var person1 = new Person();</span><br><span class="line">var person2 = new Person();</span><br><span class="line">console.log(person1.name) // Kevin</span><br><span class="line">console.log(person2.name) // Kevin</span><br></pre></td></tr></table></figure>

<p>那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？</p>
<p>其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的<strong>实例</strong>的原型，也就是这个例子中的 person1 和 person2 的原型。</p>
<p>那什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。</p>
<p>让我们用一张图表示构造函数和实例原型之间的关系：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype1.png"><img src="/_posts/javascript/assets/https:/github.com/mqyqingfeng/Blog/raw/master/Images/prototype1.png" alt="构造函数和实例原型的关系图"></a></p>
<p>在这张图中我们用 Object.prototype 表示实例原型。</p>
<p>那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性：</p>
<h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h2><p>这是每一个JavaScript对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。</p>
<p>为了证明这一点,我们可以在火狐或者谷歌中输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var person = new Person();</span><br><span class="line">console.log(person.__proto__ === Person.prototype); // true</span><br></pre></td></tr></table></figure>

<p>于是我们更新下关系图：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype2.png"><img src="/_posts/javascript/assets/%E5%8E%9F%E5%9E%8B%E9%93%BE/prototype2.png" alt="实例与实例原型的关系图"></a></p>
<p>既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？</p>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor，每个原型都有一个 constructor 属性指向关联的构造函数。</p>
<p>为了验证这一点，我们可以尝试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(Person === Person.prototype.constructor); // true</span><br></pre></td></tr></table></figure>

<p>所以再更新下关系图：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype3.png"><img src="/_posts/javascript/assets/%E5%8E%9F%E5%9E%8B%E9%93%BE/prototype3.png" alt="实例原型与构造函数的关系图"></a></p>
<p>综上我们已经得出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person();</span><br><span class="line"></span><br><span class="line">console.log(person.__proto__ == Person.prototype) // true</span><br><span class="line">console.log(Person.prototype.constructor == Person) // true</span><br><span class="line">// 顺便学习一个ES5的方法,可以获得对象的原型</span><br><span class="line">console.log(Object.getPrototypeOf(person) === Person.prototype) // true</span><br></pre></td></tr></table></figure>

<p>了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系：</p>
<h2 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h2><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = &#x27;Kevin&#x27;;</span><br><span class="line"></span><br><span class="line">var person = new Person();</span><br><span class="line"></span><br><span class="line">person.name = &#x27;Daisy&#x27;;</span><br><span class="line">console.log(person.name) // Daisy</span><br><span class="line"></span><br><span class="line">delete person.name;</span><br><span class="line">console.log(person.name) // Kevin</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。</p>
<p>但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.<strong>proto</strong> ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。</p>
<p>但是万一还没有找到呢？原型的原型又是什么呢？</p>
<h2 id="原型的原型"><a href="#原型的原型" class="headerlink" title="原型的原型"></a>原型的原型</h2><p>在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object();</span><br><span class="line">obj.name = &#x27;Kevin&#x27;</span><br><span class="line">console.log(obj.name) // Kevin</span><br></pre></td></tr></table></figure>

<p>其实原型对象就是通过 Object 构造函数生成的，结合之前所讲，实例的 <strong>proto</strong> 指向构造函数的 prototype ，所以我们再更新下关系图：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype4.png"><img src="/_posts/javascript/assets/%E5%8E%9F%E5%9E%8B%E9%93%BE/prototype4.png" alt="原型的原型关系图"></a></p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>那 Object.prototype 的原型呢？</p>
<p>null，我们可以打印：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.prototype.__proto__ === null) // true</span><br></pre></td></tr></table></figure>

<p>然而 null 究竟代表了什么呢？</p>
<p>引用阮一峰老师的 <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html">《undefined与null的区别》</a> 就是：</p>
<blockquote>
<p>null 表示“没有对象”，即该处不应该有值。</p>
</blockquote>
<p>所以 Object.prototype.<strong>proto</strong> 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。</p>
<p>所以查找属性的时候查到 Object.prototype 就可以停止查找了。</p>
<p>最后一张关系图也可以更新为：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype5.png"><img src="/_posts/javascript/assets/https:/github.com/mqyqingfeng/Blog/raw/master/Images/prototype5.png" alt="原型链示意图"></a></p>
<p>顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>最后，补充三点大家可能不会注意的地方：</p>
<h3 id="constructor"><a href="#constructor" class="headerlink" title="constructor"></a>constructor</h3><p>首先是 constructor 属性，我们看个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var person = new Person();</span><br><span class="line">console.log(person.constructor === Person); // true</span><br></pre></td></tr></table></figure>

<p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.constructor === Person.prototype.constructor</span><br></pre></td></tr></table></figure>

<h3 id="proto-1"><a href="#proto-1" class="headerlink" title="proto"></a><strong>proto</strong></h3><p>其次是 <strong>proto</strong> ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter&#x2F;setter，当使用 obj.<strong>proto</strong> 时，可以理解成返回了 Object.getPrototypeOf(obj)。</p>
<h3 id="真的是继承吗？"><a href="#真的是继承吗？" class="headerlink" title="真的是继承吗？"></a>真的是继承吗？</h3><p>最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》 上册中的话，就是：</p>
<p>​ 继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/vue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/vue/" class="post-title-link" itemprop="url">vue初始化流程-简易流程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-19 00:00:00" itemprop="dateCreated datePublished" datetime="2021-01-19T00:00:00+08:00">2021-01-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-18 16:50:53" itemprop="dateModified" datetime="2024-07-18T16:50:53+08:00">2024-07-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">源码分析</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="/_posts/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/assets/vue/image-20220325102130556.png" alt="image-20220325102130556"></p>
<p>本文简单的分析一下vue从初始化到完成渲染的流程，重点还是在于响应式的分析，生命周期函数简单带过。</p>
<blockquote>
<p>以下代码均经过不同程度的精简</p>
</blockquote>
<h3 id="vue-init"><a href="#vue-init" class="headerlink" title="vue.init"></a>vue.init</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._init = function(options) &#123;</span><br><span class="line">  vm.$options = mergeOptions(  // 合并options</span><br><span class="line">      resolveConstructorOptions(vm.constructor),</span><br><span class="line">      options || &#123;&#125;,</span><br><span class="line">      vm</span><br><span class="line">  )</span><br><span class="line">  // ...</span><br><span class="line">  initLifecycle(vm) // 开始一系列的初始化 </span><br><span class="line">  initEvents(vm)</span><br><span class="line">  initRender(vm)</span><br><span class="line">  callHook(vm, &#x27;beforeCreate&#x27;)        //执行 beforeCreate 钩子</span><br><span class="line">  initInjections(vm)</span><br><span class="line">  initState(vm) // observe</span><br><span class="line">  initProvide(vm)</span><br><span class="line">  callHook(vm, &#x27;created&#x27;)                    //执行 created 钩子</span><br><span class="line">  // ...</span><br><span class="line">  // 挂载dom</span><br><span class="line">  if (vm.$options.el) &#123;</span><br><span class="line">  // 可以认为是运行了 mountComponent </span><br><span class="line">    vm.$mount(vm.$options.el)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其实上述代码已经包含了整个生命周期的行为，简要分析一下函数所做的事情</p>
<h3 id="初始化到created"><a href="#初始化到created" class="headerlink" title="初始化到created"></a>初始化到created</h3><p>首先，将用户提供的<code>options</code>对象，父组件定义在子组件上的<code>event</code>、<code>props</code>(子组件实例化时)，<code>vm</code>原型方法，和<code>Vue</code>构造函数内置的选项合并成一个新的<code>options</code>对象，赋值给<code>vm.$options</code>。<br>接下来，执行 3 个初始化方法：</p>
<ul>
<li><p><strong>initLifecycle(vm)</strong>: 主要作用是确认组件的父子关系（定位非抽象父级）和初始化某些实例属性。找到父组件实例赋值给<code>vm.$parent</code>，将自己<code>push</code>给父组件的<code>$children</code>；</p>
</li>
<li><p><img src="/_posts/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/assets/vue/image-20230308115942545.png" alt="image-20230308115942545"></p>
</li>
<li><p><strong>initEvents(vm)</strong>: 主要作用是将父组件使用<code>v-on</code>或<code>@</code>注册的自定义事件添加到子组件的私有属性<code>vm._events</code>中；</p>
</li>
<li><p><strong>initRender(vm)</strong>: 主要作用是初始化用来将<code>render</code>函数转为<code>vnode</code>的方法<code>vm.$createElement</code>。用户自定义的<code>render</code>函数的参数<code>h</code>就是<code>vm.$createElement</code>方法，它可以返回<code>vnode</code>。此阶段还会进行<code>$attrs</code> <code>$listeners</code> <code>$slots</code> <code>$scopedSlots</code>的处理</p>
<blockquote>
<p>等以上操作全部完成，就会执行<code>beforeCreate</code>钩子函数，此时用户可以在函数中通过<code>this</code>访问到<code>vm.$parent</code>和<code>vm.$createElement</code> <code>$attrs</code> <code>$listeners</code> <code>$slots</code> <code>$scopedSlots</code>等有限的属性和方法。</p>
<p><img src="/_posts/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/assets/vue/image-20220118205925251.png" alt="image-20220118205925251"></p>
</blockquote>
</li>
<li><p><strong>触发beforeCreate</strong></p>
</li>
<li><p><strong>initInjections(vm)</strong>: 初始化<code>inject</code>，使得<code>vm</code>可以访问到对应的依赖；</p>
</li>
<li><p><strong>initState(vm)</strong>: 初始化会被使用到的状态，状态包括<code>props</code>，<code>methods</code>，<code>data</code>，<code>computed</code>，<code>watch</code>五个选项。调用相应的<code>init</code>方法，使用<code>vm.$options</code>中提供的选项对这些状态进行初始化，<strong>其中<code>initData</code>方法会调用<code>observe(data, true)</code>，实现对<code>data</code>中属性的监听，实际上是使用<code>Object.defineProperty</code>方法定义属性的<code>getter</code>和<code>setter</code>方法</strong>；</p>
<ul>
<li>Computed 和 watch 初始化 会创建computed-watch和user-watch</li>
</ul>
</li>
<li><p>**initProvide(vm)**：初始化<code>provide</code>，使得<code>vm</code>可以为子组件提供依赖。</p>
<blockquote>
<p>这 3 个初始化方法先初始化<code>inject</code>，然后初始化<code>props/data</code>状态，最后初始化<code>provide</code>，这样做的目的是可以在<code>props/data</code>中使用<code>inject</code>内所注入的内容。等以上操作全部完成，就会执行<code>created</code>钩子函数，此时用户可以在函数中通过<code>this</code>访问到<code>vm</code>中的<code>props</code>，<code>methods</code>，<code>data</code>，<code>computed</code>，<code>watch</code>和<code>inject</code>等大部分属性和方法。</p>
</blockquote>
</li>
<li><p><strong>触发created</strong></p>
</li>
</ul>
<h3 id="beforeMouted到mouted"><a href="#beforeMouted到mouted" class="headerlink" title="beforeMouted到mouted"></a>beforeMouted到mouted</h3><p>此阶段即是<code>vm.$mount(vm.$options.el)</code>过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">运行时版本：</span><br><span class="line">Vue.prototype.$mount = function(el) &#123; // 最初的定义</span><br><span class="line">    return mountComponent(this, query(el));</span><br><span class="line">&#125;</span><br><span class="line">完整版：</span><br><span class="line">const mount = Vue.prototype.$mount</span><br><span class="line">Vue.prototype.$mount = function(el) &#123;  // 拓展编译后的</span><br><span class="line">    var options = this.$options;</span><br><span class="line">    if(!options.render) &#123;</span><br><span class="line">        if(options.template) &#123;</span><br><span class="line">            ...                //一些判断</span><br><span class="line">        &#125; else if (el) &#123;    //传入的 el 选项不为空</span><br><span class="line">            options.template = getOuterHTML(el);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (options.template) &#123;</span><br><span class="line">                options.render = compileToFunctions(template, ...).render    //将 template 编译成 render 函数</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    return mount.call(this, query(el))    //即 Vue.prototype.$mount.call(this, query(el))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在完整版的<code>vm.$mount</code>方法中，如果用户未提供<code>render</code>函数，就会将<code>template</code>或者<code>el.outerHTML</code>编译成<code>render</code>函数。然后会执行<code>mountComponent</code>函数：</p>
<p><code>mountComponent</code>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">export function mountComponent(</span><br><span class="line">  vm,</span><br><span class="line">  el,</span><br><span class="line">  hydrating</span><br><span class="line">) &#123;</span><br><span class="line">  vm.$el = el</span><br><span class="line">  if (!vm.$options.render) &#123;</span><br><span class="line">    vm.$options.render = createEmptyVNode</span><br><span class="line">    if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123;</span><br><span class="line">      /* istanbul ignore if */</span><br><span class="line">      if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !== &#x27;#&#x27;) ||</span><br><span class="line">        vm.$options.el || el) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &#x27;You are using the runtime-only build of Vue where the template &#x27; +</span><br><span class="line">          &#x27;compiler is not available. Either pre-compile the templates into &#x27; +</span><br><span class="line">          &#x27;render functions, or use the compiler-included build.&#x27;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &#x27;Failed to mount component: template or render function not defined.&#x27;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  callHook(vm, &#x27;beforeMount&#x27;)</span><br><span class="line"></span><br><span class="line">  let updateComponent</span><br><span class="line">  /* istanbul ignore if */</span><br><span class="line">  if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = () =&gt; &#123;</span><br><span class="line">      const name = vm._name</span><br><span class="line">      const id = vm._uid</span><br><span class="line">      const startTag = `vue-perf-start:$&#123;id&#125;`</span><br><span class="line">      const endTag = `vue-perf-end:$&#123;id&#125;`</span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      const vnode = vm._render()</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(`vue $&#123;name&#125; render`, startTag, endTag)</span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      vm._update(vnode, hydrating)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(`vue $&#123;name&#125; patch`, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    updateComponent = () =&gt; &#123;</span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // updateComponent 函数包括vnode生成及挂载到真实dom</span><br><span class="line"></span><br><span class="line">  // 生成一个watcher实例，updateComponent作为watcher函数的回调</span><br><span class="line">  </span><br><span class="line">  new Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      if (vm._isMounted) &#123;</span><br><span class="line">        callHook(vm, &#x27;beforeUpdate&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, true /* isRenderWatcher */)</span><br><span class="line">  hydrating = false</span><br><span class="line"></span><br><span class="line">  // 挂载完成后  运行mouted</span><br><span class="line">  if (vm.$vnode == null) &#123;</span><br><span class="line">    // actived 需要判断组件已经加载过了</span><br><span class="line">    vm._isMounted = true</span><br><span class="line">    callHook(vm, &#x27;mounted&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">  return vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在完整版的<code>vm.$mount</code>方法中，如果用户未提供<code>render</code>函数，就会将<code>template</code>或者<code>el.outerHTML</code>编译成<code>render</code>函数。然后会执行<code>mountComponent</code>函数：如果用户提供了<code>el</code>选项，则会获取用于挂载的真实节点，将此节点赋值给<code>vm.$el</code>属性。</p>
</li>
<li><p>触发<code>beforeMount</code></p>
</li>
<li><p>在<code>mountComponent</code>方法中，<strong>会实例化一个watcher，watcher执行完内部逻辑后（响应式关键）</strong>，执行<code>updateComponent</code>方法将<code>vm._render()</code>返回的vnode挂载到真实节点中</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 生成一个watcher实例，updateComponent作为watcher函数的回调</span><br><span class="line"></span><br><span class="line">  new Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      if (vm._isMounted) &#123;</span><br><span class="line">        callHook(vm, &#x27;beforeUpdate&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, true /* isRenderWatcher */)</span><br><span class="line">  </span><br><span class="line">updateComponent = () =&gt; &#123;</span><br><span class="line">   vm._update(vm._render(), hydrating)</span><br><span class="line">&#125;</span><br><span class="line">Vue.prototype._render = function() &#123;</span><br><span class="line">    const vm = this</span><br><span class="line">    const &#123; render &#125; = vm.$options</span><br><span class="line">    const vnode = render.call(vm, vm.$createElement)</span><br><span class="line">    return vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>触发mouted</li>
</ul>
<p>至此vue的生命周期就结束了，下面重点介绍 <code>mountComponent</code> 实例化watcher发生了什么</p>
<h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><p>再讲解依赖收集之前，我们需要先了解，Object.defineProperties是什么时候设置的</p>
<h4 id="observer"><a href="#observer" class="headerlink" title="observer"></a>observer</h4><p><code>initState</code>阶段，vue会针对对象数据类型进行<code>observer</code>函数处理，方法的作用就是给非 VNode 的对象类型数据添加一个<code>Observer</code>类</p>
<p>举个例子, 下面的data 会有6次observer处理，会有6个Observer类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2,</span><br><span class="line">  c: [1, 2, &#123;a: 1&#125;],</span><br><span class="line">  d: &#123;</span><br><span class="line">   a: &#123;</span><br><span class="line">    b: 1</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">data 一次</span><br><span class="line">c 一次</span><br><span class="line"> c &#123;a:1&#125; 一次</span><br><span class="line">d 一次</span><br><span class="line"> a 一次</span><br><span class="line">  b 一次</span><br></pre></td></tr></table></figure>

<p>Observer会递归处理对象类型，有一个dep实例属性，用处在 defineReactive 中 childOb.dep.depend()，（父对象变化会影响子对象）</p>
<p>Observer的主要目的是对对象进行遍历并定义getter和setter，这也是依赖收集的基础，逻辑在函数 defineReactive 中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">export class Observer &#123;</span><br><span class="line">  value: any;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  vmCount: number; // number of vms that have this object as root $data</span><br><span class="line"></span><br><span class="line">  constructor (value: any) &#123;</span><br><span class="line">    this.value = value</span><br><span class="line">    this.dep = new Dep()</span><br><span class="line">    // 在 defineReactive 中 childOb.dep.depend()</span><br><span class="line">    this.vmCount = 0</span><br><span class="line">    // vm._Data.__ob__ 指向这个Observer </span><br><span class="line">    def(value, &#x27;__ob__&#x27;, this)</span><br><span class="line">    if (Array.isArray(value)) &#123;</span><br><span class="line">      if (hasProto) &#123;</span><br><span class="line">        protoAugment(value, arrayMethods)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        copyAugment(value, arrayMethods, arrayKeys)</span><br><span class="line">      &#125;</span><br><span class="line">      this.observeArray(value)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Walk through all properties and convert them into</span><br><span class="line">   * getter/setters. This method should only be called when</span><br><span class="line">   * value type is Object.</span><br><span class="line">   */</span><br><span class="line">  walk (obj: Object) &#123;</span><br><span class="line">    const keys = Object.keys(obj)</span><br><span class="line">    for (let i = 0; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Observe a list of Array items.</span><br><span class="line">   */</span><br><span class="line">  observeArray (items: Array&lt;any&gt;) &#123;</span><br><span class="line">    for (let i = 0, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>defineReactive</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">export function defineReactive (</span><br><span class="line">  obj: Object,</span><br><span class="line">  key: string,</span><br><span class="line">  val: any,</span><br><span class="line">  customSetter?: ?Function,</span><br><span class="line">  shallow?: boolean</span><br><span class="line">) &#123;</span><br><span class="line">  const dep = new Dep()</span><br><span class="line"></span><br><span class="line">  const property = Object.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  if (property &amp;&amp; property.configurable === false) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // cater for pre-defined getter/setters</span><br><span class="line">  const getter = property &amp;&amp; property.get</span><br><span class="line">  const setter = property &amp;&amp; property.set</span><br><span class="line">  if ((!getter || setter) &amp;&amp; arguments.length === 2) &#123;</span><br><span class="line">    val = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    get: function reactiveGetter () &#123;</span><br><span class="line">      const value = getter ? getter.call(obj) : val</span><br><span class="line">      if (Dep.target) &#123;</span><br><span class="line">        dep.depend()</span><br><span class="line">        if (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">          if (Array.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return value</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function reactiveSetter (newVal) &#123;</span><br><span class="line">      const value = getter ? getter.call(obj) : val</span><br><span class="line">      /* eslint-disable no-self-compare */</span><br><span class="line">      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      /* eslint-enable no-self-compare */</span><br><span class="line">      if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      if (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意函数每次运行都会实例化一个dep，getter 和 setter都是针对dep做出了处理</p>
<h4 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">export default class Dep &#123;</span><br><span class="line">  static target: ?Watcher;</span><br><span class="line">  id: number;</span><br><span class="line">  subs: Array&lt;Watcher&gt;;</span><br><span class="line"></span><br><span class="line">  constructor () &#123;</span><br><span class="line">    this.id = uid++</span><br><span class="line">    this.subs = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addSub (sub: Watcher) &#123;</span><br><span class="line">    this.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeSub (sub: Watcher) &#123;</span><br><span class="line">    remove(this.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  depend () &#123;</span><br><span class="line">    if (Dep.target) &#123;</span><br><span class="line">      // watcher addDep</span><br><span class="line">      // 简单来说 就是一个watcher dep 互相持有的过程</span><br><span class="line">      Dep.target.addDep(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notify () &#123;</span><br><span class="line">    // stabilize the subscriber list first</span><br><span class="line">    const subs = this.subs.slice()</span><br><span class="line">    if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !config.async) &#123;</span><br><span class="line">      // subs aren&#x27;t sorted in scheduler if not running async</span><br><span class="line">      // we need to sort them now to make sure they fire in correct</span><br><span class="line">      // order</span><br><span class="line">      subs.sort((a, b) =&gt; a.id - b.id)</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i = 0, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// The current target watcher being evaluated.</span><br><span class="line">// This is globally unique because only one watcher</span><br><span class="line">// can be evaluated at a time.</span><br><span class="line">Dep.target = null</span><br><span class="line">const targetStack = []</span><br></pre></td></tr></table></figure>

<p><code>Dep</code> 实际上就是对 <code>Watcher</code> 的一种管理，<code>Dep</code> 脱离 <code>Watcher</code> 单独存在是没有意义的，主要看一下<code>depend</code>和<code>notify</code></p>
<h4 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h4><p>上一节我们提到在<code>mountComponent</code> 函数中实例化了一个**<code>render watcher</code>** 实例，现在来重点分析一下。</p>
<p><strong><code>render watcher</code></strong> 是一个比较特殊的watcher实例，会挂载到vm._watcher上，并且持有该组件响应数据所有的dep实例，所有的dep实例也会持有**<code>render watcher</code>** ，<em><strong>每个组件有且仅有一个render watch</strong></em></p>
<p>首先看一下watcher的代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; pushTarget, popTarget &#125; <span class="keyword">from</span> <span class="string">&#x27;./dep&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">deps</span> = []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDeps</span> = []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">depIds</span> = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDepIds</span> = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = uid++</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">get</span> () &#123;</span><br><span class="line">    <span class="title function_">pushTarget</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="comment">// pushTarget 代码如下，入栈并把当前的watcher赋值给dep</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* function pushTarget (_target) &#123;</span></span><br><span class="line"><span class="comment">      if (Dep.target) targetStack.push(Dep.target)</span></span><br><span class="line"><span class="comment">      Dep.target = _target</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">deep</span>) &#123;</span><br><span class="line">      <span class="comment">// 递归去访问 value，触发它所有子项的 getter</span></span><br><span class="line">      <span class="title function_">traverse</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">popTarget</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">cleanupDeps</span>()</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">addDep</span> (dep) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = dep.<span class="property">id</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">has</span>(id)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">add</span>(id)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">newDeps</span>.<span class="title function_">push</span>(dep)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">depIds</span>.<span class="title function_">has</span>(id)) &#123;</span><br><span class="line">        dep.<span class="title function_">addSub</span>(<span class="variable language_">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;接受到更新消息&quot;</span>);</span><br><span class="line">    <span class="comment">// 推入队列等待触发</span></span><br><span class="line">    <span class="title function_">queueWatcher</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先实例化<code>wather</code>会运行<code>get</code>函数中的<code>pushTaget</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">pushTarget</span>(<span class="variable language_">this</span>)</span><br><span class="line"><span class="comment">// pushTarget 代码如下，入栈并把当前的watcher赋值给dep</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* function pushTarget (_target) &#123;</span></span><br><span class="line"><span class="comment"> targetStack.push(target)</span></span><br><span class="line"><span class="comment">  Dep.target = target</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 黄轶电子书的源码 和 2.6.14的源码有出入</span></span><br></pre></td></tr></table></figure>

<p>首先说明，<code>Dep.target</code>  和 <code>targetStack</code> 均为全局属性</p>
<p>实际上就是把 <code>Dep.target</code> 赋值为当前的<strong>渲染 <code>watcher</code></strong>(貌似一个实例仅有一个) 并压栈（为了恢复用，vue3中是为了满足嵌套watch）。接着又执行了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = <span class="variable language_">this</span>.<span class="property">getter</span>.<span class="title function_">call</span>(vm, vm)</span><br></pre></td></tr></table></figure>

<p><code>this.getter</code> 对应就是 <code>updateComponent</code> 函数，这实际上就是在执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.<span class="title function_">_update</span>(vm.<span class="title function_">_render</span>(), hydrating)</span><br></pre></td></tr></table></figure>

<p>它会先执行 <code>vm._render()</code> 方法，因为之前分析过这个方法会生成 渲染 VNode，并且在这个过程中会对 <code>vm</code> 上的数据访问，这个时候就触发了数据对象的 getter。</p>
<p>那么每个对象值的 getter 都持有一个 <code>dep</code>，在触发 getter 的时候会调用 <code>dep.depend()</code> 方法，也就会执行<code>Dep.target.addDep(this)</code>。</p>
<p>刚才我们提到这个时候 <code>Dep.target</code> 已经被赋值为渲染 <code>watcher</code>，那么就执行到 <code>addDep</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">addDep</span> (<span class="attr">dep</span>: <span class="title class_">Dep</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> id = dep.<span class="property">id</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">has</span>(id)) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">add</span>(id)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDeps</span>.<span class="title function_">push</span>(dep)</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">depIds</span>.<span class="title function_">has</span>(id)) &#123;</span><br><span class="line">      dep.<span class="title function_">addSub</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候会做一些逻辑判断（保证同一数据不会被添加多次）后执行 <code>dep.addSub(this)</code>，那么就会执行 <code>this.subs.push(sub)</code>，也就是说把当前的 <code>watcher</code> 订阅到这个数据持有的 <code>dep</code> 的 <code>subs</code> 中，这个目的是为后续数据变化时候能通知到哪些 <code>subs</code> 做准备。</p>
<p>所以在 <code>vm._render()</code> 过程中，会触发所有数据的 getter，这样实际上已经完成了一个依赖收集的过程。那么到这里就结束了么，其实并没有，<strong>在完成依赖收集后</strong>，还有几个逻辑要执行，首先是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">deep</span>) &#123;</span><br><span class="line">  <span class="title function_">traverse</span>(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个是要递归去访问 <code>value</code>，触发它所有子项的 <code>getter</code>，这个之后会详细讲。接下来执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">popTarget</span>()</span><br></pre></td></tr></table></figure>

<p><code>popTarget</code> 的定义在 <code>src/core/observer/dep.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Dep</span>.<span class="property">target</span> = targetStack.<span class="title function_">pop</span>()</span><br></pre></td></tr></table></figure>

<p>实际上就是把 <code>Dep.target</code> 恢复成上一个状态，因为当前 vm 的数据依赖收集已经完成，那么对应的渲染<code>Dep.target</code> 也需要改变。最后执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">cleanupDeps</span>()</span><br></pre></td></tr></table></figure>

<p>其实很多人都分析过并了解到 Vue 有依赖收集的过程，但我几乎没有看到有人分析依赖清空的过程，其实这是大部分同学会忽视的一点，也是 Vue 考虑特别细的一点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">cleanupDeps</span> () &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">deps</span>.<span class="property">length</span></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = <span class="variable language_">this</span>.<span class="property">deps</span>[i]</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">has</span>(dep.<span class="property">id</span>)) &#123;</span><br><span class="line">      dep.<span class="title function_">removeSub</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> tmp = <span class="variable language_">this</span>.<span class="property">depIds</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">depIds</span> = <span class="variable language_">this</span>.<span class="property">newDepIds</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">newDepIds</span> = tmp</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">clear</span>()</span><br><span class="line">  tmp = <span class="variable language_">this</span>.<span class="property">deps</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">deps</span> = <span class="variable language_">this</span>.<span class="property">newDeps</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">newDeps</span> = tmp</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">newDeps</span>.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑到 Vue 是数据驱动的，所以每次数据变化都会重新 render，那么 <code>vm._render()</code> 方法又会再次执行，并再次触发数据的 getters，所以 <code>Watcher</code> 在构造函数中会初始化 2 个 <code>Dep</code> 实例数组，<code>newDeps</code> 表示新添加的 <code>Dep</code> 实例数组，而 <code>deps</code> 表示上一次添加的 <code>Dep</code> 实例数组。</p>
<p>在执行 <code>cleanupDeps</code> 函数的时候，会首先遍历 <code>deps</code>，移除对 <code>dep.subs</code> 数组中 <code>Wathcer</code> 的订阅，然后把 <code>newDepIds</code> 和 <code>depIds</code> 交换，<code>newDeps</code> 和 <code>deps</code> 交换，并把 <code>newDepIds</code> 和 <code>newDeps</code> 清空。</p>
<p>那么为什么需要做 <code>deps</code> 订阅的移除呢，在添加 <code>deps</code> 的订阅过程，已经能通过 <code>id</code> 去重避免重复订阅了。</p>
<p>考虑到一种场景，我们的模板会根据 <code>v-if</code> 去渲染不同子模板 a 和 b，当我们满足某种条件的时候渲染 a 的时候，会访问到 a 中的数据，这时候我们对 a 使用的数据添加了 getter，做了依赖收集，那么当我们去修改 a 的数据的时候，理应通知到这些订阅者。那么如果我们一旦改变了条件渲染了 b 模板，又会对 b 使用的数据添加了 getter，如果我们没有依赖移除的过程，那么这时候我去修改 a 模板的数据，会通知 a 数据的订阅的回调，这显然是有浪费的。</p>
<p>因此 Vue 设计了在每次添加完新的订阅，会移除掉旧的订阅，这样就保证了在我们刚才的场景中，如果渲染 b 模板的时候去修改 a 模板的数据，a 数据订阅回调已经被移除了，所以不会有任何浪费，真的是非常赞叹 Vue 对一些细节上的处理。</p>
<h3 id="代码反推"><a href="#代码反推" class="headerlink" title="代码反推"></a>代码反推</h3><p>首先看vue文件，</p>
<ul>
<li>data包含三个数据，其中一个是对象类型</li>
<li>computed有一个，依赖于data1，data2</li>
<li>wather有一个，依赖于data1</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;home&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;data1&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123;data2&#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;data3.a&#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;a href=&quot;&quot;&gt;&#123;&#123;com1&#125;&#125;&lt;/a&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">// @ is an alias to /src</span><br><span class="line">import SlopScope from &#x27;@/components/slotScope.vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;Home&#x27;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      data1: 1,</span><br><span class="line">      data2: 2,</span><br><span class="line">      data3: &#123;</span><br><span class="line">        a: &quot;1sdfds&quot;,</span><br><span class="line">        b: &quot;fasaga&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    console.log(&quot;mounted&quot;);</span><br><span class="line">    console.log(this);</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    com1()&#123;</span><br><span class="line">      return this.data1 + this.data2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    data1() &#123;</span><br><span class="line">      console.log(111111);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>我们在控制台打印一下vm，先看一下_data，可见每一个对象类型均持有一个<code>__ob__</code>即Oberver实例</p>
<p><img src="/_posts/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/assets/vue/image-20210909153539012.png" alt="image-20210909153539012"></p>
<p>然后看一下water，其中有两个watcher相关的属性</p>
<p><img src="/_posts/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/assets/vue/image-20210909153816298.png" alt="image-20210909153816298"></p>
<ul>
<li>_watcher属性指向的就是render watcher，每个组件有且仅有一个（真实渲染到页面上的）</li>
<li>_wathers属性是组件相关的所有watcher<ul>
<li>一个render watcher 就是 _watcher指向的那个</li>
<li>一个computed watcher 可以看到属性中 lazy &#x3D; true</li>
<li>一个user watcher 可以看到属性 user &#x3D; true</li>
</ul>
</li>
<li>我们再重点关注一下computed watcher中的deps<ul>
<li>其中一个是data1对应的dep，subs存在三个watcher，对应render user computed</li>
<li>还有一个是data2对应的dep，subs存在二个watcher，对应render  computed</li>
</ul>
</li>
<li>&#x2F;&#x2F; TODO 为什么根data的<code>__ob__</code>持有的dep没有关联的watcher，也没有watcher关联它</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>根据自己的理解，进行一个简短的总结，方便理解记忆</p>
<ul>
<li>vue在init阶段中的initData<ul>
<li>initProps(vm, opts.props) 对prop进行<code>defineReactive</code>设置<code>set</code>和<code>get</code></li>
<li>initMethods(vm, opts.methods)</li>
<li>initData(vm)  对data进行初始化，针对对象类型进行递归处理，使用<code>observer</code>函数处理</li>
<li>initComputed 针对每个computed生成一个对应的watcher，并在访问get函数时触发依赖收集</li>
<li>initWatch(vm, opts.watch) 生成<code>user watcher</code>，并完成依赖收集</li>
</ul>
</li>
<li>每一个observer函数，都会实例化一个Observer实例，挂载到对象类型的<code>__ob__</code>上</li>
<li>Observer在实例化的过程中，会针对对象的每一个key用defineReactive进行处理</li>
<li>defineReactive会生成一个dep实例，并设置key的getter和setter</li>
<li>在mouted阶段，vue会初始化一个<code>render watcher</code>实例，watcher在实例化的过程中会将Dep.target指向自身，然后运行回调函数，并且有一个入栈的操作(可能是递归处理的时候方便恢复，因为是子组件先mouted，这是我自己猜测的)</li>
<li>render watch对应的回调函数就是<code>vm._update(vm._render(), hydrating)</code>，在构建虚拟dom的过程中，会触发视图依赖数据的getter函数(在构建虚拟dom的过程中，应该会深度遍历子组件，先完成子组件的依赖收集，这也是watch入栈出栈的原因吧)</li>
<li>getter函数 会将数据对应的dep和当前的render watch 互相链接（持有）</li>
<li>虚拟dom及挂载完成，render watch 会进行出栈</li>
<li>执行 cleanupDeps ，用新的订阅替换旧订阅（性能优化，详细参考黄轶blog）</li>
</ul>
<h3 id="其它需要掌握的点"><a href="#其它需要掌握的点" class="headerlink" title="其它需要掌握的点"></a>其它需要掌握的点</h3><h4 id="keep-alive组件"><a href="#keep-alive组件" class="headerlink" title="keep-alive组件"></a>keep-alive组件</h4><p><a target="_blank" rel="noopener" href="https://ustbhuangyi.github.io/vue-analysis/v2/extend/keep-alive.html#%E5%86%85%E7%BD%AE%E7%BB%84%E4%BB%B6">https://ustbhuangyi.github.io/vue-analysis/v2/extend/keep-alive.html#%E5%86%85%E7%BD%AE%E7%BB%84%E4%BB%B6</a></p>
<p>需要注意的点</p>
<ul>
<li>Keep-alive缓存的是vnode</li>
<li>keep-alive 只缓存第一个子组件</li>
<li><code>vnode.elm</code> 缓存了 <code>vnode</code> 创建生成的 DOM 节点</li>
<li>再次激活的时候跳过mount过程，直接把dom插入目标元素中</li>
</ul>
<h4 id="数组原型拦截"><a href="#数组原型拦截" class="headerlink" title="数组原型拦截"></a>数组原型拦截</h4><p>简单的描述一下过程：</p>
<p>在observe数组时，会将数组的<code>__proto__</code>指向由<code>Array.prototype</code>拓展而来的原型对象，该对象会原原本本的执行数组原生的方法，并针对七种方法做了重新定义，<strong>把新添加的值变成一个响应式对象，并且再调用 <code>ob.dep.notify()</code> 手动触发依赖通知</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import &#123; def &#125; from &#x27;../util/index&#x27;</span><br><span class="line"></span><br><span class="line">const arrayProto = Array.prototype</span><br><span class="line">export const arrayMethods = Object.create(arrayProto)</span><br><span class="line"></span><br><span class="line">const methodsToPatch = [</span><br><span class="line">  &#x27;push&#x27;,</span><br><span class="line">  &#x27;pop&#x27;,</span><br><span class="line">  &#x27;shift&#x27;,</span><br><span class="line">  &#x27;unshift&#x27;,</span><br><span class="line">  &#x27;splice&#x27;,</span><br><span class="line">  &#x27;sort&#x27;,</span><br><span class="line">  &#x27;reverse&#x27;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Intercept mutating methods and emit events</span><br><span class="line"> */</span><br><span class="line">methodsToPatch.forEach(function (method) &#123;</span><br><span class="line">  // cache original method</span><br><span class="line">  const original = arrayProto[method]</span><br><span class="line">  // 重新定义七种方法</span><br><span class="line">  def(arrayMethods, method, function mutator (...args) &#123;</span><br><span class="line">    // 调用原方法 </span><br><span class="line">    const result = original.apply(this, args)</span><br><span class="line">    // 数组对象的__ob__</span><br><span class="line">    const ob = this.__ob__</span><br><span class="line">    let inserted</span><br><span class="line">    switch (method) &#123;</span><br><span class="line">      case &#x27;push&#x27;:</span><br><span class="line">      case &#x27;unshift&#x27;:</span><br><span class="line">        inserted = args</span><br><span class="line">        break</span><br><span class="line">      case &#x27;splice&#x27;:</span><br><span class="line">        inserted = args.slice(2)</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">    if (inserted) ob.observeArray(inserted)</span><br><span class="line">    // notify change</span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    return result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>只是拓展了数组原型链还不够，还需要将数组的<code>__proto__</code>指向拓展后的类，这段代码在vue源码中Observe类中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (Array.isArray(value)) &#123;</span><br><span class="line">     if (hasProto) &#123;</span><br><span class="line">       protoAugment(value, arrayMethods)</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       copyAugment(value, arrayMethods, arrayKeys)</span><br><span class="line">     &#125;</span><br><span class="line">     this.observeArray(value)</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     this.walk(value)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p><img src="/_posts/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/assets/vue/44114780-3aca-11eb-85f6-6fac77c0c9b3-20220215152913357.png" alt="img"></p>
<h5 id="要掌握每个生命周期什么时候被调用"><a href="#要掌握每个生命周期什么时候被调用" class="headerlink" title="要掌握每个生命周期什么时候被调用"></a>要掌握每个生命周期什么时候被调用</h5><p><img src="/_posts/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/assets/vue/Snipaste_2021-09-06_20-27-19.png" alt="Snipaste_2021-09-06_20-27-19"></p>
<ol>
<li>beforeCreate 在实例初始化之后，数据观测(data observer) 之前被调用。<ol>
<li>initLifecycle(vm): 主要作用是确认组件的父子关系和初始化某些实例属性。找到父组件实例赋值给<code>vm.$parent</code>，将自己<code>push</code>给父组件的<code>$children</code>；</li>
<li>initEvents(vm): 主要作用是将父组件使用<code>v-on</code>或<code>@</code>注册的自定义事件添加到子组件的私有属性<code>vm._events</code>中；</li>
<li>initRender(vm): 主要作用是初始化用来将<code>render</code>函数转为<code>vnode</code>的两个方法<code>vm._c</code> 和<code>vm.$createElement</code>。用户自定义的<code>render</code>函数的参数<code>h</code>就是<code>vm.$createElement</code>方法，它可以返回<code>vnode</code>。此阶段还会进行<code>$attrs</code> <code>$listeners</code> <code>$slots</code> <code>$scopedSlots</code>的处理, 此时用户可以在函数中通过<code>this</code>访问到<code>vm.$parent</code>和<code>vm.$createElement</code> <code>$attrs</code> <code>$listeners</code> <code>$slots</code> <code>$scopedSlots</code>等有限的属性和方法。等以上操作全部完成，就会执行<code>beforeCreate</code>钩子函数</li>
</ol>
</li>
<li>created 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算，<br>watch&#x2F;event 事件回调。这里没有$el。这 3 个初始化方法先初始化<code>inject</code>，然后初始化<code>props/data</code>状态，最后初始化<code>provide</code>，这样做的目的是可以在<code>props/data</code>中使用<code>inject</code>内所注入的内容。<br>等以上操作全部完成，就会执行<code>created</code>钩子函数，此时用户可以在函数中通过<code>this</code>访问到<code>vm</code>中的<code>props</code>，<code>methods</code>，<code>data</code>，<code>computed</code>，<code>watch</code>和<code>inject</code>等大部分属性和方法。<ol>
<li>initInjections(vm): 初始化<code>inject</code>，使得<code>vm</code>可以访问到对应的依赖；</li>
<li>initState(vm): 初始化会被使用到的状态，状态包括<code>props</code>，<code>methods</code>，<code>data</code>，<code>computed</code>，<code>watch</code>五个选项。调用相应的<code>init</code>方法，使用<code>vm.$options</code>中提供的选项对这些状态进行初始化，其中<code>initData</code>方法会调用<code>observe(data, true)</code>，实现对<code>data</code>中属性的监听，实际上是使用<code>Object.defineProperty</code>方法定义属性的<code>getter</code>和<code>setter</code>方法；</li>
<li>initProvide(vm)：初始化<code>provide</code>，使得<code>vm</code>可以为子组件提供依赖(所以在<code>initState</code>后)。</li>
</ol>
</li>
<li>beforeMount 在挂载开始之前被调用：相关的 render 函数首次被调用。</li>
<li>mounted el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。</li>
<li>beforeUpdate 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。</li>
<li>updated 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</li>
<li>beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。</li>
<li>destroyed Vue 实例销毁后调用。调用后， Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用</li>
</ol>
<h5 id="要掌握每个生命周期内部可以做什么事"><a href="#要掌握每个生命周期内部可以做什么事" class="headerlink" title="要掌握每个生命周期内部可以做什么事"></a>要掌握每个生命周期内部可以做什么事</h5><ol>
<li>created 实例已经创建完成，因为它是最早触发的原因可以进行一些数据，资源的请求。</li>
<li>mounted 实例已经挂载完成，可以进行一些DOM操作</li>
<li>beforeUpdate 可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</li>
<li>updated 可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</li>
<li>destroyed 可以执行一些优化操作,清空定时器，解除绑定事件</li>
</ol>
<h5 id="Vue-的父组件和子组件生命周期钩子"><a href="#Vue-的父组件和子组件生命周期钩子" class="headerlink" title="Vue 的父组件和子组件生命周期钩子"></a>Vue 的父组件和子组件生命周期钩子</h5><ul>
<li>加载渲染过程</li>
</ul>
<p>​  父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p>
<ul>
<li>子组件更新过程</li>
</ul>
<p>​  父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p>
<ul>
<li>子组件销毁过程</li>
</ul>
<p>​  父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p>
<h5 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h5><p><a target="_blank" rel="noopener" href="https://vue3js.cn/interview/vue/diff.html#%E4%BA%8C%E3%80%81%E6%AF%94%E8%BE%83%E6%96%B9%E5%BC%8F">https://vue3js.cn/interview/vue/diff.html#%E4%BA%8C%E3%80%81%E6%AF%94%E8%BE%83%E6%96%B9%E5%BC%8F</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6994959998283907102#comment">https://juejin.cn/post/6994959998283907102#comment</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/vue/vue%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/vue/vue%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">vue问题记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-12 00:00:00" itemprop="dateCreated datePublished" datetime="2021-01-12T00:00:00+08:00">2021-01-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-18 16:49:13" itemprop="dateModified" datetime="2024-07-18T16:49:13+08:00">2024-07-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="v-model-的修饰符"><a href="#v-model-的修饰符" class="headerlink" title="v-model 的修饰符"></a>v-model 的修饰符</h2><h3 id="prop"><a href="#prop" class="headerlink" title=".prop"></a>.prop</h3><p>将属性绑定至dom的原生properties,看下边例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:test=&quot;ceshiProp&quot; class=&quot;prop&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div v-bind.prop:test=&quot;ceshiProp&quot; class=&quot;prop&quot;&gt;&lt;/div&gt;</span><br><span class="line">ceshiProp: &#123;</span><br><span class="line">  a:1,</span><br><span class="line">  b:2 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染结果如下：</p>
<p><img src="/_posts/vue/assets/vue%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210121155711009.png" alt="image-20210121155711009"></p>
<ul>
<li>Property：节点对象在内存中存储的属性，可以访问和设置。</li>
<li>Attribute：节点对象的其中一个属性( property )，值是一个对象，可以通过点访问法 document.getElementById(‘xx’).attributes 或者 document.getElementById(‘xx’).getAttributes(‘xx’) 读取，通过 document.getElementById(‘xx’).setAttribute(‘xx’,value) 新增和修改。<br>在标签里定义的所有属性包括 HTML 属性和自定义属性都会在 attributes 对象里以键值对的方式存在。</li>
</ul>
<p>太深层的暂不探究</p>
<h3 id="number"><a href="#number" class="headerlink" title=".number"></a>.number</h3><p>自动将数值转换为number，和el-input type&#x3D;number 一起用 会有bug</p>
<h2 id="v-on-修饰符"><a href="#v-on-修饰符" class="headerlink" title="v-on 修饰符"></a>v-on 修饰符</h2><h3 id="passive"><a href="#passive" class="headerlink" title=".passive"></a>.passive</h3><p>passive这个修饰符会执行默认方法。你们可能会问，明明默认执行为什么会设置这样一个修饰符。这就要说一下这个修饰符的本意了。</p>
<p>​    【浏览器只有等内核线程执行到事件监听器对应的JavaScript代码时，才能知道内部是否会调用preventDefault函数来阻止事件的默认行为，所以浏览器本身是没有办法对这种场景进行优化的。这种场景下，用户的手势事件无法快速产生，会导致页面无法快速执行滑动逻辑，从而让用户感觉到页面卡顿。】</p>
<p>​    通俗点说就是每次事件产生，浏览器都会去查询一下是否有preventDefault阻止该次事件的默认动作。我们加上<strong>passive就是为了告诉浏览器，不用查询了，我们没用preventDefault阻止默认动作。</strong></p>
<p>​    这里一般用在滚动监听，@scoll，@touchmove 。因为滚动监听过程中，移动每个像素都会产生一次事件，每次都使用内核线程查询prevent会使滑动卡顿。我们通过passive将内核线程查询跳过，可以大大提升滑动的流畅度。</p>
<h2 id="获取初始data"><a href="#获取初始data" class="headerlink" title="获取初始data"></a>获取初始data</h2><p>在某些情况我们可能要重置data上面的某些属性，比如在表单提交后需要清空form</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this.$data // 组件当前data对象</span><br><span class="line">this.$options.data() // 组件初始化状态下的data对象</span><br><span class="line"></span><br><span class="line">Object.assign(this.$data, this.$options.data()) // 重置data对象到初始化状态</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上这个this.$options.data 是一个函数，也就是组件声明时用来初始化data的函数</p>
</blockquote>
<h2 id="在不刷新页面的情况下，更新页面"><a href="#在不刷新页面的情况下，更新页面" class="headerlink" title="在不刷新页面的情况下，更新页面"></a>在不刷新页面的情况下，更新页面</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 先注册一个名为 `redirect` 的路由</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  beforeCreate() &#123;</span><br><span class="line">    const &#123; params, query &#125; = this.$route</span><br><span class="line">    const &#123; path &#125; = params</span><br><span class="line">    this.$router.replace(&#123; path: &#x27;/&#x27; + path, query &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  render: function(h) &#123;</span><br><span class="line">    return h() // avoid warning message</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 手动重定向页面到 &#x27;/redirect&#x27; 页面 实现更新页面</span><br><span class="line">const &#123; fullPath &#125; = this.$route</span><br><span class="line">this.$router.replace(&#123;</span><br><span class="line">  path: &#x27;/redirect&#x27; + fullPath</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当遇到你需要刷新页面的情况，你就手动重定向页面到<code>redirect</code>页面，它会将页面重新<code>redirect</code>重定向回来，由于页面的 key 发生了变化，从而间接实现了刷新页面组件的效果。</p>
<h2 id="动态清除注册的路由"><a href="#动态清除注册的路由" class="headerlink" title="动态清除注册的路由"></a>动态清除注册的路由</h2><p> 那就是动态添加的路由，并不能动态的删除。这就是导致一个问题，当用户权限发生变化的时候，或者说用户登出的时候，我们只能通过刷新页面的方式，才能清空我们之前注册的路由。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function resetRouter() &#123;</span><br><span class="line"> const newRouter = createRouter()</span><br><span class="line"> router.matcher = newRouter.matcher // reset router</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 它的原理其实很简单，所有的 vue-router 注册的路由信息都是存放在<code>matcher</code>之中的，所以当我们想清空路由的时候，我们只要新建一个空的<code>Router实例</code>，将它的<code>matcher</code>重新赋值给我们之前定义的路由就可以了。巧妙的实现了动态路由的清除。 现在我们只需要调用<code>resetRouter</code>，就能得到一个空的路有实例，之后你就可以重新<code>addRoutes</code>你想要的路由了</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/" class="post-title-link" itemprop="url">运算符优先级</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2021-01-01T00:00:00+08:00">2021-01-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-17 10:44:26" itemprop="dateModified" datetime="2024-07-17T10:44:26+08:00">2024-07-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">零散知识</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="运算符优先级，从上到下依次减低"><a href="#运算符优先级，从上到下依次减低" class="headerlink" title="运算符优先级，从上到下依次减低"></a>运算符优先级，从上到下依次减低</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>. [] ()</td>
<td>字段访问、数组下标、函数调用以及表达式分组</td>
</tr>
<tr>
<td>++ – - ~ ! delete new typeof void</td>
<td>一元运算符、返回数据类型、对象创建、未定义值</td>
</tr>
<tr>
<td>* &#x2F; %</td>
<td>乘法、除法、取模</td>
</tr>
<tr>
<td>+ - +</td>
<td>加法、减法、字符串连接</td>
</tr>
<tr>
<td>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</td>
<td>移位</td>
</tr>
<tr>
<td>&lt; &lt;&#x3D; &gt; &gt;&#x3D; instanceof</td>
<td>小于、小于等于、大于、大于等于、instanceof</td>
</tr>
<tr>
<td><code>==</code> <code>!=</code> <code>===</code> <code>!==</code></td>
<td>等于、不等于、严格相等、非严格相等</td>
</tr>
<tr>
<td>&amp;</td>
<td>按位与</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
</tr>
<tr>
<td>|</td>
<td>按位或</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>逻辑与</td>
</tr>
<tr>
<td>||</td>
<td>逻辑或</td>
</tr>
<tr>
<td>?:</td>
<td>条件</td>
</tr>
<tr>
<td>&#x3D; oP&#x3D;</td>
<td>赋值、运算赋值</td>
</tr>
<tr>
<td>,</td>
<td>多重求值</td>
</tr>
</tbody></table>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">MDN更详细的优先级</a></p>
</blockquote>
<p>还有一些影响运算结果（左右关联）的因素，参考你不知道的JavaScript中卷 128页左右</p>
<h3 id="运算符左右关联"><a href="#运算符左右关联" class="headerlink" title="运算符左右关联"></a>运算符左右关联</h3><h4 id="左关联"><a href="#左关联" class="headerlink" title="左关联"></a>左关联</h4><p><code>&amp;&amp;</code> 和 <code>||</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &amp;&amp; b &amp;&amp; c</span><br><span class="line">(a &amp;&amp; b) &amp;&amp; c</span><br></pre></td></tr></table></figure>

<h4 id="右关联"><a href="#右关联" class="headerlink" title="右关联"></a>右关联</h4><p>三元运算符 和 <code>=</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a ? b : c ? d : e;</span><br><span class="line"></span><br><span class="line">a ? b : (c ? d : e)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &amp;&amp; b || c ? c || b ? a : c &amp;&amp; b : a;</span><br><span class="line">((a &amp;&amp; b) || c) ? ((c || b) ? a : (c &amp;&amp; b)) : a</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/%E8%BF%90%E7%AE%97%E7%AC%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/%E8%BF%90%E7%AE%97%E7%AC%A6/" class="post-title-link" itemprop="url">运算符</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-17 00:00:00" itemprop="dateCreated datePublished" datetime="2020-12-17T00:00:00+08:00">2020-12-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-17 10:40:53" itemprop="dateModified" datetime="2024-07-17T10:40:53+08:00">2024-07-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">零散知识</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="和-和-和"><a href="#和-和-和" class="headerlink" title="&amp;&amp; 和 || 和 | 和 &amp;"></a><code>&amp;&amp;</code> 和 <code>||</code> 和 <code>|</code> 和 <code>&amp;</code></h2><p>逻辑运算符如下表所示 (其中expr可能是任何一种类型, 不一定是布尔值):<br>&amp;&amp; 优先级高于 ||  </p>
<p><img src="/_posts/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/assets/%E8%BF%90%E7%AE%97%E7%AC%A6/bg1.png" alt="控制台输出"><br>如果一个值可以被转换为 true，那么这个值就是所谓的 truthy，如果可以被转换为 false，那么这个值就是所谓的 falsy。<br>会被转换为 false 的表达式有：</p>
<ul>
<li>null；</li>
<li>NaN；</li>
<li>0；</li>
<li>空字符串（”” or ‘’ or ``）；</li>
<li>undefined。</li>
</ul>
<p>尽管 &amp;&amp; 和 || 运算符能够使用非布尔值的操作数, 但它们依然可以被看作是布尔操作符，因为它们的返回值总是能够被转换为布尔值。如果要显式地将它们的返回值（或者表达式）转换为布尔值，请使用双重非运算符（即!!）或者Boolean构造函数。</p>
<h3 id="短路计算"><a href="#短路计算" class="headerlink" title="短路计算"></a>短路计算</h3><p>由于逻辑表达式的运算顺序是从左到右，也可以用以下规则进行”短路”计算：</p>
<ul>
<li><p>(some falsy expression) &amp;&amp; (expr) 短路计算的结果为假。</p>
</li>
<li><p>(some truthy expression) || (expr) 短路计算的结果为真。<br>常见用法</p>
</li>
<li><p>判断对象属性是否存在</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(obj.prop&amp;&amp;obj.prop.prop)</span><br></pre></td></tr></table></figure>

<ul>
<li>赋值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function (arg)&#123;</span><br><span class="line">  var a = arg || 5;</span><br><span class="line">&#125;</span><br><span class="line">// 是否存在 不存在创建并赋值</span><br><span class="line">(this._events[event] || (this._evnet[evnet] = [])).push(fn)</span><br></pre></td></tr></table></figure>

<ul>
<li>简写</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(a==b)&#123;console.log(1)&#125;</span><br><span class="line">a==b&amp;&amp;console.log(1)</span><br></pre></td></tr></table></figure>

<h3 id="属于位运算符"><a href="#属于位运算符" class="headerlink" title="| &amp;属于位运算符"></a><code>|</code> <code>&amp;</code>属于位运算符</h3><p>此处不深究</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/ES6/%E5%A3%B0%E6%98%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/ES6/%E5%A3%B0%E6%98%8E/" class="post-title-link" itemprop="url">ES6详细内容参照 阮一峰的ES6深入浅出</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-12 00:00:00" itemprop="dateCreated datePublished" datetime="2020-11-12T00:00:00+08:00">2020-11-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-02-17 15:58:52" itemprop="dateModified" datetime="2022-02-17T15:58:52+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ES6/" itemprop="url" rel="index"><span itemprop="name">ES6</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/8/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/10/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">马农</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
