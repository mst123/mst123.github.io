<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"mst123.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="学习记录">
<meta property="og:type" content="website">
<meta property="og:title" content="博客">
<meta property="og:url" content="https://mst123.github.io/page/4/index.html">
<meta property="og:site_name" content="博客">
<meta property="og:description" content="学习记录">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="马农">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://mst123.github.io/page/4/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">博客</h1>
      <i class="logo-line"></i>
    </a>
      <img class="custom-logo-image" src="/images/gintama.jpg" alt="博客">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="马农"
      src="/images/luopo.gif">
  <p class="site-author-name" itemprop="name">马农</p>
  <div class="site-description" itemprop="description">学习记录</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">105</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">125</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/%E7%BD%91%E7%BB%9C/cache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E7%BD%91%E7%BB%9C/cache/" class="post-title-link" itemprop="url">浏览器缓存原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-24 00:00:00" itemprop="dateCreated datePublished" datetime="2021-08-24T00:00:00+08:00">2021-08-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-18 11:03:34" itemprop="dateModified" datetime="2024-07-18T11:03:34+08:00">2024-07-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>转载</p>
<h1 id="一、浏览器缓存基本认识"><a href="#一、浏览器缓存基本认识" class="headerlink" title="一、浏览器缓存基本认识"></a>一、浏览器缓存基本认识</h1><p><strong>分为强缓存和协商缓存</strong></p>
<ol>
<li>浏览器在加载资源时，先根据这个资源的一些<code>http header</code>判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个<code>css</code>文件，如果浏览器在加载它所在的网页时，这个<code>css</code>文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个<code>css</code>，连请求都不会发送到网页所在服务器</li>
<li>当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些<code>http header</code>验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源</li>
<li><strong>强缓存与协商缓存的共同点是</strong>：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：<strong>强缓存不发请求到服务器</strong>，<strong>协商缓存会发请求到服务器</strong></li>
<li>当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据</li>
</ol>
<h1 id="二、强缓存的原理"><a href="#二、强缓存的原理" class="headerlink" title="二、强缓存的原理"></a>二、强缓存的原理</h1><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h2><blockquote>
<p>当浏览器对某个资源的请求命中了强缓存时，返回的<code>http</code>状态为<code>200</code>，在<code>chrome</code>的开发者工具的<code>network</code>里面<code>size</code>会显示为<code>from cache</code>，比如京东的首页里就有很多静态资源配置了强缓存，用<code>chrome</code>打开几次，再用<code>f12</code>查看<code>network</code>，可以看到有不少请求就是从缓存中加载的</p>
</blockquote>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/1.png" alt="img"></p>
<ul>
<li>强缓存是利用<code>Expires</code>或者<code>Cache-Control</code>这两个<code>http response header</code>实现的，它们都用来表示资源在客户端缓存的有效期。</li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires`是`http1.0`提出的一个表示资源过期时间的`header`，它描述的是一个绝对时间，由服务器返回，用`GMT`格式的字符串表示，如：`Expires:Thu, 31 Dec 2037 23:55:55 GMT</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="2-2-Expires缓存原理"><a href="#2-2-Expires缓存原理" class="headerlink" title="2.2 Expires缓存原理"></a>2.2 Expires缓存原理</h2><ol>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在<code>respone</code>的<code>header</code>加上<code>Expires</code>，如</li>
</ol>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/2.png" alt="img"></p>
<ol>
<li>浏览器在接收到这个资源后，会把这个资源连同所有<code>response header</code>一起缓存下来（所以缓存命中的请求返回的<code>header</code>并不是来自服务器，而是来自之前缓存的<code>header</code>）</li>
<li>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的<code>Expires</code>跟当前的请求时间比较，如果请求时间在<code>Expires</code>指定的时间之前，就能命中缓存，否则就不行</li>
<li>如果缓存没有命中，浏览器直接从服务器加载资源时，<code>Expires Header</code>在重新加载的时候会被更新</li>
</ol>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires`是较老的强缓存管理`header`，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。所以在`http1.1`的时候，提出了一个新的`header`，就是`Cache-Control`，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：`Cache-Control:max-age=315360000</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="2-3-Cache-Control缓存原理"><a href="#2-3-Cache-Control缓存原理" class="headerlink" title="2.3 Cache-Control缓存原理"></a>2.3 Cache-Control缓存原理</h2><ol>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在<code>respone</code>的<code>header</code>加上<code>Cache-Control</code>，如：</li>
</ol>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/3.png" alt="img"></p>
<ol>
<li>浏览器在接收到这个资源后，会把这个资源连同所有<code>response header</code>一起缓存下来</li>
<li>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和<code>Cache-Control</code>设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行</li>
<li>如果缓存没有命中，浏览器直接从服务器加载资源时，<code>Cache-Control Header</code>在重新加载的时候会被更新</li>
</ol>
<ul>
<li><code>Cache-Control</code>描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较<code>Expires</code>，<code>Cache-Control</code>的缓存管理更有效，安全一些。</li>
<li>这两个<code>header</code>可以只启用一个，也可以同时启用，当<code>response header</code>中，<code>Expires</code>和<code>Cache-Control</code>同时存在时，<code>Cache-Control</code>优先级高于<code>Expires</code>：</li>
</ul>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/4.png" alt="img"></p>
<h2 id="2-4-cache-control-补充"><a href="#2-4-cache-control-补充" class="headerlink" title="2.4 cache-control 补充"></a>2.4 cache-control 补充</h2><p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/cache/1642834020024-2f112f4b-df67-4094-856c-04d71c79360d.png" alt="img"></p>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/cache/1642835507632-481e335e-b8ee-44e0-ae15-a738503d3776.png" alt="img"></p>
<h1 id="三、强缓存的管理"><a href="#三、强缓存的管理" class="headerlink" title="三、强缓存的管理"></a>三、强缓存的管理</h1><blockquote>
<p>前面介绍的是强缓存的原理，在实际应用中我们会碰到需要强缓存的场景和不需要强缓存的场景，通常有2种方式来设置是否启用强缓存</p>
</blockquote>
<ol>
<li>通过代码的方式，在<code>web</code>服务器返回的响应中添加<code>Expires</code>和<code>Cache-Control Header</code></li>
<li>通过配置<code>web</code>服务器的方式，让<code>web</code>服务器在响应资源的时候统一添加<code>Expires</code>和<code>Cache-Control Header</code></li>
</ol>
<blockquote>
<p>比如在javaweb里面，我们可以使用类似下面的代码设置强缓存</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.util.Date date = new java.util.Date();    </span><br><span class="line">response.setDateHeader(&quot;Expires&quot;,date.getTime()+20000); //Expires:过时期限值 </span><br><span class="line">response.setHeader(&quot;Cache-Control&quot;, &quot;public&quot;); //Cache-Control来控制页面的缓存与否,public:浏览器和缓存服务器都可以缓存页面信息；</span><br><span class="line">response.setHeader(&quot;Pragma&quot;, &quot;Pragma&quot;); //Pragma:设置页面是否缓存，为Pragma则缓存，no-cache则不缓存</span><br></pre></td></tr></table></figure>

<blockquote>
<p>还可以通过类似下面的<code>java</code>代码设置不启用强缓存</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader( &quot;Pragma&quot;, &quot;no-cache&quot; );   </span><br><span class="line">response.setDateHeader(&quot;Expires&quot;, 0);   </span><br><span class="line">response.addHeader( &quot;Cache-Control&quot;, &quot;no-cache&quot; );//浏览器和缓存服务器都不应该缓存页面信息</span><br></pre></td></tr></table></figure>

<ul>
<li><code>nginx</code>和<code>apache</code>作为专业的<code>web</code>服务器，都有专门的配置文件，可以配置<code>expires</code>和<code>cache-control</code>，这方面的知识，如果你对运维感兴趣的话，可以在百度上搜索<code>nginx</code> 设置 <code>expires cache-control</code>或 <code>apache 设置 expires cache-control</code> 都能找到不少相关的文章。</li>
<li>由于在开发的时候不会专门去配置强缓存，而浏览器又默认会缓存图片，<code>css</code>和<code>js</code>等静态资源，所以开发环境下经常会因为强缓存导致资源没有及时更新而看不到最新的效果，解决这个问题的方法有很多，常用的有以下几种</li>
</ul>
<p><strong>处理缓存带来的问题</strong></p>
<ol>
<li>直接<code>ctrl+f5</code>，这个办法能解决页面直接引用的资源更新的问题</li>
<li>使用浏览器的隐私模式开发</li>
<li>如果用的是<code>chrome</code>，可以<code>f12</code>在<code>network</code>那里把缓存给禁掉（这是个非常有效的方法）</li>
</ol>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/5.png" alt="img"></p>
<ol>
<li>在开发阶段，给资源加上一个动态的参数，如<code>css/index.css?v=0.0001</code>，由于每次资源的修改都要更新引用的位置，同时修改参数的值，所以操作起来不是很方便，除非你是在动态页面比如jsp里开发就可以用服务器变量来解决（<code>v=$&#123;sysRnd&#125;</code>），或者你能用一些前端的构建工具来处理这个参数修改的问题</li>
<li>如果资源引用的页面，被嵌入到了一个<code>iframe</code>里面，可以在<code>iframe</code>的区域右键单击重新加载该页面，以<code>chrome</code>为例</li>
</ol>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/6.png" alt="img"></p>
<ol>
<li>如果缓存问题出现在<code>ajax</code>请求中，最有效的解决办法就是<code>ajax</code>的请求地址追加随机数</li>
<li>还有一种情况就是动态设置<code>iframe</code>的<code>src</code>时，有可能也会因为缓存问题，导致看不到最新的效果，这时候在要设置的<code>src</code>后面添加随机数也能解决问题</li>
<li>如果你用的是<code>grunt</code>和<code>gulp</code>、<code>webpack</code>这种前端工具开发，通过它们的插件比如<code>grunt-contrib-connect</code>来启动一个静态服务器，则完全不用担心开发阶段的资源更新问题，因为在这个静态服务器下的所有资源返回的<code>respone header</code>中，<code>cache-control</code>始终被设置为不缓存</li>
</ol>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/7.png" alt="img"></p>
<h1 id="四、强缓存的应用"><a href="#四、强缓存的应用" class="headerlink" title="四、强缓存的应用"></a>四、强缓存的应用</h1><blockquote>
<p>强缓存是前端性能优化最有力的工具，没有之一，对于有大量静态资源的网页，一定要利用强缓存，提高响应速度。通常的做法是，为这些静态资源全部配置一个超时时间超长的<code>Expires</code>或<code>Cache-Control</code>，这样用户在访问网页时，只会在第一次加载时从服务器请求静态资源，其它时候只要缓存没有失效并且用户没有强制刷新的条件下都会从自己的缓存中加载，比如前面提到过的京东首页缓存的资源，它的缓存过期时间都设置到了<code>2026</code>年</p>
</blockquote>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/8.png" alt="img"></p>
<blockquote>
<p>然而这种缓存配置方式会带来一个新的问题，就是发布时资源更新的问题，比如某一张图片，在用户访问第一个版本的时候已经缓存到了用户的电脑上，当网站发布新版本，替换了这个图片时，已经访问过第一个版本的用户由于缓存的设置，导致在默认的情况下不会请求服务器最新的图片资源，除非他清掉或禁用缓存或者强制刷新，否则就看不到最新的图片效果</p>
</blockquote>
<p>这个问题已经有成熟的解决方案，具体内容可阅读知乎这篇文章详细了解：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20790576">https://www.zhihu.com/question/20790576</a></p>
<p>文章提到的东西都属于理论上的解决方案，不过现在已经有很多前端工具能够实际地解决这个问题，由于每个工具涉及到的内容细节都有很多，本文没有办法一一深入介绍。有兴趣的可以去了解下<code>grunt</code> <code>gulp</code> <code>webpack</code> <code>fis</code> 还有edp这几个工具，基于这几个工具都能解决这个问题，尤其是<code>fis</code>和<code>edp</code>是百度推出的前端开发平台，有现成的文档可以参考：</p>
<p><a target="_blank" rel="noopener" href="http://fis.baidu.com/fis3/api/index.html">http://fis.baidu.com/fis3/api/index.html</a></p>
<p><a target="_blank" rel="noopener" href="http://ecomfe.github.io/edp/doc/initialization/install/">http://ecomfe.github.io/edp/doc/initialization/install/</a></p>
<blockquote>
<p>强缓存还有一点需要注意的是，通常都是针对静态资源使用，动态资源需要慎用，除了服务端页面可以看作动态资源外，那些引用静态资源的<code>html</code>也可以看作是动态资源，如果这种<code>html</code>也被缓存，当这些<code>html</code>更新之后，可能就没有机制能够通知浏览器这些html有更新，尤其是前后端分离的应用里，页面都是纯<code>html</code>页面，每个访问地址可能都是直接访问<code>html</code>页面，这些页面通常不加强缓存，以保证浏览器访问这些页面时始终请求服务器最新的资源</p>
</blockquote>
<h1 id="五、协商缓存的原理"><a href="#五、协商缓存的原理" class="headerlink" title="五、协商缓存的原理"></a>五、协商缓存的原理</h1><h2 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h2><blockquote>
<p>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的<code>http</code>状态为<code>304</code>并且会显示一个<code>Not Modified</code>的字符串，比如你打开京东的首页，按<code>f12</code>打开开发者工具，再按<code>f5</code>刷新页面，查看<code>network</code>，可以看到有不少请求就是命中了协商缓存的</p>
</blockquote>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/9.png" alt="img"></p>
<blockquote>
<p>查看单个请求的<code>Response Header</code>，也能看到<code>304</code>的状态码和<code>Not Modified</code>的字符串，只要看到这个就可说明这个资源是命中了协商缓存，然后从客户端缓存中加载的，而不是服务器最新的资源</p>
</blockquote>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/10.png" alt="img"></p>
<h2 id="5-2-Last-Modified-response-，If-Modified-Since-request-控制协商缓存"><a href="#5-2-Last-Modified-response-，If-Modified-Since-request-控制协商缓存" class="headerlink" title="5.2 Last-Modified(response)，If-Modified-Since(request)控制协商缓存"></a>5.2 Last-Modified(response)，If-Modified-Since(request)控制协商缓存</h2><ol>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在<code>respone</code>的<code>header</code>加上<code>Last-Modified</code>的<code>header</code>，这个<code>header</code>表示这个资源在服务器上的最后修改时间</li>
</ol>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/11.png" alt="img"></p>
<ol>
<li>浏览器再次跟服务器请求这个资源时，在<code>request</code>的<code>header</code>上加上<code>If-Modified-Since</code>的<code>header</code>，这个<code>header</code>的值就是上一次请求时返回的<code>Last-Modified</code>的值</li>
</ol>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/12.png" alt="img"></p>
<ol>
<li>服务器再次收到资源请求时，根据浏览器传过来<code>If-Modified-Since</code>和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回<code>304 Not Modified</code>，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回<code>304 Not Modified</code>的响应时，<code>response header</code>中不会再添加<code>Last-Modified</code>的<code>header</code>，因为既然资源没有变化，那么<code>Last-Modified</code>也就不会改变，这是服务器返回<code>304</code>时的<code>response header</code></li>
</ol>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/13.png" alt="img"></p>
<ol>
<li>浏览器收到<code>304</code>的响应后，就会从缓存中加载资源</li>
<li>如果协商缓存没有命中，浏览器直接从服务器加载资源时，<code>Last-Modified</code> <code>Header</code>在重新加载的时候会被更新，下次请求时，<code>If-Modified-Since</code>会启用上次返回的<code>Last-Modified</code>值</li>
</ol>
<blockquote>
<p>【<code>Last-Modified</code>，<code>If-Modified-Since</code>】都是根据服务器时间返回的<code>header</code>，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个<code>header</code>配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对<code>header</code>来管理协商缓存，这对<code>header</code>就是【<code>ETag</code>、<code>If-None-Match</code>】。它们的缓存管理的方式是</p>
</blockquote>
<h2 id="5-3-ETag-response-、If-None-Match-request-控制协商缓存"><a href="#5-3-ETag-response-、If-None-Match-request-控制协商缓存" class="headerlink" title="5.3 ETag(response)、If-None-Match(request)控制协商缓存"></a>5.3 ETag(response)、If-None-Match(request)控制协商缓存</h2><ol>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在<code>respone</code>的<code>header</code>加上<code>ETag</code>的<code>header</code>，这个<code>header</code>是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充<code>Last-Modified</code>的问题</li>
</ol>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/14.png" alt="img"></p>
<ol>
<li>浏览器再次跟服务器请求这个资源时，在<code>request</code>的<code>header</code>上加上<code>If-None-Match</code>的<code>header</code>，这个<code>header</code>的值就是上一次请求时返回的<code>ETag</code>的值</li>
</ol>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/15.png" alt="img"></p>
<ol>
<li>服务器再次收到资源请求时，根据浏览器传过来<code>If-None-Match</code>和然后再根据资源生成一个新的<code>ETag</code>，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回<code>304 Not Modified</code>，但是不会返回资源内容；如果有变化，就正常返回资源内容。与<code>Last-Modified</code>不一样的是，当服务器返回<code>304 Not Modified</code>的响应时，由于<code>ETag</code>重新生成过，<code>response header</code>中还会把这个<code>ETag</code>返回，即使这个<code>ETag</code>跟之前的没有变化</li>
</ol>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/16.png" alt="img"></p>
<ol>
<li>浏览器收到<code>304</code>的响应后，就会从缓存中加载资源。</li>
</ol>
<h1 id="六、协商缓存的管理"><a href="#六、协商缓存的管理" class="headerlink" title="六、协商缓存的管理"></a>六、协商缓存的管理</h1><blockquote>
<p>协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。大部分<code>web</code>服务器都默认开启协商缓存，而且是同时启用【<code>Last-Modified</code>，<code>If-Modified-Since</code>】和【<code>ETag</code>、<code>If-None-Match</code>】，比如<code>apache</code>:</p>
</blockquote>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/17.png" alt="img"></p>
<blockquote>
<p>如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。</p>
</blockquote>
<ul>
<li>【<code>Last-Modified</code>，<code>If-Modified-Since</code>】和【<code>ETag</code>、<code>If-None-Match</code>】一般都是同时启用，这是为了处理<code>Last-Modified</code>不可靠的情况。</li>
</ul>
<p><strong>有一种场景需要注意</strong></p>
<ul>
<li>分布式系统里多台机器间文件的<code>Last-Modified</code>必须保持一致，以免负载均衡到不同机器导致比对失败；</li>
<li><strong>分布式系统尽量关闭掉<code>ETag</code></strong>(<strong>每台机器生成的<code>ETag</code>都会不一样</strong>）；</li>
<li>京东页面的资源请求，返回的<code>repsones header</code>就只有<code>Last-Modified</code>，没有<code>ETag</code>：</li>
</ul>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/18.png" alt="img"></p>
<blockquote>
<p>协商缓存需要配合强缓存使用，你看前面这个截图中，除了<code>Last-Modified</code>这个<code>header</code>，还有强缓存的相关<code>header</code>，因为如果不启用强缓存的话，协商缓存根本没有意义</p>
</blockquote>
<h1 id="七、相关浏览器行为对缓存的影响"><a href="#七、相关浏览器行为对缓存的影响" class="headerlink" title="七、相关浏览器行为对缓存的影响"></a>七、相关浏览器行为对缓存的影响</h1><blockquote>
<p>如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。这是默认的处理方式，这个方式可能被浏览器的行为改变：</p>
</blockquote>
<ul>
<li>当<code>ctrl+f5</code>强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</li>
<li>当<code>f5</code>刷新网页时，跳过强缓存，但是会检查协商缓存</li>
</ul>
<h1 id="总结图片"><a href="#总结图片" class="headerlink" title="总结图片"></a>总结图片</h1><p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/cache/7b22f75c35414de9828c28f142a36a8d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.png" alt="强缓存"></p>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/cache/acab5cc0f39c46d9845677ddf7310746~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.png" alt="协商缓存"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E9%98%BB%E5%A1%9E%E5%85%B3%E7%B3%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E9%98%BB%E5%A1%9E%E5%85%B3%E7%B3%BB/" class="post-title-link" itemprop="url">阻塞关系</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-12 00:00:00" itemprop="dateCreated datePublished" datetime="2021-08-12T00:00:00+08:00">2021-08-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-13 13:25:30" itemprop="dateModified" datetime="2024-07-13T13:25:30+08:00">2024-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">性能优化</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>&#x2F;&#x2F; TODO<br>半成品 半成品 先别看了<br>下面结合实例代码探索html、js、css的阻塞关系,浏览器chrome 版本92</p>
<ul>
<li>html监听了DCL和load事件，拥有两个具有文字内容(可以观测到FCP、LCP)的div</li>
<li>js css 带有sleep3000-的前缀，表示服务器会阻塞3000毫秒后返回，方便观测</li>
</ul>
<blockquote>
<p>js css并存 测试变量太多3*4&#x3D;12种情况，感觉意义不大、、</p>
</blockquote>
<p>首先是html内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line"> &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line"> &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">  document.addEventListener(&#x27;DOMContentLoaded&#x27;,function()&#123;</span><br><span class="line">   console.log(&#x27;DOMContentLoaded&#x27;);</span><br><span class="line">  &#125;);</span><br><span class="line">  window.addEventListener(&#x27;load&#x27;,function()&#123;</span><br><span class="line">   console.log(&#x27;load&#x27;);</span><br><span class="line">  &#125;);</span><br><span class="line"> &lt;/script&gt;</span><br><span class="line"> &lt;style&gt;</span><br><span class="line">  div &#123;</span><br><span class="line">   width: 100px;</span><br><span class="line">   height: 100px;</span><br><span class="line">   background: green;</span><br><span class="line">  &#125;</span><br><span class="line"> &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"> &lt;div&gt;的时光飞逝东莞市地方刮大风&lt;/div&gt;</span><br><span class="line"> &lt;div&gt;asfklasjf&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>css 将div背景设置为blue，html中为green</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">  background: blue!important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>js1 打印获取的div</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const div1 = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">console.log(div1);</span><br></pre></td></tr></table></figure>

<p>Js2 执行复杂操作后 打印div</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const arr = [];</span><br><span class="line">for (let i = 0; i &lt; 10000000; i++) &#123;</span><br><span class="line">  arr.push(i);</span><br><span class="line">  arr.splice(i % 3, i % 7, i % 5);</span><br><span class="line">&#125;</span><br><span class="line">const div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">console.log(div);</span><br></pre></td></tr></table></figure>

<h3 id="首先仅测试css"><a href="#首先仅测试css" class="headerlink" title="首先仅测试css"></a>首先仅测试css</h3><h4 id="外链css放在head内"><a href="#外链css放在head内" class="headerlink" title="外链css放在head内"></a>外链css放在head内</h4><p>图上dcl只是被挡住了，几乎是立刻执行，然后等待css下载完成后，触发load时间，然后进行fp、fcp、lcp</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E9%98%BB%E5%A1%9E%E5%85%B3%E7%B3%BB/image-20210812171549248.png" alt="image-20210812171549248"></p>
<p>页面上前五秒并未显示div，但是此时在dom中已经存在div，css并不能阻塞dom的解析，五秒后显示蓝色div</p>
<p>![Kapture 2021-08-12 at 17.34.48](assets&#x2F;阻塞关系&#x2F;Kapture 2021-08-12 at 17.34.48.gif)</p>
<h4 id="外链css放在body最前部"><a href="#外链css放在body最前部" class="headerlink" title="外链css放在body最前部"></a>外链css放在body最前部</h4><p>放在body最前部，浏览器会等待css下载完毕后，才会触发dcl及一系列绘制</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E9%98%BB%E5%A1%9E%E5%85%B3%E7%B3%BB/image-20210812174254853.png" alt="image-20210812174254853"></p>
<p>很明显，放在body前的外链css阻塞的dom的解析，当css下载完毕后，触发了一系列关键事件</p>
<p>![Kapture 2021-08-12 at 17.46.42](assets&#x2F;阻塞关系&#x2F;Kapture 2021-08-12 at 17.46.42.gif)</p>
<h4 id="外链css放在body内，两个div之间"><a href="#外链css放在body内，两个div之间" class="headerlink" title="外链css放在body内，两个div之间"></a>外链css放在body内，两个div之间</h4><p>浏览器会先绘制并渲染css之前的div，待css下载完毕后，会渲染另一个div，并显示蓝色背景，触发dcl及load</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E9%98%BB%E5%A1%9E%E5%85%B3%E7%B3%BB/image-20210812175156074.png" alt="image-20210812175156074"></p>
<p>![Kapture 2021-08-12 at 17.55.14](assets&#x2F;阻塞关系&#x2F;Kapture 2021-08-12 at 17.55.14.gif)</p>
<h4 id="css外链放在body内最后"><a href="#css外链放在body内最后" class="headerlink" title="css外链放在body内最后"></a>css外链放在body内最后</h4><p>performance和放在div之间一样，实际页面表现有一些差异</p>
<p>![Kapture 2021-08-12 at 18.03.58](assets&#x2F;阻塞关系&#x2F;Kapture 2021-08-12 at 18.03.58.gif)</p>
<h4 id="外链css放在body之后"><a href="#外链css放在body之后" class="headerlink" title="外链css放在body之后"></a>外链css放在body之后</h4><p>会被浏览器修复到body内最后</p>
<h3 id="仅测试js"><a href="#仅测试js" class="headerlink" title="仅测试js"></a>仅测试js</h3><h4 id="js放在head内、body头部"><a href="#js放在head内、body头部" class="headerlink" title="js放在head内、body头部"></a>js放在head内、body头部</h4><p>很明显，js的下载和解析（执行）都会阻塞dom元素的解析和渲染，直到js下载解析之后，才会继续解析渲染dom，触发dcl、fp等等</p>
<h4 id=""><a href="#" class="headerlink" title=""></a><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E9%98%BB%E5%A1%9E%E5%85%B3%E7%B3%BB/image-20210813140650543.png" alt="image-20210813140650543"></h4><p>![Kapture 2021-08-12 at 21.36.22](assets&#x2F;阻塞关系&#x2F;Kapture 2021-08-12 at 21.36.22.gif)</p>
<h4 id="js放在div之间"><a href="#js放在div之间" class="headerlink" title="js放在div之间"></a>js放在div之间</h4><p>js会阻塞js之后的dom解析和渲染，对于js之前的dom会正常解析渲染，并触发fp等，但是dcl需要等待js下载解析（执行）完成后</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E9%98%BB%E5%A1%9E%E5%85%B3%E7%B3%BB/image-20210813140535630.png" alt="image-20210813140535630"></p>
<p>![Kapture 2021-08-12 at 21.41.08](assets&#x2F;阻塞关系&#x2F;Kapture 2021-08-12 at 21.41.08.gif)</p>
<h4 id="js放body尾部"><a href="#js放body尾部" class="headerlink" title="js放body尾部"></a>js放body尾部</h4><p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E9%98%BB%E5%A1%9E%E5%85%B3%E7%B3%BB/image-20210813141225951.png" alt="image-20210813141225951"></p>
<p>![Kapture 2021-08-12 at 21.46.00](assets&#x2F;阻塞关系&#x2F;Kapture 2021-08-12 at 21.46.00.gif)</p>
<h3 id="js、css并存"><a href="#js、css并存" class="headerlink" title="js、css并存"></a>js、css并存</h3><h4 id="css处于head"><a href="#css处于head" class="headerlink" title="css处于head"></a>css处于head</h4><h5 id="js处于dom前"><a href="#js处于dom前" class="headerlink" title="js处于dom前"></a>js处于dom前</h5><p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E9%98%BB%E5%A1%9E%E5%85%B3%E7%B3%BB/image-20210813152617775.png" alt="image-20210813152617775"></p>
<h5 id="js处于dom中"><a href="#js处于dom中" class="headerlink" title="js处于dom中"></a>js处于dom中</h5><p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E9%98%BB%E5%A1%9E%E5%85%B3%E7%B3%BB/image-20210813152844462.png" alt="image-20210813152844462"></p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E9%98%BB%E5%A1%9E%E5%85%B3%E7%B3%BB/image-20210813152950225.png" alt="image-20210813152950225"></p>
<h5 id="js处于dom后"><a href="#js处于dom后" class="headerlink" title="js处于dom后"></a>js处于dom后</h5><p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E9%98%BB%E5%A1%9E%E5%85%B3%E7%B3%BB/image-20210813153113295.png" alt="image-20210813153113295"></p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E9%98%BB%E5%A1%9E%E5%85%B3%E7%B3%BB/image-20210813153206303.png" alt="image-20210813153206303"></p>
<h2 id="css和js文件对html的阻塞"><a href="#css和js文件对html的阻塞" class="headerlink" title="css和js文件对html的阻塞"></a>css和js文件对html的阻塞</h2><ul>
<li><p><code>CSS</code> 不会（仅限head内）阻塞 <code>DOM</code> 的解析(document存在)，但会阻塞其后的 <code>DOM</code> 渲染。</p>
</li>
<li><p>在js前的css会阻塞js的解析（不会阻止下载），继而阻止dom的解析和渲染</p>
</li>
<li><p><code>JS</code> 阻塞 <code>DOM</code> 解析，但浏览器会”偷看”<code>DOM</code>，预先下载相关资源。</p>
</li>
</ul>
<h2 id="DCL的结论"><a href="#DCL的结论" class="headerlink" title="DCL的结论"></a>DCL的结论</h2><p>除了放在head里的css，html中的js、css都会阻塞dcl事件</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%87%92%E5%8A%A0%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%87%92%E5%8A%A0%E8%BD%BD/" class="post-title-link" itemprop="url">13 预加载和懒加载</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-30 00:00:00" itemprop="dateCreated datePublished" datetime="2021-07-30T00:00:00+08:00">2021-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-13 13:13:31" itemprop="dateModified" datetime="2024-07-13T13:13:31+08:00">2024-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">性能优化</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%87%92%E5%8A%A0%E8%BD%BD/%E6%87%92%E5%8A%A0%E8%BD%BD.png" alt="懒加载"></p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%87%92%E5%8A%A0%E8%BD%BD/%E9%A2%84%E5%8A%A0%E8%BD%BD.png" alt="预加载"></p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%87%92%E5%8A%A0%E8%BD%BD/%E9%A2%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F1.png" alt="预加载方式1"></p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%87%92%E5%8A%A0%E8%BD%BD/%E9%A2%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F2.png" alt="预加载方式2"></p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%87%92%E5%8A%A0%E8%BD%BD/%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%A5%BD%E5%A4%84.png" alt="预加载好处"></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/61298b51a5fb">pre系列讲解</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%BC%A0%E8%BE%93%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%BC%A0%E8%BE%93%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">12 传输优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-20 00:00:00" itemprop="dateCreated datePublished" datetime="2021-07-20T00:00:00+08:00">2021-07-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-13 13:13:35" itemprop="dateModified" datetime="2024-07-13T13:13:35+08:00">2024-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">性能优化</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="GZIP压缩"><a href="#GZIP压缩" class="headerlink" title="GZIP压缩"></a>GZIP压缩</h3><h3 id="启用keep-alive"><a href="#启用keep-alive" class="headerlink" title="启用keep alive"></a>启用keep alive</h3><p>默认http1.1以后默认开启</p>
<ul>
<li>keepalive-timeout  保持时间 s</li>
<li>keepalive-requests 链接数</li>
</ul>
<h3 id="http-缓存"><a href="#http-缓存" class="headerlink" title="http 缓存"></a>http 缓存</h3><ul>
<li>cache control 1.1 &#x2F; expires 1.0</li>
<li>Last-modified  if-modified-since 1.0</li>
<li>Etag  if-none-match  1.1</li>
</ul>
<p>一般设置：html 不缓存, css、js缓存过期时间可以设置的很长，因为一般使用hash命名文件</p>
<p>图片、字体不经常更换的话，缓存时间设置长一点</p>
<blockquote>
<p><strong>server-work和HTTP2 都依赖https</strong>，可以生成自签名的证书</p>
</blockquote>
<h3 id="http2"><a href="#http2" class="headerlink" title="http2"></a>http2</h3><ul>
<li>二进制传输（http1.1是基于文本的，传输效率慢且不安全）</li>
<li>请求响应多路复用</li>
<li>server push （服务器直接推送，没有请求过程）</li>
<li>只能部署在https</li>
<li>适合较高的请求量</li>
</ul>
<h3 id="资源优先级"><a href="#资源优先级" class="headerlink" title="资源优先级"></a>资源优先级</h3><ul>
<li>浏览器默认安排资源加载优先级</li>
<li>使用preload，prefetch调整优先级</li>
<li>preload 提前加载较晚出现，但对于当前页面非常重要的资源<ul>
<li>就是通过标签显式声明一个高优先级资源，强制浏览器提前请求资源，同时不阻塞文档正常onload</li>
<li>preload link必须设置as属性来声明资源的类型（font&#x2F;image&#x2F;style&#x2F;script等)，否则浏览器可能无法正确加载资源。</li>
</ul>
</li>
<li>prefetch 提前加载后继路由需要的资源，优先级低</li>
</ul>
<p>文章写的相当好<br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6893681741240909832">pre系列讲解</a><br><a href="./prefetch%E5%92%8Cpreload">同上，防止链接挂掉</a></p>
<h3 id="接口缓存策略"><a href="#接口缓存策略" class="headerlink" title="接口缓存策略"></a>接口缓存策略</h3><ol>
<li>ajax&#x2F;fetch缓存<ul>
<li>前端请求的时间带上cache，依赖浏览器本身缓存机制</li>
</ul>
</li>
<li>本地缓存<ul>
<li>异步接口数据优先使用本地localStorage中的缓存数据</li>
</ul>
</li>
<li>多次请求<ul>
<li>接口数据本地无localStorage缓存数据，重新再次发出ajax请求</li>
</ul>
</li>
</ol>
<h3 id="使用CDN"><a href="#使用CDN" class="headerlink" title="使用CDN"></a>使用CDN</h3><p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%A0%E8%BE%93%E4%BC%98%E5%8C%96/CDN%E4%BC%98%E7%82%B9.png" alt="CDN优点"></p>
<h4 id="cdn回源"><a href="#cdn回源" class="headerlink" title="cdn回源"></a>cdn回源</h4><p>回源是指浏览器访问cdn集群上静态文件时，文件缓存过期，直接穿透cdn集群而访问源站机器的行为。（发生这种情况后，cdn会更新文件及缓存标记）</p>
<h4 id="cdn缓存"><a href="#cdn缓存" class="headerlink" title="cdn缓存"></a>cdn缓存</h4><p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%A0%E8%BE%93%E4%BC%98%E5%8C%96/cdn%E7%BC%93%E5%AD%98.png" alt="cdn缓存"></p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%A0%E8%BE%93%E4%BC%98%E5%8C%96/cdn%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83.png" alt="cdn灰度发布"></p>
<h3 id="减少http请求"><a href="#减少http请求" class="headerlink" title="减少http请求"></a>减少http请求</h3><p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%A0%E8%BE%93%E4%BC%98%E5%8C%96/reducehttp%E8%AF%B7%E6%B1%82.png" alt="减少http请求"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/javascript/js%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/javascript/js%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/" class="post-title-link" itemprop="url">JavaScript的内存空间</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-20 00:00:00" itemprop="dateCreated datePublished" datetime="2021-07-20T00:00:00+08:00">2021-07-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-13 13:25:34" itemprop="dateModified" datetime="2024-07-13T13:25:34+08:00">2024-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h3><p>众所众知，JavaScript是一种弱类型、动态语言。这意味着：</p>
<ul>
<li><p><strong>弱类型</strong>，意味着你不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型，JavaScript 引擎在运行代码的时候自己会计算出来。</p>
</li>
<li><p><strong>动态</strong>，意味着你可以使用同一个变量保存不同类型的数据。</p>
</li>
</ul>
<p>其实 JavaScript 中的数据类型一种有 8 种，它们分别是：</p>
<p><img src="/_posts/javascript/assets/js%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/image-20210720140409634.png" alt="image-20210720140409634"></p>
<p>我们把前面的 7 种数据类型称为<strong>原始类型</strong>，把最后一个对象类型称为<strong>引用类型</strong>，之所以把它们区分为两种不同的类型，<strong>是因为它们在内存中存放的位置不一样</strong></p>
<h3 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h3><p>要理解 JavaScript 在运行过程中数据是如何存储的，你就得先搞清楚其存储空间的种类。下面是JavaScript 的内存模型，可以参考：</p>
<p><img src="/_posts/javascript/assets/js%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/image-20210720140604983.png" alt="image-20210720140604983"></p>
<p> 在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是<strong>代码空间、栈空间</strong>和<strong>堆空间</strong></p>
<h4 id="栈空间和堆空间"><a href="#栈空间和堆空间" class="headerlink" title="栈空间和堆空间"></a>栈空间和堆空间</h4><p>这里的栈空间就是<strong>我们之前反复提及的调用栈，是用来存储执行上下文的</strong>。为了搞清楚栈空间是如何存储数据的，我们还是先看下面这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line"> var a = &quot; 极客时间 &quot;</span><br><span class="line"> var b = a</span><br><span class="line"> var c = &#123;name:&quot; 极客时间 &quot;&#125;</span><br><span class="line"> var d = c</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>最终分配好内存的示意图如下所示：</p>
<p><img src="/_posts/javascript/assets/js%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/image-20210720140826201.png" alt="image-20210720140826201"></p>
<p><strong>可以认为简单类型的值都是存放在栈空间中，对象类型是存放在堆空间的，在栈空间中只是保留了对象的引用地址</strong></p>
<h4 id="为什么一定要分堆和栈两个存储空间"><a href="#为什么一定要分堆和栈两个存储空间" class="headerlink" title="为什么一定要分堆和栈两个存储空间"></a>为什么一定要分堆和栈两个存储空间</h4><p>​ 这是因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。</p>
<p>​ 下面简单介绍一下上下文的切换，比如文中的 foo 函数执行结束了，JavaScript 引擎需要离开当前的执行上下文，只需要将指针下移到上个执行上下文的地址就可以了，foo 函数执行上下文栈区空间全部回收。</p>
<p><img src="/_posts/javascript/assets/js%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/image-20210720141334853.png" alt="image-20210720141334853"></p>
<h4 id="再谈闭包"><a href="#再谈闭包" class="headerlink" title="再谈闭包"></a>再谈闭包</h4><p>这里简单的探讨下闭包的内存模型，看下述代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line"> var myName = &quot; 极客时间 &quot;</span><br><span class="line"> let test1 = 1</span><br><span class="line"> const test2 = 2</span><br><span class="line"> var innerBar = &#123; </span><br><span class="line">  setName:function(newName)&#123;</span><br><span class="line">   myName = newName</span><br><span class="line">  &#125;,</span><br><span class="line">  getName:function()&#123;</span><br><span class="line">   console.log(test1)</span><br><span class="line">   return myName</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> return innerBar</span><br><span class="line">&#125;</span><br><span class="line">var bar = foo()</span><br><span class="line">bar.setName(&quot; 极客邦 &quot;)</span><br><span class="line">bar.getName()</span><br><span class="line">console.log(bar.getName())</span><br></pre></td></tr></table></figure>

<p>由闭包知识我们可以知道：了当 foo 函数的执行上下文销毁时，由于 foo 函数产生了闭包，所以变量 myName 和 test1 并没有被销毁，而是保存在内存中，那么应该如何解释这个现象呢？</p>
<p>要解释这个现象，我们就得站在内存模型的角度来分析这段代码的执行流程。</p>
<ul>
<li><p>当 JavaScript 引擎执行到 foo 函数时，首先会编译，并创建一个空执行上下文。</p>
</li>
<li><p>在编译过程中，遇到内部函数 setName，JavaScript 引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了 foo 函数中的 myName 变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建换一个“closure(foo)”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 myName 变量。</p>
</li>
<li><p>接着继续扫描到 getName 方法时，发现该函数内部还引用变量 test1，于是JavaScript 引擎又将 test1 添加到“closure(foo)”对象中。这时候堆中的“closure(foo)”对象中就包含了 myName 和 test1 两个变量了。</p>
</li>
<li><p>由于 test2 并没有被内部函数引用，所以 test2 依然保存在调用栈中。</p>
</li>
<li><p>当foo执行上下文销毁了，foo函数中的对closure(foo)的引用也断开了，但是setName和getName里面又重新建立起来了对closure(foo)引用</p>
<blockquote>
<ul>
<li>打开“开发者工具”</li>
<li>在控制台执行上述代码</li>
<li>然后选择“Memory”标签，点击”take snapshot” 获取V8的堆内存快照。</li>
<li>然后“command+f”(mac) 或者 “ctrl+f”(win),搜索“setName”，然后你就会发现setName对象下面包含了 <strong>raw_outer_scope_info_or_feedback_metadata</strong>，对闭包的引用数据就在这里面。（实际上也看不到闭包的数据）</li>
</ul>
</blockquote>
</li>
</ul>
<p><img src="/_posts/javascript/assets/js%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/image-20210720143331806.png" alt="image-20210720143331806"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" class="post-title-link" itemprop="url">深入理解垃圾回收机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-20 00:00:00" itemprop="dateCreated datePublished" datetime="2021-07-20T00:00:00+08:00">2021-07-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-13 13:13:28" itemprop="dateModified" datetime="2024-07-13T13:13:28+08:00">2024-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">零散知识</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>在V8原理中 22小节 有一些增量知识–回收效率</p>
</blockquote>
<p>在JavaScript中<strong>产生的垃圾数据是由垃圾回收器来释放的</strong>，并不需要手动通过代码来释放。</p>
<p>我们知道JavaScript的数据分为两类，<strong>原始数据类型是存储在栈空间中的，引用类型的数据是存储在堆空间中的</strong>。</p>
<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><h3 id="栈中的数据是如何回收的"><a href="#栈中的数据是如何回收的" class="headerlink" title="栈中的数据是如何回收的"></a><strong>栈中的数据是如何回收的</strong></h3><p>在blog中有关于介绍**执行上下文(调用栈)**的详细介绍，栈中的垃圾回收，我们通过一段代码来看一下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"> <span class="keyword">var</span> b = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客邦 &quot;</span>&#125;</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">showName</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">  <span class="keyword">var</span> d = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客时间 &quot;</span>&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="title function_">showName</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>

<p>当执行到第 6 行代码时，其调用栈和堆空间状态图如下所示：</p>
<p><img src="/_posts/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/assets/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210720151826588.png" alt="image-20210720151826588"></p>
<p>当showName执行完毕，上下文需要切换至foo时，有一个<strong>记录当前执行状态的指针（称为 ESP）</strong>会下移指向foo函数的执行上下文，虽然showName的执行上下文未被摧毁，但是已经是无效内存了。因为如果当foo 函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文</p>
<p><img src="/_posts/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/assets/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210720152137737.png" alt="image-20210720152137737"></p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p> 在栈空间中，<strong>JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文，顺带完成了栈空间的垃圾回收</strong>。</p>
<h3 id="堆中的数据是如何回收的"><a href="#堆中的数据是如何回收的" class="headerlink" title="堆中的数据是如何回收的"></a><strong>堆中的数据是如何回收的</strong></h3><p>继续上边代码的执行，当上面那段代码的 foo 函数执行结束之后，ESP 应该是指向全局执行上下文的，那这样的话，showName 函数和 foo 函数的执行上下文就处于无效状态了，<strong>不过保存在堆中的两个对象依然占用着空间</strong>，如下图所示：</p>
<p><img src="/_posts/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/assets/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210720152420782.png" alt="image-20210720152420782"></p>
<p><strong>要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了</strong>。</p>
<h4 id="代际假说"><a href="#代际假说" class="headerlink" title="代际假说"></a>代际假说</h4><p> <strong>代际假说（The Generational Hypothesis）</strong>，这是垃圾回收领域中一个重要的术语，后续垃圾回收的策略都是建立在该假说的基础之上的。</p>
<p><strong>代际假说</strong>有以下两个特点：</p>
<ul>
<li><p>第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；</p>
</li>
<li><p>第二个是不死的对象，会活得更久。</p>
</li>
</ul>
<h4 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h4><p>在 V8 中会把堆分为<strong>新生代</strong>和<strong>老生代</strong>两个区域，<strong>新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象</strong>。</p>
<ul>
<li><p><strong>副垃圾回收器，主要负责新生代的垃圾回收。</strong></p>
</li>
<li><p><strong>主垃圾回收器，主要负责老生代的垃圾回收。</strong></p>
</li>
</ul>
<h4 id="统一的回收流程"><a href="#统一的回收流程" class="headerlink" title="统一的回收流程"></a>统一的回收流程</h4><p> 不论什么类型的垃圾回收器，它们都有一套共同的执行流程</p>
<ul>
<li><p>标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。</p>
</li>
<li><p>回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</p>
</li>
<li><p>第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们</p>
<p>把这些不连续的内存空间称为<strong>内存碎片</strong>。（<strong>副垃圾回收器不会产生内存碎片</strong>）</p>
</li>
</ul>
<h4 id="副垃圾回收器"><a href="#副垃圾回收器" class="headerlink" title="副垃圾回收器"></a><strong>副垃圾回收器</strong></h4><p> 副垃圾回收器主要负责新生区的垃圾回收。大多数小的对象都会被分配到新生区，所以说这个<strong>区域虽然不大</strong>，但是垃圾回收还是比较<strong>频繁</strong>的。</p>
<p> 新生代中用<strong>Scavenge 算法</strong>来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，如下图所示：</p>
<p><img src="/_posts/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/assets/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210720153841493.png" alt="image-20210720153841493"></p>
<p>新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</p>
<p> 在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还<strong>会把这些对象有序地排列起来</strong>，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。</p>
<p> 完成复制后，对象区域与空闲区域进行角色翻转，这样就完成了垃圾对象的回收操作，同时这种<strong>角色翻转的操作还能让新生代中的这两块区域无限重复使用下去</strong>。</p>
<blockquote>
<p>复制操作需要时间成本，<strong>为了执行效率，一般新生区的空间会被设置得比较小</strong></p>
</blockquote>
<h5 id="对象晋升策略"><a href="#对象晋升策略" class="headerlink" title="对象晋升策略"></a>对象晋升策略</h5><p> JavaScript 引擎采用了<strong>对象晋升策略</strong>，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中</p>
<h4 id="主垃圾回收器"><a href="#主垃圾回收器" class="headerlink" title="主垃圾回收器"></a><strong>主垃圾回收器</strong></h4><p> 主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，<strong>一些大的对象会直接被分配到老生区</strong>。因此老生区中的对象有两个特点，一个是<strong>对象占用空间大</strong>，另一个是<strong>对象存活时间长</strong>。</p>
<p> 由于老生去对象比较大，不适合新生去的回收机制，主垃圾回收器是采用标记-清除算法</p>
<h5 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记 - 清除"></a>标记 - 清除</h5><p> 首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素（<strong>调用栈</strong>），在这个遍历过程中，能到达的元素称为<strong>活动对象</strong>，没有到达的元素就可以判断为<strong>垃圾数据</strong>。</p>
<p> 接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其清除过程：</p>
<p><img src="/_posts/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/assets/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210720154746371.png" alt="image-20210720154746371"></p>
<p>不过对一块内存多次执行标记 - 清除算法后，会<strong>产生大量不连续的内存碎片</strong>，于是又产生了另外一种算法——<strong>标记 - 整理（Mark-Compact）</strong></p>
<p> 这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。你可以参考下图：</p>
<p><img src="/_posts/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/assets/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210720154921297.png" alt="image-20210720154921297"></p>
<h4 id="全停顿"><a href="#全停顿" class="headerlink" title="全停顿"></a><strong>全停顿</strong></h4><p> JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做<strong>全停顿（Stop-The-World）</strong>。</p>
<p><img src="/_posts/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/assets/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210720154954477.png" alt="image-20210720154954477"></p>
<p>一般来说是老生代的垃圾回收占用时间较长，新生代可以忽略不计。为了解决这个问题，V8使用了<strong>增量标记（Incremental Marking）算法</strong>。</p>
<p><img src="/_posts/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/assets/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210720155150795.png" alt="image-20210720155150795"></p>
<p>V8 将<strong>标记过程</strong>分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成。这样当执行复杂动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。</p>
<blockquote>
<p>精彩评论</p>
<p><img src="/_posts/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/assets/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220720104725019.png" alt="image-20220720104725019"></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/javascript/this/this/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/javascript/this/this/" class="post-title-link" itemprop="url">this绑定规则的详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-20 00:00:00" itemprop="dateCreated datePublished" datetime="2021-07-20T00:00:00+08:00">2021-07-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-16 14:08:25" itemprop="dateModified" datetime="2024-07-16T14:08:25+08:00">2024-07-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/javascript/this/" itemprop="url" rel="index"><span itemprop="name">this</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="this的由来"><a href="#this的由来" class="headerlink" title="this的由来"></a>this的由来</h2><p>看下述一段代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var bar = &#123;</span><br><span class="line">    myName:&quot;time.geekbang.com&quot;,</span><br><span class="line">    printName: function () &#123;</span><br><span class="line">        console.log(myName)</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">function foo() &#123;</span><br><span class="line">    let myName = &quot;极客时间&quot;</span><br><span class="line">    return bar.printName</span><br><span class="line">&#125;</span><br><span class="line">let myName = &quot;极客邦&quot;</span><br><span class="line">let _printName = foo()</span><br><span class="line">_printName()</span><br><span class="line">bar.printName()</span><br></pre></td></tr></table></figure>

<p>相信你已经知道了，在 printName 函数里面使用的变量 myName 是属于全局作用域下面的，所以最终打印出来的值都是“极客邦”</p>
<p>不过按照常理来说，调用bar.printName方法时，该方法内部的变量 myName 应该使用bar 对象中的，因为它们是一个整体，大多数面向对象语言都是这样设计的，以<strong>在对象内部的方法中使用对象内部的属性是一个非常普遍的需求</strong>。但是 JavaScript 的作用域机制并不支持这一点，基于这个需求，JavaScript 又搞出来另外一套<strong>this 机制</strong>。</p>
<h2 id="this到底是什么"><a href="#this到底是什么" class="headerlink" title="this到底是什么"></a>this到底是什么</h2><p><code>this</code> 是在运行时进行绑定的，<strong>是和执行上下文绑定的</strong>，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。<code>this</code>的绑定和<strong>函数声明的位置没有任何关系，只取决于函数的调用方式</strong>。</p>
<p><img src="/_posts/javascript/this/assets/this/image-20210720111215903.png" alt="image-20210720111215903"></p>
<blockquote>
<p>执行上下文其余相关的内容，在blog中浏览器原理中有详细介绍</p>
</blockquote>
<h2 id="this的绑定规则"><a href="#this的绑定规则" class="headerlink" title="this的绑定规则"></a>this的绑定规则</h2><h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><p>首先要介绍的是最常用的函数调用类型：<strong>独立函数调用</strong>。可以把这条规则看作是无法应用其他规则时的默认规则。<br>this指向window对象，在严格模式下指向 <code>undefined</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;      </span><br><span class="line">  console.log( this.a ); </span><br><span class="line">&#125; </span><br><span class="line">var a = 2; </span><br><span class="line">foo(); // 2</span><br></pre></td></tr></table></figure>

<p>foo() 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。</p>
<h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><ol>
<li>另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;      </span><br><span class="line">  console.log( this.a ); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 2,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">obj.foo(); // 2</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>对象属性引用链中只有最顶层或者说<strong>最后一层会影响调用结果</strong>,看下例</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;      </span><br><span class="line">  console.log( this.a ); </span><br><span class="line">&#125; </span><br><span class="line">var obj2 = &#123;      </span><br><span class="line">  a: 42,     </span><br><span class="line">  foo: foo  </span><br><span class="line">&#125;; </span><br><span class="line">var obj1 = &#123;      </span><br><span class="line">  a: 2,     </span><br><span class="line">  obj2: obj2  </span><br><span class="line">&#125;; </span><br><span class="line">obj1.obj2.foo(); // 42</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>隐式丢失, 一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;      </span><br><span class="line">  console.log( this.a ); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">var obj = &#123;      </span><br><span class="line">  a: 2,     </span><br><span class="line">  foo: foo  </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">var bar = obj.foo; // 函数别名！   </span><br><span class="line">var a = &quot;oops, global&quot;; // a 是全局对象的属性 </span><br><span class="line">bar(); // &quot;oops, global&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>虽然 bar 是 obj.foo 的一个引用，<strong>但是实际上，它引用的是 foo 函数本身</strong>，因此此时的 bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定</p>
</blockquote>
<p>一种更微妙、更常见并且更出乎意料的情况发生在传入回调函数时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;      </span><br><span class="line">  console.log( this.a ); </span><br><span class="line">&#125; </span><br><span class="line">function doFoo(fn) &#123;     </span><br><span class="line">  // fn 其实引用的是 foo </span><br><span class="line">  fn(); // &lt;-- 调用位置！ </span><br><span class="line">&#125; </span><br><span class="line">var obj = &#123;      </span><br><span class="line">  a: 2,     </span><br><span class="line">  foo: foo  </span><br><span class="line">&#125;; </span><br><span class="line">var a = &quot;oops, global&quot;; // a 是全局对象的属性 </span><br><span class="line">doFoo( obj.foo ); // &quot;oops, global&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子一样。</p>
</blockquote>
<h3 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h3><p><code>call(..)</code> 、<code>apply(..)</code>和<code>bind(..)</code> 方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;      </span><br><span class="line">  console.log( this.a ); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">var obj = &#123;</span><br><span class="line">  a:2 </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">foo.call( obj ); // 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="new-绑定-（暂不深究）"><a href="#new-绑定-（暂不深究）" class="headerlink" title="new 绑定 （暂不深究）"></a>new 绑定 （暂不深究）</h3><p>在 JavaScript 中，构造函数只是一些使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上， 它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。<br>使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</p>
<ol>
<li>创建（或者说构造）一个全新的对象。</li>
<li>这个新对象会被执行 <code>[[ 原型 ]]</code> 连接。</li>
<li>这个新对象会绑定到函数调用的 this。</li>
<li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象</li>
</ol>
<h3 id="还有一些需要注意的示例"><a href="#还有一些需要注意的示例" class="headerlink" title="还有一些需要注意的示例"></a>还有一些需要注意的示例</h3><p>注意后三个示例，详细解释在 <strong>同分类下-从ECMAScript规范解读this</strong>中有解读</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var value = 1;</span><br><span class="line"></span><br><span class="line">var foo = &#123;</span><br><span class="line">  value: 2,</span><br><span class="line">  bar: function () &#123;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//示例1</span><br><span class="line">console.log(foo.bar()); // 2</span><br><span class="line">//示例2</span><br><span class="line">console.log((foo.bar)()); // 2</span><br><span class="line">//示例3</span><br><span class="line">console.log((foo.bar = foo.bar)()); // 1</span><br><span class="line">//示例4</span><br><span class="line">console.log((false || foo.bar)()); // 1</span><br><span class="line">//示例5</span><br><span class="line">console.log((foo.bar, foo.bar)()); // 1</span><br></pre></td></tr></table></figure>

<p>后三个类型，方便记忆的话，可以将其理解为隐式绑定，foo.bar被隐式的赋值了，相当于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = foo.bar</span><br><span class="line">a()</span><br></pre></td></tr></table></figure>

<p>但是需要注意第二个示例</p>
<h2 id="关于this补充"><a href="#关于this补充" class="headerlink" title="关于this补充"></a>关于this补充</h2><p>可以帮助理解</p>
<p><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/7">从ECMAScript规范解读this</a></p>
<p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/128427">极客时间</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/javascript/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E7%9A%84%E6%9C%AC%E8%B4%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/javascript/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E7%9A%84%E6%9C%AC%E8%B4%A8/" class="post-title-link" itemprop="url">变量提升的本质</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-19 00:00:00" itemprop="dateCreated datePublished" datetime="2021-07-19T00:00:00+08:00">2021-07-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-16 14:05:18" itemprop="dateModified" datetime="2024-07-16T14:05:18+08:00">2024-07-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">showName()</span><br><span class="line">console.log(myname)</span><br><span class="line">var myname = &#x27;极客时间&#x27;</span><br><span class="line">function showName() &#123;</span><br><span class="line"> console.log(&#x27;函数 showName 被执行&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">// 函数 showName 被执行</span><br><span class="line">// undefined</span><br></pre></td></tr></table></figure>

<p>最后输出的结果不太符合预期，其中的本质与js的执行过程有关，这种现象被称为变量提升</p>
<p><strong>所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined。</strong></p>
<blockquote>
<p>声明部分 指 var myname &#x3D; 这部分 以及 完整的函数声明</p>
<p>var bar &#x3D; function(){} 这种与var bar &#x3D; 1 并无大的区别，与function bar(){} 从编译过程来说截然不同</p>
</blockquote>
<p><strong>实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中</strong></p>
<h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p><img src="/_posts/javascript/assets/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20210719142421766.png" alt="image-20210719142421766"></p>
<p>从上图可以看出，输入一段代码，经过编译后，会生成两部分内容：<strong>执行上下文（Execution context）和可执行代码</strong>。</p>
<blockquote>
<p>执行上下文也是一个特别重要的概念，会在后边具体分析</p>
</blockquote>
<p>由此不难分析出打印的结果，但是如果存在<strong>相同的命名</strong>怎么处理，可以参考下述规则：</p>
<ul>
<li><p>如果是同名的函数，JavaScript编译阶段会选择最后声明的那个。</p>
</li>
<li><p>如果变量和函数同名，那么在编译阶段，变量的声明会被忽略</p>
</li>
</ul>
<h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>执行上下文（以下简称“上下文”）的概念在 JavaScript 中是颇为重要的。变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的<strong>变量对象</strong>（variable object），而这个上下文中定义的所有变量和函数都存在于这个对象上。</p>
<p><strong>执行上下文的组成代码示例：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const ExecutionContextObj = &#123;</span><br><span class="line">    VO: window, // 变量对象</span><br><span class="line">    ScopeChain: &#123;&#125;, // 作用域链</span><br><span class="line">    this: window</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>执行上下文的组成图例示例：</strong></p>
<p><img src="/_posts/javascript/assets/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E7%9A%84%E6%9C%AC%E8%B4%A8/v2-197a2714b1f1069f3fffebcdd630531c_1440w.jpg" alt="img"></p>
<p>**上下文基本上有三类(包括ES6)**：</p>
<ul>
<li>全局上下文 在浏览器环境下即为window</li>
<li>函数上下文（当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文）</li>
<li>eval上下文 （不考虑）</li>
</ul>
<p>上下文中的代码在执行的时候，会创建<strong>变量对象</strong>的一个<strong>作用域链</strong>。</p>
<blockquote>
<p>作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象</p>
</blockquote>
<h4 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h4><p><strong>如果上下文是函数，则其活动对象（activation object）用作变量对象，下面以函数为例具体分析一下</strong></p>
<blockquote>
<p>为什么称其为活动对象呢，因为只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，并且只有被激活的变量对象，其属性才能被访问。</p>
</blockquote>
<p>以下面的例子为例，结合着之前讲的变量对象和执行上下文栈，我们来总结一下函数执行上下文中作用域链和变量对象的创建过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var scope = &#x27;global scope&#x27;;</span><br><span class="line">function checkscope(s) &#123;  </span><br><span class="line"> var scope = &#x27;local scope&#x27;;  </span><br><span class="line"> function f() &#123;    </span><br><span class="line">  return scope;</span><br><span class="line">  &#125;  </span><br><span class="line">  return f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope(&#x27;scope&#x27;);</span><br></pre></td></tr></table></figure>

<p>执行过程如下：</p>
<p>1.checkscope 函数被创建，保存作用域链到 内部属性<code>[[scope]]</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checkscope.[[scope]] = [</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>2.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    checkscopeContext,</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>3.checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数<code>[[scope]]</code>属性创建<strong>作用域链</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    Scope: checkscope.[[scope]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">          0: &#x27;scope&#x27;,</span><br><span class="line">          length: 1,</span><br><span class="line">        &#125;,</span><br><span class="line">        s: &#x27;scope&#x27;, // 传入的参数</span><br><span class="line">        f: pointer to function f(),</span><br><span class="line">        scope: undefined, // 此时声明的变量为undefined</span><br><span class="line">    &#125;，</span><br><span class="line">    Scope: checkscope.[[scope]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.第三步：将活动对象压入 checkscope 作用域链顶端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">          0: &#x27;scope&#x27;,</span><br><span class="line">          length: 1,</span><br><span class="line">        &#125;,</span><br><span class="line">        s: &#x27;scope&#x27;, // 传入的参数</span><br><span class="line">        f: pointer to function f(),</span><br><span class="line">        scope: undefined, // 此时声明的变量为undefined</span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, [[Scope]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">          0: &#x27;scope&#x27;,</span><br><span class="line">          length: 1,</span><br><span class="line">        &#125;,</span><br><span class="line">        s: &#x27;scope&#x27;, // 传入的参数</span><br><span class="line">        f: pointer to function f(),</span><br><span class="line">        scope: &#x27;local scope&#x27;, // 变量赋值</span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, [[Scope]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h4 id="执行上下文的维护"><a href="#执行上下文的维护" class="headerlink" title="执行上下文的维护"></a>执行上下文的维护</h4><p>说在执行 JavaScript 时，可能会存在多个执行上下文，那么 JavaScript 引擎是如何管理这些执行上下文的呢？</p>
<p>答案是<strong>通过一种叫栈的数据结构来管理的</strong>。</p>
<p>JavaScript 引擎正是利用栈的这种结构来管理执行上下文的。在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为<strong>执行上下文栈，又称调用栈</strong>。</p>
<p>看如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = 2</span><br><span class="line">function add(b,c)&#123;</span><br><span class="line"> return b+c</span><br><span class="line">&#125; </span><br><span class="line">function addAll(b,c)&#123;</span><br><span class="line"> var d = 10</span><br><span class="line"> result = add(b,c)</span><br><span class="line"> return a+result+d</span><br><span class="line">&#125;</span><br><span class="line">addAll(3,6)</span><br></pre></td></tr></table></figure>

<p><strong>第一步，创建全局上下文，并将其压入栈底</strong>。</p>
<p><img src="/_posts/javascript/assets/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20210719153100763.png" alt="image-20210719153100763"></p>
<p><strong>第二步是调用 addAll 函数</strong>。当调用该函数时，JavaScript 引擎会编译该函数，并为其创建一个执行上下文，最后还将该函数的执行上下文压入栈中，如下图所示：</p>
<p><img src="/_posts/javascript/assets/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20210719153303513.png" alt="image-20210719153303513"></p>
<p><strong>第三步，当执行到 add 函数</strong>调用语句时，同样会为其创建执行上下文，并将其压入调用栈，如下图所示：</p>
<p><img src="/_posts/javascript/assets/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20210719153352832.png" alt="image-20210719153352832"></p>
<p>当 add 函数返回时，该函数的执行上下文就会从栈顶弹出，并将 result 的值设置为 add函数的返回值，也就是 9。如下图所示：</p>
<p><img src="/_posts/javascript/assets/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20210719153501404.png" alt="image-20210719153501404"></p>
<p>紧接着 addAll 执行最后一个相加操作后并返回，addAll 的执行上下文也会从栈顶部弹出，此时调用栈中就只剩下全局上下文了。最终如下图所示：</p>
<p><img src="/_posts/javascript/assets/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20210719153551914.png" alt="image-20210719153551914"></p>
<p>至此，整个 JavaScript 流程执行结束了。</p>
<blockquote>
<p>调用栈的跟踪可以借助chorme调试工具中的call stack 或者借助 console.trace()</p>
</blockquote>
<h4 id="解决变量提升的弊端"><a href="#解决变量提升的弊端" class="headerlink" title="解决变量提升的弊端"></a>解决变量提升的弊端</h4><p>ES6 通过 let const 解决了变量提升的问题，那么 ES6 又是如何在函数级作用域的基础之上，实现对块级作用域的支持呢？</p>
<p>变量对象应该包括 变量环境 和 词法环境</p>
<p>下面我们来看如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  var a = 1</span><br><span class="line">  let b = 2</span><br><span class="line">  &#123;</span><br><span class="line">    let b = 3</span><br><span class="line">    var c = 4</span><br><span class="line">    let d = 5</span><br><span class="line">    console.log(a)</span><br><span class="line">    console.log(b)</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(b)</span><br><span class="line">  console.log(c)</span><br><span class="line">  console.log(d)</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p><strong>第一步是编译并创建执行上下文</strong>，下面是我画出来的执行上下文示意图，你可以参考下：</p>
<p><img src="/_posts/javascript/assets/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20210719180147793.png" alt="image-20210719180147793"></p>
<p>通过上图，我们可以得出以下结论：</p>
<ul>
<li><p>函数内部通过 var 声明的变量，在编译阶段全都被存放到<strong>变量环境</strong>里面了。</p>
</li>
<li><p>通过 let 声明的变量，在编译阶段会被存放到<strong>词法环境（Lexical Environment）</strong>中。</p>
</li>
<li><p>在函数的作用域内部，通过 let 声明的变量并（<strong>暂时</strong>）没有被存放到词法环境中。</p>
</li>
</ul>
<p>接下来，<strong>第二步继续执行代码</strong>，当执行到代码块里面时，变量环境中 a 的值已经被设置成了 1，词法环境中 b 的值已经被设置成了 2，这时候函数的执行上下文就如下图所示：</p>
<p><img src="/_posts/javascript/assets/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20210719180806940.png" alt="image-20210719180806940"></p>
<p>​ 从图中可以看出，当进入函数的作用域块时，作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量，比如在作用域外面声明了变量 b，在该作用域块内部也声明了变量 b，当执行到作用域内部时，它们都是独立的存在。</p>
<p>​ 其实，<strong>在词法环境内部，维护了一个小型栈结构</strong>，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。需要注意下，我这里所讲的变量是指通过 let 或者 const 声明的变量。</p>
<p>​ 再接下来，当执行到作用域块中的console.log(a)这行代码时，就需要在词法环境和变量环境中查找变量 a 的值了，具体查找方式是：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，那么继续在变量环境中查找。</p>
<p><img src="/_posts/javascript/assets/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20210719181101068.png" alt="image-20210719181101068"></p>
<p>当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出，最终执行上下文</p>
<p>如下图所示：</p>
<p><img src="/_posts/javascript/assets/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20210719181919678.png" alt="image-20210719181919678"></p>
<p>通过上面的分析，想必你已经理解了词法环境的结构和工作机制，<strong>块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现</strong>，通过这两者的结合，JavaScript 引擎也就同时支持了变量提升和块级作用域了。</p>
<h4 id="查缺补漏–优秀blog文章"><a href="#查缺补漏–优秀blog文章" class="headerlink" title="查缺补漏–优秀blog文章"></a>查缺补漏–优秀blog文章</h4><ol>
<li><h4 id="JavaScript深入之执行上下文栈"><a href="#JavaScript深入之执行上下文栈" class="headerlink" title="JavaScript深入之执行上下文栈"></a><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/4">JavaScript深入之执行上下文栈</a></h4></li>
<li><h4 id="JavaScript深入之变量对象"><a href="#JavaScript深入之变量对象" class="headerlink" title="JavaScript深入之变量对象"></a><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/5">JavaScript深入之变量对象</a></h4></li>
<li><h4 id="JavaScript深入之作用域链"><a href="#JavaScript深入之作用域链" class="headerlink" title="JavaScript深入之作用域链"></a><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/6">JavaScript深入之作用域链</a></h4></li>
</ol>
<blockquote>
<p>该作者其余文章  <a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog">https://github.com/mqyqingfeng/Blog</a></p>
</blockquote>
<h4 id="Tips-为了防止链接失效，请看-深入执行上下文"><a href="#Tips-为了防止链接失效，请看-深入执行上下文" class="headerlink" title="Tips 为了防止链接失效，请看 深入执行上下文"></a>Tips 为了防止链接失效，请看 深入执行上下文</h4>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/html&css%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/html&css%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">11.html和css优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-16 00:00:00" itemprop="dateCreated datePublished" datetime="2021-07-16T00:00:00+08:00">2021-07-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-05 11:41:30" itemprop="dateModified" datetime="2022-03-05T11:41:30+08:00">2022-03-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">性能优化</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="html的优化"><a href="#html的优化" class="headerlink" title="html的优化"></a>html的优化</h3><ul>
<li>减少iframes的使用<ul>
<li>必须使用的时候 延迟加载，动态赋予src</li>
</ul>
</li>
<li>压缩空白符</li>
<li>避免节点深层次嵌套</li>
<li>避免使用table布局（已经没人用了）</li>
<li>删除注释</li>
<li>css&amp;js 尽量外链</li>
<li>删除元素默认属性</li>
<li>语义化标签</li>
</ul>
<h4 id="借用工具进行优化"><a href="#借用工具进行优化" class="headerlink" title="借用工具进行优化"></a>借用工具进行优化</h4><ul>
<li>html-minifier (webpack已经集成)</li>
</ul>
<h3 id="css优化"><a href="#css优化" class="headerlink" title="css优化"></a>css优化</h3><ul>
<li>降低css对渲染的阻塞</li>
<li>利用gpu完成动画绘制</li>
<li>使用contain属性<ul>
<li><a target="_blank" rel="noopener" href="https://www.webhek.com/post/css-contain-property.html">contain介绍</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/contain">MDN-contain</a></li>
</ul>
</li>
<li>使用font-display属性</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">字节和unicode</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-07 00:00:00" itemprop="dateCreated datePublished" datetime="2021-07-07T00:00:00+08:00">2021-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-11 14:51:13" itemprop="dateModified" datetime="2024-07-11T14:51:13+08:00">2024-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="位-bit-字节-Byte"><a href="#位-bit-字节-Byte" class="headerlink" title="位(bit) &amp; 字节(Byte)"></a>位(bit) &amp; 字节(Byte)</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7002088412903637022#heading-2">详细</a></p>
<h3 id="bit"><a href="#bit" class="headerlink" title="bit"></a>bit</h3><p>1位二进制数，也就是1bit，有2种可能，可以表示数0,1 <strong>也就是开关状态 是计算机的存储基础</strong></p>
<p>2位二进制数，2bit，有4种可能(2x2)，可以表示数0,1,2,3</p>
<p>3位二进制数,3bit，有8种可能(2x2x2)，可以表示数0,1,2,3,4,5,6,7</p>
<h3 id="Byte"><a href="#Byte" class="headerlink" title="Byte"></a>Byte</h3><p>大B，表示字节</p>
<p>1Byte &#x3D; 8 bit, 2^8是256，1个字节能表示的数就是0-255,共256种可能性。</p>
<h2 id="Unicode编码"><a href="#Unicode编码" class="headerlink" title="Unicode编码"></a>Unicode编码</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903590155272199#heading-3">摘抄</a></p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>​ Unicode（统一码、万国码、单一码）是计算机科学领域里的一项业界标准,包括字符集、编码方案等。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。</p>
<h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>UTF-8（<strong>8-bit Unicode Transformation Format</strong>）是一种针对Unicode的可变长度字符编码，又称万国码。UTF-8 <strong>用1到6个字节编码Unicode字符</strong>。用在网页上可以统一页面显示中文简体繁体及其它语言（如英文，日文，韩文）。</p>
<blockquote>
<p>UTF-8是一种非常通用的<strong>可变长</strong>字符编码方式</p>
<p>像UTF-8里面，ASCII所表示的字符集就是用1 Byte来表示，而大部分汉字则是用3 Byte来表示。</p>
</blockquote>
<h3 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><blockquote>
<p>UTF-16 Unicode字符编码五层次模型的第三层：字符编码表（Character Encoding Form，也称为 “storage format”）的一种实现方式。即把Unicode字符集的抽象码位映射为16位长的二进制整数（即码元， 长度为2 Byte）的序列，用于数据存储或传递。Unicode字符的码位，需要1个或者2个16位长的码元来表示，因此这是一个变长表示。</p>
</blockquote>
<p>引用维基百科中对于UTF-16编码的解释我们可以知道，UTF-16最少也会用2 Byte来表示一个字符，因此没有办法兼容ASCII编码（ASCII编码使用1 Byte来进行存储）。</p>
<h3 id="JS中的string"><a href="#JS中的string" class="headerlink" title="JS中的string"></a>JS中的string</h3><p>在JavaScript中，所有的string类型（或者被称为DOMString）都是使用UTF-16编码的。</p>
<p>因此，当我们需要转换成二进制与后端进行通信时，需要注意相关的编码方式。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">马农</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
