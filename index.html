<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"mst123.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="学习记录">
<meta property="og:type" content="website">
<meta property="og:title" content="博客">
<meta property="og:url" content="https://mst123.github.io/index.html">
<meta property="og:site_name" content="博客">
<meta property="og:description" content="学习记录">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="马农">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://mst123.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">博客</h1>
      <i class="logo-line"></i>
    </a>
      <img class="custom-logo-image" src="/images/gintama.jpg" alt="博客">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="马农"
      src="/images/luopo.gif">
  <p class="site-author-name" itemprop="name">马农</p>
  <div class="site-description" itemprop="description">学习记录</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">106</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">125</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/%E9%97%B2%E8%AE%B0/%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90%E7%9A%84%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E9%97%B2%E8%AE%B0/%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90%E7%9A%84%E5%A4%84%E7%90%86/" class="post-title-link" itemprop="url">图片资源的处理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-07-19 16:49:39 / 修改时间：17:20:27" itemprop="dateCreated datePublished" datetime="2024-07-19T16:49:39+08:00">2024-07-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%97%B2%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">闲记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p> 在写<code>md</code>文档的时候，不免插入一些图片，借助<code>typora</code>可以轻松的实现图片的插入，还可以设定文件夹，不过在<code>hexo</code>下只能存放在与<code>md</code>文档同名的文件夹下，特别混乱，尤其是借助<code>obsidan</code>浏览时。</p>
<p> 所有我就在文件夹下新增了一个<code>assets</code>文件夹，图片分类存放了进去，但是<code>hexo</code>无法处理，经常2天的研究终于搞定了。特记录如下：</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="确定版本"><a href="#确定版本" class="headerlink" title="确定版本"></a>确定版本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&quot;hexo&quot;: &quot;^7.3.0&quot;,</span><br><span class="line">&quot;hexo-deployer-git&quot;: &quot;^4.0.0&quot;,</span><br><span class="line">&quot;hexo-generator-archive&quot;: &quot;^2.0.0&quot;,</span><br><span class="line">&quot;hexo-generator-category&quot;: &quot;^2.0.0&quot;,</span><br><span class="line">&quot;hexo-generator-index&quot;: &quot;^4.0.0&quot;,</span><br><span class="line">&quot;hexo-generator-searchdb&quot;: &quot;^1.4.1&quot;,</span><br><span class="line">&quot;hexo-generator-tag&quot;: &quot;^2.0.0&quot;,</span><br><span class="line">&quot;hexo-renderer-ejs&quot;: &quot;^2.0.0&quot;,</span><br><span class="line">&quot;hexo-renderer-marked&quot;: &quot;^6.3.0&quot;,</span><br><span class="line">&quot;hexo-renderer-stylus&quot;: &quot;^3.0.1&quot;,</span><br><span class="line">&quot;hexo-server&quot;: &quot;^3.0.0&quot;,</span><br><span class="line">&quot;hexo-theme-landscape&quot;: &quot;^1.0.0&quot;,</span><br><span class="line">&quot;hexo-theme-next&quot;: &quot;^8.20.0&quot;</span><br></pre></td></tr></table></figure>

<h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h3><p>需要开启下面的配置</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认不会处理这类文件 需要配置下</span></span><br><span class="line"><span class="attr">include:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;**/assets/**&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="修改源码"><a href="#修改源码" class="headerlink" title="修改源码"></a>修改源码</h2><p>需要修改一个包的内容 <code>hexo-renderer-marked</code>，把<code>image</code>部分的处理修改一下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">image</span>(<span class="params">href, title, text</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; hexo, options &#125; = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">const</span> &#123; relative_link &#125; = hexo.<span class="property">config</span>;</span><br><span class="line">    <span class="keyword">const</span> &#123; lazyload, figcaption, prependRoot, postPath &#125; = options;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ============================== 以下代码有改动 ==============================</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="regexp">/^(#|\/\/|http(s)?:)/</span>.<span class="title function_">test</span>(href) &amp;&amp; !relative_link &amp;&amp; prependRoot) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!href.<span class="title function_">startsWith</span>(<span class="string">&#x27;/&#x27;</span>) &amp;&amp; !href.<span class="title function_">startsWith</span>(<span class="string">&#x27;\\&#x27;</span>) &amp;&amp; postPath) &#123;</span><br><span class="line">        <span class="keyword">let</span> destPath = <span class="title function_">join</span>(postPath, <span class="string">&#x27;../&#x27;</span>);</span><br><span class="line">        <span class="comment">// findById requires forward slash</span></span><br><span class="line">        destPath = destPath.<span class="title function_">replace</span>(<span class="string">&#x27;source/_posts&#x27;</span>, <span class="string">&#x27;/md-images&#x27;</span>)</span><br><span class="line">        href = <span class="title function_">join</span>(destPath, href.<span class="title function_">replace</span>(<span class="regexp">/\\/g</span>, <span class="string">&#x27;/&#x27;</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> out = <span class="string">`&lt;img src=&quot;<span class="subst">$&#123;encodeURL(href)&#125;</span>&quot;`</span>;</span><br><span class="line">    <span class="comment">// ============================== 以上代码有改动 ==============================</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (text) out += <span class="string">` alt=&quot;<span class="subst">$&#123;text&#125;</span>&quot;`</span>;</span><br><span class="line">    <span class="keyword">if</span> (title) out += <span class="string">` title=&quot;<span class="subst">$&#123;title&#125;</span>&quot;`</span>;</span><br><span class="line">    <span class="keyword">if</span> (lazyload) out += <span class="string">&#x27; loading=&quot;lazy&quot;&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">    out += <span class="string">&#x27;&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (figcaption) &#123;</span><br><span class="line">      <span class="keyword">if</span> (text) out += <span class="string">`&lt;figcaption aria-hidden=&quot;true&quot;&gt;<span class="subst">$&#123;text&#125;</span>&lt;/figcaption&gt;`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="md文档写法"><a href="#md文档写法" class="headerlink" title="md文档写法"></a>md文档写法</h2><p>文件组织形式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">摄像技术/</span><br><span class="line"> 摄影技术.md</span><br><span class="line"> 拍照技术.md</span><br><span class="line"> assets/</span><br><span class="line">  摄影技术/</span><br><span class="line">   1.png</span><br><span class="line">   2.png</span><br><span class="line">  拍照技术/</span><br><span class="line">   1.png</span><br></pre></td></tr></table></figure>

<p><code>md</code>文档的写法</p>
<p><code>!()[assets/拍照技术/1.png]</code></p>
<h2 id="部署流程"><a href="#部署流程" class="headerlink" title="部署流程"></a>部署流程</h2><p>todo 多了一步流程，以后优化掉吧</p>
<p><code>hexo build</code>之后，在<code>public</code>文件夹内找到<code>_post</code>文件夹（全是图片），重命名为<code>md-images</code>（与代码中的一致即可以）</p>
<p>执行 <code>hexo deploy</code> 就可以了</p>
<blockquote>
<p>为什么要多此一举重命名呢，因为<code>_post</code>文件夹推送上去，访问不到，我猜是github忽略了 <code>_</code>开头的文件</p>
</blockquote>
<h2 id="优化部署流程"><a href="#优化部署流程" class="headerlink" title="优化部署流程"></a>优化部署流程</h2><p>项目根目录新建一个<code>rename.js</code>帮助我们自动重命名</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> publicDir = path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;public&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> oldFolder = path.<span class="title function_">join</span>(publicDir, <span class="string">&#x27;_posts&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> newFolder = path.<span class="title function_">join</span>(publicDir, <span class="string">&#x27;md-images&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 _posts 文件夹是否存在</span></span><br><span class="line">fs.<span class="title function_">access</span>(oldFolder, fs.<span class="property">constants</span>.<span class="property">F_OK</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error: _posts folder does not exist.&#x27;</span>);</span><br><span class="line">    process.<span class="title function_">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 重命名文件夹</span></span><br><span class="line">    fs.<span class="title function_">rename</span>(oldFolder, newFolder, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error renaming folder:&#x27;</span>, err);</span><br><span class="line">        process.<span class="title function_">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Folder renamed successfully.&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>修改<code>package.json</code></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;hexo:generate&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo generate&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;rename&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node rename.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm run hexo:generate &amp;&amp; npm run rename&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;clean&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo clean&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;deploy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node deploy.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo server&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这样就可以在 <code>npm run build</code> 后，自动重命名了</p>
<h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><p>上去看一下，已经解决了问题，而且支持文章嵌套 ，让文章关系更加清晰，例如：vue分类下还有一个源码分析的分类。</p>
<p><img src="/md-images/markdown/assets/%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90%E7%9A%84%E5%A4%84%E7%90%86/image-20240719164530109.png" alt="image-20240719164530109"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">网络协议</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-18 14:45:21" itemprop="dateCreated datePublished" datetime="2024-07-18T14:45:21+08:00">2024-07-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-19 16:18:39" itemprop="dateModified" datetime="2024-07-19T16:18:39+08:00">2024-07-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="常见网页协议"><a href="#常见网页协议" class="headerlink" title="常见网页协议"></a>常见网页协议</h3><ul>
<li><strong>TCP&#x2F;IP</strong>  是互联网相关的各类协议族的总称</li>
<li><strong>IP</strong>（Internet Protocol）网际协议（<strong>网络层协议</strong>）IP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC 地址（Media Access Control Address）</li>
<li><strong>HTTP</strong> 超文本传输协议是一个用于传输超媒体文档（例如 HTML）的<strong>应用层协议</strong>。它是为 Web 浏览器与 Web 服务器之间的通信而设计的，但也可以用于其他目的</li>
<li><strong>TCP</strong>（Transmission Control Protocol，<strong>传输控制协议</strong>）是一种面向连接的、可靠的、基于字节流的<strong>传输层通信协议</strong></li>
<li><strong>UDP</strong>（User Data Protocol，<strong>用户数据报协议</strong>）一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上</li>
</ul>
<h3 id="TCP-IP-的分层管理"><a href="#TCP-IP-的分层管理" class="headerlink" title="TCP&#x2F;IP 的分层管理"></a><strong>TCP&#x2F;IP</strong> 的分层管理</h3><p><strong>利用 TCP&#x2F;IP 协议族进行网络通信时，会通过分层顺序与对方进行通信</strong></p>
<p><img src="/md-images/%E7%BD%91%E7%BB%9C/assets/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/image-20210714152647756.png" alt="image-20210714152647756"></p>
<p>这些层基本上被分为4层：</p>
<ul>
<li><p>应用层</p>
<ul>
<li>1、超文本传输协议（<strong>HTTP</strong>):万维网的基本协议</li>
<li>2、文件传输（<strong>FTP</strong>文件传输协议）；</li>
<li>3、远程登录（<strong>Telnet</strong>），提供远程访问其它主机功能, 它允许用户登录internet主机，并在这台主机上执行命令</li>
<li>4、网络管理（<strong>SNMP</strong>简单网络管理协议），该协议提供了监控网络设备的方法， 以及配置管理,统计信息收集,性能管理及安全管理等</li>
<li>5、域名系统（<strong>DNS</strong>），该系统用于在internet中将域名及其公共广播的网络节点转换成IP地址</li>
</ul>
</li>
<li><p>传输层</p>
<ul>
<li>1、<strong>TCP</strong></li>
<li>2、<strong>UDP</strong></li>
</ul>
</li>
<li><p>网络层</p>
<ul>
<li>1、Internet协议（IP）</li>
<li>2、Internet控制信息协议（ICMP）</li>
<li>3、地址解析协议（ARP）ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。</li>
<li>4、反向地址解析协议（RARP）</li>
</ul>
</li>
<li><p>链路层</p>
<p>用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。</p>
<blockquote>
<p>OSI 七层模型</p>
</blockquote>
<p><img src="/md-images/%E7%BD%91%E7%BB%9C/assets/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/6b87668471004dffbe71ee14b7bd8c8d~tplv-k3u1fbpfcp-watermark.gif" alt="img"></p>
<blockquote>
<p>附图 tcp段，IP分段 HTTP权威指南80页</p>
</blockquote>
<p><img src="/md-images/%E7%BD%91%E7%BB%9C/assets/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E5%85%AD%E7%AB%A0IP%E5%88%86%E7%BB%84.jpeg" alt="HTTP权威指南第六章IP分组"></p>
</li>
</ul>
<h3 id="TCP-IP-通信传输流"><a href="#TCP-IP-通信传输流" class="headerlink" title="TCP&#x2F;IP 通信传输流"></a><strong>TCP&#x2F;IP</strong> 通信传输流</h3><p> 利用 TCP&#x2F;IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。 发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。</p>
<p> 这种把数据信息包装起来的做法称为<strong>封装</strong>（encapsulate），如下图所示</p>
<p><img src="/md-images/%E7%BD%91%E7%BB%9C/assets/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/image-20210714153451934.png" alt="image-20210714153451934"></p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p><img src="/md-images/%E7%BD%91%E7%BB%9C/assets/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/170723f106ff0306~tplv-t2oaga2asx-watermark.gif" alt="img"></p>
<p> 头部至少20个字节</p>
<p>待整理</p>
<h4 id="TCP协议的特点"><a href="#TCP协议的特点" class="headerlink" title="TCP协议的特点"></a>TCP协议的特点</h4><h5 id="面向连接"><a href="#面向连接" class="headerlink" title="面向连接"></a>面向连接</h5><p>  面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</p>
<h5 id="仅支持单播传输"><a href="#仅支持单播传输" class="headerlink" title="仅支持单播传输"></a>仅支持单播传输</h5><p>  每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p>
<h5 id="面向字节流"><a href="#面向字节流" class="headerlink" title="面向字节流"></a>面向字节流</h5><p>  TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</p>
<h5 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h5><p>  对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的<strong>按序接收</strong>。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p>
<h5 id="提供拥塞控制"><a href="#提供拥塞控制" class="headerlink" title="提供拥塞控制"></a>提供拥塞控制</h5><p>  当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞</p>
<h5 id="TCP提供全双工通信"><a href="#TCP提供全双工通信" class="headerlink" title="TCP提供全双工通信"></a>TCP提供全双工通信</h5><p>  TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）</p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>  UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p>
<p>它有以下几个特点：</p>
<h4 id="1-面向无连接"><a href="#1-面向无连接" class="headerlink" title="1. 面向无连接"></a>1. 面向无连接</h4><p>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，<strong>不会对数据报文进行任何拆分和拼接操作</strong>。</p>
<p>具体来说就是：</p>
<ul>
<li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li>
<li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li>
</ul>
<h4 id="2-有单播，多播，广播的功能"><a href="#2-有单播，多播，广播的功能" class="headerlink" title="2. 有单播，多播，广播的功能"></a>2. 有单播，多播，广播的功能</h4><p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p>
<h4 id="3-UDP是面向报文的"><a href="#3-UDP是面向报文的" class="headerlink" title="3. UDP是面向报文的"></a>3. UDP是面向报文的</h4><p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p>
<h4 id="4-不可靠性"><a href="#4-不可靠性" class="headerlink" title="4. 不可靠性"></a>4. 不可靠性</h4><p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</p>
<p>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p>
<p>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p>
<p><img src="/md-images/%E7%BD%91%E7%BB%9C/assets/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/b20e3fe2fd2a486498a8683ff92fb69d~tplv-k3u1fbpfcp-watermark-20211220150615293.gif" alt="img"></p>
<p>从上面的动态图可以得知，UDP只会把想发的数据报文一股脑的丢给对方，并不在意数据有无安全完整到达。</p>
<h4 id="5-头部开销小，传输数据报文时是很高效的"><a href="#5-头部开销小，传输数据报文时是很高效的" class="headerlink" title="5. 头部开销小，传输数据报文时是很高效的"></a>5. 头部开销小，传输数据报文时是很高效的</h4><p><img src="/md-images/%E7%BD%91%E7%BB%9C/assets/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/49fcab711e4f43beb72f1b2d297bbf0f~tplv-k3u1fbpfcp-watermark-20211220150611420.gif" alt="img"></p>
<p>UDP 头部包含了以下几个数据：</p>
<ul>
<li>两个十六位的端口号，分别为源端口（可选字段）和目标端口 （4字节？）</li>
<li>整个数据报文的长度</li>
<li>整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误</li>
</ul>
<p><strong>因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的</strong></p>
<h3 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h3><table>
<thead>
<tr>
<th></th>
<th>UDP</th>
<th>TCP</th>
</tr>
</thead>
<tbody><tr>
<td>是否连接</td>
<td>无连接</td>
<td>面向连接</td>
</tr>
<tr>
<td>是否可靠</td>
<td>不可靠传输，不使用流量控制和拥塞控制</td>
<td>可靠传输，使用流量控制和拥塞控制</td>
</tr>
<tr>
<td>连接对象个数</td>
<td>支持一对一，一对多，多对一和多对多交互通信</td>
<td>只能是一对一通信</td>
</tr>
<tr>
<td>传输方式</td>
<td>面向报文</td>
<td>面向字节流</td>
</tr>
<tr>
<td>首部开销</td>
<td>首部开销小，仅8字节</td>
<td>首部最小20字节，最大60字节</td>
</tr>
<tr>
<td>适用场景</td>
<td>适用于实时应用（IP电话、视频会议、直播等）</td>
<td>适用于要求可靠传输的应用，例如文件传输</td>
</tr>
</tbody></table>
<h3 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h3><p>拥塞处理和流量控制不同，后者是作用于接收方，保证接收方来得及接受数据。而前者是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。</p>
<p>拥塞处理包括了四个算法，分别为：慢开始，拥塞避免，快速重传，快速恢复。</p>
<h4 id="慢开始算法"><a href="#慢开始算法" class="headerlink" title="慢开始算法"></a>慢开始算法</h4><p>慢开始算法，顾名思义，就是在传输开始时将发送窗口慢慢指数级扩大，从而避免一开始就传输大量数据导致网络拥塞。</p>
<p>慢开始算法步骤具体如下</p>
<ol>
<li>连接初始设置拥塞窗口（Congestion Window） 为 1 MSS（一个分段的最大数据量）</li>
<li>每过一个 RTT 就将窗口大小乘二</li>
<li>指数级增长肯定不能没有限制的，所以有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法。</li>
</ol>
<h4 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h4><p>拥塞避免算法相比简单点，每过一个 RTT 窗口大小只加一，这样能够避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值。</p>
<p>在传输过程中可能定时器超时的情况，这时候 TCP 会认为网络拥塞了，会马上进行以下步骤：</p>
<ul>
<li>将阈值设为当前拥塞窗口的一半</li>
<li>将拥塞窗口设为 1 MSS</li>
<li>启动拥塞避免算法</li>
</ul>
<h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>快速重传一般和快恢复一起出现。一旦接收端收到的报文出现失序的情况，接收端只会回复最后一个顺序正确的报文序号（没有 Sack 的情况下）。如果收到三个重复的 ACK，无需等待定时器超时再重发而是启动快速重传。具体算法分为两种：</p>
<p><strong>TCP Taho 实现如下</strong></p>
<ul>
<li>将阈值设为当前拥塞窗口的一半</li>
<li>将拥塞窗口设为 1 MSS</li>
<li>重新开始慢开始算法</li>
</ul>
<p><strong>TCP Reno 实现如下</strong></p>
<ul>
<li>拥塞窗口减半</li>
<li>将阈值设为当前拥塞窗口</li>
<li>进入快恢复阶段（重发对端需要的包，一旦收到一个新的 ACK 答复就退出该阶段）</li>
<li>使用拥塞避免算法</li>
</ul>
<h4 id="TCP-New-Ren-改进后的快恢复"><a href="#TCP-New-Ren-改进后的快恢复" class="headerlink" title="TCP New Ren 改进后的快恢复"></a>TCP New Ren 改进后的快恢复</h4><p><strong>TCP New Reno</strong> 算法改进了之前 <strong>TCP Reno</strong> 算法的缺陷。在之前，快恢复中只要收到一个新的 ACK 包，就会退出快恢复。</p>
<p>在 <strong>TCP New Reno</strong> 中，TCP 发送方先记下三个重复 ACK 的分段的最大序号。</p>
<p>假如我有一个分段数据是 1 ~ 10 这十个序号的报文，其中丢失了序号为 3 和 7 的报文，那么该分段的最大序号就是 10。发送端只会收到 ACK 序号为 3 的应答。这时候重发序号为 3 的报文，接收方顺利接收并会发送 ACK 序号为 7 的应答。这时候 TCP 知道对端是有多个包未收到，会继续发送序号为 7 的报文，接收方顺利接收并会发送 ACK 序号为 11 的应答，这时发送端认为这个分段接收端已经顺利接收，接下来会退出快恢复阶段。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/%E7%BD%91%E7%BB%9C/http%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E7%BD%91%E7%BB%9C/http%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2/" class="post-title-link" itemprop="url">HTTP的发展史</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-18 11:01:34" itemprop="dateCreated datePublished" datetime="2024-07-18T11:01:34+08:00">2024-07-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="http-0-9"><a href="#http-0-9" class="headerlink" title="http 0.9"></a>http 0.9</h3><p> HTTP&#x2F;0.9 是于 1991 年提出的，主要用于学术交流，需求很简单——用来在网络之间传递 HTML 超文本的内容，所以被称为<strong>超文本传输协议</strong></p>
<p> 总的来说，当时的需求很简单，就是用来传输体积很小的 HTML 文件，所以 HTTP&#x2F;0.9 的实现有以下三个特点。</p>
<ul>
<li><p>第一个是只有一个请求行，并没有<strong>HTTP 请求头和请求体</strong>，因为只需要一个请求行就可以完整表达客户端的需求了。</p>
</li>
<li><p>第二个是服务器也没有返回头信息，这是因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了。</p>
</li>
<li><p>第三个是返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输是最合适的。</p>
</li>
</ul>
<h3 id="http-1-0"><a href="#http-1-0" class="headerlink" title="http 1.0"></a>http 1.0</h3><p>万维网的高速发展带来了很多新的需求，而 HTTP&#x2F;0.9 已经不能适用新兴网络的发展，所以这时就需要一个新的协议来支撑新兴网络，这就是 HTTP&#x2F;1.0 诞生的原因。</p>
<ul>
<li>引入了请求头和响应头<ul>
<li>多类型数据</li>
<li>压缩方式</li>
<li>用户代理 user-agent</li>
</ul>
</li>
<li>引入了状态码</li>
<li>引入了cache机制</li>
</ul>
<h3 id="http-1-1"><a href="#http-1-1" class="headerlink" title="http 1.1"></a>http 1.1</h3><p>不过随着技术的继续发展，需求也在不断迭代更新，很快 HTTP&#x2F;1.0 也不能满足需求了，所以 HTTP&#x2F;1.1 又在 HTTP&#x2F;1.0 的基础之上做了大量的更新</p>
<ul>
<li><p><strong>改进持久连接</strong>（默认开启），<strong>它的特点是在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持</strong>。</p>
<blockquote>
<p>每个域名最多同时维护 6 个 TCP 持久连接</p>
</blockquote>
</li>
<li><p><strong>不成熟的 HTTP 管线化</strong>，如果 TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求，这就是著名的<strong>队头阻塞</strong>的问题</p>
<ul>
<li><p>HTTP&#x2F;1.1 中试图通过管线化的技术来解决<strong>队头阻塞</strong>的问题。HTTP&#x2F;1.1 中的管线化是指将多个 HTTP 请求整批提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。</p>
<blockquote>
<p>FireFox、Chrome 都做过管线化的试验，但是由于各种原因，它们最终都放弃了管线化技术。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>提供虚拟主机的支持</strong></p>
</li>
<li><p><strong>对动态生成的内容提供了完美支持</strong>，HTTP&#x2F;1.1 通过引入<strong>Chunk transfer 机制</strong>来解决这个问题，最后使用一个零长度的块作为发送数据完成的标志</p>
</li>
<li><p><strong>客户端 Cookie、安全机制</strong></p>
</li>
</ul>
<h3 id="http-2-0"><a href="#http-2-0" class="headerlink" title="http 2.0"></a>http 2.0</h3><h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a><strong>多路复用</strong></h4><p> 前面我们分析了 HTTP&#x2F;1.1 所存在的一些主要问题：慢启动和 TCP 连接之间相互竞争带宽是由于 TCP 本身的机制导致的，而队头阻塞是由于 HTTP&#x2F;1.1 的机制导致的。</p>
<p> HTTP&#x2F;2 的思路就是<strong>一个域名只使用一个 TCP 长连接来传输数据</strong>，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题</p>
<p> 另一个问题就是队头阻塞的问题，等待请求完成后才能去请求下一个资源，这种方式无疑是最慢的，所以 <strong>HTTP&#x2F;2 需要实现资源的并行请求</strong>，解决了<strong>应用层面的队头阻塞</strong>，也就是任何时候都可以将请求发送给服务器，而并不需要等待其他请求的完成，然后服务器也可以随时返回处理好的请求资源给浏览器</p>
<p><img src="/md-images/%E7%BD%91%E7%BB%9C/assets/http%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2/image-20210803172922718.png" alt="image-20210803172922718"></p>
<p><img src="/md-images/%E7%BD%91%E7%BB%9C/assets/http%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2/image-20210803173309562.png" alt="image-20210803173309562"></p>
<h4 id="http2分帧"><a href="#http2分帧" class="headerlink" title="http2分帧"></a>http2分帧</h4><p>帧是数据传输的最小单位，以二进制传输代替原本的明文传输，原本的报文消息被划分为更小的数据帧</p>
<h5 id="帧结构"><a href="#帧结构" class="headerlink" title="帧结构"></a>帧结构</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> +-----------------------------------------------+</span><br><span class="line"> |                 Length (24)                   |</span><br><span class="line"> +---------------+---------------+---------------+</span><br><span class="line"> |   Type (8)    |   Flags (8)   |</span><br><span class="line"> +-+-------------+---------------+-------------------------------+</span><br><span class="line"> |R|                 Stream Identifier (31)                      |</span><br><span class="line"> +=+=============================================================+</span><br><span class="line"> |                   Frame Payload (0...)                      ...</span><br><span class="line"> +---------------------------------------------------------------+</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>名称</th>
<th>长度</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Length</td>
<td>3 字节</td>
<td>表示帧负载的长度，取值范围为 （2 的 14 次方）至 （2 的 24 次方 - 1）。（2 的 14 次方） 16384 字节是默认的最大帧大小，如果需要更大的帧，必须在 SETTINGS 帧中设置</td>
</tr>
<tr>
<td>Type</td>
<td>1 字节</td>
<td>当前帧类型（见下表）</td>
</tr>
<tr>
<td>Flags</td>
<td>1 字节</td>
<td>具体帧类型的标识</td>
</tr>
<tr>
<td>R</td>
<td>1 位</td>
<td>保留位，不要设置，否则可能会带来严重的后果</td>
</tr>
<tr>
<td>Stream Identifier</td>
<td>31 位</td>
<td>每个流的唯一 ID</td>
</tr>
<tr>
<td>Frame Payload</td>
<td>长度可变</td>
<td>真实的帧内容，长度是在 Length 字段中设置的</td>
</tr>
</tbody></table>
<p>由于  HTTP&#x2F;2 是分帧的，请求和响应都可以多路复用，有助于解决类似类似队头阻塞的问题。</p>
<h5 id="帧类型"><a href="#帧类型" class="headerlink" title="帧类型"></a>帧类型</h5><table>
<thead>
<tr>
<th>名称</th>
<th>ID</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DATA</td>
<td>0x0</td>
<td>传输流的核心内容</td>
</tr>
<tr>
<td>HEADERS</td>
<td>0x1</td>
<td>包含 HTTP 首部，和可选的优先级参数</td>
</tr>
<tr>
<td>PRIORITY</td>
<td>0x2</td>
<td>指示或更改流的优先级和依赖</td>
</tr>
<tr>
<td>RST_STREAM</td>
<td>0x3</td>
<td>允许一端停止流（通常由于错误导致的）</td>
</tr>
<tr>
<td>SETTINGS</td>
<td>0x4</td>
<td>协商连接级参数</td>
</tr>
<tr>
<td>PUSH_PROMISE</td>
<td>0x5</td>
<td>提示客户端，服务器要推送些东西</td>
</tr>
<tr>
<td>PING</td>
<td>0x6</td>
<td>测试连接可用性和往返时延（RTT）</td>
</tr>
<tr>
<td>GOAWAY</td>
<td>0x7</td>
<td>告诉另一端，当前的端已结束</td>
</tr>
<tr>
<td>WINDOW_UPDATE</td>
<td>0x8</td>
<td>协商一端将要接收多少字节（用于流量控制）</td>
</tr>
<tr>
<td>CONTINUATION</td>
<td>0x9</td>
<td>用以扩展 HEADERS 模块</td>
</tr>
</tbody></table>
<h4 id="HTTP-2-其他特性"><a href="#HTTP-2-其他特性" class="headerlink" title="HTTP&#x2F;2 其他特性"></a><strong>HTTP&#x2F;2</strong> <strong>其他特性</strong></h4><ul>
<li>可以设置请求优先级</li>
<li>服务器推送</li>
<li>头部压缩</li>
</ul>
<h3 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h3><h4 id="应用层面"><a href="#应用层面" class="headerlink" title="应用层面"></a>应用层面</h4><p>在 <strong>HTTP&#x2F;1.1</strong> 中使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。</p>
<p>http 2通过对请求和响应进行编号的方式，实现资源并行请求解决了这个问题</p>
<h4 id="TCP层面"><a href="#TCP层面" class="headerlink" title="TCP层面"></a>TCP层面</h4><h5 id="http-1-1-1"><a href="#http-1-1-1" class="headerlink" title="http 1.1"></a>http 1.1</h5><p><img src="/md-images/%E7%BD%91%E7%BB%9C/assets/http%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2/image-20210805145222668.png" alt="image-20210805145222668"></p>
<p>通过上图你会发现，从一端发送给另外一端的数据会被拆分为一个个按照顺序排列的数据包，这些数据包通过网络传输到了接收端，接收端再按照顺序将这些数据包组合成原始数据，这样就完成了数据传输。</p>
<p>不过，如果在数据传输的过程中，有一个数据因为网络故障或者其他原因而丢包了，那么整个 TCP 的连接就会处于暂停状态，需要等待丢失的数据包被重新传输过来。你可以把 TCP连接看成是一个按照顺序传输数据的管道，管道中的任意一个数据丢失了，那之后的数据都需要等待该数据的重新传输。为了直观理解，你可以参考下图：</p>
<p><img src="/md-images/%E7%BD%91%E7%BB%9C/assets/http%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2/image-20210805145256682.png" alt="image-20210805145256682"></p>
<p>我们就把<strong>在 TCP 传输过程中，由于单个数据包的丢失而造成的阻塞称为 TCP 上的队头阻塞</strong>。</p>
<h5 id="http-2-0-1"><a href="#http-2-0-1" class="headerlink" title="http 2.0"></a>http 2.0</h5><p>那队头阻塞是怎么影响 HTTP&#x2F;2 传输的呢？首先我们来看正常情况下 HTTP&#x2F;2 是怎么传输多路请求的，为了直观理解，你可以参考下图：</p>
<p><img src="/md-images/%E7%BD%91%E7%BB%9C/assets/http%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2/image-20230216173807167.png" alt="image-20230216173807167"></p>
<p><strong>通过该图，我们知道在 HTTP&#x2F;2 中，多个请求是跑在一个 TCP 管道中的，如果其中任意一路数据流中出现了丢包的情况，那么就会阻塞该 TCP 连接中的所有请求。这不同于HTTP&#x2F;1.1，使用 HTTP&#x2F;1.1 时，浏览器为每个域名开启了 6 个 TCP 连接，如果其中的 1个 TCP 连接发生了队头阻塞，那么其他的 5 个连接依然可以继续传输数据。</strong></p>
<p>所以随着丢包率的增加，HTTP&#x2F;2 的传输效率也会越来越差。有测试数据表明，当系统达到了 2% 的丢包率时，HTTP&#x2F;1.1 的传输效率反而比 HTTP&#x2F;2 表现得更好。</p>
<p>HTTP&#x2F;2 是通过分帧并且给每个帧打上流的 ID 去避免依次响应的问题，对方接收到帧之后根据 ID 拼接出流，这样就可以做到乱序响应从而避免请求时的队首阻塞问题。但是 TCP 层面的队首阻塞是 HTTP&#x2F;2 无法解决的（HTTP 只是应用层协议，TCP 是传输层协议），<strong>TCP 的阻塞问题是因为传输阶段可能会丢包，一旦丢包就会等待重新发包，阻塞后续传输，这个问题虽然有滑动窗口（Sliding Window）这个方案，但是只能增强抗干扰，并没有彻底解决。</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">浏览器原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-17 14:26:57" itemprop="dateCreated datePublished" datetime="2024-07-17T14:26:57+08:00">2024-07-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">浏览器原理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="chrome架构"><a href="#chrome架构" class="headerlink" title="chrome架构"></a>chrome架构</h2><p>打开一个chrome网页，如图所示会出现很多线程</p>
<p><img src="/md-images/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/image-20210712221958756.png" alt="image-20210712221958756"></p>
<p>首先需要讲解一下 进程和线程</p>
<h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><ul>
<li><strong>一个进程就是一个程序的运行实例</strong></li>
<li><strong>线程是不能单独存在的，它是由进程来启动和管理的</strong></li>
<li><strong>线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率</strong></li>
</ul>
<p><img src="/md-images/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/image-20210712222146731.png" alt="image-20210712222146731"></p>
<p>总结来说，进程和线程之间的关系有以下 4 个特点。</p>
<ul>
<li><strong>1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。</strong></li>
<li><strong>2. 线程之间共享进程中的数据。</strong></li>
<li><strong>3. 当一个进程关闭之后，操作系统会回收进程所占用的内存(包括泄漏的内存)。</strong></li>
<li><strong>4. 进程之间的内容相互隔离。(通信依靠IPC进程间通信)</strong></li>
</ul>
<h3 id="浏览器架构发展史"><a href="#浏览器架构发展史" class="headerlink" title="浏览器架构发展史"></a>浏览器架构发展史</h3><h4 id="单进程浏览器"><a href="#单进程浏览器" class="headerlink" title="单进程浏览器"></a>单进程浏览器</h4><p><strong>单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里</strong></p>
<p><img src="/md-images/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/image-20210712222743496.png" alt="image-20210712222743496"></p>
<p>缺点很明显</p>
<ul>
<li><p>不稳定</p>
<p>一个插件的意外崩溃会引起整个浏览器的崩溃，除了插件之外，<strong>渲染引擎模块（复杂代码）</strong>也是不稳定的</p>
</li>
<li><p>不流畅</p>
<p>所有页面的渲染模块、JavaScript 执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行</p>
</li>
<li><p>不安全</p>
<p>插件可以使用c++编写，可以轻易访问操作系统</p>
</li>
</ul>
<h4 id="多进程浏览器"><a href="#多进程浏览器" class="headerlink" title="多进程浏览器"></a>多进程浏览器</h4><p>多进程浏览器<strong>解决了</strong>单进程浏览器的几个问题</p>
<ul>
<li>不稳定：由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面</li>
<li>不流畅：每个tab页均有一个渲染进程，JavaScript 也是运行在渲染进程中的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染页面</li>
<li>不安全：安全沙箱，Chrome 把插件进程和渲染进程锁在沙箱里面</li>
</ul>
<p>多进程浏览器也会有一些问题</p>
<ul>
<li><p><strong>更高的资源占用：</strong>因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环</p>
<p>境），这就意味着浏览器会消耗更多的内存资源。</p>
</li>
<li><p><strong>更复杂的体系架构：</strong>浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已</p>
<p>经很难适应新的需求了。</p>
</li>
</ul>
<p>多进程浏览器包括（浏览器架构持续优化中，仅供参考）:<br><img src="/md-images/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/image-20210712223130924.png" alt="image-20210712223130924"></p>
<ul>
<li><p><strong>浏览器进程</strong>。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</p>
</li>
<li><p><em><strong>渲染进程</strong></em>。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中。默认情况下，<strong>Chrome 会为每个 Tab 标签创建一个渲染进程</strong>。出于安全考虑，渲染进程都是运行在沙箱模式下。</p>
<ul>
<li>主线程（<strong>也就是我们常说的js单线程</strong>）<ul>
<li>渲染事件（如解析 DOM、计算布局、绘制）</li>
<li>用户交互事件（如鼠标点击、滚动页面、放大缩小等）</li>
<li>JavaScript 脚本执行事件</li>
<li>网络请求完成、文件读写完成事件</li>
<li>垃圾回收</li>
<li>等等</li>
</ul>
</li>
<li>合成线程(动画优化)</li>
<li>光栅化线程池</li>
<li>IO 线程</li>
</ul>
</li>
<li><p><strong>GPU 进程</strong></p>
</li>
<li><p><strong>网络进程</strong></p>
</li>
<li><p><strong>插件进程</strong></p>
</li>
</ul>
<h2 id="从输入URL到页面展示，这中间发生了什么"><a href="#从输入URL到页面展示，这中间发生了什么" class="headerlink" title="从输入URL到页面展示，这中间发生了什么"></a>从输入URL到页面展示，这中间发生了什么</h2><p><img src="/md-images/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/image-20210714180345180.png" alt="image-20210714180345180"></p>
<p>从图中可以看出，<strong>整个过程需要各个进程之间的配合</strong>，首先介绍一下各进程的主要职责</p>
<ul>
<li><p>浏览器进程主要负责用户交互、子进程管理和文件储存等功能。</p>
</li>
<li><p>网络进程是面向渲染进程和浏览器进程等提供网络下载功能。</p>
</li>
<li><p>渲染进程的主要职责是把从网络下载的 HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。</p>
</li>
</ul>
<h3 id="渲染流程之前的流程"><a href="#渲染流程之前的流程" class="headerlink" title="渲染流程之前的流程"></a>渲染流程之前的流程</h3><p> 这个过程可以大致描述为如下。</p>
<ul>
<li><p>首先，浏览器进程接收到用户输入的 URL 请求，浏览器进程便将该 URL 转发给网络进程。然后，在网络进程中发起真正的 URL 请求。</p>
</li>
<li><p>接着网络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程。</p>
</li>
<li><p>浏览器进程接收到网络进程的响应头数据之后，发送“提交导航 (CommitNavigation)”消息到渲染进程；</p>
</li>
<li><p>渲染进程接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立数据管道；</p>
</li>
<li><p>最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程：“已经准备好接受和解析页面数据了”。</p>
</li>
<li><p>浏览器进程接收到渲染进程“提交文档”的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态。</p>
</li>
</ul>
<h3 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h3><p>美团文章的图</p>
<p><img src="/md-images/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/1671b9d4d735398e~tplv-t2oaga2asx-watermark-20220303151906096.gif" alt="img"></p>
<p> 按照渲染的时间顺序，流水线可分为如下几个子阶段：</p>
<h4 id="构建-DOM-树"><a href="#构建-DOM-树" class="headerlink" title="构建 DOM 树"></a>构建 DOM 树</h4><p><img src="/md-images/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/image-20210715143236150.png" alt="image-20210715143236150"></p>
<p> 构建 DOM 树的<strong>输入内容</strong>是一个非常简单的 HTML 文件，然后经由HTML 解析器解析，最终输出树状结构的 DOM</p>
<h4 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h4><p> 样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成：</p>
<ol>
<li><p>把CSS转换为浏览器能够理解的结构</p>
<blockquote>
<p>和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以<strong>当渲染引擎接</strong></p>
<p><strong>收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——</strong></p>
<p><strong>styleSheets</strong>。</p>
</blockquote>
</li>
<li><p>转换样式表中的属性值，使其标准化</p>
<p><img src="/md-images/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/image-20210715143850698.png" alt="image-20210715143850698"></p>
<blockquote>
<p><strong>需要将所有值转换为渲染引擎容易理解的、标准化的计算值</strong></p>
</blockquote>
</li>
<li><p>计算出 DOM 树中每个节点的具体样式</p>
</li>
</ol>
<h4 id="布局阶段"><a href="#布局阶段" class="headerlink" title="布局阶段"></a>布局阶段</h4><p> 我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。<strong>那么接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局</strong>。</p>
<p>​    Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。</p>
<h5 id="创建布局树"><a href="#创建布局树" class="headerlink" title="创建布局树"></a>创建布局树</h5><p> 在显示之前，我们还要额外地构建一棵只包含可见元素布局树。</p>
<p><img src="/md-images/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/image-20210715165934972.png" alt="image-20210715165934972"></p>
<h5 id="布局计算"><a href="#布局计算" class="headerlink" title="布局计算"></a>布局计算</h5><p> <strong>在执行布局操作的时候，会把布局运算的结果重新写回布局树中</strong>，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方</p>
<blockquote>
<p>所以在调试台中 经常看到layout之后 在再次update layer tree</p>
<p><img src="/md-images/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/image-20211223095237296.png" alt="image-20211223095237296"></p>
</blockquote>
<h4 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h4><p> 渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的<strong>图层树（LayerTree）</strong></p>
<p><img src="/md-images/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/image-20210715170447195.png" alt="image-20210715170447195"></p>
<p> 那么需要满足什么条件，渲染引擎才会为特定的节点创建新的层呢？</p>
<ul>
<li><p>拥有<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context">层叠上下文</a>属性的元素会被提升为单独的一层</p>
</li>
<li><p>需要剪裁（clip）的地方也会被创建为图层</p>
<blockquote>
<p>层叠上下文在css中也是一个很重要的概念，在blog中也有一些相关文章</p>
</blockquote>
</li>
</ul>
<h4 id="图层绘制"><a href="#图层绘制" class="headerlink" title="图层绘制"></a>图层绘制</h4><h5 id="分析出绘制列表"><a href="#分析出绘制列表" class="headerlink" title="分析出绘制列表"></a>分析出绘制列表</h5><p> 在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制。渲染引擎会把一个图层的绘制拆分成很多小的<strong>绘制指令</strong>，然后再把这些指令按照顺序组成一个待绘制列表，如下图所示：</p>
<p><img src="/md-images/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/image-20210715172527999.png" alt="image-20210715172527TCP协议的特点999"></p>
<p> 绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的<strong>合成线程</strong>来完成的。当图层的绘制列表准备好之后，主线程会把该绘制列表<strong>提交（commit）</strong>给合成线程</p>
<h5 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h5><p> 通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做<strong>视口</strong>（viewport）。通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。</p>
<p> 基于这个原因，<strong>合成线程会将图层划分为图块（tile）</strong>，这些图块的大小通常是 <strong>256x256</strong> 或者 <strong>512x512</strong></p>
<h5 id="光栅化raster"><a href="#光栅化raster" class="headerlink" title="光栅化raster"></a>光栅化raster</h5><p> 合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓<strong>栅格化，是指将图块转换为位图</strong>。</p>
<p> 而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的</p>
<p><img src="/md-images/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/image-20210715173725392.png" alt="image-20210715173725392"></p>
<h5 id="合成和显示"><a href="#合成和显示" class="headerlink" title="合成和显示"></a>合成和显示</h5><p> 一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</p>
<p> 浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p>
<h4 id="渲染流水线大总结"><a href="#渲染流水线大总结" class="headerlink" title="渲染流水线大总结"></a>渲染流水线大总结</h4><p><img src="/md-images/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/image-20210715173820255.png" alt="image-20210715173820255"></p>
<p>结合上图，一个完整的渲染流程大致可总结为如下：</p>
<ul>
<li>渲染进程将 HTML 内容转换为能够读懂的<strong>DOM 树</strong>结构。</li>
<li>渲染引擎将 CSS 样式表转化为浏览器可以理解的<strong>styleSheets</strong>，计算出 DOM 节点的样式。</li>
<li>创建<strong>布局树</strong>，并计算元素的布局信息。</li>
<li>计算结果<strong>重新写入布局树</strong>（我觉得这一步挺重要）</li>
<li>对布局树进行分层，并生成<strong>分层树</strong>。</li>
<li>为每个图层生成<strong>绘制列表</strong>，并将其提交到合成线程。</li>
<li>合成线程将图层分成<strong>图块</strong>，并在<strong>光栅化线程池</strong>中将图块转换成位图。</li>
<li>合成线程发送绘制图块命令<strong>DrawQuad</strong>给浏览器进程。</li>
<li>浏览器进程根据 DrawQuad 消息<strong>生成页面</strong>，并<strong>显示</strong>到显示器上。</li>
</ul>
<h3 id="css和js对dom解析渲染的影响"><a href="#css和js对dom解析渲染的影响" class="headerlink" title="css和js对dom解析渲染的影响"></a>css和js对dom解析渲染的影响</h3><p>直接说结论</p>
<ul>
<li><p>css不会阻塞DOM的解析(<strong>document中已存在，只是没有渲染在屏幕上</strong>)，但会阻塞其渲染</p>
<blockquote>
<p>样式树 和 dom树 共同决定渲染树，两者可以并行解析，但是dom树必须等样式树解析后才可以合成</p>
</blockquote>
</li>
<li><p>css会阻塞后面JS的的执行</p>
<blockquote>
<p>因为js有修改cssom的能力</p>
</blockquote>
</li>
<li><p>JS会阻塞DOM解析和渲染</p>
<blockquote>
<p>js有修改dom的能力</p>
</blockquote>
</li>
</ul>
<h3 id="减少白屏时间"><a href="#减少白屏时间" class="headerlink" title="减少白屏时间"></a>减少白屏时间</h3><p> 如果白屏时间过久，就会影响到用户体验。</p>
<p> 为了缩短白屏时间，我们来挨个分析这个阶段的主要任务，包括了<strong>解析 HTML、下载 CSS、下载 JavaScript、生成 CSSOM、执行 JavaScript、生成布局树、绘制页面</strong>一系列操作。</p>
<p> 通常情况下的瓶颈主要体现在<strong>下载 CSS 文件、下载 JavaScript 文件和执行 JavaScript</strong>。</p>
<p> 所以要想缩短白屏时长，可以有以下策略：</p>
<ul>
<li>通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。</li>
<li>但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。</li>
<li>还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 async 或者 defer。</li>
<li>对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。</li>
<li>骨架屏和loading css</li>
</ul>
<h3 id="回流、重绘、合成"><a href="#回流、重绘、合成" class="headerlink" title="回流、重绘、合成"></a>回流、重绘、合成</h3><p>需要补充</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904083212468238#heading-12">回流重绘</a></p>
<h2 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h2><p>浏览器安全可以分为三大块——<strong>Web 页面安全、浏览器网络安全</strong>和<strong>浏览器系统安全</strong></p>
<h3 id="web页面安全"><a href="#web页面安全" class="headerlink" title="web页面安全"></a>web页面安全</h3><p>在没有安全保障的 Web 世界中，我们是没有隐私的，因此需要安全策略来保障我们的隐私和数据的安全。</p>
<h4 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h4><p>在页面中最基础、最核心的安全策略：**<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">同源策略</a>（Same-origin policy），<strong>如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源，两个不同的源之间若想要</strong>相互访问资源或者操作 DOM**，那么会有一套基础的安全策略的制约，我们把这称为同源策略。</p>
<p>下表给出了与 URL <code>http://store.company.com/dir/page.html</code> 的源进行对比的示例:</p>
<p><img src="/md-images/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/image-20210805172753684.png" alt="image-20210805172753684"></p>
<p>具体来讲，同源策略主要表现在 DOM、Web 数据和网络这三个层面：</p>
<ul>
<li><p><strong>DOM 层面</strong>。同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。</p>
</li>
<li><p><strong>数据层面</strong>。同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据</p>
</li>
<li><p><strong>网络层面</strong>。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点</p>
</li>
</ul>
<h4 id="安全和便利性的权衡"><a href="#安全和便利性的权衡" class="headerlink" title="安全和便利性的权衡"></a><strong>安全和便利性的权衡</strong></h4><p> 安全性和便利性是相互对立的，让不同的源之间绝对隔离，无疑是最安全的措施，但这也会使得 Web 项目难以开发和使用，因此浏览器就要在这之间做出权衡，出让一些安全性来满足灵活性：</p>
<ul>
<li><strong>页面中可以嵌入第三方资源</strong></li>
<li><strong>跨域资源共享和跨文档消息机制</strong><ul>
<li><strong>跨域资源共享（CORS）</strong></li>
<li><strong>跨文档消息机制</strong> <strong>postMessage</strong></li>
</ul>
</li>
</ul>
<h4 id="xss-csrf"><a href="#xss-csrf" class="headerlink" title="xss csrf"></a>xss csrf</h4><p>在前端安全中有详细介绍</p>
<p><a href="/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8">前端安全</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/%E9%9D%A2%E8%AF%95/selfFuc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E9%9D%A2%E8%AF%95/selfFuc/" class="post-title-link" itemprop="url">常用手写函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-16 14:02:12" itemprop="dateCreated datePublished" datetime="2024-07-16T14:02:12+08:00">2024-07-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="call函数"><a href="#call函数" class="headerlink" title="call函数"></a>call函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.selfCall = function(context) &#123;</span><br><span class="line">  const ctx = context || window;</span><br><span class="line">  // 去除第一个参数</span><br><span class="line">  const arg = [...arguments].slice(1);</span><br><span class="line">  // const arg = Array.slice.call(arguments, 1);</span><br><span class="line">  // 将函数赋值给ctx.fnc </span><br><span class="line">  ctx.fnc = this;</span><br><span class="line">  // 执行函数</span><br><span class="line">  const res = ctx.fnc(...arg);</span><br><span class="line">  Reflect.deleteProperty(ctx, &quot;fnc&quot;)</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法借用了很多ES6的方法，让我们看一下比较原始的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.call2 = function (context) &#123;</span><br><span class="line">    var context = context || window;</span><br><span class="line">    context.fn = this;</span><br><span class="line"></span><br><span class="line">    var args = [];</span><br><span class="line">    for(var i = 1, len = arguments.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(&#x27;arguments[&#x27; + i + &#x27;]&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var result = eval(&#x27;context.fn(&#x27; + args +&#x27;)&#x27;);</span><br><span class="line"></span><br><span class="line">    delete context.fn</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="apply函数"><a href="#apply函数" class="headerlink" title="apply函数"></a>apply函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.selfApply = function (context) &#123;</span><br><span class="line">  const ctx = context || window;</span><br><span class="line">  ctx.fnc = this;</span><br><span class="line">  const arg = [...arguments].slice(1)[0];</span><br><span class="line">  // const arg = Array.slice.call(arguments, 1)[0];</span><br><span class="line">  const res = ctx.fnc(...arg)</span><br><span class="line">  Reflect.deleteProperty(ctx, &quot;fnc&quot;)</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不借用ES6</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.apply = function (context, arr) &#123;</span><br><span class="line">    var context = Object(context) || window;</span><br><span class="line">    context.fn = this;</span><br><span class="line"></span><br><span class="line">    var result;</span><br><span class="line">    if (!arr) &#123;</span><br><span class="line">        result = context.fn();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        var args = [];</span><br><span class="line">        for (var i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">            args.push(&#x27;arr[&#x27; + i + &#x27;]&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        result = eval(&#x27;context.fn(&#x27; + args + &#x27;)&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete context.fn</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于 Object(context) 原文是这么说的：</p>
<p>非严格模式下，指定为 null 或 undefined 时会自动指向全局对象，郑航写的是严格模式下的，我写的是非严格模式下的，实际上现在的模拟代码有一点没有覆盖，就是当值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。</p>
</blockquote>
<h2 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h2><ul>
<li>首先书写了一个简单的bind函数，并不包括 new 操作</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myBind = function (ctx) &#123;</span><br><span class="line">  const args = [...arguments].slice(1)</span><br><span class="line">  const self = this</span><br><span class="line">  return function () &#123;</span><br><span class="line">    return self.apply(ctx, [...args, ...arguments])   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数效果的模拟实现 &#x2F;&#x2F; TODO</p>
<h2 id="new-操作符"><a href="#new-操作符" class="headerlink" title="new 操作符"></a>new 操作符</h2><p>首先分析一下 new 操作符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Student(name, age) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.age = age</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.say = function () &#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">var jojo = new Student(&quot;jsd&quot;, 23);</span><br></pre></td></tr></table></figure>

<p>从结果分析</p>
<ul>
<li>返回了一个对象，其实例属性是通过构造函数(Student)生成的</li>
<li>对象的<code>__proto__</code>指向Student.prototype</li>
<li>创建一个空对象obj（{}）</li>
<li>将obj的<code>[[prototype]]</code>属性指向构造函数constrc的原型（即<code>obj.[[prototype]]</code> &#x3D; constrc.prototype）。</li>
<li>将构造函数constrc内部的this绑定到新建的对象obj，执行constrc（也就是跟调用普通函数一样，只是此时函数的this为新创建的对象obj而已，就好像执行obj.constrc()一样）；</li>
<li>若构造函数没有返回非原始值（即不是引用类型的值），则返回该新建的对象obj（默认会添加return this）。否则，返回引用类型的值。</li>
</ul>
<p>官方解释</p>
<ul>
<li>创建一个空的简单JavaScript对象（即{}）；</li>
<li>链接该对象（设置该对象的constructor）到另一个对象 ；</li>
<li>将步骤1新创建的对象作为this的上下文 ；</li>
<li>如果该函数没有返回对象，则返回this。<br>实现方式如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function createClass(_Class, ...rest) &#123;</span><br><span class="line">  const obj = &#123;&#125;</span><br><span class="line">  const res = _Class.apply(obj, rest)</span><br><span class="line">  obj.__proto__ = _Class.prototype</span><br><span class="line">  return typeof res === &quot;object&quot; ? res : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用Object.create稍微简化一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function newFactorSimple(ctor) &#123;</span><br><span class="line">  const arg = [...arguments].slice(1);</span><br><span class="line">  // 生成一个__proto__指向ctor.prototype的对象</span><br><span class="line">  var obj = Object.create(ctor.prototype);</span><br><span class="line">  ctor.call(obj, ...arg);</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实构造函数内含有return语句时，结果会出现差异</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 例子4</span><br><span class="line">function Student(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    // Null（空） null</span><br><span class="line">    // Undefined（未定义） undefined</span><br><span class="line">    // Number（数字） 1</span><br><span class="line">    // String（字符串）&#x27;1&#x27;</span><br><span class="line">    // Boolean（布尔） true</span><br><span class="line">    // Symbol（符号）（第六版新增） symbol</span><br><span class="line">    </span><br><span class="line">    // Object（对象） &#123;&#125;</span><br><span class="line">        // Function（函数） function()&#123;&#125;</span><br><span class="line">        // Array（数组） []</span><br><span class="line">        // Date（日期） new Date()</span><br><span class="line">        // RegExp（正则表达式）/a/</span><br><span class="line">        // Error （错误） new Error() </span><br><span class="line">    // return /a/;</span><br><span class="line">&#125;</span><br><span class="line">var student = new Student(&#x27;若川&#x27;);</span><br><span class="line">console.log(student); &#123;name: &#x27;若川&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p>前面六种基本类型都会正常返回{name: ‘若川’}，后面的Object(包含Functoin, Array, Date, RegExg, Error)都会直接返回这些值<br><strong>下面是考虑到各种情况后的new实现</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 模拟实现 new 操作符</span><br><span class="line"> * @param  &#123;Function&#125; ctor [构造函数]</span><br><span class="line"> * @return &#123;Object|Function|Regex|Date|Error&#125;      [返回结果]</span><br><span class="line"> */</span><br><span class="line">function newOperator(ctor)&#123;</span><br><span class="line">    if(typeof ctor !== &#x27;function&#x27;)&#123;</span><br><span class="line">      throw &#x27;newOperator function the first param must be a function&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    // ES6 new.target 是指向构造函数</span><br><span class="line">    newOperator.target = ctor;</span><br><span class="line">    var newObj = Object.create(ctor.prototype);</span><br><span class="line">    // ES5 arguments转成数组 当然也可以用ES6 [...arguments], Aarry.from(arguments);</span><br><span class="line">    // 除去ctor构造函数的其余参数</span><br><span class="line">    var argsArr = [].slice.call(arguments, 1);</span><br><span class="line">    // 3.生成的新对象会绑定到函数调用的`this`。</span><br><span class="line">    // 获取到ctor函数返回结果</span><br><span class="line">    var ctorReturnResult = ctor.apply(newObj, argsArr);</span><br><span class="line">    // 小结4 中这些类型中合并起来只有Object和Function两种类型 typeof null 也是&#x27;object&#x27;所以要不等于null，排除null</span><br><span class="line">    var isObject = typeof ctorReturnResult === &#x27;object&#x27; &amp;&amp; ctorReturnResult !== null;</span><br><span class="line">    var isFunction = typeof ctorReturnResult === &#x27;function&#x27;;</span><br><span class="line">    if(isObject || isFunction)&#123;</span><br><span class="line">      return ctorReturnResult;</span><br><span class="line">    &#125;</span><br><span class="line">    // 5.如果函数没有返回对象类型`Object`(包含`Functoin`, `Array`, `Date`, `RegExg`, `Error`)，那么`new`表达式中的函数调用会自动返回这个新的对象。</span><br><span class="line">    return newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="create函数"><a href="#create函数" class="headerlink" title="create函数"></a>create函数</h2><p>很多框架源码作者使用它来初始化一个新的对象，难道是最佳实践？<br>原因有二  </p>
<ul>
<li>通过Object.create(null)创建出来的对象，没有任何属性，显示No properties。我们可以将其当成一个干净的 map 来使用，自主定义 toString,hasOwnProperty等方法，并且不必担心将原型链上的同名方法被覆盖。</li>
<li>{…}创建的对象，使用for in遍历对象的时候，会遍历原型链上的属性，带来性能上的损耗。使用Object.create(null)则不必再对其进行遍历了。<br><img src="/md-images/%E9%9D%A2%E8%AF%95/assets/selfFuc/write1.png" alt="两种方式的比较"></li>
</ul>
<p>手写Object.create</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function ObjCreate(proto, properties) &#123;</span><br><span class="line">  // 判断类型，第一个参数传入的必须是 object, function</span><br><span class="line">  if (typeof proto !== &quot;object&quot; &amp;&amp; typeof proto !== &quot;function&quot;) &#123;</span><br><span class="line">    throw new TypeError(&quot;Object prototype may only be an Object: &quot; + proto);</span><br><span class="line">  &#125; </span><br><span class="line">  // 简单的实现的过程，忽略了properties</span><br><span class="line">  var func = function() &#123;&#125;;</span><br><span class="line">  func.prototype = proto; // 将fn的原型指向传入的proto</span><br><span class="line">  return new func();  // 返回创建的新对象，这里思考下，new func() 又做了什么事情呢？且往下看！</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>new func()的作用是创建一个新的对象，其中func是一个构造函数，在这个过程中，主要包含了如下步骤：  </p>
<ul>
<li>创建空对象obj;</li>
<li>将obj的原型设置为构造函数的原型，obj.<strong>proto</strong>&#x3D; func.prototype;</li>
<li>以obj为上下文执行构造函数，func.call(obj);</li>
<li>返回obj对象。</li>
</ul>
<h2 id="手写promise"><a href="#手写promise" class="headerlink" title="手写promise"></a>手写promise</h2><p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<ul>
<li>对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</li>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li>
</ul>
<blockquote>
<p>摘自阮一峰ES6深入理解</p>
</blockquote>
<h3 id="引入三个问题"><a href="#引入三个问题" class="headerlink" title="引入三个问题"></a>引入三个问题</h3><p>这三个问题可以帮助理解</p>
<p>1、Promise 中为什么要引入微任务？</p>
<p>由于promise采用.then延时绑定回调机制，而new Promise时又需要直接执行promise中的方法，即发生了先执行方法后添加回调的过程，此时需等待then方法绑定两个回调后才能继续执行方法回调，便可将回调添加到当前js调用栈中执行结束后的任务队列中，由于宏任务较多容易堵塞，则采用了微任务</p>
<p>2、Promise 中是如何实现回调函数返回值穿透的？</p>
<p>首先Promise的执行结果保存在promise的data变量中，然后是.then方法返回值为使用resolved或rejected回调方法新建的一个promise对象，即例如成功则返回new Promise（resolved），将前一个promise的data值赋给新建的promise</p>
<p>3、Promise 出错后，是怎么通过“冒泡”传递给最后那个捕获</p>
<p>promise内部有resolved_和rejected_变量保存成功和失败的回调，进入.then（resolved，rejected）时会判断rejected参数是否为函数，若是函数，错误时使用rejected处理错误；若不是，则错误时直接throw错误，一直传递到最后的捕获，若最后没有被捕获，则会报错。可通过监听unhandledrejection事件捕获未处理的promise错误</p>
<h3 id="简单的promise"><a href="#简单的promise" class="headerlink" title="简单的promise"></a>简单的promise</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function MyPromise(executor) &#123;</span><br><span class="line">  var _this = this;</span><br><span class="line">  this._status = &quot;pending&quot;;</span><br><span class="line">  this._successCallBack = null;</span><br><span class="line">  this._errorCallBack = null;</span><br><span class="line">  var resolve = function (res) &#123;</span><br><span class="line">    if (_this._status === &quot;pending&quot;) &#123;</span><br><span class="line">      _this._status = &quot;fulfilled&quot;;</span><br><span class="line">      // 运行then函数传递过来的成功函数</span><br><span class="line">      // 并将结果作为参数回传</span><br><span class="line">      _this._successCallBack(res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  var reject = function (res) &#123;</span><br><span class="line">    if (_this._status === &quot;pending&quot;) &#123;</span><br><span class="line">      _this._status = &quot;rejected&quot;;</span><br><span class="line">      // 运行then函数传递过来的错误函数</span><br><span class="line">      // 并将结果作为参数回传</span><br><span class="line">      _this._errorCallBack(res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 把内部函数resolve, reject作为参数，把传进来的函数执行一遍</span><br><span class="line">  setTimeout(() =&gt; &#123; // 使用setTimeout 是让resolve晚于then方法赋值</span><br><span class="line">    executor(resolve, reject)</span><br><span class="line">  &#125;, 0)</span><br><span class="line">&#125;</span><br><span class="line">MyPromise.prototype.then = function (sucess, error) &#123;</span><br><span class="line">  this._successCallBack = sucess;</span><br><span class="line">  this._errorCallBack = error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="进阶的promise"><a href="#进阶的promise" class="headerlink" title="进阶的promise"></a>进阶的promise</h3><p>实现then的链式调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">class MyPromise &#123;</span><br><span class="line">  PromiseResult = null; // 终值</span><br><span class="line">  PromiseState = &quot;pending&quot;; // 状态</span><br><span class="line">  toDoFulFilled = null;</span><br><span class="line">  toDoRejected = null;</span><br><span class="line">  // 构造方法</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    const resolve = (value) =&gt; &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&quot;resolve&quot;);</span><br><span class="line">        if (this.PromiseState !== &quot;pending&quot;) return;</span><br><span class="line">        this.PromiseState = &quot;fulfilled&quot;;</span><br><span class="line">        this.PromiseResult = value;</span><br><span class="line"></span><br><span class="line">        if (this.toDoFulFilled) &#123;</span><br><span class="line">          this.toDoFulFilled(this.PromiseResult);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, 0);</span><br><span class="line">    &#125;;</span><br><span class="line">    const reject = (reason) =&gt; &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        if (this.PromiseState !== &quot;pending&quot;) return;</span><br><span class="line">        this.PromiseState = &quot;rejected&quot;;</span><br><span class="line">        this.PromiseResult = reason;</span><br><span class="line"></span><br><span class="line">        if (this.toDoRejected) &#123;</span><br><span class="line">          this.toDoRejected(this.PromiseResult);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, 0);</span><br><span class="line">    &#125;;</span><br><span class="line">    // 执行传进来的函数</span><br><span class="line">    try &#123;</span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    return new MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">      const resolvePromise = (cb) =&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          // 这个prevRes 就是本次then的返回值</span><br><span class="line">          // cb 就是 onFulfilled  onRejected</span><br><span class="line">          const prevRes = cb(this.PromiseResult);</span><br><span class="line">          // TODO</span><br><span class="line">          if (prevRes instanceof MyPromise) &#123;</span><br><span class="line">            prevRes.then(resolve, reject);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            resolve(prevRes);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; catch (err) &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">          throw new Error(err);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      this.toDoFulFilled = resolvePromise.bind(this, onFulfilled);</span><br><span class="line">      this.toDoRejected = resolvePromise.bind(this, onRejected);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* const test1 = new MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(&quot;成功&quot;);</span><br><span class="line">&#125;).then(</span><br><span class="line">  (res) =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">  &#125;,</span><br><span class="line">  (error) =&gt; &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">); */</span><br><span class="line"></span><br><span class="line">const test2 = new MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&quot;定时器&quot;);</span><br><span class="line">  &#125;, 2000);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(</span><br><span class="line">    (res) =&gt; &#123;</span><br><span class="line">      console.log(res);</span><br><span class="line">      return res + &quot;链式调用&quot;;</span><br><span class="line">    &#125;,</span><br><span class="line">    (error) =&gt; &#123;</span><br><span class="line">      console.log(error);</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .then(</span><br><span class="line">    (res) =&gt; &#123;</span><br><span class="line">      console.log(res);</span><br><span class="line">    &#125;,</span><br><span class="line">    (error) =&gt; &#123;</span><br><span class="line">      console.log(error);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>

<h3 id="限制promise并发"><a href="#限制promise并发" class="headerlink" title="限制promise并发"></a>限制promise并发</h3><p>主要的点</p>
<ul>
<li>在then方法里启动下一次任务</li>
<li>while为了塞满队列</li>
<li>task是一个待启动的promise</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class MaxDuty&#123;</span><br><span class="line">  used = 0</span><br><span class="line">  tasks = []</span><br><span class="line">  constructor(max) &#123;</span><br><span class="line">    this.max = max</span><br><span class="line">  &#125;</span><br><span class="line">  addTask(task) &#123;</span><br><span class="line">    this.tasks.push(task)</span><br><span class="line">  &#125;</span><br><span class="line">  walk() &#123;</span><br><span class="line">    if (this.tasks.length &amp;&amp; this.used &lt; this.max) &#123;</span><br><span class="line">      this.used++</span><br><span class="line">      const task = this.tasks.shift()</span><br><span class="line">      task().then(res =&gt; &#123;</span><br><span class="line">        console.log(res);</span><br><span class="line">        this.used--</span><br><span class="line">        this.walk()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  start() &#123;</span><br><span class="line">    // 需要塞满</span><br><span class="line">    while (this.used &lt; this.max) &#123;</span><br><span class="line">      this.walk()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 返回一个待启动的promise</span><br><span class="line">function createTask(time, order) &#123;</span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    return new Promise(resolve =&gt; &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        resolve(order)</span><br><span class="line">      &#125;, time);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const maxDuty = new MaxDuty(2)</span><br><span class="line"></span><br><span class="line">maxDuty.addTask(createTask(1000, 1))</span><br><span class="line">maxDuty.addTask(createTask(500, 2))</span><br><span class="line">maxDuty.addTask(createTask(300, 3))</span><br><span class="line">maxDuty.addTask(createTask(400, 4))</span><br><span class="line"></span><br><span class="line">maxDuty.start()</span><br></pre></td></tr></table></figure>

<h2 id="珂里化"><a href="#珂里化" class="headerlink" title="珂里化"></a>珂里化</h2><p>第一版 比较简单，也好理解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var curry = function (fn) &#123;</span><br><span class="line">  // 取到fn之后的参数</span><br><span class="line">  var args = [].slice.call(arguments, 1);</span><br><span class="line">  // 返回一个待使用的新函数</span><br><span class="line">  return function () &#123;</span><br><span class="line">    // 将新函数的参数 和 之前生成珂里化函数的参数合并</span><br><span class="line">    var newArgs = args.concat([].slice.call(arguments));</span><br><span class="line">    // 不改变this，使用所有参数进行调用</span><br><span class="line">    return fn.apply(this, newArgs);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var addCurry = curry(add, 1, 2);</span><br><span class="line">addCurry() // 3</span><br><span class="line">//或者</span><br><span class="line">var addCurry = curry(add, 1);</span><br><span class="line">addCurry(2) // 3</span><br><span class="line">//或者</span><br><span class="line">var addCurry = curry(add);</span><br><span class="line">addCurry(1, 2) // 3</span><br></pre></td></tr></table></figure>

<h3 id="固定参数"><a href="#固定参数" class="headerlink" title="固定参数"></a>固定参数</h3><p>第二版 稍微复杂一些，先看实现的效果会比较好理解一点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var fn = curry(function (a, b, c) &#123;</span><br><span class="line">  console.log([a, b, c]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fn(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fn(&quot;a&quot;, &quot;b&quot;)(&quot;c&quot;); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fn(&quot;a&quot;)(&quot;b&quot;)(&quot;c&quot;); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fn(&quot;a&quot;)(&quot;b&quot;, &quot;c&quot;); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>首先需要明确1点</strong></p>
<ul>
<li>参数的个数是确定的，这也是递归调用的截止条件</li>
</ul>
<p>来看实现过程</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="comment">// 形参的个数 </span></span><br><span class="line">  <span class="keyword">const</span> length = fn.<span class="property">length</span></span><br><span class="line">  <span class="keyword">let</span> args = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> argChild = [...args,...<span class="variable language_">arguments</span>]</span><br><span class="line">    <span class="keyword">if</span> (argChild.<span class="property">length</span> === length) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, argChild)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(argChild);</span></span><br><span class="line">      <span class="keyword">return</span> curry.<span class="title function_">call</span>(<span class="variable language_">this</span>, fn, ...argChild)</span><br><span class="line">      <span class="comment">// return curry.apply(this, fn, argChild)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn1 = <span class="title function_">curry</span>(<span class="keyword">function</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>([a, b, c]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn1</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>) <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="title function_">fn1</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)(<span class="string">&quot;c&quot;</span>) <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="title function_">fn1</span>(<span class="string">&quot;a&quot;</span>)(<span class="string">&quot;b&quot;</span>)(<span class="string">&quot;c&quot;</span>) <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="title function_">fn1</span>(<span class="string">&quot;a&quot;</span>)(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>) <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="title function_">curry</span>(<span class="keyword">function</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>([a, b, c]);</span><br><span class="line">&#125;, <span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn2</span>(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>) <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="title function_">fn2</span>(<span class="string">&quot;b&quot;</span>)(<span class="string">&quot;c&quot;</span>) <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="不固定参数"><a href="#不固定参数" class="headerlink" title="不固定参数"></a>不固定参数</h3><p>这种方法太刻意了，建议闲下来的时候看看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// fn(a,b,c) = fn(a)(b)(c)</span><br><span class="line">function curry(fn) &#123;</span><br><span class="line">    return function core(...args) &#123;</span><br><span class="line">        let params = []</span><br><span class="line">        params = params.concat(args)</span><br><span class="line">        let inner = function(...args2) &#123;</span><br><span class="line">            params = params.concat(args2)</span><br><span class="line">            return core.apply(this, params)</span><br><span class="line">        &#125;</span><br><span class="line">        inner.toString = ()=&gt;&#123;</span><br><span class="line">            return fn.apply(null, params)</span><br><span class="line">        &#125;</span><br><span class="line">        return inner</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function add(...args) &#123;</span><br><span class="line">    return args.reduce((prev,curr)=&gt;prev + curr, 0)</span><br><span class="line">&#125;</span><br><span class="line">let curriedAdd = curry(add)</span><br><span class="line">alert(curriedAdd(1,2,3))</span><br><span class="line"></span><br><span class="line">alert(curriedAdd(1, 2)(1, 2, 3))</span><br><span class="line">curriedAdd(1)(2)(3)(4)(5)</span><br></pre></td></tr></table></figure>

<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/22">参考</a></p>
<p>有一些需要注意的点，可以帮助理解函数，重点看代码中注释的地方</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    html, body &#123;</span><br><span class="line">      height: 100%;</span><br><span class="line">      width: 100%;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    var count = 1</span><br><span class="line">    function handle(event) &#123;</span><br><span class="line">      console.log(this);</span><br><span class="line">    &#125;</span><br><span class="line">    document.onmousemove = debounce(handle, 400)</span><br><span class="line"></span><br><span class="line">    function debounce(fn, wait) &#123;</span><br><span class="line">      var timer = null</span><br><span class="line">      return function () &#123;</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">        timer = setTimeout(</span><br><span class="line">         // 这么写 实际上没有效果</span><br><span class="line">          fn.apply(this, arguments),</span><br><span class="line">          // 下面的写法均有效果</span><br><span class="line">          fn.bind(this, arguments),</span><br><span class="line">     fn,</span><br><span class="line">          wait</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，setTimeout第一个参数需要是一个函数，而<code>fn.apply(this, arguments)</code>不能算一个函数</p>
<p>下面写一个比较标准的debounce，可以正确响应参数和this</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> function debounce(fn, wait) &#123;</span><br><span class="line">      var timer = null</span><br><span class="line">      return function () &#123;</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">        timer = setTimeout(</span><br><span class="line">          fn.bind(this, ...arguments),</span><br><span class="line">          wait</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> // 不使用es6</span><br><span class="line">function debounce(func, wait) &#123;</span><br><span class="line">    var timeout;</span><br><span class="line"></span><br><span class="line">    return function () &#123;</span><br><span class="line">        var context = this;</span><br><span class="line">        var args = arguments;</span><br><span class="line"></span><br><span class="line">        clearTimeout(timeout)</span><br><span class="line">        timeout = setTimeout(function()&#123;</span><br><span class="line">            func.apply(context, args)</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="立刻执行"><a href="#立刻执行" class="headerlink" title="立刻执行"></a>立刻执行</h3><p>这个时候，代码已经很是完善了，但是为了让这个函数更加完善，我们接下来思考一个新的需求。</p>
<p>这个需求就是：</p>
<p>我不希望非要等到事件停止触发后才执行，我希望<strong>立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行</strong>。</p>
<p>其实这个实现也算简单，主要是理解需求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function immedia(fn, wait) &#123;</span><br><span class="line">      var flag = true</span><br><span class="line">      var timer = null</span><br><span class="line">      return function () &#123;</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">        // 保证不在触发后wait时间后，可以再次被触发</span><br><span class="line">        timer = setTimeout(</span><br><span class="line">          function () &#123;</span><br><span class="line">            flag = true</span><br><span class="line">          &#125;,</span><br><span class="line">          wait</span><br><span class="line">        )</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">         // 触发后 开启保护</span><br><span class="line">          flag = false</span><br><span class="line">          fn.apply(this, arguments)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>写在一个函数里，也很简单</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function debounce(fn, wait, immediate) &#123;</span><br><span class="line">     var timer = null</span><br><span class="line">     if(immediate)&#123;</span><br><span class="line">       var flag = true</span><br><span class="line">       return function () &#123;</span><br><span class="line">         clearTimeout(timer)</span><br><span class="line">         timer = setTimeout(</span><br><span class="line">           function () &#123;</span><br><span class="line">             flag = true</span><br><span class="line">           &#125;,</span><br><span class="line">           wait</span><br><span class="line">         )</span><br><span class="line">         if(flag)&#123;</span><br><span class="line">           flag = false</span><br><span class="line">           fn.apply(this, arguments)</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">       return function () &#123;</span><br><span class="line">         clearTimeout(timer)</span><br><span class="line">         timer = setTimeout(</span><br><span class="line">           fn.bind(this, ...arguments),</span><br><span class="line">           wait</span><br><span class="line">         )</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>节流的原理很简单：</p>
<p>如果你持续触发事件，每隔一段时间，只执行一次事件。</p>
<p>关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器。</p>
<h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function throttle(fn, wait) &#123;</span><br><span class="line">  const previous = 0;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    const now = new Date().getTime()</span><br><span class="line">    if (now - previous &gt; wait) &#123;</span><br><span class="line">      previous = now</span><br><span class="line">    &#125;</span><br><span class="line">    fn.apply(this, arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function throttle(fn, wait) &#123;</span><br><span class="line">     let flag = true</span><br><span class="line">     return function () &#123;</span><br><span class="line">       if (flag) &#123;</span><br><span class="line">         flag = false</span><br><span class="line">         fn.apply(this, arguments)</span><br><span class="line">         setTimeouto=(function () &#123;</span><br><span class="line">           flag = true</span><br><span class="line">         &#125;,wait)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="deepclone"><a href="#deepclone" class="headerlink" title="deepclone"></a>deepclone</h2><p>先看一个足够用的版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(obj) &#123;</span><br><span class="line">  if (obj === &#x27;null&#x27;) return null</span><br><span class="line">  if (typeof obj !== &#x27;object&#x27;) return obj</span><br><span class="line">  if (obj instanceof RegExp) return new RegExp(obj)</span><br><span class="line">  if (obj instanceof Date) return new Date(obj)</span><br><span class="line">  let result = new obj.constructor</span><br><span class="line">  for (let key in obj) &#123;</span><br><span class="line">    if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">     result[key] = deepClone(obj[key]) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 上面的for循环可以改成</span><br><span class="line">  // Reflect.ownKeys(key =&gt; result[key] = deepClone(obj[key])</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先实现一个简单clone，包括对象 数组和基本类型的clone</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(target) &#123;</span><br><span class="line">  if (typeof target !== &quot;object&quot;) &#123;</span><br><span class="line">    return target</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    const copy = Array.isArray(target) ? [] : &#123;&#125;</span><br><span class="line">    for (const key in target) &#123;</span><br><span class="line">      copy[key] = deepClone(target[key])</span><br><span class="line">    &#125;</span><br><span class="line">    return copy</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果出现循环引用，就会栈溢出，如何解决这个问题呢，需要借助map数据结构</p>
<p>解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题。</p>
<p>这个存储空间，需要可以存储<code>key-value</code>形式的数据，且<code>key</code>可以是一个引用类型，我们可以选择<code>Map</code>这种数据结构：</p>
<ul>
<li>检查<code>map</code>中有无克隆过的对象</li>
<li>有 - 直接返回</li>
<li>没有 - 将当前对象作为<code>key</code>，克隆对象作为<code>value</code>进行存储</li>
<li>继续克隆</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(target) &#123;</span><br><span class="line">  const map = new Map();</span><br><span class="line">  return (function _clone(target) &#123;</span><br><span class="line">    if (typeof target !== &quot;object&quot;) &#123;</span><br><span class="line">      return target</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (map.has(target)) &#123;</span><br><span class="line">        return target</span><br><span class="line">      &#125;</span><br><span class="line">      map.set(target, null)</span><br><span class="line">      const copy = Array.isArray(target) ? [] : &#123;&#125;</span><br><span class="line">      for (const key in target) &#123;</span><br><span class="line">        copy[key] = _clone(target[key])</span><br><span class="line">      &#125;</span><br><span class="line">      return copy</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(target)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const target = &#123;</span><br><span class="line">  field1: 1,</span><br><span class="line">  field2: undefined,</span><br><span class="line">  field3: &#123;</span><br><span class="line">      child: &#x27;child&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  field4: [2, 4, 8]</span><br><span class="line">&#125;;</span><br><span class="line">target.target = target</span><br><span class="line">console.log(deepClone(target));</span><br></pre></td></tr></table></figure>

<p>控制台结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  field1: 1,</span><br><span class="line">  field2: undefined,</span><br><span class="line">  field3: &#123; child: &#x27;child&#x27; &#125;,</span><br><span class="line">  field4: [ 2, 4, 8 ],</span><br><span class="line">  target: &lt;ref *1&gt; &#123;</span><br><span class="line">    field1: 1,</span><br><span class="line">    field2: undefined,</span><br><span class="line">    field3: &#123; child: &#x27;child&#x27; &#125;,</span><br><span class="line">    field4: [ 2, 4, 8 ],</span><br><span class="line">    target: [Circular *1]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>circular</code>表示循环引用的意思，把Map换成weakMap，Map有强引用，不利用垃圾收集</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/" class="post-title-link" itemprop="url">二叉树遍历</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-13 15:13:57" itemprop="dateCreated datePublished" datetime="2024-07-13T15:13:57+08:00">2024-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">刷题记录</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="常规遍历"><a href="#常规遍历" class="headerlink" title="常规遍历"></a>常规遍历</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/tu-jie-er-cha-shu-de-si-chong-bian-li-by-z1m/">优秀题解</a></p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归的代码很简单</p>
<h4 id="前序-中左右"><a href="#前序-中左右" class="headerlink" title="前序 中左右"></a>前序 中左右</h4><p><strong>这种写法其实不好，容易让人误解，return res 会被执行好多次</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var preorderTraversal = function(root, res = []) &#123;</span><br><span class="line">  if(!root)&#123;</span><br><span class="line">    return res</span><br><span class="line">  &#125;</span><br><span class="line">  res.push(root.val)</span><br><span class="line">  preorderTraversal(root.left, res)</span><br><span class="line">  preorderTraversal(root.right, res)</span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面这种容易理解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var preorderTraversal = function(root) &#123;</span><br><span class="line"> var res = []</span><br><span class="line">  if(!root)&#123;</span><br><span class="line">    return res</span><br><span class="line">  &#125;</span><br><span class="line">  res.push(root.val)</span><br><span class="line">  preorderTraversal(root.left, res)</span><br><span class="line">  preorderTraversal(root.right, res)</span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br><span class="line">function handle(root) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="中序-左中右"><a href="#中序-左中右" class="headerlink" title="中序 左中右"></a>中序 左中右</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var preorderTraversal = function(root, res = []) &#123;</span><br><span class="line">  if(!root)&#123;</span><br><span class="line">    return res</span><br><span class="line">  &#125;</span><br><span class="line">  preorderTraversal(root.left, res)</span><br><span class="line">  res.push(root.val)</span><br><span class="line">  preorderTraversal(root.right, res)</span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="后序-左右中"><a href="#后序-左右中" class="headerlink" title="后序 左右中"></a>后序 左右中</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var preorderTraversal = function(root, res = []) &#123;</span><br><span class="line">  if(!root)&#123;</span><br><span class="line">    return res</span><br><span class="line">  &#125;</span><br><span class="line">  preorderTraversal(root.left, res)</span><br><span class="line">  preorderTraversal(root.right, res)</span><br><span class="line">  res.push(root.val)</span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>迭代的很不容易理解</p>
<h4 id="前序-中左右-1"><a href="#前序-中左右-1" class="headerlink" title="前序 中左右"></a>前序 中左右</h4><p>普通写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var preorderTraversal = function(root) &#123;</span><br><span class="line">  if(!root)&#123;</span><br><span class="line">    return []</span><br><span class="line">  &#125;</span><br><span class="line">  const stack = [];</span><br><span class="line">  const res = []</span><br><span class="line">  stack.push(root)</span><br><span class="line">  while(stack.length)&#123;</span><br><span class="line">    const popNode = stack.pop()</span><br><span class="line">    res.push(popNode.val)</span><br><span class="line">    if(popNode.right)&#123;</span><br><span class="line">      stack.push(popNode.right)</span><br><span class="line">    &#125;</span><br><span class="line">    if(popNode.left)&#123;</span><br><span class="line">      stack.push(popNode.left)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>统一写法 前序和中序 结果采集的地方不同，一个是出栈 一个是入栈</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var preorderTraversal = function(root) &#123;</span><br><span class="line">  const res = []</span><br><span class="line">  let cur = root</span><br><span class="line">  const stack = []</span><br><span class="line">  while (stack.length || cur) &#123;</span><br><span class="line">    while (cur) &#123;</span><br><span class="line">      res.push(cur.val)</span><br><span class="line">      stack.push(cur)</span><br><span class="line">      cur = cur.left</span><br><span class="line">    &#125;</span><br><span class="line">    const popNode = stack.pop()</span><br><span class="line">    if(popNode.right)&#123;</span><br><span class="line">      cur = popNode.right</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="中序-左中右-1"><a href="#中序-左中右-1" class="headerlink" title="中序 左中右"></a>中序 左中右</h4><p>统一写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var inorderTraversal = (root) =&gt; &#123;</span><br><span class="line">  const res = []</span><br><span class="line">  let cur = root</span><br><span class="line">  const stack = []</span><br><span class="line">  while (stack.length || cur) &#123;</span><br><span class="line">    // 找到最左侧的节点，并把沿路的节点全部推入栈中</span><br><span class="line">    while(cur)&#123;</span><br><span class="line">      stack.push(cur)</span><br><span class="line">      cur = cur.left</span><br><span class="line">    &#125;</span><br><span class="line">    // 取出栈顶元素</span><br><span class="line">    const popNode = stack.pop()</span><br><span class="line">    // 记录出栈元素</span><br><span class="line">    res.push(popNode.val)</span><br><span class="line">    // 存在右节点 即为父节点 而且左节点已经处理过了</span><br><span class="line">    if(popNode.right)&#123;</span><br><span class="line">      cur = popNode.right</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="后序-左右中-1"><a href="#后序-左右中-1" class="headerlink" title="后序 左右中"></a>后序 左右中</h4><p>可以把前序的普通写法改一下，变成中右左，然后倒着输出</p>
<p>普通写法倒着输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const postorderTraversal = function(root) &#123;</span><br><span class="line">  const res = []</span><br><span class="line">  if(!root)&#123;</span><br><span class="line">    return res</span><br><span class="line">  &#125;</span><br><span class="line">  const stack = []</span><br><span class="line">  stack.push(root)</span><br><span class="line">  while(stack.length)&#123;</span><br><span class="line">    const popRoot = stack.pop()</span><br><span class="line">    res.push(popRoot.val)</span><br><span class="line">    // 左右换一下顺序</span><br><span class="line">    if(popRoot.left)&#123;</span><br><span class="line">      stack.push(popRoot.left)</span><br><span class="line">    &#125;</span><br><span class="line">    if(popRoot.right)&#123;</span><br><span class="line">      stack.push(popRoot.right)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 倒着输出</span><br><span class="line">  return res.reverse()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>统一写法倒着输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const postorderTraversal = function(root) &#123;</span><br><span class="line">  const res = []</span><br><span class="line">  let cur = root</span><br><span class="line">  const stack = []</span><br><span class="line">  while (stack.length || cur) &#123;</span><br><span class="line">    while (cur) &#123;</span><br><span class="line">      res.push(cur.val)</span><br><span class="line">      stack.push(cur)</span><br><span class="line">      cur = cur.right</span><br><span class="line">    &#125;</span><br><span class="line">    const popNode = stack.pop()</span><br><span class="line">    if(popNode.left)&#123;</span><br><span class="line">      cur = popNode.left</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 把上边的push 换成unshift 这边就不用倒着了 但是时间复杂度更高了，不好</span><br><span class="line">  return res.reverse()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>利用标识符进行迭代,普通写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">const postorderTraversal = function(root) &#123;</span><br><span class="line">  if (!root) &#123;</span><br><span class="line">    return []</span><br><span class="line">  &#125;</span><br><span class="line">  const stack = []</span><br><span class="line">  const res = []</span><br><span class="line">  stack.push(&#123;</span><br><span class="line">    node: root,</span><br><span class="line">    flag: 0</span><br><span class="line">  &#125;)</span><br><span class="line">  while (stack.length) &#123;</span><br><span class="line">    const &#123;node, flag&#125; = stack.pop()</span><br><span class="line">    if (!node) &#123;</span><br><span class="line">      continue</span><br><span class="line">    &#125;</span><br><span class="line">    if (flag === 1) &#123;</span><br><span class="line">      res.push(node.val)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      stack.push(&#123;</span><br><span class="line">        node: node,</span><br><span class="line">        flag: 1</span><br><span class="line">      &#125;)</span><br><span class="line">      stack.push(&#123;</span><br><span class="line">        node: node.right,</span><br><span class="line">        flag: 0</span><br><span class="line">      &#125;)</span><br><span class="line">      stack.push(&#123;</span><br><span class="line">        node: node.left,</span><br><span class="line">        flag: 0</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="优秀统一迭代法-直接记这个就好"><a href="#优秀统一迭代法-直接记这个就好" class="headerlink" title="优秀统一迭代法 直接记这个就好"></a>优秀统一迭代法 直接记这个就好</h3><h4 id="前序遍历统一迭代法"><a href="#前序遍历统一迭代法" class="headerlink" title="前序遍历统一迭代法"></a>前序遍历统一迭代法</h4><p>&#x2F;&#x2F; 前序遍历：中左右<br>&#x2F;&#x2F; 压栈顺序：右左中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var preorderTraversal = function(root, res = []) &#123;</span><br><span class="line">    const stack = [];</span><br><span class="line">    if (root) stack.push(root);</span><br><span class="line">    while(stack.length) &#123;</span><br><span class="line">        const node = stack.pop();</span><br><span class="line">        if(!node) &#123;</span><br><span class="line">            res.push(stack.pop().val);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (node.right) stack.push(node.right); // 右</span><br><span class="line">        if (node.left) stack.push(node.left); // 左</span><br><span class="line">        stack.push(node); // 中</span><br><span class="line">        stack.push(null);</span><br><span class="line">    &#125;;</span><br><span class="line">    return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="中序遍历统一迭代法"><a href="#中序遍历统一迭代法" class="headerlink" title="中序遍历统一迭代法"></a>中序遍历统一迭代法</h4><p>&#x2F;&#x2F;  中序遍历：左中右<br>&#x2F;&#x2F;  压栈顺序：右中左</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var inorderTraversal = function(root, res = []) &#123;</span><br><span class="line">    const stack = [];</span><br><span class="line">    if (root) stack.push(root);</span><br><span class="line">    while(stack.length) &#123;</span><br><span class="line">        const node = stack.pop();</span><br><span class="line">        if(!node) &#123;</span><br><span class="line">            res.push(stack.pop().val);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (node.right) stack.push(node.right); // 右</span><br><span class="line">        stack.push(node); // 中</span><br><span class="line">        stack.push(null);</span><br><span class="line">        if (node.left) stack.push(node.left); // 左</span><br><span class="line">    &#125;;</span><br><span class="line">    return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="后序遍历统一迭代法"><a href="#后序遍历统一迭代法" class="headerlink" title="后序遍历统一迭代法"></a>后序遍历统一迭代法</h4><p>&#x2F;&#x2F; 后续遍历：左右中<br>&#x2F;&#x2F; 压栈顺序：中右左</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var postorderTraversal = function(root, res = []) &#123;</span><br><span class="line">    const stack = [];</span><br><span class="line">    if (root) stack.push(root);</span><br><span class="line">    while(stack.length) &#123;</span><br><span class="line">        const node = stack.pop();</span><br><span class="line">        if(!node) &#123;</span><br><span class="line">            res.push(stack.pop().val);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(node); // 中</span><br><span class="line">        stack.push(null);</span><br><span class="line">        if (node.right) stack.push(node.right); // 右</span><br><span class="line">        if (node.left) stack.push(node.left); // 左</span><br><span class="line">    &#125;;</span><br><span class="line">    return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>作者：carlsun-2<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/dai-ma-sui-xiang-lu-chi-tou-qian-zhong-hou-xu-de-d/">https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/dai-ma-sui-xiang-lu-chi-tou-qian-zhong-hou-xu-de-d/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p>leetcode一道基础的题</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></p>
<p>难度中等1081收藏分享切换为英文接收动态反馈</p>
<p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p><strong>示例：</strong><br>二叉树：<code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回其层序遍历结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><p>利用层级和数组解决</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var levelOrder = function(root) &#123;</span><br><span class="line">  const levelArr = []</span><br><span class="line">  handle(root,0,levelArr)</span><br><span class="line">  return levelArr</span><br><span class="line">&#125;;</span><br><span class="line">function handle(root, level, levelArr)&#123;</span><br><span class="line">  if(!root)&#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  Array.isArray(levelArr[level]) ? levelArr[level].push(root.val) : levelArr[level] = [root.val]</span><br><span class="line">  level++</span><br><span class="line">  handle(root.left, level, levelArr)</span><br><span class="line">  handle(root.right, level, levelArr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h3><p>方法看一下 很容易就能理解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var levelOrder = function(root) &#123;</span><br><span class="line">  const res = []</span><br><span class="line">  if(!root)&#123;</span><br><span class="line">    return res</span><br><span class="line">  &#125;</span><br><span class="line">  const queue = [root]</span><br><span class="line">  let index = 0</span><br><span class="line">  while (queue.length) &#123; // 关键点</span><br><span class="line">    // 每一层的新开始</span><br><span class="line">    // 记录当前层的节点个数，防止shift多了</span><br><span class="line">    const l = queue.length // 关键点</span><br><span class="line">    res.push([])</span><br><span class="line">    // 把该层推入结果，顺便把该层的下一层推入q中</span><br><span class="line">    for(var i=0;i&lt;l;i++)&#123; // 关键点</span><br><span class="line">      const head = queue.shift()</span><br><span class="line">      res[index].push(head.val)</span><br><span class="line">      if(head.left)&#123;</span><br><span class="line">        queue.push(head.left)</span><br><span class="line">      &#125;</span><br><span class="line">      if(head.right)&#123;</span><br><span class="line">        queue.push(head.right)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    index++</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="加深对二叉树递归的理解"><a href="#加深对二叉树递归的理解" class="headerlink" title="加深对二叉树递归的理解"></a>加深对二叉树递归的理解</h2><h3 id="230-二叉搜索树中第K小的元素-labuladong-题解-思路"><a href="#230-二叉搜索树中第K小的元素-labuladong-题解-思路" class="headerlink" title="230. 二叉搜索树中第K小的元素 labuladong 题解 思路"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a> <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/plugin-v2/?qno=230">labuladong 题解</a> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/#">思路</a></h3><p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/md-images/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/assets/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/kthtree1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,1,4,null,2], k = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/md-images/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/assets/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/kthtree2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<h4 id="对递归理解不深的解法，没错-我写的"><a href="#对递归理解不深的解法，没错-我写的" class="headerlink" title="对递归理解不深的解法，没错 我写的"></a>对递归理解不深的解法，没错 我写的</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var kthSmallest = function(root, k) &#123;</span><br><span class="line">  let res</span><br><span class="line">  function handle(root, count, k)&#123;</span><br><span class="line">    if(!root)&#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    handle(root.left, count, k)</span><br><span class="line">    if(count === k)&#123;</span><br><span class="line">      res = root.val</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    count++</span><br><span class="line">    handle(root.right, count, k)</span><br><span class="line">  &#125;</span><br><span class="line">  handle(root, 1, k)</span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="实际上的正确解法"><a href="#实际上的正确解法" class="headerlink" title="实际上的正确解法"></a>实际上的正确解法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var kthSmallest = function(root, k) &#123;</span><br><span class="line">  let count = 1</span><br><span class="line">  function handle(root, k)&#123;</span><br><span class="line">    if(!root)&#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    handle(root.left, k)</span><br><span class="line">    if(count === k)&#123;</span><br><span class="line">      res = root.val</span><br><span class="line">      // 如果没有这个count++ 会一直指向下一个节点</span><br><span class="line">      count++</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    count++</span><br><span class="line">    handle(root.right, k)</span><br><span class="line">  &#125;</span><br><span class="line">  handle(root, k)</span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="搜索二叉树插入数据"><a href="#搜索二叉树插入数据" class="headerlink" title="搜索二叉树插入数据"></a>搜索二叉树插入数据</h3><p>重点理解两种模式的不同</p>
<h4 id="我的解法-简单直接"><a href="#我的解法-简单直接" class="headerlink" title="我的解法 简单直接"></a>我的解法 简单直接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var insertIntoBST = function(root, val) &#123;</span><br><span class="line">  if(!root)&#123;</span><br><span class="line">    return new TreeNode(val)</span><br><span class="line">  &#125;</span><br><span class="line">  if(val &gt; root.val)&#123;</span><br><span class="line">    if(!root.right)&#123;</span><br><span class="line">      root.right = new TreeNode(val)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      insertIntoBST(root.right, val)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    if(!root.left)&#123;</span><br><span class="line">      root.left = new TreeNode(val)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      insertIntoBST(root.left, val)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="另一种解法-不太容易理解"><a href="#另一种解法-不太容易理解" class="headerlink" title="另一种解法 不太容易理解"></a>另一种解法 不太容易理解</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var insertIntoBST = function(root, val) &#123;</span><br><span class="line">  if(!root)&#123;</span><br><span class="line">    return new TreeNode(val)</span><br><span class="line">  &#125;</span><br><span class="line">  if(val &gt; root.val)&#123;</span><br><span class="line">    root.right = insertIntoBST(root.right, val)</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    root.left = insertIntoBST(root.left, val)</span><br><span class="line">  &#125;</span><br><span class="line">  // 对return之外情况的兜底 找不到原样返回</span><br><span class="line">  // root.right = root.right</span><br><span class="line">  return root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>搜索二叉树的删除操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var deleteNode = function(root, key) &#123;</span><br><span class="line">  if(!root)&#123;</span><br><span class="line">    return root</span><br><span class="line">  &#125;</span><br><span class="line">  if(root.val === key)&#123;</span><br><span class="line">    if(!root.left)&#123;</span><br><span class="line">      // 如果root.right 也不存在 就是null</span><br><span class="line">      return root.right</span><br><span class="line">    &#125;</span><br><span class="line">    if(!root.right)&#123;</span><br><span class="line">      return root.left</span><br><span class="line">    &#125;</span><br><span class="line">    const minVal = getRightMin(root.right)</span><br><span class="line">    root.val = minVal.val</span><br><span class="line">    root.right = deleteNode(root.right, minVal.val)</span><br><span class="line">  &#125;else if(key &lt; root.val)&#123;</span><br><span class="line">    root.left = deleteNode(root.left, key)</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    root.right = deleteNode(root.right, key)</span><br><span class="line">  &#125;</span><br><span class="line">  return root</span><br><span class="line">&#125;;</span><br><span class="line">function getRightMin(root)&#123;</span><br><span class="line">  while(root.left)&#123;</span><br><span class="line">    root = root.left</span><br><span class="line">  &#125;</span><br><span class="line">  return root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II</a></h3><p>给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。</p>
<p> <img src="/md-images/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/assets/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/uniquebstn3.jpg" alt="img"></p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]</span><br><span class="line">示例 2：</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var generateTrees = function(n) &#123;</span><br><span class="line">  if(n===0)&#123;</span><br><span class="line">    return []</span><br><span class="line">  &#125;</span><br><span class="line">  return build(1, n)</span><br><span class="line">&#125;;</span><br><span class="line">function build(l, r)&#123;</span><br><span class="line">  const res = []</span><br><span class="line">  if(l&gt;r)&#123;</span><br><span class="line">    res.push(null)</span><br><span class="line">    return res</span><br><span class="line">  &#125;</span><br><span class="line">  for(var i=l;i&lt;=r;i++)&#123;</span><br><span class="line">    const leftTree = build(l, i-1)</span><br><span class="line">    const rightTree = build(i+1, r)</span><br><span class="line">    for(var left of leftTree)&#123;</span><br><span class="line">      for(var right of rightTree)&#123;</span><br><span class="line">        const root = new TreeNode(i, left, right)</span><br><span class="line">        res.push(root)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">leetCode刷题记录-链表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-13 14:58:38" itemprop="dateCreated datePublished" datetime="2024-07-13T14:58:38+08:00">2024-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">刷题记录</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="146-LRU缓存算法"><a href="#146-LRU缓存算法" class="headerlink" title="146.LRU缓存算法"></a>146.LRU缓存算法</h3><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">实现 LRUCache 类：</span><br><span class="line"></span><br><span class="line">LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存</span><br><span class="line">int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</span><br><span class="line">void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</span><br><span class="line"></span><br><span class="line">进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https://leetcode-cn.com/problems/lru-cache</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h4 id="利用链表保持时序，利用hash存储节点"><a href="#利用链表保持时序，利用hash存储节点" class="headerlink" title="利用链表保持时序，利用hash存储节点"></a>利用链表保持时序，利用hash存储节点</h4><p>调试了好久，终于搞定了，需要仔细</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">class ListNode &#123;</span><br><span class="line">  constructor(key, val, pre=null, next=null)&#123;</span><br><span class="line">    this.key = key;</span><br><span class="line">    this.val = val;</span><br><span class="line">    this.pre = pre;</span><br><span class="line">    this.next = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var LRUCache = function (capacity) &#123;</span><br><span class="line">  // 最大长度</span><br><span class="line">  this.capacity = capacity</span><br><span class="line">  this.hash = new Map()</span><br><span class="line">  // 计数器</span><br><span class="line">  this.count = 0</span><br><span class="line">  // 虚拟头部</span><br><span class="line">  this.dummyHead = new ListNode(-1, -1)</span><br><span class="line">  // 虚拟尾部</span><br><span class="line">  this.dummyTail = new ListNode(-1, -1)</span><br><span class="line">  this.dummyHead.next = this.dummyTail</span><br><span class="line">  this.dummyTail.pre = this.dummyHead</span><br><span class="line">  // 头部</span><br><span class="line">  this.listHead = this.dummyHead</span><br><span class="line">  // 尾部</span><br><span class="line">  this.listTail = this.dummyTail</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LRUCache.prototype.get = function(key) &#123;</span><br><span class="line">  if (this.hash.has(key)) &#123;</span><br><span class="line">    const existNode = this.hash.get(key)</span><br><span class="line">    // 从原位置删除</span><br><span class="line">    existNode.next.pre = existNode.pre</span><br><span class="line">    existNode.pre.next = existNode.next</span><br><span class="line">    // 把节点插入虚拟尾部之前</span><br><span class="line">    this.insertBeforeTail(existNode)</span><br><span class="line">    return this.hash.get(key).val</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    return -1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LRUCache.prototype.put = function(key, value) &#123;</span><br><span class="line">  if (this.hash.has(key)) &#123; // 已存在</span><br><span class="line">    const existNode = this.hash.get(key)</span><br><span class="line">    // 从原位置删除</span><br><span class="line">    existNode.next.pre = existNode.pre</span><br><span class="line">    existNode.pre.next = existNode.next</span><br><span class="line">    // 题目有个变更要求</span><br><span class="line">    existNode.val = value</span><br><span class="line">    // 把节点插入虚拟尾部之前</span><br><span class="line">    this.insertBeforeTail(existNode)</span><br><span class="line">  &#125; else &#123; // 未存在</span><br><span class="line">    const newNode = new ListNode(key, value)</span><br><span class="line">    if (this.count &lt; this.capacity) &#123; // 容量没满</span><br><span class="line">      // 把新节点插入虚拟尾部之前</span><br><span class="line">      this.insertBeforeTail(newNode)</span><br><span class="line">      // 用key记录节点</span><br><span class="line">      this.hash.set(key, newNode)</span><br><span class="line">      // 计数</span><br><span class="line">      this.count++</span><br><span class="line">    &#125; else &#123; // 容量满了</span><br><span class="line">      // 删除节点记录</span><br><span class="line">      this.hash.delete(this.listHead.next.key)</span><br><span class="line">      // 把虚拟头部后边节点删除</span><br><span class="line">      this.listHead.next = this.listHead.next.next</span><br><span class="line">      this.listHead.next.pre = this.listHead </span><br><span class="line">      // 把新节点插入虚拟尾部之前   </span><br><span class="line">      this.insertBeforeTail(newNode)</span><br><span class="line">      // 用key记录节点</span><br><span class="line">      this.hash.set(key, newNode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">LRUCache.prototype.insertBeforeTail = function (newNode) &#123;</span><br><span class="line">  // 把节点插入虚拟尾部之前</span><br><span class="line">  this.listTail.pre.next = newNode</span><br><span class="line">  newNode.pre = this.listTail.pre</span><br><span class="line">  newNode.next = this.listTail</span><br><span class="line">  this.listTail.pre = newNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="利用map数据结构"><a href="#利用map数据结构" class="headerlink" title="利用map数据结构"></a>利用map数据结构</h4><p>利用map特别简单</p>
<p><strong>map数据结构兼顾有序性和hash</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var LRUCache = function(capacity) &#123;</span><br><span class="line">    this.capacity = capacity;</span><br><span class="line">    this.map = new Map();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LRUCache.prototype.get = function(key) &#123;</span><br><span class="line">    if(this.map.has(key))&#123;</span><br><span class="line">        let temp=this.map.get(key)</span><br><span class="line">         this.map.delete(key);</span><br><span class="line">         this.map.set(key, temp);</span><br><span class="line">         return temp</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return -1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LRUCache.prototype.put = function(key, value) &#123;</span><br><span class="line">    if(this.map.has(key))&#123;</span><br><span class="line">        this.map.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">    this.map.set(key,value);</span><br><span class="line">    if(this.map.size &gt; this.capacity)&#123;</span><br><span class="line">     </span><br><span class="line">        this.map.delete(this.map.keys().next().value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="380-O-1-时间插入、删除和获取随机元素"><a href="#380-O-1-时间插入、删除和获取随机元素" class="headerlink" title="380.O(1) 时间插入、删除和获取随机元素"></a>380.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1/">O(1) 时间插入、删除和获取随机元素</a></h3><p>实现RandomizedSet 类：</p>
<p>RandomizedSet() 初始化 RandomizedSet 对象<br>bool insert(int val) 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false 。<br>bool remove(int val) 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。<br>int getRandom() 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。<br>你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 O(1) 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">[&quot;RandomizedSet&quot;, &quot;insert&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;]</span><br><span class="line">[[], [1], [2], [2], [], [1], [2], []]</span><br><span class="line">输出</span><br><span class="line">[null, true, false, true, 2, true, false, 2]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">RandomizedSet randomizedSet = new RandomizedSet();</span><br><span class="line">randomizedSet.insert(1); // 向集合中插入 1 。返回 true 表示 1 被成功地插入。</span><br><span class="line">randomizedSet.remove(2); // 返回 false ，表示集合中不存在 2 。</span><br><span class="line">randomizedSet.insert(2); // 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。</span><br><span class="line">randomizedSet.getRandom(); // getRandom 应随机返回 1 或 2 。</span><br><span class="line">randomizedSet.remove(1); // 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。</span><br><span class="line">randomizedSet.insert(2); // 2 已在集合中，所以返回 false 。</span><br><span class="line">randomizedSet.getRandom(); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https://leetcode-cn.com/problems/insert-delete-getrandom-o1</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h4 id="利用map进行设计，利用水塘抽样算法实现等概率"><a href="#利用map进行设计，利用水塘抽样算法实现等概率" class="headerlink" title="利用map进行设计，利用水塘抽样算法实现等概率"></a>利用map进行设计，利用水塘抽样算法实现等概率</h4><p>但是随机获取 时间复杂度不是O1,而是O(n)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">var RandomizedSet = function() &#123;</span><br><span class="line">  this.hash = new Map()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RandomizedSet.prototype.insert = function(val) &#123;</span><br><span class="line">  if (this.hash.has(val)) &#123;</span><br><span class="line">    return false</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    this.hash.set(val, true)</span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RandomizedSet.prototype.remove = function(val) &#123;</span><br><span class="line">  if (this.hash.has(val)) &#123;</span><br><span class="line">    this.hash.delete(val)</span><br><span class="line">    return true</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RandomizedSet.prototype.getRandom = function() &#123;</span><br><span class="line">  let count = 1;</span><br><span class="line">  let iterator = this.hash.keys();</span><br><span class="line">  let result = null;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    const &#123; value, done &#125; = iterator.next()</span><br><span class="line">    if (done) &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    if (Math.floor(Math.random() * count) === 0) &#123;</span><br><span class="line">      result = value</span><br><span class="line">    &#125;</span><br><span class="line">    count++</span><br><span class="line">  &#125;</span><br><span class="line">  return result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="利用hash实现O1存储删除，数组实现O1等概率访问"><a href="#利用hash实现O1存储删除，数组实现O1等概率访问" class="headerlink" title="利用hash实现O1存储删除，数组实现O1等概率访问"></a>利用hash实现O1存储删除，数组实现O1等概率访问</h4><p>难点还是在于理解和设计，熟悉数据结构的基础方法时间复杂度</p>
<blockquote>
<p>删除的前提是访问</p>
<p>数组某个元素和尾部交换后删除，O1</p>
<p>数组push 01</p>
<p>代码重点在于交换时，hash对应的index也需要考虑</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">var RandomizedSet = function() &#123;</span><br><span class="line">  this.hash = Object.create(null, &#123;&#125;)</span><br><span class="line">  this.array = []</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RandomizedSet.prototype.insert = function(val) &#123;</span><br><span class="line">  if (typeof this.hash[val] !== &quot;undefined&quot;) &#123;</span><br><span class="line">    return false</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    this.array.push(val)</span><br><span class="line">    // 存储位置</span><br><span class="line">    this.hash[val] = this.array.length - 1</span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RandomizedSet.prototype.remove = function(val) &#123;</span><br><span class="line">  if (typeof this.hash[val] !== &quot;undefined&quot;) &#123;</span><br><span class="line">    // 待删除元素的索引</span><br><span class="line">    const index = this.hash[val]</span><br><span class="line">    // 对末尾元素进行操作</span><br><span class="line">    const tailValue = this.array[this.array.length - 1]</span><br><span class="line">    this.hash[tailValue] = index</span><br><span class="line">    this.array[index] = tailValue</span><br><span class="line">    // 删除</span><br><span class="line">    this.array.pop()</span><br><span class="line">    delete this.hash[val]</span><br><span class="line">    return true</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RandomizedSet.prototype.getRandom = function() &#123;</span><br><span class="line">  return this.array[Math.floor(Math.random()*this.array.length)]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-queue-using-stacks/solution/tu-jie-guan-fang-tui-jian-ti-jie-yong-zh-4hru/">题解简单易懂</a>，主要是需要搞懂push pop穿插如果保证有序性就可以了,pop必须一次性从inStack全部转移过来才能保持顺序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var MyQueue = function() &#123;</span><br><span class="line">  this.inStack = []</span><br><span class="line">  this.outStack = []</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyQueue.prototype.push = function(x) &#123;</span><br><span class="line">  this.inStack.push(x)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyQueue.prototype.pop = function() &#123;</span><br><span class="line">  if(!this.outStack.length)&#123;</span><br><span class="line">    while(this.inStack.length)&#123;</span><br><span class="line">      this.outStack.push(</span><br><span class="line">        this.inStack.pop()</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return this.outStack.pop()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyQueue.prototype.peek = function() &#123;</span><br><span class="line">  if(!this.outStack.length)&#123;</span><br><span class="line">    while(this.inStack.length)&#123;</span><br><span class="line">      this.outStack.push(</span><br><span class="line">        this.inStack.pop()</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return this.outStack[this.outStack.length-1]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyQueue.prototype.empty = function() &#123;</span><br><span class="line">  return !this.inStack.length &amp;&amp; !this.outStack.length</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h3><p>请你仅使用<strong>两个队列</strong>实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p>
<p>实现 MyStack 类：</p>
<p>void push(int x) 将元素 x 压入栈顶。<br>int pop() 移除并返回栈顶元素。<br>int top() 返回栈顶元素。<br>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var MyStack = function() &#123;</span><br><span class="line">  this.list = []</span><br><span class="line">  this.tempList = []</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyStack.prototype.push = function(x) &#123;</span><br><span class="line">  if(this.list.length)&#123;</span><br><span class="line">    while(this.list.length)&#123;</span><br><span class="line">      this.tempList.push(this.list.shift())</span><br><span class="line">    &#125;</span><br><span class="line">    this.list.push(x)</span><br><span class="line">    while(this.tempList.length)&#123;</span><br><span class="line">      this.list.push(this.tempList.shift())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    this.list.push(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyStack.prototype.pop = function() &#123;</span><br><span class="line">  return this.list.shift()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyStack.prototype.top = function() &#123;</span><br><span class="line">  return this.list[0]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyStack.prototype.empty = function() &#123;</span><br><span class="line">  return !this.list.length</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E9%93%BE%E8%A1%A8/" class="post-title-link" itemprop="url">leetCode刷题记录-链表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-13 14:58:01" itemprop="dateCreated datePublished" datetime="2024-07-13T14:58:01+08:00">2024-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">刷题记录</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="206-反转链表-简单"><a href="#206-反转链表-简单" class="headerlink" title="206.反转链表 -简单"></a>206.反转链表 -简单</h3><h4 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h4><p>使用迭代方法，我可以做出来，但是不太完美，代码不够精简</p>
<h5 id="自己的代码"><a href="#自己的代码" class="headerlink" title="自己的代码"></a>自己的代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var reverseList = function(head) &#123;</span><br><span class="line">    if(!head)&#123; // 这个判断多余了</span><br><span class="line">        return head</span><br><span class="line">    &#125;</span><br><span class="line">    let prev = null // 这个利用了哨兵，简化了判断</span><br><span class="line">    while(head)&#123; // 判断条件很重要</span><br><span class="line">        const next = head.next</span><br><span class="line">        head.next = prev</span><br><span class="line">        if(!next)&#123;</span><br><span class="line">            return head</span><br><span class="line">        &#125;</span><br><span class="line">        prev = head</span><br><span class="line">        head = next</span><br><span class="line">    &#125;</span><br><span class="line">    return head // return pre 就不用判断next了</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="优秀代码"><a href="#优秀代码" class="headerlink" title="优秀代码"></a>优秀代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var reverseList = function (head) &#123;</span><br><span class="line">    var pre = null, cur = head, next;</span><br><span class="line">    while (cur) &#123; // 用cur取代head 迭代过程更加清晰</span><br><span class="line">      next = cur.next;</span><br><span class="line">      cur.next = pre;</span><br><span class="line">      </span><br><span class="line">      pre = cur;</span><br><span class="line">      cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre;</span><br><span class="line">  &#125;; </span><br></pre></td></tr></table></figure>

<p>少了两步判断，注意细节</p>
<h4 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h4><h5 id="自己的代码-1"><a href="#自己的代码-1" class="headerlink" title="自己的代码"></a>自己的代码</h5><p>条件重复了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var reverseList = function(head) &#123;</span><br><span class="line">    if(!head)&#123; // 这个其实和下边的条件重复了</span><br><span class="line">        return head</span><br><span class="line">    &#125;</span><br><span class="line">    return df(null, head)</span><br><span class="line">    function df(prev, cur)&#123;</span><br><span class="line">        if(!cur)&#123;</span><br><span class="line">            return prev</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            const next = cur.next</span><br><span class="line">            cur.next = prev</span><br><span class="line">            return df(cur, next)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="优秀代码-1"><a href="#优秀代码-1" class="headerlink" title="优秀代码"></a>优秀代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var reverseList = function (head) &#123;</span><br><span class="line">  function df(pre, cur) &#123;</span><br><span class="line">    if (cur === null) &#123;</span><br><span class="line">      return pre;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      var temp = cur.next;</span><br><span class="line">      cur.next = pre;</span><br><span class="line">      return df(cur, temp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return df(null, head);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="单参数递归-需要重点理解"><a href="#单参数递归-需要重点理解" class="headerlink" title="单参数递归-&#x3D;&#x3D;需要重点理解&#x3D;&#x3D;"></a>单参数递归-&#x3D;&#x3D;需要重点理解&#x3D;&#x3D;</h5><p>可以被称为前置递归，而上边那种可以叫做后置递归</p>
<p>这种递归处理 从尾部开始处理，一步步向头部靠近，不太容易理解，需要重点关注</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var reverseList = function (head) &#123;</span><br><span class="line"> function df(head) &#123;</span><br><span class="line">    if (!head || head.next === null) &#123;</span><br><span class="line">      return head;</span><br><span class="line">    &#125;</span><br><span class="line">    const last = df(head.next)</span><br><span class="line">    head.next.next = head</span><br><span class="line">    head.next = null</span><br><span class="line">    return last</span><br><span class="line">  &#125;</span><br><span class="line">  return df(head);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个算法常常拿来显示递归的巧妙和优美</p>
</blockquote>
<h6 id="重点理解"><a href="#重点理解" class="headerlink" title="重点理解"></a>重点理解</h6><p>这个方法很难理解，一篇文章写的很好<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484467&idx=1&sn=beb3ae89993b812eeaa6bbdeda63c494&chksm=9bd7fa3baca0732dc3f9ae9202ecaf5c925b4048514eeca6ac81bc340930a82fc62bb67681fa&scene=21#wechat_redirect">labuladong</a>，在这里摘抄一部分重要的内容</p>
<h6 id="原文如下"><a href="#原文如下" class="headerlink" title="原文如下"></a>原文如下</h6><p>这个算法可能很多读者都听说过，这里详细介绍一下，先直接看实现代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ListNode reverse(ListNode head) &#123;</span><br><span class="line">    if (head.next == null) return head;</span><br><span class="line">    ListNode last = reverse(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = null;</span><br><span class="line">    return last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来是不是感觉不知所云，完全不能理解这样为什么能够反转链表？这就对了，这个算法常常拿来显示递归的巧妙和优美，我们下面来详细解释一下这段代码。</p>
<p>**&#x3D;&#x3D;对于递归算法，最重要的就是明确递归函数的定义&#x3D;&#x3D;**。</p>
<p>除原文之外，还有几个容易遗漏而且比较<strong>重要的点</strong></p>
<ul>
<li><strong>last的指向一直未变</strong></li>
<li><strong>函数的截止条件和只有一个listNode的情况一样</strong>（也许这也是递归的魅力吧）</li>
<li><strong>head的指向由于是栈结构，所以前置运行的时候head是倒着的</strong></li>
<li><strong>前置递归能不能看成是一种倒叙迭代呢？，利用栈的特效进行倒叙操作</strong></li>
</ul>
<p>具体来说，我们的<code>reverse</code>函数定义是这样的：</p>
<p><strong>输入一个节点<code>head</code>，将「以<code>head</code>为起点」的链表反转，并返回反转之后的头结点</strong>。</p>
<p>明白了函数的定义，再来看这个问题。比如说我们想反转这个链表：</p>
<p><img src="/md-images/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/assets/%E9%93%BE%E8%A1%A8/640-20211019112839879.png" alt="图片"></p>
<p>那么输入<code>reverse(head)</code>后，会在这里进行递归：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ListNode last = reverse(head.next);</span><br></pre></td></tr></table></figure>

<p>不要跳进递归（你的脑袋能压几个栈呀？），而是要根据刚才的函数定义，来弄清楚这段代码会产生什么结果：</p>
<p><img src="/md-images/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/assets/%E9%93%BE%E8%A1%A8/640-20211019112840006.png" alt="图片"></p>
<p>按照定义，这个<code>reverse(head.next)</code>执行完成后，整个链表应该变成了这样：</p>
<p><img src="/md-images/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/assets/%E9%93%BE%E8%A1%A8/640.png" alt="图片"></p>
<p>并且根据函数定义，<code>reverse</code>函数会返回反转之后的头结点，我们用变量<code>last</code>接收了。</p>
<p>现在再来看下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head.next.next = head;</span><br></pre></td></tr></table></figure>

<p><img src="/md-images/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/assets/%E9%93%BE%E8%A1%A8/640-20211019112839982.png" alt="图片"></p>
<p>接下来进行的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head.next = null;</span><br><span class="line">return last;</span><br></pre></td></tr></table></figure>

<p><img src="/md-images/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/assets/%E9%93%BE%E8%A1%A8/640-20211019112839935.png" alt="图片"></p>
<p>神不神奇，这样整个链表就反转过来了！递归代码就是这么简洁优雅，不过其中有两个地方需要注意：</p>
<p><strong>1、递归函数要有 base case</strong>，也就是这句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (head.next == null) return head;</span><br></pre></td></tr></table></figure>

<p>意思是如果链表只有一个节点的时候反转也是它自己，直接返回即可。</p>
<p><strong>2、当链表递归反转之后，新的头节点是<code>last</code>，而之前的<code>head</code>变成了最后一个节点，别忘了链表的末尾要指向 null：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head.next = null;</span><br></pre></td></tr></table></figure>

<h6 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h6><p>虽然按照他的说法，代码理解起来确实简单了一些，但是怎么把代码写出来是个问题。</p>
<p>针对过程做一个代码示意</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null</span><br><span class="line">var reverseList = function (head) &#123;</span><br><span class="line"> function df(head) &#123;</span><br><span class="line">    if (!head || head.next === null) &#123;</span><br><span class="line">      return head;</span><br><span class="line">    &#125;</span><br><span class="line">    const last = df(head.next)</span><br><span class="line">    head.next.next = head</span><br><span class="line">    head.next = null</span><br><span class="line">    return last</span><br><span class="line">  &#125;</span><br><span class="line">  return df(head);</span><br><span class="line">&#125;;</span><br><span class="line">// 模拟代码运行步骤</span><br><span class="line">df(1)</span><br><span class="line">df(2)</span><br><span class="line">df(3)</span><br><span class="line">df(4)</span><br><span class="line">df(5) // 满足条件 开始return 开始运行df函数后面的代码</span><br><span class="line">// 第一次执行df后代码</span><br><span class="line">// last 5</span><br><span class="line">// head 4-&gt;5-&gt;null </span><br><span class="line">head.next.next = head // 5-&gt;4 </span><br><span class="line">head.next = null // 4-&gt;null</span><br><span class="line">// 执行完成后</span><br><span class="line">// last 5-&gt;4-&gt;null</span><br><span class="line">return last </span><br><span class="line"></span><br><span class="line">// 第二次执行</span><br><span class="line">// last 5-&gt;4-&gt;null</span><br><span class="line">// head 3-&gt;4</span><br><span class="line">head.next.next = head // 4-&gt;3</span><br><span class="line">head.next = null // 3-&gt;null</span><br><span class="line">// 执行完成后</span><br><span class="line">// last 5-&gt;4-&gt;3-&gt;null</span><br><span class="line">return last</span><br><span class="line"></span><br><span class="line">// 第三次执行</span><br><span class="line">// last 5-&gt;4-&gt;3-&gt;null</span><br><span class="line">// head 2-&gt;3</span><br><span class="line">head.next.next = head // 3-&gt;2</span><br><span class="line">head.next = null // 2-&gt;null</span><br><span class="line">// 执行完成后</span><br><span class="line">// last 5-&gt;4-&gt;3-&gt;2-&gt;null</span><br><span class="line">return last</span><br><span class="line"></span><br><span class="line">// 第四次执行</span><br><span class="line">// last 5-&gt;4-&gt;3-&gt;2-&gt;null</span><br><span class="line">// head 1-&gt;2</span><br><span class="line">head.next.next = head // 2-&gt;1</span><br><span class="line">head.next = null // 1-&gt;null</span><br><span class="line">// 执行完成后</span><br><span class="line">// last 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;null</span><br><span class="line">return last</span><br><span class="line">// 整体结束</span><br></pre></td></tr></table></figure>

<h3 id="92-反转链表2-困难"><a href="#92-反转链表2-困难" class="headerlink" title="92.反转链表2 困难"></a>92.反转链表2 困难</h3><p>官方头穿法容易理解，labuladong 公众号文章 较难理解</p>
<h4 id="自己的代码-2"><a href="#自己的代码-2" class="headerlink" title="自己的代码"></a>自己的代码</h4><p>虽然头穿法理解起来容易，但是写起来需要仔细和不断试错，还需要照顾边界情况</p>
<p>代码中需要注意一下几点</p>
<ul>
<li>使用了哨兵，方便left为1的情况，使用了哨兵，返回的时候需要注意处理</li>
<li>cur情况不同 赋值的方式也不同</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var reverseBetween = function(head, left, right) &#123;</span><br><span class="line">    const dmNode = new ListNode(-1, head)</span><br><span class="line">    let cur = dmNode</span><br><span class="line">    let pre = null</span><br><span class="line">    let leftNode = null</span><br><span class="line">    let index = 0</span><br><span class="line">    while(cur)&#123;</span><br><span class="line">      if(index === right+1)&#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      if(index===left-1)&#123;</span><br><span class="line">        leftNode = cur</span><br><span class="line">        pre = cur.next</span><br><span class="line"></span><br><span class="line">        cur = cur.next</span><br><span class="line">      &#125;else if(index &gt; left)&#123;</span><br><span class="line">        const leftNodeNext = leftNode.next</span><br><span class="line">        pre.next = cur.next</span><br><span class="line">        leftNode.next = cur</span><br><span class="line">        cur.next = leftNodeNext</span><br><span class="line">        cur = pre.next</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        cur = cur.next</span><br><span class="line">      &#125;</span><br><span class="line">      index++</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    return dmNode.next</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="优秀代码-2"><a href="#优秀代码-2" class="headerlink" title="优秀代码"></a>优秀代码</h4><p>官方代码 采取的分断式处理-for循环分段，逻辑较为清晰，ye</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var reverseBetween = function(head, left, right) &#123;</span><br><span class="line">    // 设置 dummyNode 是这一类问题的一般做法</span><br><span class="line">    const dummy_node = new ListNode(-1);</span><br><span class="line">    dummy_node.next = head;</span><br><span class="line">    let pre = dummy_node;</span><br><span class="line">    for (let i = 0; i &lt; left - 1; ++i) &#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let cur = pre.next;</span><br><span class="line">    for (let i = 0; i &lt; right - left; ++i) &#123;</span><br><span class="line">        const next = cur.next;</span><br><span class="line">        cur.next = next.next;</span><br><span class="line">        next.next = pre.next;</span><br><span class="line">        pre.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummy_node.next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode-solut-teyq/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h3 id="234-如何判断回文链表"><a href="#234-如何判断回文链表" class="headerlink" title="234.如何判断回文链表"></a>234.如何判断回文链表</h3><h4 id="自己的代码-3"><a href="#自己的代码-3" class="headerlink" title="自己的代码"></a>自己的代码</h4><p>缺点无法提前结束</p>
<p>时间 空间都是O n</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var isPalindrome = function (head) &#123;</span><br><span class="line">  let left = right = head;</span><br><span class="line">  let flag = true</span><br><span class="line">  function df(head)&#123;</span><br><span class="line">    if(!head)&#123;</span><br><span class="line">      return head</span><br><span class="line">    &#125;</span><br><span class="line">    df(head.next)</span><br><span class="line">    if(head.val !== left.val)&#123;</span><br><span class="line">      flag = false</span><br><span class="line">      return </span><br><span class="line">    &#125;</span><br><span class="line">    left = left.next</span><br><span class="line">  &#125;</span><br><span class="line">  df(right)</span><br><span class="line">  return flag</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p>通过双指针判断中间节点，翻转后半段并进行比较</p>
<p>时间 空间都是O n</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">var isPalindrome = function (head) &#123;</span><br><span class="line"> // 特殊情况</span><br><span class="line">  if(!head || !head.next)&#123;</span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line">  let slow = fast = head;</span><br><span class="line">  while (fast &amp;&amp; fast.next) &#123;</span><br><span class="line">    slow = slow.next</span><br><span class="line">    fast = fast.next.next</span><br><span class="line">  &#125;</span><br><span class="line">  // 区别单双链表</span><br><span class="line">  if (fast !== null) &#123;</span><br><span class="line">    slow = slow.next</span><br><span class="line">  &#125;</span><br><span class="line">  let right = reserve(slow)</span><br><span class="line">  // 注意结束条件 right比较短</span><br><span class="line">  while (right) &#123;</span><br><span class="line">    if (right.val !== head.val) &#123;</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line">    right = right.next</span><br><span class="line">    head = head.next</span><br><span class="line">  &#125;</span><br><span class="line">  return true</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function reserve(head) &#123;</span><br><span class="line">  if (!head.next) &#123;</span><br><span class="line">    return head</span><br><span class="line">  &#125;</span><br><span class="line">  const newHead = reserve(head.next)</span><br><span class="line">  head.next.next = head</span><br><span class="line">  head.next = null</span><br><span class="line">  return newHead</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="142-环形链表-2"><a href="#142-环形链表-2" class="headerlink" title="142.环形链表 2"></a>142.环形链表 2</h3><h4 id="利用hash可以很方便的解决"><a href="#利用hash可以很方便的解决" class="headerlink" title="利用hash可以很方便的解决"></a>利用hash可以很方便的解决</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var detectCycle = function(head) &#123;</span><br><span class="line">    const set = new Set();</span><br><span class="line">    while(head &amp;&amp; !set.has(head))&#123;</span><br><span class="line">      set.add(head)</span><br><span class="line">      head = head.next</span><br><span class="line">    &#125;</span><br><span class="line">    return head</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里和回文链表不一样，没有比较listNode.val</p>
</blockquote>
<h4 id="利用快慢指针"><a href="#利用快慢指针" class="headerlink" title="利用快慢指针"></a>利用快慢指针</h4><p>条件放的位置需要格外注意</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var detectCycle = function(head) &#123;</span><br><span class="line">    let slow = fast = head;</span><br><span class="line">    while(fast &amp;&amp; fast.next)&#123;</span><br><span class="line">      slow = slow.next</span><br><span class="line">      fast = fast.next.next</span><br><span class="line">      // 刚开始位置放错了</span><br><span class="line">      if(slow === fast)&#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!fast || !fast.next)&#123;</span><br><span class="line">      return null</span><br><span class="line">    &#125;</span><br><span class="line">    slow = head</span><br><span class="line">    while(slow !== fast)&#123;</span><br><span class="line">      slow = slow.next</span><br><span class="line">      fast = fast.next</span><br><span class="line">    &#125;</span><br><span class="line">    return slow</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="快慢指针可行性推导"><a href="#快慢指针可行性推导" class="headerlink" title="快慢指针可行性推导"></a>快慢指针可行性推导</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode-solution/">https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode-solution/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">解释：为何慢指针第一圈走不完一定会和快指针相遇, 很精彩的推论</span><br><span class="line"> 首先，第一步，快指针先进入环 </span><br><span class="line"> 第二步：当慢指针刚到达环的入口时，快指针此时在环中的某个位置(也可能此时相遇) </span><br><span class="line"> 第三步：设此时快指针和慢指针距离为x，若在第二步相遇，则x = 0； </span><br><span class="line"> 第四步：设环的周长为n，那么看成快指针追赶慢指针，需要追赶n-x； </span><br><span class="line"> 第五步：快指针每次都追赶慢指针1个单位，设慢指针速度1/s，快指针2/s，那么追赶需要(n-x)s </span><br><span class="line"> 第六步：在n-x秒内，慢指针走了n-x单位，因为x&gt;=0，则慢指针走的路程小于等于n，即走不完一圈就和快指针相遇</span><br></pre></td></tr></table></figure>

<h3 id="剑指offer-II-023"><a href="#剑指offer-II-023" class="headerlink" title="剑指offer II 023"></a>剑指offer II 023</h3><p>自己的代码,暴力法 Om*n，这里需要注意一个细节，内层while需要重置条件，可能是for循环用多了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var getIntersectionNode = function(headA, headB) &#123;</span><br><span class="line">    let pA = headA,pB;</span><br><span class="line">    while(pA)&#123;</span><br><span class="line">      pB = headB</span><br><span class="line">      while(pB)&#123;</span><br><span class="line">        if(pB === pA)&#123;</span><br><span class="line">          console.log(pA)</span><br><span class="line">          return pA;</span><br><span class="line">        &#125;</span><br><span class="line">        pB = pB.next</span><br><span class="line">      &#125;</span><br><span class="line">      pA = pA.next</span><br><span class="line">    &#125;</span><br><span class="line">    return null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>官方解法，建议看<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3u1WK4/solution/tu-jie-shuang-zhi-zhen-javascript-by-lzx-i6yo/">题解</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const getIntersectionNode = (A, B) =&gt; &#123;</span><br><span class="line">    let pA = A,</span><br><span class="line">        pB = B;</span><br><span class="line">    while (pA !== pB) &#123;</span><br><span class="line">        pA = pA === null ? B : pA.next;</span><br><span class="line">        pB = pB === null ? A : pB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return pA;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E4%BA%8C%E5%88%86%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E4%BA%8C%E5%88%86%E6%B3%95/" class="post-title-link" itemprop="url">leetCode刷题记录-链表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-13 14:57:56" itemprop="dateCreated datePublished" datetime="2024-07-13T14:57:56+08:00">2024-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">刷题记录</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>关于二分查找，可以看<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485044&idx=1&sn=e6b95782141c17abe206bfe2323a4226&chksm=9bd7f87caca0716aa5add0ddddce0bfe06f1f878aafb35113644ebf0cf0bfe51659da1c1b733&scene=21#wechat_redirect">labuladong</a>，或者是极客王铮的算法课15 16</p>
<p>王铮总结的左右边界 要比公众号好记的多</p>
<h3 id="704-二分查找-基础题"><a href="#704-二分查找-基础题" class="headerlink" title="704.二分查找 基础题"></a>704.二分查找 基础题</h3><p>最基础的一个二分查找</p>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<p>你可以假设 nums 中的所有元素是不重复的。<br>n 将在 [1, 10000]之间。<br>nums 的每个元素都将在 [-9999, 9999]之间。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-search">https://leetcode-cn.com/problems/binary-search</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>自己的代码,含有4个二分法变种</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">// 正常二分法</span><br><span class="line">var search = function(nums, target) &#123;</span><br><span class="line">  let left = 0, right = nums.length - 1;</span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    const mid = left + ((right - left) &gt;&gt; 1);</span><br><span class="line">    if (nums[mid] &gt; target) &#123;</span><br><span class="line">      right = mid - 1;</span><br><span class="line">    &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">      left = mid + 1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return mid</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1</span><br><span class="line">&#125;;</span><br><span class="line">// 含有重复元素 找到第一个等于target的数</span><br><span class="line">var search = function(nums, target) &#123;</span><br><span class="line">  let left = 0, right = nums.length - 1;</span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    const mid = left + ((right - left) &gt;&gt; 1);</span><br><span class="line">    if (nums[mid] &gt; target) &#123;</span><br><span class="line">      right = mid - 1;</span><br><span class="line">    &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">      left = mid + 1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (mid === 0 || nums[mid - 1] !== target) &#123;</span><br><span class="line">        return mid</span><br><span class="line">      &#125;</span><br><span class="line">      right = mid - 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1</span><br><span class="line">&#125;;</span><br><span class="line">// 含有重复元素 找到最后一个等于target的数</span><br><span class="line">var search = function(nums, target) &#123;</span><br><span class="line">  let left = 0, right = nums.length - 1;</span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    const mid = left + ((right - left) &gt;&gt; 1);</span><br><span class="line">    if (nums[mid] &gt; target) &#123;</span><br><span class="line">      right = mid - 1;</span><br><span class="line">    &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">      left = mid + 1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (mid === nums.length - 1 || nums[mid + 1] !== target) &#123;</span><br><span class="line">        return mid</span><br><span class="line">      &#125;</span><br><span class="line">      left = mid + 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1</span><br><span class="line">&#125;;</span><br><span class="line">// 含有重复元素 查找第一个大于等于给定值的元素</span><br><span class="line">var search = function(nums, target) &#123;</span><br><span class="line">  let left = 0, right = nums.length - 1;</span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    const mid = left + ((right - left) &gt;&gt; 1);</span><br><span class="line">    if (nums[mid] &gt;= target) &#123;</span><br><span class="line">      if (mid === 0 || nums[mid - 1] &lt; target) &#123;</span><br><span class="line">        return mid</span><br><span class="line">      &#125;</span><br><span class="line">      right = mid - 1</span><br><span class="line">    &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">      left = mid + 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1</span><br><span class="line">&#125;;</span><br><span class="line">// 含有重复元素 查找最后一个小于等于给定值的元素</span><br><span class="line">var search = function(nums, target) &#123;</span><br><span class="line">  let left = 0, right = nums.length - 1;</span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    const mid = left + ((right - left) &gt;&gt; 1);</span><br><span class="line">    if (nums[mid] &gt; target) &#123;</span><br><span class="line">      right = mid - 1;</span><br><span class="line">    &#125; else if (nums[mid] &lt;= target) &#123;</span><br><span class="line">      if (mid === nums.length - 1 || nums[mid + 1] &gt; target) &#123;</span><br><span class="line">        return mid</span><br><span class="line">      &#125;</span><br><span class="line">      left = mid + 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33.搜索旋转排序数组"></a>33.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">搜索旋转排序数组</a></h3><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p>
<p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p>
<p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p>
<p>需要注意的细节很多很多，一般看着官方题解和代码，慢慢调试才写了出来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var search = function(nums, target) &#123;</span><br><span class="line">  let left = 0,right = nums.length - 1, n = nums.length;</span><br><span class="line">  if (!n) &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  if (n == 1) &#123;</span><br><span class="line">      return nums[0] == target ? 0 : -1;</span><br><span class="line">  &#125;</span><br><span class="line">  while(left &lt;= right)&#123;</span><br><span class="line">    // 两种写法都能过</span><br><span class="line">    const mid = (right + left) &gt;&gt; 1;</span><br><span class="line">    const mid = left + ((right - left) &gt;&gt; 1);</span><br><span class="line">    if(nums[mid] === target)&#123;</span><br><span class="line">      return mid</span><br><span class="line">    &#125;else if(nums[left] &lt;= nums[mid])&#123;</span><br><span class="line">      // 细节一，必须保证target 在左右区间</span><br><span class="line">      // 普通二分法 只需要一个就够了，那是因为target 必然在有序的left-right之间</span><br><span class="line">      // 细节二 小于等于 等于不能忘</span><br><span class="line">      if(nums[mid] &gt; target &amp;&amp; nums[left] &lt;= target)&#123;</span><br><span class="line">        right = mid - 1</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        left = mid + 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      if(nums[mid] &lt; target &amp;&amp; target &lt;= nums[right])&#123;</span><br><span class="line">        left = mid + 1</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        right = mid - 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">  return -1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167.两数之和 II - 输入有序数组"></a>167.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">两数之和 II - 输入有序数组</a></h3><p>给定一个已按照 非递减顺序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。</p>
<p>函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;&#x3D; answer[0] &lt; answer[1] &lt;&#x3D; numbers.length 。</p>
<p>你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted">https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="自己的代码"><a href="#自己的代码" class="headerlink" title="自己的代码"></a>自己的代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var twoSum = function(numbers, target) &#123;</span><br><span class="line">  const l = numbers.length;</span><br><span class="line">  for(let i = 0; i&lt;l-1;i++)&#123;</span><br><span class="line">    const result = getIndex(i+1, target - numbers[i]);</span><br><span class="line">    if(result)&#123;</span><br><span class="line">      return result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  function getIndex(i, target)&#123;</span><br><span class="line">    let left = i, right = l - 1;</span><br><span class="line">    while(left &lt;= right)&#123;</span><br><span class="line">      const mid = left + ((right - left) &gt;&gt; 1);</span><br><span class="line">      if(numbers[mid] === target) &#123;</span><br><span class="line">        return [i, mid+1]</span><br><span class="line">      &#125;else if(numbers[mid]&gt;target)&#123;</span><br><span class="line">        right = mid - 1</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        left = mid +1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>稍微优化了一下，把函数体放入循环里</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var twoSum = function(numbers, target) &#123;</span><br><span class="line">  const l = numbers.length;</span><br><span class="line">  for(let i = 0; i&lt;l-1;i++)&#123;</span><br><span class="line">    const result = target - numbers[i];</span><br><span class="line">    let left = i+1, right = l - 1;</span><br><span class="line">    while(left &lt;= right)&#123;</span><br><span class="line">      const mid = left + ((right - left) &gt;&gt; 1);</span><br><span class="line">      if(numbers[mid] === result) &#123;</span><br><span class="line">        return [i+1, mid+1]</span><br><span class="line">      &#125;else if(numbers[mid]&gt;result)&#123;</span><br><span class="line">        right = mid - 1</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        left = mid +1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​ </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mst123.github.io/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8D%95%E8%B0%83%E6%A0%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/luopo.gif">
      <meta itemprop="name" content="马农">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8D%95%E8%B0%83%E6%A0%88/" class="post-title-link" itemprop="url">leetCode刷题记录-单调栈</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-13 14:57:47" itemprop="dateCreated datePublished" datetime="2024-07-13T14:57:47+08:00">2024-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">刷题记录</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>单调栈实际上就是栈，只是利用了一些巧妙的逻辑，使得每次新元素入栈后，栈内的元素都保持有序（单调递增或单调递减）。</p>
<p>听起来有点像堆（heap）？不是的，单调栈用途不太广泛，只处理一种典型的问题，叫做 Next Greater Element。</p>
<h3 id="先来一道基础题"><a href="#先来一道基础题" class="headerlink" title="先来一道基础题"></a>先来一道基础题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给一个数组，返回一个大小相同的数组。返回的数组的第i个位置的值应当是，对于原数组中的第i个元素，至少往右走多少步，才能遇到一个比自己大的元素（如果之后没有比自己大的元素，或者已经是最后一个元素，则在返回数组的对应位置放上-1）。</span><br><span class="line"></span><br><span class="line">例如给定数组为：[2,1,5,6,2,3]</span><br><span class="line">返回数组应该为：[2,1,1,-1,1,-1]</span><br></pre></td></tr></table></figure>

<h4 id="正序"><a href="#正序" class="headerlink" title="正序"></a>正序</h4><p>建议自己再画一遍示意图，根据代码画，还是比较容易理解的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const arr1 = [2, 1, 5, 6, 2, 3];</span><br><span class="line">function countSteps(arr) &#123;</span><br><span class="line">  // 用栈存储下标</span><br><span class="line">  const stack = [];</span><br><span class="line">  const result = Array(arr.length).fill(-1);</span><br><span class="line">  for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    while (stack.length &amp;&amp; arr[i] &gt; arr[stack[stack.length - 1]]) &#123;</span><br><span class="line">      result[stack.pop()] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(countSteps(arr1));</span><br><span class="line">[ 5, 5, 6, -1, 3, -1 ]</span><br></pre></td></tr></table></figure>

<p><img src="/md-images/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/assets/%E5%8D%95%E8%B0%83%E6%A0%88/151635833917_.pic_%E5%89%AF%E6%9C%AC.jpg" alt="151635833917_.pic_副本"></p>
<h4 id="倒叙"><a href="#倒叙" class="headerlink" title="倒叙"></a>倒叙</h4><p>这个讲的比较好，<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484525&idx=1&sn=3d2e63694607fec72455a52d9b15d4e5&chksm=9bd7fa65aca073734df90b45054448e09c14e6e35ad7b778bff62f9bd6c2b4f6e1ca7bc4f844&scene=21#wechat_redirect">labuladong</a></p>
<p>倒叙好像是不用记录下标，因为倒叙处理，每到一个元素，<strong>它的结果都会在此轮遍历中确定，和正序不同</strong>，再多理解理解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const arr2 = [2, 1, 2, 4, 3];</span><br><span class="line">function nextBigElement(arr) &#123;</span><br><span class="line">  const stack = []</span><br><span class="line">  const result = []</span><br><span class="line">  for (let i = arr.length-1; i &gt;=0; i--) &#123;</span><br><span class="line">    while (stack.length &amp;&amp; arr[i] &gt;= stack[stack.length-1]) &#123;</span><br><span class="line">      stack.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    result[i] = stack.length ? stack[stack.length - 1] : -1</span><br><span class="line">    stack.push(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br><span class="line">console.log(nextBigElement(arr2));</span><br></pre></td></tr></table></figure>

<p><img src="/md-images/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/assets/%E5%8D%95%E8%B0%83%E6%A0%88/%E5%9B%BE%E5%83%8F.jpeg" alt="图像"></p>
<h4 id="正序和倒序的一些区别"><a href="#正序和倒序的一些区别" class="headerlink" title="正序和倒序的一些区别"></a>正序和倒序的一些区别</h4><ul>
<li>确定值的时机不同<ul>
<li>倒序在每一轮循环中都可以确认</li>
<li>正序只会在pop时确认</li>
<li>由此造成书写结构和逻辑有些许差异</li>
</ul>
</li>
</ul>
<h3 id="496-下一个更大元素I"><a href="#496-下一个更大元素I" class="headerlink" title="496.下一个更大元素I"></a>496.下一个更大元素I</h3><p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。</p>
<p>请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。</p>
<p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</p>
<p>示例 1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [4,1,2], nums2 = [1,3,4,2].</span><br><span class="line">输出: [-1,3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。</span><br><span class="line">    对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。</span><br><span class="line">    对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [2,4], nums2 = [1,2,3,4].</span><br><span class="line">输出: [3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。</span><br><span class="line">    对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/next-greater-element-i">https://leetcode-cn.com/problems/next-greater-element-i</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h4><p>这道题和基础题基本上一致，多了一个映射的过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var nextGreaterElement = function(nums1, nums2) &#123;</span><br><span class="line">  const map = new Map();</span><br><span class="line">  // 存储数值 而不是位置 因为没有重复元素</span><br><span class="line">  const stack = [];</span><br><span class="line">  for(let i=0;i&lt;nums2.length;i++)&#123;</span><br><span class="line">    // 出栈条件</span><br><span class="line">    while(stack.length &amp;&amp; nums2[i] &gt; stack[stack.length-1]) &#123;</span><br><span class="line">      map.set(stack.pop(), nums2[i])</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(nums2[i])</span><br><span class="line">  &#125;</span><br><span class="line">  return nums1.map(item =&gt; &#123;</span><br><span class="line">    const r = map.get(item);</span><br><span class="line">    return r?r:-1</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739.每日温度"></a>739.每日温度</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">请根据每日 气温 列表 temperatures ，请计算在每一天需要等几天才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: temperatures = [73,74,75,71,69,72,76,73]</span><br><span class="line">输出: [1,1,4,2,1,1,0,0]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里以正序和倒序各写一次，方便理解记忆</p>
<p>正序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var dailyTemperatures = function(temperatures) &#123;</span><br><span class="line">	// 需要预先设置查找不到的情况</span><br><span class="line">	const r = Array(temperatures.length).fill(0)</span><br><span class="line">	// 栈底到栈顶单调递减 **可以等于**</span><br><span class="line">  const stack = []</span><br><span class="line">  // 正序</span><br><span class="line">  for(let i=0;i&lt;temperatures.length;i++)&#123;</span><br><span class="line">  	// 当栈不为空 且 当前温度大于栈顶温度</span><br><span class="line">    while(stack.length &amp;&amp; temperatures[i] &gt; temperatures[stack[stack.length-1]])&#123;</span><br><span class="line">    	// 当前温度大于栈顶温度，即找到了栈顶元素 对应的 符合条件的元素</span><br><span class="line">    	// 弹出栈顶 并记录下标</span><br><span class="line">      const index = stack.pop()</span><br><span class="line">      // 记录栈顶元素的对应的天数</span><br><span class="line">      r[index] = i - index</span><br><span class="line">    &#125;</span><br><span class="line">    // 当栈为空 或者 当前元素**小于等于** 栈顶元素时 入栈</span><br><span class="line">    stack.push(i)</span><br><span class="line">  &#125;</span><br><span class="line">  return r</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>倒序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var dailyTemperatures = function(temperatures) &#123;</span><br><span class="line">  const r = []</span><br><span class="line">  const s = []</span><br><span class="line">  // 倒序</span><br><span class="line">  for(let i=temperatures.length-1;i&gt;=0;i--)&#123;</span><br><span class="line">  	// 当栈不为空 且 当前元素**大于等于**栈顶元素</span><br><span class="line">    while(s.length &amp;&amp; temperatures[i] &gt;= temperatures[s[s.length-1]])&#123;</span><br><span class="line">      s.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    r[i] = s.length ? s[s.length-1] - i : 0</span><br><span class="line">    s.push(i)</span><br><span class="line">  &#125;</span><br><span class="line">  return r</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>差异性</strong></p>
<ul>
<li>赋值<ul>
<li><strong>倒序</strong>遍历在while外，每轮遍历赋值一次</li>
<li><strong>正序</strong>每次pop赋值，需要提前准备默认值</li>
</ul>
</li>
<li>大小比较<ul>
<li>倒序<strong>大于等于</strong></li>
<li>正序<strong>大于</strong></li>
</ul>
</li>
</ul>
<h3 id="503-下一个更大元素-II-循环数组"><a href="#503-下一个更大元素-II-循环数组" class="headerlink" title="503.下一个更大元素 II 循环数组"></a>503.下一个更大元素 II 循环数组</h3><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [1,2,1]</span><br><span class="line">输出: [2,-1,2]</span><br><span class="line">解释: 第一个 1 的下一个更大的数是 2；</span><br><span class="line">数字 2 找不到下一个更大的数； </span><br><span class="line">第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="最简单的方式，拼接一个数组在后边"><a href="#最简单的方式，拼接一个数组在后边" class="headerlink" title="最简单的方式，拼接一个数组在后边"></a>最简单的方式，拼接一个数组在后边</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var nextGreaterElements = function(nums) &#123;</span><br><span class="line">  const arr = nums.concat(nums)</span><br><span class="line">  const res = []</span><br><span class="line">  const stack = []</span><br><span class="line">  for(let i=arr.length-1;i&gt;=0;i--)&#123;</span><br><span class="line">    while(stack.length &amp;&amp; arr[i] &gt;= stack[stack.length-1])&#123;</span><br><span class="line">      stack.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    res[i] = stack.length ? stack[stack.length-1] : -1</span><br><span class="line">    stack.push(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  return res.slice(0, nums.length)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种方式，时间复杂度和空间复杂度都比较高</p>
<h4 id="利用取余"><a href="#利用取余" class="headerlink" title="利用取余 %"></a>利用取余 <code>%</code></h4><p>减少了空间复杂度，利用 <strong><code>%</code></strong> 模拟循环数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var nextGreaterElements = function(nums) &#123;</span><br><span class="line">  const result = []</span><br><span class="line">  const stack = []</span><br><span class="line">  const n = nums.length</span><br><span class="line">  for(let i=2*n-1;i&gt;=0;i--)&#123;</span><br><span class="line">    while(stack.length &amp;&amp; nums[i%n] &gt;= stack[stack.length-1])&#123;</span><br><span class="line">      stack.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    result[i%n] = stack.length ? stack[stack.length-1] : -1</span><br><span class="line">    stack.push(nums[i%n])</span><br><span class="line">  &#125;</span><br><span class="line">  return result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="316-去除重复字符串"><a href="#316-去除重复字符串" class="headerlink" title="316.去除重复字符串"></a>316.去除重复字符串</h3><p>建议参考 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247486946&idx=1&sn=94804eb15be33428582544a1cd90da4d&chksm=9bd7f3eaaca07afc6fdfa94d05fa3007d9ecc54914a238e6deabeafd5032a299155505b40f2d&scene=21#wechat_redirect">labuladong</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 困难题</span><br><span class="line">var s = &quot;bcabc&quot;</span><br><span class="line">function handle(string) &#123;</span><br><span class="line">  const stack = []</span><br><span class="line">  const map = new Map()</span><br><span class="line">  const countMap = Object.create(null, &#123;&#125;)</span><br><span class="line">  for (let i = 0; i &lt; string.length; i++) &#123;</span><br><span class="line">    const s = string[i];</span><br><span class="line">    if (countMap[s]) &#123;</span><br><span class="line">      countMap[s]++</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      countMap[s] = 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for (let i = 0; i &lt; string.length; i++) &#123;</span><br><span class="line">    const s = string[i]</span><br><span class="line">    // 何时减法 很重要 重点理解</span><br><span class="line">    countMap[s]--</span><br><span class="line">    // 后边可以删除的</span><br><span class="line">    if (map.has(s)) &#123;</span><br><span class="line">      continue</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果charcode码较小 会把栈顶元素(后面存在重复的) pop掉  </span><br><span class="line">    // 既保证了顺序 也不会删除只有一个的元素</span><br><span class="line">    while (stack.length &amp;&amp; stack[stack.length - 1].charCodeAt(0) &gt; string.charCodeAt(i)) &#123;</span><br><span class="line">      if (countMap[stack[stack.length - 1]] === 0) &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      map.delete(stack.pop())</span><br><span class="line">    &#125;</span><br><span class="line">    map.set(s, true)</span><br><span class="line">    stack.push(s)   </span><br><span class="line">  &#125;</span><br><span class="line">  return stack</span><br><span class="line">&#125;</span><br><span class="line">console.log(handle(s));</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">马农</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
