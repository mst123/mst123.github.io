<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>前言</title>
    <url>/javascript%E5%9F%BA%E7%A1%80/%E5%89%8D%E8%A8%80/</url>
    <content><![CDATA[<p>先占个坑，后期会把 JavaScript权威指南第七版和JavaScript高级程序设计第四版两本书读过一遍以后，写一下<br>可能会一章一章的仔细写，也可能只会写不明白的重点、难点，毕竟这两本书太厚了（笑哭）</p>
]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>javascript基础</tag>
      </tags>
  </entry>
  <entry>
    <title>css中重要的概念</title>
    <url>/CSS/css%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h3 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context">层叠上下文</a></h3><p>文档中的层叠上下文由满足以下任意一个条件的元素形成：</p>
<p><strong>小总结</strong></p>
<p>z-index相关：</p>
<ul>
<li>z-index不为auto<ul>
<li>position 为absolute relative fixed sticky（后两种z-index无限制）</li>
<li>flex grid容器的子元素</li>
</ul>
</li>
<li>新属性css3相关<ul>
<li>transform 变换</li>
<li>filter 过滤器</li>
</ul>
</li>
<li>和性能方面有关系<ul>
<li>will-change</li>
<li>contain</li>
</ul>
</li>
</ul>
<p><strong>详细介绍</strong></p>
<ul>
<li>文档根元素（<code>&lt;html&gt;</code>）；</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position"><code>position</code></a> 值为 <code>absolute</code>（绝对定位）或 <code>relative</code>（相对定位）且 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index"><code>z-index</code></a> 值不为 <code>auto</code> 的元素；</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position"><code>position</code></a> 值为 <code>fixed</code>（固定定位）或 <code>sticky</code>（粘滞定位）的元素（沾滞定位适配所有移动设备上的浏览器，但老的桌面浏览器不支持）；</li>
<li>flex (<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex"><code>flex</code></a>) 容器的子元素，且 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index"><code>z-index</code></a> 值不为 <code>auto</code>；</li>
<li>grid (<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid"><code>grid</code></a>) 容器的子元素，且 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index"><code>z-index</code></a> 值不为 <code>auto</code>；</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/opacity"><code>opacity</code></a> 属性值小于 <code>1</code> 的元素（参见 <a href="https://www.w3.org/TR/css3-color/#transparency">the specification for opacity</a>）；</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/mix-blend-mode"><code>mix-blend-mode</code></a> 属性值不为 <code>normal</code> 的元素；</li>
<li>以下任意属性值不为<code>none</code>的元素：<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform"><code>transform</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter"><code>filter</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/backdrop-filter"><code>backdrop-filter</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/perspective"><code>perspective</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clip-path"><code>clip-path</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/mask"><code>mask</code></a> &#x2F; <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/mask-image"><code>mask-image</code></a> &#x2F; <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/mask-border"><code>mask-border</code></a></li>
</ul>
</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/isolation"><code>isolation</code></a> 属性值为 <code>isolate</code> 的元素；</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/will-change"><code>will-change</code></a> 值设定了任一属性而该属性在 non-initial 值时会创建层叠上下文的元素（参考<a href="https://dev.opera.com/articles/css-will-change-property/">这篇文章</a>）；</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/contain"><code>contain</code></a> 属性值为 <code>layout</code>、<code>paint</code> 或包含它们其中之一的合成值（比如 <code>contain: strict</code>、<code>contain: content</code>）的元素。在层叠上下文中，子元素同样也按照上面解释的规则进行层叠。 重要的是，其子级层叠上下文的 <code>z-index</code>值只在父级中才有意义。子级层叠上下文被自动视为父级层叠上下文的一个独立单元。</li>
</ul>
<p>总结:</p>
<ul>
<li>层叠上下文可以包含在其他层叠上下文中，并且一起创建一个层叠上下文的层级。</li>
<li>每个层叠上下文都完全独立于它的兄弟元素：当处理层叠时只考虑子元素。</li>
<li>每个层叠上下文都是自包含的：当一个元素的内容发生层叠后，该元素将被作为整体在父级层叠上下文中按顺序进行层叠。</li>
</ul>
<p>Tips:  层叠上下文顺序</p>
<p><img src="/_posts/css/assets/css%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5/2016-01-09_211116.png" alt="更完整的7阶层叠顺序图"></p>
<h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context">BFC</a></h3><p><strong>块格式化上下文（Block Formatting Context，BFC）</strong> 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p>
<p>下列方式会创建<strong>块格式化上下文</strong>：</p>
<ul>
<li>根元素（<code>&lt;html&gt;）</code></li>
<li>浮动元素（元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a> 不是 <code>none</code>）</li>
<li>绝对定位元素（元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position"><code>position</code></a> 为 <code>absolute</code> 或 <code>fixed</code>）</li>
<li>行内块元素（元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 为 <code>inline-block</code>）</li>
<li>表格单元格（元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 为 <code>table-cell</code>，HTML表格单元格默认为该值）</li>
<li>表格标题（元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 为 <code>table-caption</code>，HTML表格标题默认为该值）</li>
<li>匿名表格单元格元素（元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 为 <code>table、``table-row</code>、 <code>table-row-group、``table-header-group、``table-footer-group</code>（分别是HTML table、row、tbody、thead、tfoot 的默认属性）或 <code>inline-table</code>）</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow"><code>overflow</code></a> 计算值(Computed)不为 <code>visible</code> 的块元素</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 值为 <code>flow-root</code> 的元素</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/contain"><code>contain</code></a> 值为 <code>layout</code>、<code>content</code>或 paint 的元素</li>
<li>弹性元素（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 为 <code>flex</code> 或 <code>inline-flex</code>元素的直接子元素）</li>
<li>网格元素（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 为 <code>grid</code> 或 <code>inline-grid</code> 元素的直接子元素）</li>
<li>多列容器（元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-count"><code>column-count</code></a> 或 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/column-width"><code>column-width</code> (en-US)</a> 不为 <code>auto，包括 ``column-count</code> 为 <code>1</code>）</li>
<li><code>column-span</code> 为 <code>all</code> 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（<a href="https://github.com/w3c/csswg-drafts/commit/a8634b96900279916bd6c505fda88dda71d8ec51">标准变更</a>，<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=709362">Chrome bug</a>）。</li>
</ul>
<p>块格式化上下文包含创建它的元素内部的所有内容.</p>
<p>块格式化上下文对浮动定位（参见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a>）与清除浮动（参见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear"><code>clear</code></a>）都很重要。浮动定位和清除浮动时只会应用于同一个BFC内的元素。浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。外边距折叠（<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing">Margin collapsing</a>）也只会发生在属于同一BFC的块级元素之间。</p>
<p>几个重要的应用:</p>
<ul>
<li><p>BFC 可以包含浮动的元素（清除浮动，防止高度塌陷）</p>
</li>
<li><p>同一个 BFC 下外边距会发生折叠</p>
</li>
<li><p>BFC 可以阻止元素被浮动元素覆盖(左侧固定，右侧自适应布局)  </p>
<p><img src="/_posts/css/assets/css%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5/v2-5ebd48f09fac875f0bd25823c76ba7fa_720w-20211213143017754.png" alt="img"></p>
</li>
</ul>
<p>可以参考<a href="https://zhuanlan.zhihu.com/p/25321647">知乎</a></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>层叠上下文</tag>
        <tag>BFC</tag>
      </tags>
  </entry>
  <entry>
    <title>层叠上下文-张鑫旭</title>
    <url>/CSS/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<blockquote>
<p>转载于  <a href="https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/">张鑫旭</a></p>
</blockquote>
<h3 id="简短总结"><a href="#简短总结" class="headerlink" title="简短总结"></a>简短总结</h3><h4 id="什么是层叠上下文"><a href="#什么是层叠上下文" class="headerlink" title="什么是层叠上下文"></a>什么是层叠上下文</h4><p> 层叠上下文，英文称作”stacking context”. 是HTML中的一个三维的概念。简单来说就是一个容器，比普通元素高一个层级</p>
<p>如何产生一个层叠上下文</p>
<h4 id="如何创建层叠上下文-MDN"><a href="#如何创建层叠上下文-MDN" class="headerlink" title="如何创建层叠上下文(MDN)"></a>如何创建<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context?spm=taofed.bloginfo.blog.3.19585ac8FPDXDu">层叠上下文(MDN)</a></h4><ol>
<li>文档根元素（<code>&lt;html&gt;</code>）；</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position"><code>position</code></a> 值为 <code>absolute</code>（绝对定位）或 <code>relative</code>（相对定位）且 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index"><code>z-index</code></a> 值不为 <code>auto</code> 的元素；</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position"><code>position</code></a> 值为 <code>fixed</code>（固定定位）或 <code>sticky</code>（粘滞定位）的元素（沾滞定位适配所有移动设备上的浏览器，但老的桌面浏览器不支持）；</li>
<li>flex (<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flexbox"><code>flexbox</code></a>) 容器的子元素，且 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index"><code>z-index</code></a> 值不为 <code>auto</code>；</li>
<li>grid (<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid"><code>grid</code></a>) 容器的子元素，且 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index"><code>z-index</code></a> 值不为 <code>auto</code>；</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/opacity"><code>opacity</code></a> 属性值小于 <code>1</code> 的元素（参见 <a href="http://www.w3.org/TR/css3-color/#transparency">the specification for opacity</a>）；</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/mix-blend-mode"><code>mix-blend-mode</code></a> 属性值不为 <code>normal</code> 的元素；</li>
<li>以下任意属性值不为<code>none</code>的元素：<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform"><code>transform</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter"><code>filter</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/perspective"><code>perspective</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clip-path"><code>clip-path</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/mask"><code>mask</code></a> &#x2F; <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/mask-image"><code>mask-image</code></a> &#x2F; <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/mask-border"><code>mask-border</code></a></li>
</ul>
</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/isolation"><code>isolation</code></a> 属性值为 <code>isolate</code> 的元素；</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/-webkit-overflow-scrolling"><code>-webkit-overflow-scrolling</code></a> 属性值为 <code>touch</code> 的元素；</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/will-change"><code>will-change</code></a> 值设定了任一属性而该属性在 non-initial 值时会创建层叠上下文的元素（参考<a href="http://dev.opera.com/articles/css-will-change-property/">这篇文章</a>）；</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/contain"><code>contain</code></a> 属性值为 <code>layout</code>、<code>paint</code> 或包含它们其中之一的合成值（比如 <code>contain: strict</code>、<code>contain: content</code>）的元素。</li>
</ol>
<h4 id="层叠上下文内部元素的顺序"><a href="#层叠上下文内部元素的顺序" class="headerlink" title="层叠上下文内部元素的顺序"></a>层叠上下文内部元素的顺序</h4><p><img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/2016-01-09_211116.png" alt="更完整的7阶层叠顺序图"></p>
<h4 id="不同层叠上下文的层叠顺序"><a href="#不同层叠上下文的层叠顺序" class="headerlink" title="不同层叠上下文的层叠顺序"></a>不同层叠上下文的层叠顺序</h4><ol>
<li>如果层叠上下文元素不依赖<code>z-index</code>数值，则其层叠顺序是<code>z-index:auto</code>可看成<code>z:index:0</code>级别；</li>
<li>如果层叠上下文元素依赖<code>z-index</code>数值，则其层叠顺序由<code>z-index</code>值决定。</li>
<li>后写的居上</li>
</ol>
<h4 id="拓展：层叠图层和复合图层有什么区别和联系呢"><a href="#拓展：层叠图层和复合图层有什么区别和联系呢" class="headerlink" title="拓展：层叠图层和复合图层有什么区别和联系呢"></a>拓展：层叠图层和复合图层有什么区别和联系呢</h4><h5 id="了解层"><a href="#了解层" class="headerlink" title="了解层"></a>了解层</h5><p>首先说明，这里讨论的是 WebKit，描述的是 Chrome 的实现细节，而并非是 web 平台的功能，因此这里介绍的内容不一定适用于其他浏览器。</p>
<ul>
<li>Chrome 拥有两套不同的渲染路径(rendering path)：硬件加速路径和旧软件路径(older software path)</li>
<li>Chrome 中有不同类型的层： RenderLayer(渲染层)和GraphicsLayer(图形层，也称复合图层)，只有 GraphicsLayer 是作为纹理(texture)上传给GPU的。</li>
</ul>
<p>浏览器中图层一般包含两大类：渲染图层（普通图层）以及复合图层</p>
<ul>
<li>渲染图层，是页面普通的<a href="https://blog.csdn.net/wangfeijiu/article/details/106563074">文档流</a>。我们<strong>虽然可以通过绝对定位，相对定位，浮动定位脱离文档流</strong>，但它<strong>仍然属于默认渲染图层</strong>，共用同一个绘图上下文对象（GraphicsContext）。<ul>
<li>满足形成层叠上下文条件的 LayoutObject 一定会<strong>为其创建新的独立的渲染层</strong></li>
</ul>
</li>
<li>复合图层，又称图形层。它会单独分配系统资源，每个复合图层都有一个独立的<strong>GraphicsContext</strong>。（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）</li>
</ul>
<blockquote>
<p><a href="https://fed.taobao.org/blog/taofed/do71ct/performance-composite/">淘宝的文章描述的很清楚</a></p>
</blockquote>
<hr>
<h3 id="以下是转载原文"><a href="#以下是转载原文" class="headerlink" title="以下是转载原文"></a>以下是转载原文</h3><p>在这个世界上，凡事都有个先后顺序，凡物都有个论资排辈。比方说食堂排队打饭，对吧，讲求先到先得，总不可能一拥而上。再比如说话语权，老婆的话永远是对的，领导的话永远是对的。</p>
<p>在CSS届，也是如此。只是，一般情况下，大家歌舞升平，看不出什么差异，即所谓的众生平等。但是，当发生冲突发生纠葛的时候，显然，是不可能做到完全等同的，先后顺序，身份差异就显现出来了。例如，杰克和罗斯，只能一人浮在木板上，此时，出现了冲突，结果大家都知道的。那对于CSS世界中的元素而言，所谓的“冲突”指什么呢，其中，很重要的一个层面就是“层叠显示冲突”。</p>
<p>默认情况下，网页内容是没有偏移角的垂直视觉呈现，当内容发生层叠的时候，一定会有一个前后的层叠顺序产生，有点类似于真实世界中论资排辈的感觉。</p>
<p>而要理解网页中元素是如何“论资排辈”的，就需要深入理解CSS中的层叠上下文和层叠顺序。</p>
<p>我们大家可能都熟悉CSS中的<code>z-index</code>属性，需要跟大家讲的是，<code>z-index</code>实际上只是CSS层叠上下文和层叠顺序中的一叶小舟。</p>
<h3 id="一、什么是层叠上下文"><a href="#一、什么是层叠上下文" class="headerlink" title="一、什么是层叠上下文"></a>一、什么是层叠上下文</h3><p>层叠上下文，英文称作”stacking context”. 是HTML中的一个三维的概念。如果一个元素含有层叠上下文，我们可以理解为这个元素在z轴上就“高人一等”。</p>
<p>这里出现了一个名词-<strong>z轴</strong>，指的是什么呢？</p>
<p>表示的是用户与屏幕的这条看不见的垂直线（参见下图示意-红线）：<br><img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/z-aris.png" alt="网页中z轴示意"></p>
<p>层叠上下文是一个概念，跟「<a href="http://www.zhangxinxu.com/wordpress/?p=4588">块状格式化上下文(BFC)</a>」类似。然而，概念这个东西是比较虚比较抽象的，要想轻松理解，我们需要将其具象化。</p>
<p>怎么个具象化法呢？</p>
<p>你可以<strong>把「层叠上下文」理解为当官</strong>：网页中有很多很多的元素，我们可以看成是真实世界的芸芸众生。真实世界里，我们大多数人是普通老百姓们，还有一部分人是做官的官员。OK，这里的“官员”就可以理解为网页中的层叠上下文元素。</p>
<p>换句话说，页面中的元素有了层叠上下文，就好比我们普通老百姓当了官，一旦当了官，相比普通老百姓而言，离皇帝更近了，对不对，就等同于网页中元素级别更高，离我们用户更近了。</p>
<p><img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/point.gif" alt="你懂的"></p>
<h3 id="二、什么是层叠水平"><a href="#二、什么是层叠水平" class="headerlink" title="二、什么是层叠水平"></a>二、什么是层叠水平</h3><p>再来说说层叠水平。“层叠水平”英文称作”stacking level”，决定了同一个层叠上下文中元素在z轴上的显示顺序。level这个词很容易让我们联想到我们真正世界中的三六九等、论资排辈。真实世界中，每个人都是独立的个体，包括同卵双胞胎，有差异就有区分。例如，双胞胎虽然长得像Ctrl+C&#x2F;Ctrl+V得到的，但实际上，出生时间还是有先后顺序的，先出生的那个就大，大哥或大姐。网页中的元素也是如此，页面中的每个元素都是独立的个体，他们一定是会有一个类似的排名排序的情况存在。而这个排名排序、论资排辈就是我们这里所说的“层叠水平”。层叠上下文元素的层叠水平可以理解为官员的职级，1品2品，县长省长之类；对于普通元素，这个嘛……你自己随意理解。</p>
<p>于是，显而易见，所有的元素都有层叠水平，包括层叠上下文元素，层叠上下文元素的层叠水平可以理解为官员的职级，1品2品，县长省长之类。然后，对于普通元素的层叠水平，我们的探讨仅仅局限在当前层叠上下文元素中。为什么呢？因为否则没有意义。</p>
<p>这么理解吧~ 上面提过元素具有层叠上下文好比当官，大家都知道的，这当官的家里都有丫鬟啊保镖啊管家啊什么的。所谓打狗看主人，A官员家里的管家和B官员家里的管家做PK实际上是没有意义的，因为他们牛不牛逼完全由他们的主子决定的。一人得道鸡犬升天，你说这和珅家里的管家和七侠镇娄知县县令家里的管家有可比性吗？李总理的秘书是不是分分钟灭了你村支部书记的秘书（如果有）。</p>
<p>翻译成术语就是：普通元素的层叠水平优先由层叠上下文决定，因此，层叠水平的比较只有在当前层叠上下文元素中才有意义。</p>
<p><img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/point.gif" alt="你懂的"></p>
<p>需要注意的是，诸位千万不要把层叠水平和CSS的z-index属性混为一谈。没错，某些情况下z-index确实可以影响层叠水平，但是，只限于定位元素以及flex盒子的孩子元素；而层叠水平所有的元素都存在。</p>
<h3 id="三、什么是层叠顺序"><a href="#三、什么是层叠顺序" class="headerlink" title="三、什么是层叠顺序"></a>三、什么是层叠顺序</h3><p>再来说说层叠顺序。“层叠顺序”英文称作”stacking order”. 表示元素发生层叠时候有着特定的垂直显示顺序，注意，这里跟上面两个不一样，上面的<strong>层叠上下文和层叠水平是概念</strong>，而这里的<strong>层叠顺序是规则</strong>。</p>
<p>在CSS2.1的年代，在CSS3还没有出现的时候（注意这里的前提），层叠顺序规则遵循下面这张图：<br><img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/2016-01-07_223349.png" alt="层叠顺序"></p>
<p>有人可能有见过类似图，那个图是很多很多年前老外绘制的，英文内容。而是更关键的是国内估计没有同行进行过验证与实践，实际上很多关键信息缺失。上面是我自己手动重绘的中文版同时补充很多其他地方绝对没有的重要知识信息。如果想要无水印高清大图，点击这里购买(0.5元)。</p>
<p>缺失的关键信息包括：</p>
<ol>
<li>位于最低水平的<code>border</code>&#x2F;<code>background</code>指的是层叠上下文元素的边框和背景色。每一个层叠顺序规则适用于一个完整的层叠上下文元素。</li>
<li>原图没有呈现inline-block的层叠顺序，实际上，inline-block和inline水平元素是同等level级别。</li>
<li>z-index:0实际上和z-index:auto单纯从层叠水平上看，是可以看成是一样的。注意这里的措辞——“单纯从层叠水平上看”，实际上，两者在层叠上下文领域有着根本性的差异。</li>
</ol>
<p>下面我要向大家发问了，大家有没有想过，为什么内联元素的层叠顺序要比浮动元素和块状元素都高？<br><img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/ask.gif" alt="疑问"></p>
<p>为什么呢？我明明感觉浮动元素和块状元素要更屌一点啊。</p>
<p>嘿嘿嘿，我就不卖关子了，直接看下图的标注说明：<br><img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/2016-01-07_235108.png" alt="层叠顺序元素的标注说明"></p>
<p>诸如<code>border</code>&#x2F;<code>background</code>一般为装饰属性，而浮动和块状元素一般用作布局，而内联元素都是内容。网页中最重要的是什么？当然是内容了哈，对不对！</p>
<p>因此，一定要让内容的层叠顺序相当高，当发生层叠是很好，重要的文字啊图片内容可以优先暴露在屏幕上。例如，文字和浮动图片重叠的时候：</p>
<p><img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/2016-01-07_235830.jpg" alt="浮动和文字重叠"></p>
<p>上面说的这些层叠顺序规则还是老时代的，如果把CSS3也牵扯进来，科科，事情就不一样了。</p>
<h3 id="四、务必牢记的层叠准则"><a href="#四、务必牢记的层叠准则" class="headerlink" title="四、务必牢记的层叠准则"></a>四、务必牢记的层叠准则</h3><p>下面这两个是层叠领域的黄金准则。当元素发生层叠的时候，其覆盖关系遵循下面2个准则：</p>
<ol>
<li><strong>谁大谁上：</strong>当具有明显的层叠水平标示的时候，如识别的z-indx值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。通俗讲就是官大的压死官小的。</li>
<li><strong>后来居上：</strong>当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。</li>
</ol>
<p>在CSS和HTML领域，只要元素发生了重叠，都离不开上面这两个黄金准则。因为后面会有多个实例说明，这里就到此为止。</p>
<h3 id="五、层叠上下文的特性"><a href="#五、层叠上下文的特性" class="headerlink" title="五、层叠上下文的特性"></a>五、层叠上下文的特性</h3><p>层叠上下文元素有如下特性：</p>
<ul>
<li>层叠上下文的层叠水平要比普通元素高（原因后面会说明）；</li>
<li>层叠上下文可以阻断元素的混合模式（见<a href="http://www.zhangxinxu.com/wordpress/?p=5155">此文第二部分说明</a>）；</li>
<li>层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的层叠上下文。</li>
<li>每个层叠上下文和兄弟元素独立，也就是当进行层叠变化或渲染的时候，只需要考虑后代元素。</li>
<li>每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。</li>
</ul>
<p>翻译成真实世界语言就是：</p>
<ul>
<li>当官的比老百姓更有机会面见圣上；</li>
<li>领导下去考察，会被当地官员阻隔只看到繁荣看不到真实民情；</li>
<li>一个家里，爸爸可以当官，孩子也是可以同时当官的。但是，孩子这个官要受爸爸控制。</li>
<li>自己当官，兄弟不占光。有什么福利或者变故只会影响自己的孩子们。</li>
<li>每个当官的都有属于自己的小团体，当家眷管家发生摩擦磕碰的时候（包括和其他官员的家眷管家），都是要优先看当官的也就是主子的脸色。</li>
</ul>
<h3 id="六、层叠上下文的创建"><a href="#六、层叠上下文的创建" class="headerlink" title="六、层叠上下文的创建"></a>六、层叠上下文的创建</h3><p>卖了这么多文字，到底层叠上下文是个什么鬼，倒是拿出来瞅瞅啊！</p>
<p>哈哈。如同块状格式化上下文，层叠上下文也基本上是有一些特定的CSS属性创建的。我将其总结为3个流派，也就是做官的3种途径：</p>
<ol>
<li><strong>皇亲国戚</strong>派：页面根元素天生具有层叠上下文，称之为“根层叠上下文”。</li>
<li><strong>科考入选</strong>派：z-index值为数值的定位元素的传统层叠上下文。</li>
<li><strong>其他当官途径</strong>：其他CSS3属性。</li>
</ol>
<p>&#x2F;&#x2F;zxx: 下面很多例子是实时CSS效果，建议您去<a href="http://www.zhangxinxu.com/wordpress/?p=5115">原地址浏览</a>，以便预览更准确的效果。</p>
<p><strong>①. 根层叠上下文</strong><br>指的是页面根元素，也就是滚动条的默认的始作俑者<code>&lt;html&gt;</code>元素。这就是为什么，绝对定位元素在<code>left</code>&#x2F;<code>top</code>等值定位的时候，如果没有其他定位元素限制，会相对浏览器窗口定位的原因。</p>
<p><strong>②. 定位元素与传统层叠上下文</strong><br>对于包含有<code>position:relative</code>&#x2F;<code>position:absolute</code>的定位元素，以及FireFox&#x2F;IE浏览器（不包括Chrome等webkit内核浏览器）（目前，也就是2016年初是这样）下含有<code>position:fixed</code>声明的定位元素，当其<code>z-index</code>值不是<code>auto</code>的时候，会创建层叠上下文。</p>
<p>知道了这一点，有些现象就好理解了。</p>
<p>如下HTML代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div style=&quot;position:relative; z-index:auto;&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;mm1.jpg&quot; style=&quot;position:absolute; z-index:2;&quot;&gt;    &lt;-- 横妹子 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div style=&quot;position:relative; z-index:auto;&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;mm2.jpg&quot; style=&quot;position:relative; z-index:1;&quot;&gt;    &lt;-- 竖妹子 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm1.jpg" alt="img"></p>
<p><img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm2.jpg" alt="img"></p>
<p>大家会发现，竖着的妹子(mm2)被横着的妹子(mm1)给覆盖了。</p>
<p>下面，我们对父级简单调整下，把<code>z-index:auto</code>改成层叠水平一致的<code>z-index:0</code>, 代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div style=&quot;position:relative; z-index:0;&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;mm1.jpg&quot; style=&quot;position:absolute; z-index:2;&quot;&gt;    &lt;-- 横妹子 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div style=&quot;position:relative; z-index:0;&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;mm2.jpg&quot; style=&quot;position:relative; z-index:1;&quot;&gt;    &lt;-- 竖妹子 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm1.jpg" alt="img"></p>
<p><img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm2.jpg" alt="img"></p>
<p>大家会发现，尼玛反过来了，竖着的妹子(mm2)这回趴在了横着的妹子(mm1)身上。</p>
<p><img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/2016-01-08_220622.jpg" alt="百合大法好"></p>
<p>为什么小小的改变会有想法的结果呢？<br><img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/think-2.gif" alt="思考"></p>
<p>差别就在于，<code>z-index:0</code>所在的<code>&lt;div&gt;</code>元素是层叠上下文元素，而<code>z-index:auto</code>所在的<code>&lt;div&gt;</code>元素是一个普通的元素，于是，里面的两个<code>&lt;img&gt;</code>妹子的层叠比较就不受父级的影响，两者直接套用层叠黄金准则，这里，两者有着明显不一的<code>z-index</code>值，因此，遵循“<strong>谁大谁上</strong>”的准则，于是，<code>z-index</code>为<code>2</code>的那个横妹子，就趴在了<code>z-index</code>为<code>1</code>的竖妹子身上。</p>
<p>而<code>z-index</code>一旦变成数值，哪怕是<code>0</code>，都会创建一个层叠上下文。此时，层叠规则就发生了变化。层叠上下文的特性里面最后一条——自成体系。两个<code>&lt;img&gt;</code>妹子的层叠顺序比较变成了优先比较其父级层叠上下文元素的层叠顺序。这里，由于两者都是<code>z-index:0</code>，层叠顺序这一块两者一样大，此时，遵循层叠黄金准则的另外一个准则“<strong>后来居上</strong>”，根据在DOM流中的位置决定谁在上面，于是，位于后面的竖着的妹子就自然而然趴在了横着的妹子身上。对，没错，<code>&lt;img&gt;</code>元素上的<code>z-index</code>打酱油了！</p>
<p>有时候，我们在网页重构的时候，会发现，<code>z-index</code>嵌套错乱，看看是不是受父级的层叠上下文元素干扰了。然后，可能没多大意义了，但我还是提一下，算是祭奠下，IE6&#x2F;IE7浏览器有个bug，就是<code>z-index:auto</code>的定位元素也会创建层叠上下文。这就是为什么在过去，IE6&#x2F;IE7的<code>z-index</code>会搞死人的原因。</p>
<p>然后，我再提一下<code>position:fixed</code>, 在过去，<code>position:fixed</code>和<code>relative/absolute</code>在层叠上下文这一块是一路货色，都是需要<code>z-index</code>为数值才行。但是，不知道什么时候起，Chrome等webkit内核浏览器，<code>position:fixed</code>元素天然层叠上下文元素，无需<code>z-index</code>为数值。根据我的测试，目前，IE以及FireFox仍是老套路。</p>
<p><strong>③. CSS3与新时代的层叠上下文</strong><br>CSS3的出现除了带来了新属性，同时还对过去的很多规则发出了挑战。例如，CSS3 <code>transform</code><a href="http://www.zhangxinxu.com/wordpress/2015/05/css3-transform-affect/">对overflow隐藏对position:fixed定位的影响</a>等。而这里，层叠上下文这一块的影响要更加广泛与显著。</p>
<p>如下：</p>
<ol>
<li><code>z-index</code>值不为<code>auto</code>的<code>flex</code>项(父元素<code>display:flex|inline-flex</code>).</li>
<li>元素的<code>opacity</code>值不是<code>1</code>.</li>
<li>元素的<code>transform</code>值不是<code>none</code>.</li>
<li>元素<code>mix-blend-mode</code>值不是<code>normal</code>.</li>
<li>元素的<code>filter</code>值不是<code>none</code>.</li>
<li>元素的<code>isolation</code>值是<code>isolate</code>.</li>
<li><code>will-change</code>指定的属性值为上面任意一个。</li>
<li>元素的<code>-webkit-overflow-scrolling</code>设为<code>touch</code>.</li>
</ol>
<p>基本上每一项都有很多槽点。</p>
<p><strong>1. display:flex|inline-flex与层叠上下文</strong><br>注意，这里的规则有些<del>负责</del>复杂。要满足两个条件才能形成层叠上下文：条件1是父级需要是<code>display:flex</code>或者<code>display:inline-flex</code>水平，条件2是子元素的z-index不是<code>auto</code>，必须是数值。此时，这个子元素为层叠上下文元素，没错，注意了，是子元素，不是flex父级元素。</p>
<p>眼见为实，给大家上例子吧。</p>
<p>如下HTML和CSS代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">     &lt;img src=&quot;mm1.jpg&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">.box &#123;  &#125;</span><br><span class="line">.box &gt; div &#123; background-color: blue; z-index: 1; &#125;    /* 此时该div是普通元素，z-index无效 */</span><br><span class="line">.box &gt; div &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1; right: -150px;     /* 注意这里是负值z-index */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm1.jpg" alt="img"></p>
<p>会发现，妹子跑到蓝色背景的下面了。为什么呢？层叠顺序图可以找到答案，如下：<br><img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/2016-01-08_235511.png" alt="负值z-index的层叠顺序"></p>
<p>从上图可以看出负值z-index的层叠顺序在block水平元素的下面，而蓝色背景<code>div</code>元素是个普通元素，因此，妹子直接穿越过去，在蓝色背景后面的显示了。</p>
<p>现在，我们CSS微调下，增加<code>display:flex</code>, 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box &#123; display: flex; &#125;</span><br><span class="line">.box &gt; div &#123; background-color: blue; z-index: 1; &#125;    /* 此时该div是层叠上下文元素，同时z-index生效 */</span><br><span class="line">.box &gt; div &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1; right: -150px;     /* 注意这里是负值z-index */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm1.jpg" alt="img"></p>
<p>会发现，妹子在蓝色背景上面显示了，为什么呢？层叠顺序图可以找到答案，如下：<br><img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/2016-01-08_235217.png" alt="img"></p>
<p>从上图可以看出负值<code>z-index</code>的层叠顺序在当前第一个父层叠上下文元素的上面，而此时，那个<code>z-index</code>值为<code>1</code>的蓝色背景<code>&lt;div&gt;</code>的父元素的<code>display</code>值是<code>flex</code>，一下子升官发财变成层叠上下文元素了，于是，图片在蓝色背景上面显示了。这个现象也证实了层叠上下文元素是<code>flex</code>子元素，而不是<code>flex</code>容器元素。</p>
<p>另外，另外，这个例子也颠覆了我们传统的对<code>z-index</code>的理解。在CSS2.1时代，<code>z-index</code>属性必须和定位元素一起使用才有作用，但是，在CSS3的世界里，非定位元素也能和<code>z-index</code>愉快地搞基。</p>
<p><strong>2. opacity与层叠上下文</strong><br>我们直接看代码，原理和上面例子一样，就不解释了。</p>
<p>如下HTML和CSS代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;mm1.jpg&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">.box &#123; background-color: blue;  &#125;</span><br><span class="line">.box &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1; right: -150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm1.jpg" alt="img"></p>
<p>然后价格透明度，例如50%透明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box &#123; background-color: blue; opacity: 0.5;  &#125;</span><br><span class="line">.box &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1; right: -150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm1.jpg" alt="img"></p>
<p>原因就是半透明元素具有层叠上下文，妹子图片的<code>z-index:-1</code>无法穿透，于是，在蓝色背景上面乖乖显示了。</p>
<p><strong>3. transform与层叠上下文</strong><br>应用了<a href="http://www.zhangxinxu.com/wordpress/2010/11/css3-transitions-transforms-animation-introduction/">transform变换</a>的元素同样具有菜单上下文。</p>
<p>我们直接看应用后的结果，如下CSS代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box &#123; background-color: blue; transform: rotate(15deg);  &#125;</span><br><span class="line">.box &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1; right: -150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm1.jpg" alt="img"></p>
<p>妹子同样在蓝色背景之上。</p>
<p><strong>4. mix-blend-mode与层叠上下文</strong><br><code>mix-blend-mode</code>类似于PS中的混合模式，之前专门有文章介绍-“<a href="http://www.zhangxinxu.com/wordpress/2015/05/css3-mix-blend-mode-background-blend-mode/">CSS3混合模式mix-blend-mode简介</a>”。</p>
<p>元素和白色背景混合。无论哪种模式，要么全白，要么没有任何变化。为了让大家有直观感受，因此，下面例子我特意加了个原创平铺背景：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box &#123; background-color: blue; mix-blend-mode: darken;  &#125;</span><br><span class="line">.box &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1; right: -150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm1.jpg" alt="img"></p>
<p>需要注意的是，目前，IE浏览器(包括IE14)还不支持<code>mix-blend-mode</code>，因此，要想看到妹子在背景色之上，请使用Chrome或FireFox。</p>
<p>同样的，因为蓝色背景元素升级成了层叠上下文，因此，<code>z-index:-1</code>无法穿透，在蓝色背景上显示了。</p>
<p><strong>5. filter与层叠上下文</strong><br>此处说的<code>filter</code>是CSS3中规范的滤镜，不是旧IE时代私有的那些，虽然目的类似。同样的，我之前有提过，例如<a href="http://www.zhangxinxu.com/wordpress/2012/08/css-svg-filter-image-grayscale/">图片的灰度</a>或者<a href="http://www.zhangxinxu.com/wordpress/2013/11/css-svg-image-blur/">图片的毛玻璃效果</a>等。</p>
<p>我们使用常见的模糊效果示意下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box &#123; background-color: blue; filter: blur(5px);  &#125;</span><br><span class="line">.box &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1; right: -150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm1.jpg" alt="img"></p>
<p>好吧，果然被你猜对了，妹子蓝色床上躺着，只是你眼镜摘了，看得有些不够真切罢了。</p>
<p><strong>6. isolation:isolate与层叠上下文</strong><br><code>isolation:isolate</code>这个声明是<code>mix-blend-mode</code>应运而生的。默认情况下，<code>mix-blend-mode</code>会混合z轴所有层叠在下面的元素，要是我们不希望某个层叠的元素参与混合怎么办呢？就是使用<code>isolation:isolate</code>。由于一言难尽，我特意为此写了篇文章：“<a href="http://www.zhangxinxu.com/wordpress/?p=5155">理解CSS3 isolation: isolate的表现和作用</a>”，解释了其阻隔混合模式的原理，建议大家看下。</p>
<p>要演示这个效果，我需要重新设计下，如下HTML结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;img/mm2.jpg&quot; class=&quot;mode&quot;&gt;</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;mm1.jpg&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>CSS主要代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.mode &#123;</span><br><span class="line">  /* 竖妹子绝对定位，同时混合模式 */</span><br><span class="line">  position: absolute; mix-blend-mode: darken;</span><br><span class="line">&#125;    </span><br><span class="line">.box &#123;</span><br><span class="line">  background: blue;         </span><br><span class="line">&#125;</span><br><span class="line">.box &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构如下：</p>
<p><img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm2.jpg" alt="img"></p>
<p><img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm1.jpg" alt="img"></p>
<p>会发现，横妹子被混合模式了。此时，我们给妹子所在容器增加<code>isolation:isolate</code>，如下CSS所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.mode &#123;</span><br><span class="line">  /* 竖妹子绝对定位，同时混合模式 */</span><br><span class="line">  position: absolute; mix-blend-mode: darken;</span><br><span class="line">&#125;    </span><br><span class="line">.box &#123;</span><br><span class="line">  background: blue; isolation:isolate;         </span><br><span class="line">&#125;</span><br><span class="line">.box &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<p><img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm2.jpg" alt="img"></p>
<p><img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm1.jpg" alt="img"></p>
<p>会发现横着的妹子跑到蓝色背景上面了。这表明确实创建了层叠上下文。</p>
<p><strong>7. will-change与层叠上下文</strong><br>关于<code>will-change</code>，如果有同学还不了解，可以参见我之前写的文章：“<a href="http://www.zhangxinxu.com/wordpress/2015/11/css3-will-change-improve-paint/">使用CSS3 will-change提高页面滚动、动画等渲染性能</a>”。</p>
<p>都是类似的演示代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box &#123; background-color: blue; will-change: transform;  &#125;</span><br><span class="line">.box &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1; right: -150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm1.jpg" alt="img"></p>
<p>果然不出所料，妹子上了蓝色的背景。</p>
<h3 id="七、层叠上下文与层叠顺序"><a href="#七、层叠上下文与层叠顺序" class="headerlink" title="七、层叠上下文与层叠顺序"></a>七、层叠上下文与层叠顺序</h3><p>本文多次提到，一旦普通元素具有了层叠上下文，其层叠顺序就会变高。那它的层叠顺序究竟在哪个位置呢？</p>
<p>这里需要分两种情况讨论：</p>
<ol>
<li>如果层叠上下文元素不依赖<code>z-index</code>数值，则其层叠顺序是<code>z-index:auto</code>可看成<code>z:index:0</code>级别；</li>
<li>如果层叠上下文元素依赖<code>z-index</code>数值，则其层叠顺序由<code>z-index</code>值决定。</li>
</ol>
<p>于是乎，我们上面提供的层叠顺序表，实际上还是缺少其他重要信息。我又花功夫重新绘制了一个更完整的7阶层叠顺序图（同样的版权所有，商业请购买，可得无水印大图）：</p>
<p><img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/2016-01-09_211116.png" alt="更完整的7阶层叠顺序图"></p>
<p>大家知道为什么定位元素会层叠在普通元素的上面吗？</p>
<p>其根本原因就在于，元素一旦成为定位元素，其<code>z-index</code>就会自动生效，此时其<code>z-index</code>就是默认的<code>auto</code>，也就是<code>0</code>级别，根据上面的层叠顺序表，就会覆盖<code>inline</code>或<code>block</code>或<code>float</code>元素。</p>
<p>而不支持z-index的层叠上下文元素天然<code>z-index:auto</code>级别，也就意味着，层叠上下文元素和定位元素是一个层叠顺序的，于是当他们发生层叠的时候，遵循的是“后来居上”准则。</p>
<p>我们可以速度测试下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;mm1&quot; style=&quot;position:relative&quot;&gt;</span><br><span class="line">&lt;img src=&quot;mm2&quot; style=&quot;transform:scale(1);&quot;&gt;</span><br><span class="line">&lt;img src=&quot;mm2&quot; style=&quot;transform:scale(1);&quot;&gt;</span><br><span class="line">&lt;img src=&quot;mm1&quot; style=&quot;position:relative&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm1.jpg" alt="img"><img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/mm2.jpg" alt="img"><br><img src="/_posts/css/assets/https:/image.zhangxinxu.com/image/study/s/s256/mm2.jpg" alt="img"><img src="/_posts/css/assets/https:/image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p>
<p>会发现，两者样式一模一样，仅仅是在DOM流中的位置不一样，导致他们的层叠表现不一样，后面的妹子趴在了前面妹子的身上。这也说明了，层叠上下文元素的层叠顺序就是<code>z-index:auto</code>级别。</p>
<p><strong>z-index值与层叠顺序</strong><br>如果元素支持z-index值，则层叠顺序就要好理解些了，比较数值大小嘛，小盆友都会，本质上是应用的“谁大谁上”的准则。在以前，我们只需要关心定位元素的z-index就好，但是，在CSS3时代，flex子项也支持<code>z-index</code>，使得我们面对的情况比以前要负复杂。然而，好的是，规则都是一样的，对于<code>z-index</code>的使用和表现也是如此，套用上面的7阶层叠顺序表就可以了。</p>
<p>同样，举个简单例子，看下<code>z-index:-1</code>和<code>z-index:1</code>变化对层叠表现的影响，如下两段HTML：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div style=&quot;display:flex; background:blue;&quot;&gt;</span><br><span class="line">   &lt;img src=&quot;mm1.jpg&quot; style=&quot;z-index:-1;&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div style=&quot;display:flex; background:blue;&quot;&gt;</span><br><span class="line">   &lt;img src=&quot;mm1.jpg&quot; style=&quot;z-index:1;&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>最后，会发现，<code>z-index:-1</code>跑到了背景色小面，而<code>z-index:1</code>高高在上。</p>
<p><img src="/_posts/css/assets/https:/image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p>
<p><img src="/_posts/css/assets/https:/image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p>
<p><strong>一个与层叠上下文相关的有趣的显示现象</strong><br>在实际项目中，我们可能会渐进使用CSS3的fadeIn淡入animation效果增强体验，于是，我们可能就会遇到类似下面的现象：</p>
<p>您可以狠狠地点击这里：<a href="http://www.zhangxinxu.com/study/201601/css3-fadein-animation-stacking-context.html">CSS3 fadeIn淡入animation动画有趣现象</a></p>
<p>有一个绝对定位的黑色半透明层覆盖在图片上，默认显示是这样的：</p>
<p><img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/2018-01-09_004641.png" alt="文字在妹子上"></p>
<p>但是，一旦图片开始走fadeIn淡出的CSS3动画，文字跑到图片后面去了<img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/36.gif" alt="img">：</p>
<p><img src="/_posts/css/assets/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/2018-01-09_004654.png" alt="文字跑到图片后面"></p>
<p>为什么会这样？</p>
<p>实际上，学了本文的内容，就很简单了！fadeIn动画本质是<code>opacity</code>透明度的变化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@keyframes fadeIn &#123;</span><br><span class="line">  0% &#123; </span><br><span class="line">    opacity: 0;</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    opacity: 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要知道，<code>opacity</code>的值不是<code>1</code>的时候，是具有层叠上下文的，层叠顺序是<code>z-index:auto</code>级别，跟没有<code>z-index</code>值的<code>absolute</code>绝对定位元素是平起平坐的。而本demo中的文字元素在图片元素的前面，于是，当CSS3动画只要不是最终一瞬间的<code>opacity: 1</code>，位于DOM流后面的图片就会遵循“后来居上”准则，覆盖文字。</p>
<p>这就是原因，于是，我们想要解决这个问题就很简单。</p>
<p>\1. 调整DOM流的先后顺序；<br>\2. 提高文字的层叠顺序，例如，设置<code>z-index:1</code>;</p>
<h3 id="八、结束语"><a href="#八、结束语" class="headerlink" title="八、结束语"></a>八、结束语</h3><p>只要元素发生层叠，要解释其表现，基本上就本文的这些内容了。</p>
<p>我发现很多重构小伙伴都有z-index滥用，或者使用不规范的问题。我觉得最主要的原因还是对理解层叠上下文以及层叠顺序这些概念都不了解。例如，只要使用了定位元素，尤其<code>absolute</code>绝对定位，都离不开设置一个<code>z-index</code>值；或者只要元素被其他元素覆盖了，例如变成定位元素或者增加<code>z-index</code>值升级。页面一复杂，必然搞得乱七八糟。</p>
<p>实际上，在我看来，觉得多数常见，z-index根本就没有出现的必要。知道了内联元素的层叠水平比块状元素高，于是，某条线你想覆盖上去的时候，需要设置<code>position:relative</code>吗？不需要，<code>inline-block</code>化就可以。因为IE6&#x2F;IE7 <code>position:relative</code>会创建层叠上下文，很烦的。</p>
<p>OK，本文已经够长了，就不多啰嗦了。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>层叠上下文</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS变量</title>
    <url>/CSS/css%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h2 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h2><p>声明变量的时候，变量名前面要加两根连词线（–）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  --foo: #7F583F;</span><br><span class="line">  --bar: #F7EFD2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，body选择器里面声明了两个变量：<code>--foo</code>和<code>--bar</code>。<br>它们与color、font-size等正式属性没有什么不同，只是没有默认含义。所以 CSS 变量（CSS variable）又叫做”CSS 自定义属性”（CSS custom properties）。因为变量与自定义的 CSS 属性其实是一回事。<br>你可能会问，为什么选择两根连词线（–）表示变量？因为$foo被 Sass 用掉了，@foo被 Less 用掉了。为了不产生冲突，官方的 CSS 变量就改用两根连词线了。<br>各种值都可以放入 CSS 变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:root&#123;</span><br><span class="line">  --main-color: #4d4e53;</span><br><span class="line">  --main-bg: rgb(255, 255, 255);</span><br><span class="line">  --logo-border-color: rebeccapurple;</span><br><span class="line"></span><br><span class="line">  --header-height: 68px;</span><br><span class="line">  --content-padding: 10px 20px;</span><br><span class="line"></span><br><span class="line">  --base-line-height: 1.428571429;</span><br><span class="line">  --transition-duration: .35s;</span><br><span class="line">  --external-link: &quot;external link&quot;;</span><br><span class="line">  --margin-top: calc(2vh + 20px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量名大小写敏感，<code>--header-color</code>和<code>--Header-Color</code>是两个不同变量。</p>
<h2 id="var-函数"><a href="#var-函数" class="headerlink" title="var() 函数"></a>var() 函数</h2><p><code>var()</code>函数用于读取变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a &#123;</span><br><span class="line">  color: var(--foo);</span><br><span class="line">  text-decoration-color: var(--bar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>var()</code>函数还可以使用第二个参数，表示变量的默认值。如果该变量不存在，就会使用这个默认值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">color: var(--foo, #7F583F);</span><br></pre></td></tr></table></figure>

<p>第二个参数不处理内部的逗号或空格，都视作参数的一部分。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var(--font-stack, &quot;Roboto&quot;, &quot;Helvetica&quot;);</span><br><span class="line">var(--pad, 10px 15px 20px);</span><br></pre></td></tr></table></figure>

<p><code>var()</code>函数还可以用在变量的声明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:root &#123;</span><br><span class="line">  --primary-color: red;</span><br><span class="line">  --logo-text: var(--primary-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，变量值只能用作属性值，不能用作属性名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.foo &#123;</span><br><span class="line">  --side: margin-top;</span><br><span class="line">  /* 无效 */</span><br><span class="line">  var(--side): 20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>--side</code>用作属性名，这是无效的。</p>
<h2 id="变量值的类型"><a href="#变量值的类型" class="headerlink" title="变量值的类型"></a>变量值的类型</h2><p>如果变量值是一个字符串，可以与其他字符串拼接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--bar: &#x27;hello&#x27;;</span><br><span class="line">--foo: var(--bar)&#x27; world&#x27;;</span><br></pre></td></tr></table></figure>

<p>利用这一点，可以 debug（例子）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">body:after &#123;</span><br><span class="line">  content: &#x27;--screen-category : &#x27;var(--screen-category);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果变量值是数值，不能与数值单位直接连用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.foo &#123;</span><br><span class="line">  --gap: 20;</span><br><span class="line">  /* 无效 */</span><br><span class="line">  margin-top: var(--gap)px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，数值与单位直接写在一起，这是无效的。必须使用calc()函数，将它们连接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.foo &#123;</span><br><span class="line">  --gap: 20;</span><br><span class="line">  margin-top: calc(var(--gap) * 1px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果变量值带有单位，就不能写成字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 无效 */</span><br><span class="line">.foo &#123;</span><br><span class="line">  --foo: &#x27;20px&#x27;;</span><br><span class="line">  font-size: var(--foo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 有效 */</span><br><span class="line">.foo &#123;</span><br><span class="line">  --foo: 20px;</span><br><span class="line">  font-size: var(--foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>同一个 CSS 变量，可以在多个选择器内声明。读取的时候，优先级最高的声明生效。这与 CSS 的”层叠”（cascade）规则是一致的。<br>下面是一个例子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  :root &#123; --color: blue; &#125;</span><br><span class="line">  div &#123; --color: green; &#125;</span><br><span class="line">  #alert &#123; --color: red; &#125;</span><br><span class="line">  * &#123; color: var(--color); &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;蓝色&lt;/p&gt;</span><br><span class="line">&lt;div&gt;绿色&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;alert&quot;&gt;红色&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，三个选择器都声明了–color变量。不同元素读取这个变量的时候，会采用优先级最高的规则，因此三段文字的颜色是不一样的。<br>这就是说，变量的作用域就是它所在的选择器的有效范围。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  --foo: #7F583F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.content &#123;</span><br><span class="line">  --bar: #F7EFD2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>--foo</code>的作用域是<code>body</code>选择器的生效范围，<code>--bar</code>的作用域是<code>.content</code>选择器的生效范围。<br>由于这个原因，全局的变量通常放在根元素:root里面，确保任何选择器都可以读取它们。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.querySelector(&#x27;:root&#x27;)==document.querySelector(&#x27;html&#x27;)</span><br><span class="line">//true</span><br><span class="line">:root &#123;</span><br><span class="line">  --main-color: #06c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><p>CSS 是动态的，页面的任何变化，都会导致采用的规则变化。<br>利用这个特点，可以在响应式布局的media命令里面声明变量，使得不同的屏幕宽度有不同的变量值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  --primary: #7F583F;</span><br><span class="line">  --secondary: #F7EFD2;</span><br><span class="line">&#125;</span><br><span class="line">a &#123;</span><br><span class="line">  color: var(--primary);</span><br><span class="line">  text-decoration-color: var(--secondary);</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (min-width: 768px) &#123;</span><br><span class="line">  body &#123;</span><br><span class="line">    --primary:  #F7EFD2;</span><br><span class="line">    --secondary: #7F583F;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="兼容性处理"><a href="#兼容性处理" class="headerlink" title="兼容性处理"></a>兼容性处理</h2><p>对于不支持 CSS 变量的浏览器，可以采用下面的写法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a &#123;</span><br><span class="line">  color: #7F583F;</span><br><span class="line">  color: var(--primary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用@support命令进行检测。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@supports ( (--a: 0)) &#123;</span><br><span class="line">  /* supported */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@supports ( not (--a: 0)) &#123;</span><br><span class="line">  /* not supported */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>七、JavaScript 操作<br>JavaScript 也可以检测浏览器是否支持 CSS 变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const isSupported =</span><br><span class="line">  window.CSS &amp;&amp;</span><br><span class="line">  window.CSS.supports &amp;&amp;</span><br><span class="line">  window.CSS.supports(&#x27;--a&#x27;, 0);</span><br><span class="line"></span><br><span class="line">if (isSupported) &#123;</span><br><span class="line">  /* supported */</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  /* not supported */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JavaScript 操作 CSS 变量的写法如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 设置变量</span><br><span class="line">document.body.style.setProperty(&#x27;--primary&#x27;, &#x27;#7F583F&#x27;);</span><br><span class="line"></span><br><span class="line">// 读取变量</span><br><span class="line">document.body.style.getPropertyValue(&#x27;--primary&#x27;).trim();</span><br><span class="line">// &#x27;#7F583F&#x27;</span><br><span class="line"></span><br><span class="line">// 删除变量</span><br><span class="line">document.body.style.removeProperty(&#x27;--primary&#x27;);</span><br></pre></td></tr></table></figure>

<p>这意味着，JavaScript 可以将任意值存入样式表。下面是一个监听事件的例子，事件信息被存入 CSS 变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const docStyle = document.documentElement.style;</span><br><span class="line"></span><br><span class="line">document.addEventListener(&#x27;mousemove&#x27;, (e) =&gt; &#123;</span><br><span class="line">  docStyle.setProperty(&#x27;--mouse-x&#x27;, e.clientX);</span><br><span class="line">  docStyle.setProperty(&#x27;--mouse-y&#x27;, e.clientY);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>那些对 CSS 无用的信息，也可以放入 CSS 变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--foo: if(x &gt; 5) this.width = 10;</span><br></pre></td></tr></table></figure>

<p>上面代码中，–foo的值在 CSS 里面是无效语句，但是可以被 JavaScript 读取。这意味着，可以把样式设置写在 CSS 变量中，让 JavaScript 读取。<br>所以，CSS 变量提供了 JavaScript 与 CSS 通信的一种途径。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>蝉原则</title>
    <url>/CSS/%E8%9D%89%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="“蝉原则”与CSS3随机多背景随机圆角等效果"><a href="#“蝉原则”与CSS3随机多背景随机圆角等效果" class="headerlink" title="“蝉原则”与CSS3随机多背景随机圆角等效果"></a>“蝉原则”与CSS3随机多背景随机圆角等效果</h1><h2 id="什么是“蝉原则”？"><a href="#什么是“蝉原则”？" class="headerlink" title="什么是“蝉原则”？"></a>什么是“蝉原则”？</h2><p>“蝉原则”，英文称作“cicada principle”，是一种让事物的重复出现符合“自然随机性”的规则，为什么这么说呢？  </p>
<p>“蝉原则”源自于北美，中国似乎并未有这样的说法，这背后是有有故事的：  </p>
<p>北美和东亚蝉的种群是不一样的，在东亚蝉的幼虫生活在土中3年5年或7年；但是北美有一种周期蝉（Magicicada），其生命周期为十三年或十七年，也被称为十七年蝉或十三年蝉。东亚的蝉生命周期短，因此，给人感觉好像每年都有很多蝉，而北美的周期蝉的生命周期很长，因此能够让人明显感觉到每隔十几年蝉的数量就会大规模爆发一下，于是就会引发一些科学家的好奇，为什么生命周期是十三年或者十七年呢？<br>蝉的天敌鸟类其繁荣萧条周期是具有规律性的（一般2至6年），然后不断重复。十三年或者十七年中的13和17都是质数，而吃蝉的鸟类一般寿命都不超过13年，因此就不会遇到上一世代所遇到的天敌。<br>东亚蝉的幼虫生活的年限比较短，可能与东亚的主要鸟类种群寿命不长有关，例如麻雀就2年寿命。还有一个很重要的原因，就是一片区域的蝉他不止一个种群，而使用质数作为生命周期年数就可以避免钻出泥土时可以和别种群的蝉类一起钻出，这样竞争压力就会小。例如，北美的十七年蝉和十三年蝉每221年才会出现同时爆发的情况。  </p>
<p>这种以质数作为循环周期来增加“自然随机性”的策略就称之为“蝉原则”。<br>那“蝉原则”对我们网页设计有什么启示呢？那就是可以以最小成本实现更自然的随机效果。<br>本文就演示两个借助“蝉原则”和CSS3特性实现随机效果的例子。</p>
<h2 id="“蝉原则”下的CSS3-multiple-Backgrounds随机多背景"><a href="#“蝉原则”下的CSS3-multiple-Backgrounds随机多背景" class="headerlink" title="“蝉原则”下的CSS3 multiple Backgrounds随机多背景"></a>“蝉原则”下的CSS3 multiple Backgrounds随机多背景</h2><p>在著名的CSS3背景底纹站点有这么一个案例，如下截图：  </p>
<p><img src="/_posts/css/assets/%E8%9D%89%E5%8E%9F%E5%88%99/bg.png" alt="效果展示">  </p>
<p>从名称就可以看出其背后的原理，Cicada stripes是“蝉条纹”的意思，意思是说这里的随机背景线条实际上是使用“蝉原则”实现的。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.stripes &#123;</span><br><span class="line">  background-color: #026873;</span><br><span class="line">  background-image: linear-gradient(90deg, rgba(255,255,255,.07) 50%, transparent 50%),</span><br><span class="line">    linear-gradient(90deg, rgba(255,255,255,.13) 50%, transparent 50%),</span><br><span class="line">    linear-gradient(90deg, transparent 50%, rgba(255,255,255,.17) 50%),</span><br><span class="line">    linear-gradient(90deg, transparent 50%, rgba(255,255,255,.19) 50%);</span><br><span class="line">  background-size: 13px, 29px, 37px, 53px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面CSS代码显示总共有4个渐变背景图，然后每个背景图的颜色透明度以及区域范围都不一样，然后最终的随机效果，最关键的就是控制4个背景图循环尺寸的background-size属性，其对应的4个尺寸值13px, 29px, 37px, 53px全部都是质数，于是保证了最大的自然随机，最终的随机线条效果更自然。</p>
<h2 id="“蝉原则”下的CSS3-border-radius随机圆角效果"><a href="#“蝉原则”下的CSS3-border-radius随机圆角效果" class="headerlink" title="“蝉原则”下的CSS3 border-radius随机圆角效果"></a>“蝉原则”下的CSS3 border-radius随机圆角效果</h2><p>这里随机圆角效果可以参见这个站点：<a href="http://2016.uxlondon.com/speakers">http://2016.uxlondon.com/speakers</a>，效果截图如下：  </p>
<p><img src="/_posts/css/assets/%E8%9D%89%E5%8E%9F%E5%88%99/radiu.jpg" alt="效果展示"><br>可以看到嘉宾的头像的圆角的大小都是随机的，不规则的，有的这里扁，又是那里歪，其实现也利用的“蝉原则”。  </p>
<p>其实现的原理是对:nth-child进行自然随机，按照原作者的话说，其原本是想类似下面实现：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list:nth-child(2n) &#123;&#125;</span><br><span class="line">list:nth-child(3n) &#123;&#125;</span><br><span class="line">list:nth-child(5n) &#123;&#125;</span><br><span class="line">list:nth-child(7n) &#123;&#125;</span><br><span class="line">list:nth-child(11n) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>但是发现不能覆盖所有的列表项，反而有些不自然，因此，进行了如下的改进：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list:nth-child(2n + 1) &#123;&#125;</span><br><span class="line">list:nth-child(3n + 2) &#123;&#125;</span><br><span class="line">list:nth-child(5n + 3) &#123;&#125;</span><br><span class="line">list:nth-child(7n + 4) &#123;&#125;</span><br><span class="line">list:nth-child(11n + 5) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>也就是后面再加一个小一号的质数值，于是，再配合默认效果，天衣无缝的随机列表交互就实现了，拿2n+1项举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list &#123;</span><br><span class="line">  border-radius: 87% 91% 98% 100%;</span><br><span class="line">&#125;</span><br><span class="line">list:hover &#123;</span><br><span class="line">  border-radius: 95% 70% 100% 80%;</span><br><span class="line">  transform: rotate(-2deg);</span><br><span class="line">&#125;</span><br><span class="line">.list:nth-child(2n+1) &#123;</span><br><span class="line">  border-radius: 59% 52% 56% 59%;</span><br><span class="line">  transform: rotate(-6deg);</span><br><span class="line">&#125;</span><br><span class="line">.list:nth-child(2n+1):hover &#123;</span><br><span class="line">  border-radius: 51% 67% 56% 64%;</span><br><span class="line">  transform: rotate(-4deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是效果达成！</p>
<h2 id="质数表"><a href="#质数表" class="headerlink" title="质数表"></a>质数表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 3 5 7 11 13 17</span><br><span class="line">19 23 29 31 37 41</span><br><span class="line">43 47 53 59 61 57 </span><br><span class="line">71 73 79 83 89 97</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>趣闻</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown 基本使用</title>
    <url>/markdown/markdown/</url>
    <content><![CDATA[<h1 id="markdown-基本使用"><a href="#markdown-基本使用" class="headerlink" title="markdown 基本使用"></a>markdown 基本使用</h1><p><a href="https://www.runoob.com/markdown/md-tutorial.html">markdown 基本使用</a></p>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>

<p><img src="/_posts/markdown/assets/markdown/title.gif" alt="效果展示"></p>
<h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。  </p>
<p><img src="/_posts/markdown/assets/markdown/duanluo.jpg" alt="效果展示"></p>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>Markdown 可以使用以下几种字体:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*斜体文本*</span><br><span class="line">_斜体文本_</span><br><span class="line">**粗体文本**</span><br><span class="line">__粗体文本__</span><br><span class="line">***粗斜体文本***</span><br><span class="line">___粗斜体文本___</span><br></pre></td></tr></table></figure>

<p><img src="/_posts/markdown/assets/markdown/ziti.gif" alt="效果展示"></p>
<h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line">* * *</span><br><span class="line">*****</span><br><span class="line">- - -</span><br><span class="line">----------</span><br></pre></td></tr></table></figure>

<p><img src="/_posts/markdown/assets/markdown/%E5%88%86%E9%9A%94%E7%BA%BF.jpg" alt="效果展示"></p>
<h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RUNOOB.COM</span><br><span class="line">GOOGLE.COM</span><br><span class="line">~~BAIDU.COM~~</span><br></pre></td></tr></table></figure>

<p><img src="/_posts/markdown/assets/markdown/%E5%88%A0%E9%99%A4%E7%BA%BF.jpg" alt="效果展示"></p>
<h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><p>下划线可以通过 HTML 的 <u> 标签来实现：</p>
<p><u>带下划线文本</u><br><img src="/_posts/markdown/assets/markdown/%E4%B8%8B%E5%88%92%E7%BA%BF.jpg" alt="效果展示"></p>
<h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>脚注是对文本的补充说明。</p>
<p>Markdown 脚注的格式如下:</p>
<p>[^要注明的文本]<br>以下实例演示了脚注的用法：  </p>
<p>创建脚注格式类似这样 [^RUNOOB]。  </p>
<p>[^RUNOOB]: 菜鸟教程 – 学的不仅是技术，更是梦想！！！<br><img src="/_posts/markdown/assets/markdown/%E8%84%9A%E6%B3%A8.gif" alt="效果展示"></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>class 重难点</title>
    <url>/ES6/class%E9%87%8D%E7%82%B9/</url>
    <content><![CDATA[<h1 id="class-重难点"><a href="#class-重难点" class="headerlink" title="class 重难点"></a>class 重难点</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  bar = &#x27;hello&#x27;; // 实例属性</span><br><span class="line">  baz = &#x27;world&#x27;; // 实例属性</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  get prop() &#123;</span><br><span class="line">    return &#x27;getter&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line">  set prop(value) &#123;</span><br><span class="line">    console.log(&#x27;setter: &#x27;+value);</span><br><span class="line">  &#125;</span><br><span class="line">  static myStaticProp = 42; // 提案，暂未实现</span><br><span class="line">  static classMethod() &#123;</span><br><span class="line">    return &#x27;hello&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    return &#x27;(&#x27; + this.x + &#x27;, &#x27; + this.y + &#x27;)&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>constructor注意点<ul>
<li>constructor()方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。（可以用来绑定this）</li>
<li>一个类必须有constructor()方法，如果没有显式定义，一个空的constructor()方法会被默认添加。</li>
<li>constructor()方法默认返回实例对象（即this）</li>
</ul>
</li>
<li>类必须使用new调用，否则会报错</li>
<li>get set方法设置的属性为prototype上的属性</li>
<li>static 可以设置静态方法 只能由原型调用，实例无法调用，可以被子类继承</li>
<li>实例属性可以写在class顶部</li>
<li>静态属性 暂时只可以 Point.prop设置 (已有提案，和静态方法类似)</li>
<li>私有属性和方法有提案，在属性和方法前面 + <code>#</code></li>
<li>拥有新特性 <code>new target</code> （用于ES5构造函数），如果构造函数不是通过new命令或Reflect.construct()调用的，new.target会返回undefined</li>
</ul>
<h2 id="class的继承"><a href="#class的继承" class="headerlink" title="class的继承"></a>class的继承</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">  constructor(x, y, color) &#123;</span><br><span class="line">    super(x, y); // 调用父类的constructor(x, y)，必须放在首行</span><br><span class="line">    this.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    return this.color + &#x27; &#x27; + super.toString(); // 调用父类的toString()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>super在constructor的作用<ul>
<li>子类必须在constructor方法中调用super方法，否则新建实例时会报错，这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。</li>
<li>ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this</li>
<li>在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例。</li>
</ul>
</li>
</ul>
<h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a><code>super</code> 关键字</h2><p>除了上面的注意事项，<code>super</code> 还有其它用法</p>
<h3 id="作为函数使用"><a href="#作为函数使用" class="headerlink" title="作为函数使用"></a>作为函数使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A &#123;&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>super() 在这里相当于 A.prototype.constructor.call(this)</li>
<li>作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错</li>
</ul>
<h3 id="作为对象使用"><a href="#作为对象使用" class="headerlink" title="作为对象使用"></a>作为对象使用</h3><h4 id="在普通方法中，指向父类的原型对象"><a href="#在普通方法中，指向父类的原型对象" class="headerlink" title="在普通方法中，指向父类的原型对象"></a>在普通方法中，指向父类的原型对象</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  p() &#123;</span><br><span class="line">    return 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    console.log(super.p()); // 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = new B();</span><br></pre></td></tr></table></figure>

<p><strong>要点</strong></p>
<ul>
<li>super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()</li>
<li>在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.x = 1;</span><br><span class="line">  &#125;</span><br><span class="line">  print() &#123;</span><br><span class="line">    console.log(this.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.x = 2;</span><br><span class="line">  &#125;</span><br><span class="line">  m() &#123;</span><br><span class="line">    super.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = new B();</span><br><span class="line">b.m() // 2</span><br></pre></td></tr></table></figure>

<ul>
<li>如果通过super对某个属性赋值，这时super就是子类this，赋值的属性会变成子类实例的属性</li>
</ul>
<h4 id="在静态方法中，指向父类"><a href="#在静态方法中，指向父类" class="headerlink" title="在静态方法中，指向父类"></a>在静态方法中，指向父类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">  static myMethod(msg) &#123;</span><br><span class="line">    console.log(&#x27;static&#x27;, msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  myMethod(msg) &#123;</span><br><span class="line">    console.log(&#x27;instance&#x27;, msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">  static myMethod(msg) &#123;</span><br><span class="line">    super.myMethod(msg); // 静态方法 指向父类</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  myMethod(msg) &#123;</span><br><span class="line">    super.myMethod(msg); // 普通方法 指向父类.prototype</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.myMethod(1); // static 1 </span><br><span class="line"></span><br><span class="line">var child = new Child();</span><br><span class="line">child.myMethod(2); // instance 2</span><br></pre></td></tr></table></figure>

<ul>
<li>super在静态方法之中指向父类，在普通方法之中指向父类的原型对象</li>
<li>在子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.x = 1;</span><br><span class="line">  &#125;</span><br><span class="line">  static print() &#123;</span><br><span class="line">    console.log(this.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.x = 2;</span><br><span class="line">  &#125;</span><br><span class="line">  static m() &#123;</span><br><span class="line">    super.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.x = 3;</span><br><span class="line">B.m() // 3</span><br></pre></td></tr></table></figure>

<h2 id="类的-prototype-属性和-proto-属性"><a href="#类的-prototype-属性和-proto-属性" class="headerlink" title="类的 prototype 属性和__proto__属性"></a>类的 prototype 属性和__proto__属性</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.__proto__ === A // true</span><br><span class="line">B.prototype.__proto__ === A.prototype // true</span><br></pre></td></tr></table></figure>

<p>上面代码中，子类B的__proto__属性指向父类A，子类B的prototype属性的__proto__属性指向父类A的prototype属性。  </p>
<p>这样的结果是因为，类的继承是按照下面的模式实现的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// B 的实例继承 A 的实例</span><br><span class="line">Object.setPrototypeOf(B.prototype, A.prototype);</span><br><span class="line"></span><br><span class="line">// B 继承 A 的静态属性</span><br><span class="line">Object.setPrototypeOf(B, A);</span><br><span class="line"></span><br><span class="line">const b = new B();</span><br></pre></td></tr></table></figure>

<h2 id="ES6允许继承原生构造函数定义子类"><a href="#ES6允许继承原生构造函数定义子类" class="headerlink" title="ES6允许继承原生构造函数定义子类"></a>ES6允许继承原生构造函数定义子类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyArray extends Array &#123;</span><br><span class="line">  constructor(...args) &#123;</span><br><span class="line">    super(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = new MyArray();</span><br><span class="line">arr[0] = 12;</span><br><span class="line">arr.length // 1</span><br><span class="line"></span><br><span class="line">arr.length = 0;</span><br><span class="line">arr[0] // undefined</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Class</tag>
      </tags>
  </entry>
  <entry>
    <title>Iterator 和 for...of 循环</title>
    <url>/ES6/Iterator%E5%92%8Cfor...of%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<h1 id="Iterator-和-for…of-循环"><a href="#Iterator-和-for…of-循环" class="headerlink" title="Iterator 和 for…of 循环"></a>Iterator 和 for…of 循环</h1><h2 id="Iterator（遍历器）的概念"><a href="#Iterator（遍历器）的概念" class="headerlink" title="Iterator（遍历器）的概念"></a>Iterator（遍历器）的概念</h2><p>JavaScript 原有的表示“集合”的数据结构，主要是数组（<code>Array</code>）和对象（<code>Object</code>），ES6 又添加了<code>Map</code>和<code>Set</code>。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p>
<p>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p>
<p>Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令<code>for...of</code>循环，Iterator 接口主要供<code>for...of</code>消费。</p>
<p>Iterator 的遍历过程是这样的。</p>
<p>（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</p>
<p>（2）第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员。</p>
<p>（3）第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员。</p>
<p>（4）不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置。</p>
<p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象。其中，<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束。</p>
<h2 id="默认-Iterator-接口"><a href="#默认-Iterator-接口" class="headerlink" title="默认 Iterator 接口"></a>默认 Iterator 接口</h2><p>Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即<code>for...of</code>循环（详见下文）。当使用<code>for...of</code>循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。</p>
<p>一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。</p>
<p>ES6 规定，默认的 Iterator 接口部署在数据结构的<code>Symbol.iterator</code>属性，或者说，一个数据结构只要具有<code>Symbol.iterator</code>属性，就可以认为是“可遍历的”（iterable）。<code>Symbol.iterator</code>属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名<code>Symbol.iterator</code>，它是一个表达式，返回<code>Symbol</code>对象的<code>iterator</code>属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内（参见《Symbol》一章）。</p>
<p>原生具备 Iterator 接口的数据结构如下。</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的 arguments 对象</li>
<li>NodeList 对象</li>
</ul>
<p>对于原生部署 Iterator 接口的数据结构，不用自己写遍历器生成函数，<code>for...of</code>循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的 Iterator 接口，都需要自己在<code>Symbol.iterator</code>属性上面部署，这样才会被<code>for...of</code>循环遍历。</p>
<p>对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 Map 结构使用，ES5 没有 Map 结构，而 ES6 原生提供了。</p>
<h2 id="调用-Iterator-接口的场合"><a href="#调用-Iterator-接口的场合" class="headerlink" title="调用 Iterator 接口的场合"></a>调用 Iterator 接口的场合</h2><p>有一些场合会默认调用 Iterator 接口（即<code>Symbol.iterator</code>方法），除了下文会介绍的<code>for...of</code>循环，还有几个别的场合。</p>
<p><strong>（1）解构赋值</strong></p>
<p>对数组和 Set 结构进行解构赋值时，会默认调用<code>Symbol.iterator</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>().<span class="title function_">add</span>(<span class="string">&#x27;a&#x27;</span>).<span class="title function_">add</span>(<span class="string">&#x27;b&#x27;</span>).<span class="title function_">add</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x,y] = set;</span><br><span class="line"><span class="comment">// x=&#x27;a&#x27;; y=&#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [first, ...rest] = set;</span><br><span class="line"><span class="comment">// first=&#x27;a&#x27;; rest=[&#x27;b&#x27;,&#x27;c&#x27;];</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）扩展运算符</strong></p>
<p>扩展运算符（…）也会调用默认的 Iterator 接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">[...str] <span class="comment">//  [&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, ...arr, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码的扩展运算符内部就调用 Iterator 接口。</p>
<p>实际上，这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。也就是说，只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [...iterable];</span><br></pre></td></tr></table></figure>

<p><strong>（3）yield*</strong></p>
<p><code>yield*</code>后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> generator = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = <span class="title function_">generator</span>();</span><br><span class="line"></span><br><span class="line">iterator.<span class="title function_">next</span>() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">iterator.<span class="title function_">next</span>() <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">iterator.<span class="title function_">next</span>() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">iterator.<span class="title function_">next</span>() <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line">iterator.<span class="title function_">next</span>() <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line">iterator.<span class="title function_">next</span>() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>（4）其他场合</strong></p>
<p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。</p>
<ul>
<li>for…of</li>
<li>Array.from()</li>
<li>Map(), Set(), WeakMap(), WeakSet()（比如<code>new Map([[&#39;a&#39;,1],[&#39;b&#39;,2]])</code>）</li>
<li>Promise.all()</li>
<li>Promise.race()</li>
</ul>
<h2 id="字符串的-Iterator-接口"><a href="#字符串的-Iterator-接口" class="headerlink" title="字符串的 Iterator 接口"></a>字符串的 Iterator 接口</h2><p>字符串是一个类似数组的对象，也原生具有 Iterator 接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> someString = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line"><span class="keyword">typeof</span> someString[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]</span><br><span class="line"><span class="comment">// &quot;function&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = someString[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"></span><br><span class="line">iterator.<span class="title function_">next</span>()  <span class="comment">// &#123; value: &quot;h&quot;, done: false &#125;</span></span><br><span class="line">iterator.<span class="title function_">next</span>()  <span class="comment">// &#123; value: &quot;i&quot;, done: false &#125;</span></span><br><span class="line">iterator.<span class="title function_">next</span>()  <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，调用<code>Symbol.iterator</code>方法返回一个遍历器对象，在这个遍历器上可以调用 next 方法，实现对于字符串的遍历。</p>
<h2 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h2><p>ES6 借鉴 C++、Java、C# 和 Python 语言，引入了<code>for...of</code>循环，作为遍历所有数据结构的统一的方法。</p>
<p>一个数据结构只要部署了<code>Symbol.iterator</code>属性，就被视为具有 iterator 接口，就可以用<code>for...of</code>循环遍历它的成员。也就是说，<code>for...of</code>循环内部调用的是数据结构的<code>Symbol.iterator</code>方法。</p>
<p><code>for...of</code>循环可以使用的<strong>范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如<code>arguments</code>对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。</strong></p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组原生具备<code>iterator</code>接口（即默认部署了<code>Symbol.iterator</code>属性），<code>for...of</code>循环本质上就是调用这个接口产生的遍历器，可以用下面的代码证明。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v); <span class="comment">// red green blue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>].<span class="title function_">bind</span>(arr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v); <span class="comment">// red green blue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，空对象<code>obj</code>部署了数组<code>arr</code>的<code>Symbol.iterator</code>属性，结果<code>obj</code>的<code>for...of</code>循环，产生了与<code>arr</code>完全一样的结果。</p>
<p><code>for...of</code>循环可以代替数组实例的<code>forEach</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>];</span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">element, index</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(element); <span class="comment">// red green blue</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index);   <span class="comment">// 0 1 2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>JavaScript 原有的<code>for...in</code>循环，只能获得对象的键名，不能直接获取键值。ES6 提供<code>for...of</code>循环，允许遍历获得键值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 0 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// a b c d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码表明，<code>for...in</code>循环读取键名，<code>for...of</code>循环读取键值。如果要通过<code>for...of</code>循环，获取数组的索引，可以借助数组实例的<code>entries</code>方法和<code>keys</code>方法（参见《数组的扩展》一章）。</p>
<p><code>for...of</code>循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟<code>for...in</code>循环也不一样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.<span class="property">foo</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">//  &quot;3&quot;, &quot;5&quot;, &quot;7&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>for...of</code>循环不会返回数组<code>arr</code>的<code>foo</code>属性。</p>
<h3 id="Set-和-Map-结构"><a href="#Set-和-Map-结构" class="headerlink" title="Set 和 Map 结构"></a>Set 和 Map 结构</h3><p>Set 和 Map 结构也原生具有 Iterator 接口，可以直接使用<code>for...of</code>循环。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> engines = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;Gecko&quot;</span>, <span class="string">&quot;Trident&quot;</span>, <span class="string">&quot;Webkit&quot;</span>, <span class="string">&quot;Webkit&quot;</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> e <span class="keyword">of</span> engines) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Gecko</span></span><br><span class="line"><span class="comment">// Trident</span></span><br><span class="line"><span class="comment">// Webkit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> es6 = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">es6.<span class="title function_">set</span>(<span class="string">&quot;edition&quot;</span>, <span class="number">6</span>);</span><br><span class="line">es6.<span class="title function_">set</span>(<span class="string">&quot;committee&quot;</span>, <span class="string">&quot;TC39&quot;</span>);</span><br><span class="line">es6.<span class="title function_">set</span>(<span class="string">&quot;standard&quot;</span>, <span class="string">&quot;ECMA-262&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [name, value] <span class="keyword">of</span> es6) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name + <span class="string">&quot;: &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// edition: 6</span></span><br><span class="line"><span class="comment">// committee: TC39</span></span><br><span class="line"><span class="comment">// standard: ECMA-262</span></span><br></pre></td></tr></table></figure>

<p>上面代码演示了如何遍历 Set 结构和 Map 结构。值得注意的地方有两个，首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，Set 结构遍历时，返回的是一个值，而 Map 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 Map 成员的键名和键值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>).<span class="title function_">set</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, 1]</span></span><br><span class="line"><span class="comment">// [&#x27;b&#x27;, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&#x27; : &#x27;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a : 1</span></span><br><span class="line"><span class="comment">// b : 2</span></span><br></pre></td></tr></table></figure>

<h3 id="计算生成的数据结构"><a href="#计算生成的数据结构" class="headerlink" title="计算生成的数据结构"></a>计算生成的数据结构</h3><p>有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6 的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象。</p>
<ul>
<li><code>entries()</code> 返回一个遍历器对象，用来遍历<code>[键名, 键值]</code>组成的数组。对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用<code>entries</code>方法。</li>
<li><code>keys()</code> 返回一个遍历器对象，用来遍历所有的键名。</li>
<li><code>values()</code> 返回一个遍历器对象，用来遍历所有的键值。</li>
</ul>
<p>这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> arr.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [0, &#x27;a&#x27;]</span></span><br><span class="line"><span class="comment">// [1, &#x27;b&#x27;]</span></span><br><span class="line"><span class="comment">// [2, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="类似数组的对象"><a href="#类似数组的对象" class="headerlink" title="类似数组的对象"></a>类似数组的对象</h3><p>类似数组的对象包括好几类。下面是<code>for...of</code>循环用于字符串、DOM NodeList 对象、<code>arguments</code>对象的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> str) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s); <span class="comment">// h e l l o</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DOM NodeList对象</span></span><br><span class="line"><span class="keyword">let</span> paras = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;p&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> paras) &#123;</span><br><span class="line">  p.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printArgs</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="variable language_">arguments</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">printArgs</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>

<p>对于字符串来说，<code>for...of</code>循环还有一个特点，就是会正确识别 32 位 UTF-16 字符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="string">&#x27;a\uD83D\uDC0A&#x27;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;\uD83D\uDC0A&#x27;</span></span><br></pre></td></tr></table></figure>

<p>并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用<code>Array.from</code>方法将其转为数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123; <span class="attr">length</span>: <span class="number">2</span>, <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> arrayLike) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对于普通的对象，<code>for...of</code>结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。但是，这样情况下，<code>for...in</code>循环依然可以用来遍历键名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> es6 = &#123;</span><br><span class="line">  <span class="attr">edition</span>: <span class="number">6</span>,</span><br><span class="line">  <span class="attr">committee</span>: <span class="string">&quot;TC39&quot;</span>,</span><br><span class="line">  <span class="attr">standard</span>: <span class="string">&quot;ECMA-262&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> e <span class="keyword">in</span> es6) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// edition</span></span><br><span class="line"><span class="comment">// committee</span></span><br><span class="line"><span class="comment">// standard</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> e <span class="keyword">of</span> es6) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TypeError: es6[Symbol.iterator] is not a function</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，对于普通的对象，<code>for...in</code>循环可以遍历键名，<code>for...of</code>循环会报错。</p>
<p>一种解决方法是，使用<code>Object.keys</code>方法将对象的键名生成一个数组，然后遍历这个数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(someObject)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&#x27;: &#x27;</span> + someObject[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个方法是使用 Generator 函数将对象重新包装一下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">entries</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title function_">entries</span>(obj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, <span class="string">&#x27;-&gt;&#x27;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a -&gt; 1</span></span><br><span class="line"><span class="comment">// b -&gt; 2</span></span><br><span class="line"><span class="comment">// c -&gt; 3</span></span><br></pre></td></tr></table></figure>

<h3 id="与其他遍历语法的比较"><a href="#与其他遍历语法的比较" class="headerlink" title="与其他遍历语法的比较"></a>与其他遍历语法的比较</h3><p>以数组为例，JavaScript 提供多种遍历语法。最原始的写法就是<code>for</code>循环。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; myArray.<span class="property">length</span>; index++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(myArray[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法比较麻烦，因此数组提供内置的<code>forEach</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myArray.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这种写法的问题在于，无法中途跳出<code>forEach</code>循环，<code>break</code>命令或<code>return</code>命令都不能奏效。</p>
<p><code>for...in</code>循环可以遍历数组的键名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> myArray) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(myArray[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>for...in</code>循环有几个缺点。</p>
<ul>
<li>数组的键名是数字，但是<code>for...in</code>循环是以字符串作为键名“0”、“1”、“2”等等。</li>
<li><code>for...in</code>循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。</li>
<li>某些情况下，<code>for...in</code>循环会以任意顺序遍历键名。</li>
</ul>
<p>总之，<code>for...in</code>循环主要是为遍历对象而设计的，不适用于遍历数组。</p>
<p><strong><code>for...of</code>循环相比上面几种做法，有一些显著的优点</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> myArray) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>有着同<code>for...in</code>一样的简洁语法，但是没有<code>for...in</code>那些缺点。</li>
<li>不同于<code>forEach</code>方法，它可以与<code>break</code>、<code>continue</code>和<code>return</code>配合使用。</li>
<li>提供了遍历所有数据结构的统一操作接口。</li>
</ul>
<p>下面是一个使用 break 语句，跳出<code>for...of</code>循环的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> n <span class="keyword">of</span> fibonacci) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子，会输出斐波纳契数列小于等于 1000 的项。如果当前项大于 1000，就会使用<code>break</code>语句跳出<code>for...of</code>循环。</p>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Iterator</tag>
        <tag>for...of</tag>
        <tag>遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6详细内容参照 阮一峰的ES6深入浅出</title>
    <url>/ES6/%E5%A3%B0%E6%98%8E/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>promise</title>
    <url>/ES6/promise/</url>
    <content><![CDATA[<p>记录一下需要记忆的点</p>
<h2 id="finally的实现方式"><a href="#finally的实现方式" class="headerlink" title="finally的实现方式"></a>finally的实现方式</h2><p>虽然看起来很简单，但是也值得思索</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Promise.prototype.myFinally = function (callback) &#123;</span><br><span class="line">  其实这个P === Promise // true</span><br><span class="line">  let P = this.constructor;</span><br><span class="line">  // finally其实返回了一个then 在resolve和reject的情况下 都会触发</span><br><span class="line">  return this.then(</span><br><span class="line">    value  =&gt; P.resolve(callback()).then(() =&gt; value),</span><br><span class="line">    // 这里继续扔出了一个错误，避免下一个catch无法捕获到错误</span><br><span class="line">    reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从上边的代码，我们可以得知</p>
<ul>
<li><p>错误捕获到后，就不会继续冒泡了，也就是不会被后面的catch捕获，所以上边代码加了一个throw reson</p>
</li>
<li><p>从上面的实现还可以看到，<code>finally</code>方法总是会返回原来的值，注意下述代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const p2 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">      setTimeout(() =&gt; resolve(&quot;11111&quot;), 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">    Promise.prototype.myFinally = function (callback) &#123;</span><br><span class="line">      let P = this.constructor;</span><br><span class="line">      return this.then(</span><br><span class="line">        value  =&gt; P.resolve(callback()).then(() =&gt; value),</span><br><span class="line">        reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line">    p2.myFinally(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#125;).then(res =&gt; &#123;</span><br><span class="line">      console.log(res); // 1111</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>也就意味着在promise中穿插finally 并不会有副作用</p>
</li>
<li><p>&#x2F;&#x2F; TODO <code>P.resolve(callback()).then(() =&gt; value)</code> 为什么需要这么长呢</p>
</li>
</ul>
<h2 id="面试手写promise"><a href="#面试手写promise" class="headerlink" title="面试手写promise"></a>面试手写promise</h2><h3 id="面试够用版"><a href="#面试够用版" class="headerlink" title="面试够用版"></a>面试够用版</h3><blockquote>
<p>没实现异步吧 我觉得</p>
</blockquote>
<blockquote>
<p>来源：<a href="https://link.juejin.cn/?target=https://github.com/forthealllight/blog/issues/4">实现一个完美符合Promise&#x2F;A+规范的Promise</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function myPromise(constructor)&#123;</span><br><span class="line">    let self=this;</span><br><span class="line">    self.status=&quot;pending&quot; //定义状态改变前的初始状态</span><br><span class="line">    self.value=undefined;//定义状态为resolved的时候的状态</span><br><span class="line">    self.reason=undefined;//定义状态为rejected的时候的状态</span><br><span class="line">    function resolve(value)&#123;</span><br><span class="line">        //两个===&quot;pending&quot;，保证了状态的改变是不可逆的</span><br><span class="line">       if(self.status===&quot;pending&quot;)&#123;</span><br><span class="line">          self.value=value;</span><br><span class="line">          self.status=&quot;resolved&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function reject(reason)&#123;</span><br><span class="line">        //两个===&quot;pending&quot;，保证了状态的改变是不可逆的</span><br><span class="line">       if(self.status===&quot;pending&quot;)&#123;</span><br><span class="line">          self.reason=reason;</span><br><span class="line">          self.status=&quot;rejected&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //捕获构造异常</span><br><span class="line">    try&#123;</span><br><span class="line">       constructor(resolve,reject);</span><br><span class="line">    &#125;catch(e)&#123;</span><br><span class="line">       reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">myPromise.prototype.then=function(onFullfilled,onRejected)&#123;</span><br><span class="line">   let self=this;</span><br><span class="line">   switch(self.status)&#123;</span><br><span class="line">      case &quot;resolved&quot;:</span><br><span class="line">        onFullfilled(self.value);</span><br><span class="line">        break;</span><br><span class="line">      case &quot;rejected&quot;:</span><br><span class="line">        onRejected(self.reason);</span><br><span class="line">        break;</span><br><span class="line">      default:       </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="大厂专供版"><a href="#大厂专供版" class="headerlink" title="大厂专供版"></a>大厂专供版</h3><p>直接贴出来吧，这个版本还算好理解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const PENDING = &quot;pending&quot;;</span><br><span class="line">const FULFILLED = &quot;fulfilled&quot;;</span><br><span class="line">const REJECTED = &quot;rejected&quot;;</span><br><span class="line"></span><br><span class="line">function Promise(excutor) &#123;</span><br><span class="line">    let that = this; // 缓存当前promise实例对象</span><br><span class="line">    that.status = PENDING; // 初始状态</span><br><span class="line">    that.value = undefined; // fulfilled状态时 返回的信息</span><br><span class="line">    that.reason = undefined; // rejected状态时 拒绝的原因</span><br><span class="line">    that.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数</span><br><span class="line">    that.onRejectedCallbacks = []; // 存储rejected状态对应的onRejected函数</span><br><span class="line"></span><br><span class="line">    function resolve(value) &#123; // value成功态时接收的终值</span><br><span class="line">        if(value instanceof Promise) &#123;</span><br><span class="line">            return value.then(resolve, reject);</span><br><span class="line">        &#125;</span><br><span class="line">        // 实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            // 调用resolve 回调对应onFulfilled函数</span><br><span class="line">            if (that.status === PENDING) &#123;</span><br><span class="line">                // 只能由pending状态 =&gt; fulfilled状态 (避免调用多次resolve reject)</span><br><span class="line">                that.status = FULFILLED;</span><br><span class="line">                that.value = value;</span><br><span class="line">                that.onFulfilledCallbacks.forEach(cb =&gt; cb(that.value));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    function reject(reason) &#123; // reason失败态时接收的拒因</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            // 调用reject 回调对应onRejected函数</span><br><span class="line">            if (that.status === PENDING) &#123;</span><br><span class="line">                // 只能由pending状态 =&gt; rejected状态 (避免调用多次resolve reject)</span><br><span class="line">                that.status = REJECTED;</span><br><span class="line">                that.reason = reason;</span><br><span class="line">                that.onRejectedCallbacks.forEach(cb =&gt; cb(that.reason));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 捕获在excutor执行器中抛出的异常</span><br><span class="line">    // new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    //     throw new Error(&#x27;error in excutor&#x27;)</span><br><span class="line">    // &#125;)</span><br><span class="line">    try &#123;</span><br><span class="line">        excutor(resolve, reject);</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.prototype.then = function(onFulfilled, onRejected) &#123;</span><br><span class="line">    const that = this;</span><br><span class="line">    let newPromise;</span><br><span class="line">    // 处理参数默认值 保证参数后续能够继续执行</span><br><span class="line">    onFulfilled =</span><br><span class="line">        typeof onFulfilled === &quot;function&quot; ? onFulfilled : value =&gt; value;</span><br><span class="line">    onRejected =</span><br><span class="line">        typeof onRejected === &quot;function&quot; ? onRejected : reason =&gt; &#123;</span><br><span class="line">            throw reason;</span><br><span class="line">        &#125;;</span><br><span class="line">    if (that.status === FULFILLED) &#123; // 成功态</span><br><span class="line">        return newPromise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">                try&#123;</span><br><span class="line">                    let x = onFulfilled(that.value);</span><br><span class="line">                    resolvePromise(newPromise, x, resolve, reject); // 新的promise resolve 上一个onFulfilled的返回值</span><br><span class="line">                &#125; catch(e) &#123;</span><br><span class="line">                    reject(e); // 捕获前面onFulfilled中抛出的异常 then(onFulfilled, onRejected);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (that.status === REJECTED) &#123; // 失败态</span><br><span class="line">        return newPromise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    let x = onRejected(that.reason);</span><br><span class="line">                    resolvePromise(newPromise, x, resolve, reject);</span><br><span class="line">                &#125; catch(e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (that.status === PENDING) &#123; // 等待态</span><br><span class="line">        // 当异步调用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中</span><br><span class="line">        return newPromise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">            that.onFulfilledCallbacks.push((value) =&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    let x = onFulfilled(value);</span><br><span class="line">                    resolvePromise(newPromise, x, resolve, reject);</span><br><span class="line">                &#125; catch(e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            that.onRejectedCallbacks.push((reason) =&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    let x = onRejected(reason);</span><br><span class="line">                    resolvePromise(newPromise, x, resolve, reject);</span><br><span class="line">                &#125; catch(e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>层叠上下文-淘宝团队</title>
    <url>/CSS/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>一个 Web 页面的展示，简单来说可以认为经历了以下下几个步骤。</p>
<p><img src="/_posts/css/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1eabOLpXXXXX3XFXXXXXXXXXX-1093-167.jpg_720x720.jpg" alt="img"></p>
<ul>
<li><p>JavaScript：一般来说，我们会使用 JavaScript 来实现一些视觉变化的效果。比如做一个动画或者往页面里添加一些 DOM 元素等。</p>
</li>
<li><p>Style：计算样式，这个过程是根据 CSS 选择器，对每个 DOM 元素匹配对应的 CSS 样式。这一步结束之后，就确定了每个 DOM 元素上该应用什么 CSS 样式规则。</p>
</li>
<li><p>Layout：布局，上一步确定了每个 DOM 元素的样式规则，这一步就是具体计算每个 DOM 元素最终在屏幕上显示的大小和位置。web 页面中元素的布局是相对的，因此一个元素的布局发生变化，会联动地引发其他元素的布局发生变化。比如，<code>&lt;body&gt;</code> 元素的宽度的变化会影响其子元素的宽度，其子元素宽度的变化也会继续对其孙子元素产生影响。因此对于浏览器来说，布局过程是经常发生的。</p>
</li>
<li><p>Paint：绘制，本质上就是填充像素的过程。包括绘制文字、颜色、图像、边框和阴影等，也就是一个 DOM 元素所有的可视效果。一般来说，这个绘制过程是在多个层上完成的。</p>
</li>
<li><p>Composite：渲染层合并，由上一步可知，对页面中 DOM 元素的绘制是在多个层上进行的。在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上。对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常。</p>
</li>
</ul>
<p>当然，本文我们只来关注 Composite 部分。</p>
<h2 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h2><p>在讨论 Composite 之前，有必要先简单了解下一些浏览器（本文只是针对 Chrome 来说）的渲染原理，方便对之后一些概念的理解。更多详细的内容可以参阅 <a href="http://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome">GPU Accelerated Compositing in Chrome</a></p>
<p>注：由于 Chrome 对 Blank 引擎某些实现的修改，某些我们之前熟知的类名有了变化，比如 RenderObject 变成了 LayoutObject，RenderLayer 变成了 PaintLayer。感兴趣的看以参阅 <a href="https://www.chromium.org/blink/slimming-paint">Slimming Paint</a>。</p>
<p>在浏览器中，页面内容是存储为由 Node 对象组成的树状结构，也就是 DOM 树。每一个 HTML element 元素都有一个 Node 对象与之对应，DOM 树的根节点永远都是 Document Node。这一点相信大家都很熟悉了，但其实，从 DOM 树到最后的渲染，需要进行一些转换映射。</p>
<p><img src="/_posts/css/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1VFRDMXXXXXahXpXXXXXXXXXX-814-320.png_720x720.jpg" alt="img"></p>
<h3 id="从-Nodes-到-LayoutObjects"><a href="#从-Nodes-到-LayoutObjects" class="headerlink" title="从 Nodes 到 LayoutObjects"></a>从 Nodes 到 LayoutObjects</h3><p>DOM 树中得每个 Node 节点都有一个对应的 LayoutObject 。LayoutObject 知道如何在屏幕上 paint Node 的内容。</p>
<h3 id="从-LayoutObjects-到-PaintLayers"><a href="#从-LayoutObjects-到-PaintLayers" class="headerlink" title="从 LayoutObjects 到 PaintLayers"></a>从 LayoutObjects 到 PaintLayers</h3><p>一般来说，拥有相同的坐标空间的 LayoutObjects，属于同一个渲染层（PaintLayer）。PaintLayer 最初是用来实现 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context">stacking contest（层叠上下文）</a>，以此来保证页面元素以正确的顺序合成（composite），这样才能正确的展示元素的重叠以及半透明元素等等。因此满足形成层叠上下文条件的 LayoutObject 一定会为其创建新的渲染层，当然还有其他的一些特殊情况，为一些特殊的 LayoutObjects 创建一个新的渲染层，比如 <code>overflow != visible</code> 的元素。根据创建 PaintLayer 的原因不同，可以将其分为常见的 3 类：</p>
<ul>
<li><p>NormalPaintLayer</p>
</li>
<li><p>根元素（HTML）</p>
</li>
<li><p>有明确的定位属性（relative、fixed、sticky、absolute）</p>
</li>
<li><p>透明的（opacity 小于 1）</p>
</li>
<li><p>有 CSS 滤镜（fliter）</p>
</li>
<li><p>有 CSS mask 属性</p>
</li>
<li><p>有 CSS mix-blend-mode 属性（不为 normal）</p>
</li>
<li><p>有 CSS transform 属性（不为 none）</p>
</li>
<li><p>backface-visibility 属性为 hidden</p>
</li>
<li><p>有 CSS reflection 属性</p>
</li>
<li><p>有 CSS column-count 属性（不为 auto）或者 有 CSS column-width 属性（不为 auto）</p>
</li>
<li><p>当前有对于 opacity、transform、fliter、backdrop-filter 应用动画</p>
</li>
<li><p>OverflowClipPaintLayer</p>
</li>
<li><p>overflow 不为 visible</p>
</li>
<li><p>NoPaintLayer</p>
</li>
<li><p>不需要 paint 的 PaintLayer，比如一个没有视觉属性（背景、颜色、阴影等）的空 div。</p>
</li>
</ul>
<p>满足以上条件的 LayoutObject 会拥有独立的渲染层，而其他的 LayoutObject 则和其第一个拥有渲染层的父元素共用一个。</p>
<h3 id="从-PaintLayers-到-GraphicsLayers"><a href="#从-PaintLayers-到-GraphicsLayers" class="headerlink" title="从 PaintLayers 到 GraphicsLayers"></a>从 PaintLayers 到 GraphicsLayers</h3><p><strong>某些特殊的渲染层会被认为是合成层（Compositing Layers），合成层拥有单独的 GraphicsLayer，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 父层公用一个</strong>。</p>
<p>每个 GraphicsLayer 都有一个 GraphicsContext，GraphicsContext 会负责输出该层的位图，位图是存储在共享内存中，作为纹理上传到 GPU 中，最后由 GPU 将多个位图进行合成，然后 draw 到屏幕上，此时，我们的页面也就展现到了屏幕上。</p>
<p>渲染层提升为合成层的原因有一下几种：</p>
<p>注：渲染层提升为合成层有一个先决条件，<strong>该渲染层必须是 SelfPaintingLayer（基本可认为是上文介绍的 NormalPaintLayer）</strong>。以下所讨论的渲染层提升为合成层的情况都是在该渲染层为 SelfPaintingLayer 前提下的。</p>
<ul>
<li><p>直接原因（direct reason）</p>
</li>
<li><p>硬件加速的 iframe 元素（比如 iframe 嵌入的页面中有合成层）<a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/direct/iframe.html">demo</a></p>
</li>
<li><p>video 元素</p>
</li>
<li><p>覆盖在 video 元素上的视频控制栏</p>
</li>
<li><p>3D 或者 硬件加速的 2D Canvas 元素</p>
</li>
<li><p><a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/direct/canvas.html">demo：普通 2D Canvas 不会提升为合成层</a></p>
</li>
<li><p><a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/direct/webgl.html">demo：3D Canvas 提升为合成层</a></p>
</li>
<li><p>硬件加速的插件，比如 flash 等等</p>
</li>
<li><p>在 DPI 较高的屏幕上，fix 定位的元素会自动地被提升到合成层中。但在 DPI 较低的设备上却并非如此，因为这个渲染层的提升会使得字体渲染方式由子像素变为灰阶（详细内容请参考：<a href="http://www.html5rocks.com/en/tutorials/internals/antialiasing-101/?redirect_from_locale=zh#toc-text-rendering">Text Rendering</a>）</p>
</li>
<li><p>有 3D transform</p>
</li>
<li><p>backface-visibility 为 hidden</p>
</li>
<li><p>对 opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition（需要是 active 的 animation 或者 transition，当 animation 或者 transition 效果未开始或结束后，提升合成层也会失效）</p>
</li>
<li><p><a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/direct/animation.html">demo：animation</a></p>
</li>
<li><p><a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/direct/transition.html">demo：transition</a></p>
</li>
</ul>
<p><img src="/_posts/css/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1XMzqMXXXXXXsXFXXXXXXXXXX-959-370.jpg" alt="img"></p>
<ul>
<li><p>will-change 设置为 opacity、transform、top、left、bottom、right（其中 top、left 等需要设置明确的定位属性，如 relative 等）<a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/direct/will-change.html">demo</a></p>
</li>
<li><p>后代元素原因</p>
</li>
<li><p>有合成层后代同时本身有 transform、opactiy（小于 1）、mask、fliter、reflection 属性 <a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/descendant/combo.html">demo</a></p>
</li>
<li><p>有合成层后代同时本身 overflow 不为 visible（如果本身是因为明确的定位因素产生的 SelfPaintingLayer，则需要 z-index 不为 auto） <a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/descendant/overflow.html">demo</a></p>
</li>
<li><p>有合成层后代同时本身 fixed 定位 <a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/descendant/fixed.html">demo</a></p>
</li>
<li><p>有 3D transfrom 的合成层后代同时本身有 preserves-3d 属性 <a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/descendant/preserves-3d.html">demo</a></p>
</li>
<li><p>有 3D transfrom 的合成层后代同时本身有 perspective 属性 <a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/descendant/perspective.html">demo</a></p>
</li>
<li><p>overlap 重叠原因<br>为什么会因为重叠原因而产生合成层呢？举个简单的栗子。<br><img src="/_posts/css/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1sZbvMXXXXXXlXXXXXXXXXXXX-491-300.jpg" alt="img"><br>蓝色的矩形重叠在绿色矩形之上，同时它们的父元素是一个 GraphicsLayer。此时假设绿色矩形为一个 GraphicsLayer，如果 overlap 无法提升合成层的话，那么蓝色矩形不会提升为合成层，也就会和父元素公用一个 GraphicsLayer。<br><img src="/_posts/css/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1qzzmMXXXXXX1XpXXXXXXXXXX-491-300.jpg" alt="img"><br>此时，渲染顺序就会发生错误，因此为保证渲染顺序，overlap 也成为了合成层产生的原因，也就是如下的正常情形。<br><img src="/_posts/css/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB13cYmMXXXXXaXXpXXXXXXXXXX-491-300.jpg" alt="img"><br>当然 overlap 的原因也会细分为几类，接下来我们会详细看下。</p>
</li>
<li><p>重叠或者说部分重叠在一个合成层之上。<br>那如何算是重叠呢，最常见和容易理解的就是元素的 border box（content + padding + border） 和合成层的有重叠，比如：<a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/overlap/normal.html">demo</a>，当然 margin area 的重叠是无效的（<a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/overlap/margin.html">demo</a>）。其他的还有一些不常见的情况，也算是同合成层重叠的条件，如下：</p>
</li>
<li><p>filter 效果同合成层重叠 <a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/overlap/filter.html">demo</a></p>
</li>
<li><p>transform 变换后同合成层重叠 <a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/overlap/transform.html">demo</a></p>
</li>
<li><p>overflow scroll 情况下同合成层重叠。即如果一个 overflow scroll（不管 <code>overflow:auto</code> 还是 <code>overflow:scrill</code>，只要是能 scroll 即可） 的元素同一个合成层重叠，则其可视子元素也同该合成层重叠 <a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/overlap/overflow.html">demo</a></p>
</li>
<li><p>假设重叠在一个合成层之上（assumedOverlap）。<br>这个原因听上去有点虚，什么叫假设重叠？其实也比较好理解，比如一个元素的 CSS 动画效果，动画运行期间，元素是有可能和其他元素有重叠的。针对于这种情况，于是就有了 assumedOverlap 的合成层产生原因，示例可见：<a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/overlap/animation.html">demo</a>。在本 demo 中，动画元素视觉上并没有和其兄弟元素重叠，但因为 assumedOverlap 的原因，其兄弟元素依然提升为了合成层。<br>需要注意的是该原因下，有一个很特殊的情况：<br>如果合成层有内联的 transform 属性，会导致其兄弟渲染层 assume overlap，从而提升为合成层。比如：<a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/overlap/inline.html">demo</a>。</p>
</li>
</ul>
<h4 id="层压缩"><a href="#层压缩" class="headerlink" title="层压缩"></a>层压缩</h4><p>基本上常见的一些合成层的提升原因如上所说，你会发现，由于重叠的原因，可能随随便便就会产生出大量合成层来，而每个合成层都要消耗 CPU 和内存资源，岂不是严重影响页面性能。这一点浏览器也考虑到了，因此就有了层压缩（Layer Squashing）的处理。如果多个渲染层同一个合成层重叠时，这些渲染层会被压缩到一个 GraphicsLayer 中，以防止由于重叠原因导致可能出现的“层爆炸”。具体可以看如下 <a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/squash-hover.html">demo</a>。一开始，蓝色方块由于<br><code>translateZ</code> 提升为了合成层，其他的方块元素因为重叠的原因，被压缩了一起，大小就是包含这 3 个方块的矩形大小。</p>
<p><img src="/_posts/css/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1yslCMXXXXXahaXXXXXXXXXXX-755-406.png_720x720.jpg" alt="img"></p>
<p>当我们 hover 绿色方块时，会给其设置 <code>translateZ</code> 属性，导致绿色方块也被提升为合成层，则剩下的两个被压缩到了一起，大小就缩小为包含这 2 个方块的矩形大小。</p>
<p><img src="/_posts/css/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1xxh1MXXXXXX_XXXXXXXXXXXX-755-406.png_720x720.jpg" alt="img"></p>
<p>当然，浏览器的自动的层压缩也不是万能的，有很多特定情况下，浏览器是无法进行层压缩的，如下所示，而这些情况也是我们应该尽量避免的。（注：以下情况都是基于重叠原因而言）</p>
<ul>
<li><p>无法进行会打破渲染顺序的压缩（squashingWouldBreakPaintOrder）</p>
<p>示例如下：</p>
<p>demo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  #ancestor &#123;</span><br><span class="line">    -webkit-mask-image: -webkit-linear-gradient(rgba(0,0,0,1), rgba(0,0,0,0));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  #composited &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100%;</span><br><span class="line">    transform: translateZ(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  #container &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    width: 400px;</span><br><span class="line">    height: 60px;</span><br><span class="line">    border: 1px solid black;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  #overlap-child &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 0;</span><br><span class="line">    top: 0 ;</span><br><span class="line">    bottom: 0px;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 60px;</span><br><span class="line">    background-color: orange;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;composited&quot;&gt;Text behind the orange box.&lt;/div&gt;</span><br><span class="line">  &lt;div id=&quot;ancestor&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;overlap-child&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>在本例中，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#overlap-child</span><br></pre></td></tr></table></figure>

<p>同合成层重叠，如果进行压缩，会导致渲染顺序的改变，其父元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ancestor</span><br></pre></td></tr></table></figure>

<p>的 mask 属性将失效，因此类似这种情况下，是无法进行层压缩的。目前常见的产生这种原因的情况有两种，一种是上述的祖先元素使用 mask 属性的情况，另一种是祖先元素使用 filter 属性的情况（</p>
<p>demo</p>
<p>）。</p>
</li>
<li><p>video 元素的渲染层无法被压缩同时也无法将别的渲染层压缩到 video 所在的合成层上（squashingVideoIsDisallowed）<a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/video.html">demo</a></p>
</li>
<li><p>iframe、plugin 的渲染层无法被压缩同时也无法将别的渲染层压缩到其所在的合成层上（squashingLayoutPartIsDisallowed）<a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/layoutpart.html">demo</a></p>
</li>
<li><p>无法压缩有 reflection 属性的渲染层（squashingReflectionDisallowed）<a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/reflection.html">demo</a></p>
</li>
<li><p>无法压缩有 blend mode 属性的渲染层（squashingBlendingDisallowed）<a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/blend-mode.html">demo</a></p>
</li>
<li><p>当渲染层同合成层有不同的裁剪容器（clipping container）时，该渲染层无法压缩（squashingClippingContainerMismatch）。</p>
<p>示例如下：</p>
<p>demo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  .clipping-container &#123;</span><br><span class="line"></span><br><span class="line">    overflow: hidden;</span><br><span class="line">    height: 10px; </span><br><span class="line">    background-color: blue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .composited &#123;</span><br><span class="line"></span><br><span class="line">    transform: translateZ(0); </span><br><span class="line">    height: 10px; </span><br><span class="line">    background-color: red;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .target &#123;</span><br><span class="line"></span><br><span class="line">    position:absolute; </span><br><span class="line">    top: 0px; </span><br><span class="line">    height:100px; </span><br><span class="line">    width:100px; </span><br><span class="line">    background-color: green;</span><br><span class="line">    color: #fff;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;clipping-container&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;composited&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;target&quot;&gt;不会被压缩到 composited div 上&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>本例中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.target</span><br></pre></td></tr></table></figure>

<p>同 合成层</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.composited</span><br></pre></td></tr></table></figure>

<p>重叠，但是由于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.composited</span><br></pre></td></tr></table></figure>

<p>在一个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">overflow: hidden</span><br></pre></td></tr></table></figure>

<p>的容器中，导致</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.target</span><br></pre></td></tr></table></figure>

<p>和合成层有不同的裁剪容器，从而</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.target</span><br></pre></td></tr></table></figure>

<p>无法被压缩。</p>
</li>
<li><p>相对于合成层滚动的渲染层无法被压缩（scrollsWithRespectToSquashingLayer）</p>
<p>示例如下：</p>
<p>demo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  body &#123;</span><br><span class="line">    height: 1500px;</span><br><span class="line">    overflow-x: hidden;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .composited &#123;</span><br><span class="line"></span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    background-color: red;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 50px;</span><br><span class="line">    top: 400px;</span><br><span class="line">    transform: translateZ(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .overlap &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background-color: green;</span><br><span class="line">    position: fixed;</span><br><span class="line">    left: 0px;</span><br><span class="line">    top: 0px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;composited&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;overlap&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>本例中，红色的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.composited</span><br></pre></td></tr></table></figure>

<p>提升为了合成层，绿色的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.overlap</span><br></pre></td></tr></table></figure>

<p>fix 在页面顶部，一开始只有</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.composited</span><br></pre></td></tr></table></figure>

<p>合成层。</p>
<p>当滑动页面，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.overlap</span><br></pre></td></tr></table></figure>

<p>重叠到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.composited</span><br></pre></td></tr></table></figure>

<p>上时，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.overlap</span><br></pre></td></tr></table></figure>

<p>会因重叠原因提升为合成层，同时，因为相对于合成层滚动，因此无法被压缩。</p>
</li>
<li><p>当渲染层同合成层有不同的具有 opacity 的祖先层（一个设置了 opacity 且小于 1，一个没有设置 opacity，也算是不同）时，该渲染层无法压缩（squashingOpacityAncestorMismatch，同 squashingClippingContainerMismatch）<a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/squashingOpacityAncestorMismatch.html">demo</a></p>
</li>
<li><p>当渲染层同合成层有不同的具有 transform 的祖先层时，该渲染层无法压缩（squashingTransformAncestorMismatch，同上） <a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/squashingTransformAncestorMismatch.html">demo</a></p>
</li>
<li><p>当渲染层同合成层有不同的具有 filter 的祖先层时，该渲染层无法压缩（squashingFilterAncestorMismatch，同上）<a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/squashingFilterAncestorMismatch.html">demo</a></p>
</li>
<li><p>当覆盖的合成层正在运行动画时，该渲染层无法压缩（squashingLayerIsAnimating），当动画未开始或者运行完毕以后，该渲染层才可以被压缩 <a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/animating.html">demo</a><br><img src="/_posts/css/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1mJjwMXXXXXajXpXXXXXXXXXX-960-391.jpg" alt="img"></p>
</li>
</ul>
<h2 id="如何查看合成层"><a href="#如何查看合成层" class="headerlink" title="如何查看合成层"></a>如何查看合成层</h2><p>使用 Chrome DevTools 工具来查看页面中合成层的情况。</p>
<p>比较简单的方法是打开 DevTools，勾选上 <code>Show layer borders</code></p>
<p><img src="/_posts/css/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1dZG.MXXXXXX2XVXXXXXXXXXX-276-164.png" alt="img"></p>
<p>其中，页面上的合成层会用黄色边框框出来。</p>
<p><img src="/_posts/css/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1EQu4MXXXXXXiaXXXXXXXXXXX-709-717.png_600x600.jpg" alt="img"></p>
<p>当然，更加详细的信息可以通过 Timeline 来查看。</p>
<p>每一个单独的帧，看到每个帧的渲染细节：</p>
<p><img src="/_posts/css/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1.uznMXXXXXbcXFXXXXXXXXXX-325-195.jpg" alt="img"></p>
<p>点击之后，你就会在视图中看到一个新的选项卡：Layers。</p>
<p><img src="/_posts/css/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1uCgsLpXXXXXNXFXXXXXXXXXX-333-260.jpg" alt="img"></p>
<p>点击这个 Layers 选项卡，你会看到一个新的视图。在这个视图中，你可以对这一帧中的所有合成层进行扫描、缩放等操作，同时还能看到每个渲染层被创建的原因。</p>
<p><img src="/_posts/css/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB163nGMXXXXXatXXXXXXXXXXXX-1440-756.jpg_720x720.jpg" alt="img"></p>
<p>有了这个视图，你就能知道页面中到底有多少个合成层。如果你在对页面滚动或渐变效果的性能分析中发现 Composite 过程耗费了太多时间，那么你可以从这个视图里看到页面中有多少个渲染层，它们为何被创建，从而对合成层的数量进行优化。</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>提升为合成层简单说来有以下几点好处：</p>
<ul>
<li><p>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</p>
</li>
<li><p>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</p>
</li>
<li><p>对于 transform 和 opacity 效果，不会触发 layout 和 paint</p>
</li>
</ul>
<p>利用合成层对于提升页面性能方面有很大的作用，因此我们也总结了一下几点优化建议。</p>
<h3 id="提升动画效果的元素"><a href="#提升动画效果的元素" class="headerlink" title="提升动画效果的元素"></a>提升动画效果的元素</h3><p>合成层的好处是不会影响到其他元素的绘制，因此，为了减少动画元素对其他元素的影响，从而减少 paint，我们需要把动画效果中的元素提升为合成层。</p>
<p>提升合成层的最好方式是使用 CSS 的 will-change 属性。从上一节合成层产生原因中，可以知道 will-change 设置为 opacity、transform、top、left、bottom、right 可以将元素提升为合成层。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#target &#123;</span><br><span class="line">  will-change: transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其兼容如下所示：</p>
<p><img src="/_posts/css/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1_6P9LpXXXXblXXXXXXXXXXXX-1252-284.png_720x720.jpg" alt="img"></p>
<p>对于那些目前还不支持 will-change 属性的浏览器，目前常用的是使用一个 3D transform 属性来强制提升为合成层：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#target &#123;</span><br><span class="line">  transform: translateZ(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但需要注意的是，不要创建太多的渲染层。因为每创建一个新的渲染层，就意味着新的内存分配和更复杂的层的管理。之后我们会详细讨论。</p>
<p>如果你已经把一个元素放到一个新的合成层里，那么可以使用 Timeline 来确认这么做是否真的改进了渲染性能。别盲目提升合成层，一定要分析其实际性能表现。</p>
<h3 id="使用-transform-或者-opacity-来实现动画效果"><a href="#使用-transform-或者-opacity-来实现动画效果" class="headerlink" title="使用 transform 或者 opacity 来实现动画效果"></a>使用 transform 或者 opacity 来实现动画效果</h3><p>文章最开始，我们讲到了页面呈现出来所经历的渲染流水线，其实从性能方面考虑，最理想的渲染流水线是没有布局和绘制环节的，只需要做合成层的合并即可：</p>
<p><img src="/_posts/css/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB14YwvLpXXXXXGXFXXXXXXXXXX-1093-167.jpg_720x720.jpg" alt="img"></p>
<p>为了实现上述效果，就需要只使用那些仅触发 Composite 的属性。目前，只有两个属性是满足这个条件的：transforms 和 opacity。更详细的信息可以查看 <a href="http://csstriggers.com/">CSS Triggers</a>。</p>
<p>注意：元素提升为合成层后，transform 和 opacity 才不会触发 paint，如果不是合成层，则其依然会触发 paint。具体见如下两个 demo。</p>
<ul>
<li><p><a href="http://taobaofed.github.io/demo/performance-composite-demo/paint/promote-element/no-promote-transform.html">demo 1：transform</a><br><img src="/_posts/css/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1XsAVLpXXXXbzXpXXXXXXXXXX-712-411.png_640x640.jpg" alt="img"></p>
</li>
<li><p><a href="http://taobaofed.github.io/demo/performance-composite-demo/paint/promote-element/no-promote-opacity.html">demo 2：opacity</a><br><img src="/_posts/css/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1j9M7LpXXXXaiXXXXXXXXXXXX-713-424.png_640x640.jpg" alt="img"></p>
</li>
</ul>
<p>可以看到未提升 target element 为合成层，transform 和 opacity 依然会触发 paint。</p>
<h3 id="减少绘制区域"><a href="#减少绘制区域" class="headerlink" title="减少绘制区域"></a>减少绘制区域</h3><p>对于不需要重新绘制的区域应尽量避免绘制，以减少绘制区域，比如一个 fix 在页面顶部的固定不变的导航 header，在页面内容某个区域 repaint 时，整个屏幕包括 fix 的 header 也会被重绘，见 <a href="http://taobaofed.github.io/demo/performance-composite-demo/paint/reduce/no-reduce.html">demo</a>，结果如下：</p>
<p><img src="/_posts/css/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1SK_9LpXXXXcaaXXXXXXXXXXX-699-304.png" alt="img"></p>
<p>而对于固定不变的区域，我们期望其并不会被重绘，因此可以通过之前的方法，将其提升为独立的合成层。</p>
<p>减少绘制区域，需要仔细分析页面，区分绘制区域，减少重绘区域甚至避免重绘。</p>
<h3 id="合理管理合成层"><a href="#合理管理合成层" class="headerlink" title="合理管理合成层"></a>合理管理合成层</h3><p>看完上面的文章，你会发现提升合成层会达到更好的性能。这看上去非常诱人，但是问题是，创建一个新的合成层并不是免费的，它得消耗额外的内存和管理资源。实际上，在内存资源有限的设备上，合成层带来的性能改善，可能远远赶不上过多合成层开销给页面性能带来的负面影响。同时，由于每个渲染层的纹理都需要上传到 GPU 处理，因此我们还需要考虑 CPU 和 GPU 之间的带宽问题、以及有多大内存供 GPU 处理这些纹理的问题。</p>
<p>对于合成层占用内存的问题，我们简单做了几个 demo 进行了验证。</p>
<p><a href="http://taobaofed.github.io/demo/performance-composite-demo/memory/multi-layers-expect.html">demo 1</a> 和 <a href="http://taobaofed.github.io/demo/performance-composite-demo/memory/multi-layers.html">demo 2</a> 中，会创建 2000 个同样的 div 元素，不同的是 <a href="http://taobaofed.github.io/demo/performance-composite-demo/memory/multi-layers.html">demo 2</a> 中的元素通过 will-change 都提升为了合成层，而两个 demo 页面的内存消耗却有很明显的差别。</p>
<p><img src="/_posts/css/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1EMYKMXXXXXcUXXXXXXXXXXXX-972-480.jpg" alt="img"></p>
<h4 id="防止层爆炸"><a href="#防止层爆炸" class="headerlink" title="防止层爆炸"></a>防止层爆炸</h4><p>通过之前的介绍，我们知道同合成层重叠也会使元素提升为合成层，虽然有浏览器的层压缩机制，但是也有很多无法进行压缩的情况。也就是说除了我们显式的声明的合成层，还可能由于重叠原因不经意间产生一些不在预期的合成层，极端一点可能会产生大量的额外合成层，出现层爆炸的现象。我们简单写了一个极端点但其实在我们的页面中比较常见的 <a href="http://taobaofed.github.io/demo/performance-composite-demo/memory/layer-explode.html">demo</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  @-webkit-keyframes slide &#123;</span><br><span class="line">    from &#123; transform: none; &#125;</span><br><span class="line">    to &#123; transform: translateX(100px); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .animating &#123;</span><br><span class="line">    </span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 30px;</span><br><span class="line">    background-color: orange;</span><br><span class="line">    color: #fff;</span><br><span class="line">      -webkit-animation: slide 5s alternate linear infinite;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ul &#123;</span><br><span class="line"></span><br><span class="line">    padding: 5px;</span><br><span class="line">    border: 1px solid #000;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    .box &#123;</span><br><span class="line"></span><br><span class="line">    width: 600px;</span><br><span class="line">    height: 30px;</span><br><span class="line">    margin-bottom: 5px;</span><br><span class="line">    background-color: blue;</span><br><span class="line">    color: #fff;</span><br><span class="line">    position: relative;</span><br><span class="line">    /* 会导致无法压缩：squashingClippingContainerMismatch */</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .inner &#123;</span><br><span class="line">      position: absolute;</span><br><span class="line">      top: 2px;</span><br><span class="line">      left: 2px;</span><br><span class="line">      font-size: 16px;</span><br><span class="line">      line-height: 16px;</span><br><span class="line">      padding: 2px;</span><br><span class="line">      margin: 0;</span><br><span class="line">      background-color: green;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动画合成层 --&gt;</span><br><span class="line">&lt;div class=&quot;animating&quot;&gt;composited animating&lt;/div&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;!-- assume overlap --&gt;</span><br><span class="line">  &lt;li class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;!-- assume overlap --&gt;</span><br><span class="line">    &lt;p class=&quot;inner&quot;&gt;asume overlap, 因为 squashingClippingContainerMismatch 无法压缩&lt;/p&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p><a href="http://taobaofed.github.io/demo/performance-composite-demo/memory/layer-explode.html">demo</a> 中，<code>.animating</code> 的合成层在运行动画，会导致 <code>.inner</code> 元素因为上文介绍过的 assumedOverlap 的原因，而被提升为合成层，同时，<code>.inner</code> 的父元素 <code>.box</code> 设置了 <code>overflow: hidden</code>，导致 <code>.inner</code> 的合成层因为 squashingClippingContainerMismatch 的原因，无法压缩，就出现了层爆炸的问题。</p>
<p><img src="/_posts/css/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1E7PEMXXXXXbAXpXXXXXXXXXX-1390-778.jpg_720x720.jpg" alt="img"></p>
<p>这种情况平时在我们的业务中还是很常见的，比如 slider + list 的结构，一旦满足了无法进行层压缩的情况，就很容易出现层爆炸的问题。</p>
<p>解决层爆炸的问题，最佳方案是打破 overlap 的条件，也就是说让其他元素不要和合成层元素重叠。对于上述的示例，我们可以将 <code>.animation</code> 的 z-index 提高。修改后 <a href="http://taobaofed.github.io/demo/performance-composite-demo/memory/layer-explode-zIndex.html">demo</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.animating &#123;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  /* 让其他元素不和合成层重叠 */</span><br><span class="line">  position: relative;</span><br><span class="line">  z-index: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，就只有 <code>.animating</code> 提升为合成层，如下：</p>
<p><img src="/_posts/css/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1LxrnMXXXXXcIXVXXXXXXXXXX-1366-777.jpg_720x720.jpg" alt="img"></p>
<p>同时，内存占用比起之前也降低了很多。</p>
<p><img src="/_posts/css/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1FoDwMXXXXXc2XFXXXXXXXXXX-947-485.jpg" alt="img"></p>
<p>如果受限于视觉需要等因素，其他元素必须要覆盖在合成层之上，那应该尽量避免无法层压缩情况的出现。针对上述示例中，无法层压缩的情况（squashingClippingContainerMismatch），我们可以将 <code>.box</code> 的 <code>overflow: hidden</code> 去掉，这样就可以利用浏览器的层压缩了。修改后 <a href="http://taobaofed.github.io/demo/performance-composite-demo/memory/layer-explode-squash.html">demo</a></p>
<p>此时，由于第一个 <code>.box</code> 因为 squashingLayerIsAnimating 的原因无法压缩，其他的都被压缩到了一起。</p>
<p><img src="/_posts/css/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1OE6uMXXXXXc8XFXXXXXXXXXX-1368-774.jpg_720x720.jpg" alt="img"></p>
<p>同时，内存占用比起之前也降低了很多。</p>
<p><img src="/_posts/css/assets/%E6%B7%98%E5%AE%9D%E5%9B%A2%E9%98%9F%E6%96%87%E7%AB%A0/TB1eYvqMXXXXXbJXVXXXXXXXXXX-936-480.jpg" alt="img"></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>之前无线开发时，大多数人都很喜欢使用 <code>translateZ(0)</code> 来进行所谓的硬件加速，以提升性能，但是性能优化并没有所谓的“银弹”，<code>translateZ(0)</code> 不是，本文列出的优化建议也不是。抛开了对页面的具体分析，任何的性能优化都是站不住脚的，盲目的使用一些优化措施，结果可能会适得其反。因此切实的去分析页面的实际性能表现，不断的改进测试，才是正确的优化途径。</p>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>转载至淘宝，防止原链接失效</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>层叠上下文</tag>
        <tag>复合图层</tag>
        <tag>浏览器渲染</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>对象属性方法总结</title>
    <url>/ES6/%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">不可枚举属性</th>
<th align="center">继承属性</th>
<th align="center">symbol属性</th>
<th align="center">自身属性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">for…in &#x2F; in</td>
<td align="center">❌</td>
<td align="center">✅</td>
<td align="center">❌</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">Object.keys()、Object.values()、Object.entries()</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">Object.getOwnPropertyNames()</td>
<td align="center">✅</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">Object.getOwnPropertySymbols(obj)</td>
<td align="center">✅</td>
<td align="center">❌</td>
<td align="center">✅</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">Reflect.ownKeys(obj)</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">JSON.stringfy()</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">Object.assign()</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">… 扩展运算符</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">Object.getOwnPropertyDescriptor<a href="">s</a></td>
<td align="center">✅</td>
<td align="center">❌</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
</tbody></table>
<style>
table th:nth-of-type(1){
  width: 40%;
}
table th:nth-of-type(2){
width: 15%;
}
table th:nth-of-type(3){
width: 15%;
}
table th:nth-of-type(4){
width: 15%;
}
table th:nth-of-type(5){
width: 15%;
}
</style>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>对象遍历</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>diff算法</title>
    <url>/vue/diff%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><strong>转载至</strong> <a href="https://github.com/aooy/blog/issues/2">blog</a><br>diff 算法 也可以参考<a href="https://juejin.cn/book/6844733705089449991/section/6844733705232056328">掘金小册</a></p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li>前言</li>
<li>virtual dom</li>
<li>分析diff</li>
<li>总结</li>
</ul>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>vue2.0加入了virtual dom，有向react靠拢的意思。vue的diff位于<a href="https://github.com/vuejs/vue/blob/dev/src/core/vdom/patch.js">patch.js</a>文件中，我的一个小框架<a href="https://github.com/aooy/aoy">aoy</a>也同样使用此算法，该算法来源于<a href="https://github.com/snabbdom/snabbdom">snabbdom</a>，复杂度为O(n)。<br>了解diff过程可以让我们更高效的使用框架。<br>本文力求以图文并茂的方式来讲明这个diff的过程。</p>
<h1 id="virtual-dom"><a href="#virtual-dom" class="headerlink" title="virtual dom"></a>virtual dom</h1><p>如果不了解virtual dom，要理解diff的过程是比较困难的。虚拟dom对应的是真实dom， 使用<code>document.CreateElement</code> 和 <code>document.CreateTextNode</code>创建的就是真实节点。</p>
<p>我们可以做个试验。打印出一个空元素的第一层属性，可以看到标准让元素实现的东西太多了。如果每次都重新生成新的元素，对性能是巨大的浪费。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var mydiv = document.createElement(&#x27;div&#x27;);</span><br><span class="line">for(var k in mydiv )&#123;</span><br><span class="line">  console.log(k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>virtual dom就是解决这个问题的一个思路，到底什么是virtual dom呢？通俗易懂的来说就是用一个简单的对象去代替复杂的dom对象。<br>举个简单的例子，我们在body里插入一个class为a的div。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var mydiv = document.createElement(&#x27;div&#x27;);</span><br><span class="line">mydiv.className = &#x27;a&#x27;;</span><br><span class="line">document.body.appendChild(mydiv);</span><br></pre></td></tr></table></figure>

<p>对于这个div我们可以用一个简单的对象<code>mydivVirtual</code>代表它，它存储了对应dom的一些重要参数，在改变dom之前，会先比较相应虚拟dom的数据，如果需要改变，才会将改变应用到真实dom上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//伪代码</span><br><span class="line">var mydivVirtual = &#123; </span><br><span class="line">  tagName: &#x27;DIV&#x27;,</span><br><span class="line">  className: &#x27;a&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">var newmydivVirtual = &#123;</span><br><span class="line">   tagName: &#x27;DIV&#x27;,</span><br><span class="line">   className: &#x27;b&#x27;</span><br><span class="line">&#125;</span><br><span class="line">if(mydivVirtual.tagName !== newmydivVirtual.tagName || mydivVirtual.className  !== newmydivVirtual.className)&#123;</span><br><span class="line">   change(mydiv)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 会执行相应的修改 mydiv.className = &#x27;b&#x27;;</span><br><span class="line">//最后  &lt;div class=&#x27;b&#x27;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="读到这里就会产生一个疑问，为什么不直接修改dom而需要加一层virtual-dom呢？"><a href="#读到这里就会产生一个疑问，为什么不直接修改dom而需要加一层virtual-dom呢？" class="headerlink" title="读到这里就会产生一个疑问，为什么不直接修改dom而需要加一层virtual dom呢？"></a>读到这里就会产生一个疑问，为什么不直接修改dom而需要加一层virtual dom呢？</h4><p>很多时候手工优化dom确实会比virtual dom效率高，对于比较简单的dom结构用手工优化没有问题，但当页面结构很庞大，结构很复杂时，手工优化会花去大量时间，而且可维护性也不高，不能保证每个人都有手工优化的能力。至此，virtual dom的解决方案应运而生，<strong>virtual dom很多时候都不是最优的操作，但它具有普适性，在效率、可维护性之间达平衡。</strong></p>
<p>virtual dom 另一个重大意义就是提供一个中间层，js去写ui，ios安卓之类的负责渲染，就像reactNative一样。</p>
<h1 id="分析diff"><a href="#分析diff" class="headerlink" title="分析diff"></a>分析diff</h1><p>一篇相当经典的文章<a href="https://calendar.perfplanet.com/2013/diff/">React’s diff algorithm</a>中的图，react的diff其实和vue的diff大同小异。所以这张图能很好的解释过程。<strong>比较只会在同层级进行, 不会跨层级比较。</strong></p>
<p><a href="https://github.com/aooy/blog/blob/master/images/issues-2/diff.png?raw=true"><img src="/_posts/vue/assets/diff%E7%AE%97%E6%B3%95/diff.png" alt="img"></a></p>
<p>举个形象的例子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 之前 --&gt;</span><br><span class="line">&lt;div&gt;           &lt;!-- 层级1 --&gt;</span><br><span class="line">  &lt;p&gt;            &lt;!-- 层级2 --&gt;</span><br><span class="line">    &lt;b&gt; aoy &lt;/b&gt;   &lt;!-- 层级3 --&gt;   </span><br><span class="line">    &lt;span&gt;diff&lt;/Span&gt;</span><br><span class="line">  &lt;/P&gt; </span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 之后 --&gt;</span><br><span class="line">&lt;div&gt;            &lt;!-- 层级1 --&gt;</span><br><span class="line">  &lt;p&gt;             &lt;!-- 层级2 --&gt;</span><br><span class="line">      &lt;b&gt; aoy &lt;/b&gt;        &lt;!-- 层级3 --&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;span&gt;diff&lt;/Span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>我们可能期望将<code>&lt;span&gt;</code>直接移动到<code>&lt;p&gt;</code>的后边，这是最优的操作。但是实际的diff操作是移除<code>&lt;p&gt;</code>里的<code>&lt;span&gt;</code>在创建一个新的<code>&lt;span&gt;</code>插到<code>&lt;p&gt;</code>的后边。<br>因为新加的<code>&lt;span&gt;</code>在层级2，旧的在层级3，属于不同层级的比较。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>文中的代码位于<a href="https://github.com/aooy/aoy/blob/master/src/vdom/diff.js">aoy-diff</a>中，已经精简了很多代码，留下最核心的部分。</p>
<p>diff的过程就是调用patch函数，就像打补丁一样修改真实dom。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function patch (oldVnode, vnode) &#123;</span><br><span class="line"> if (sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">  patchVnode(oldVnode, vnode)</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">  const oEl = oldVnode.el</span><br><span class="line">  let parentEle = api.parentNode(oEl)</span><br><span class="line">  createEle(vnode)</span><br><span class="line">  if (parentEle !== null) &#123;</span><br><span class="line">   api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl))</span><br><span class="line">   api.removeChild(parentEle, oldVnode.el)</span><br><span class="line">   oldVnode = null</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> return vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>patch</code>函数有两个参数，<code>vnode</code>和<code>oldVnode</code>，也就是新旧两个虚拟节点。在这之前，我们先了解完整的vnode都有什么属性，举个一个简单的例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// body下的 &lt;div id=&quot;v&quot; class=&quot;classA&quot;&gt;&lt;div&gt; 对应的 oldVnode 就是</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  el:  div  //对真实的节点的引用，本例中就是document.querySelector(&#x27;#id.classA&#x27;)</span><br><span class="line">  tagName: &#x27;DIV&#x27;,   //节点的标签</span><br><span class="line">  sel: &#x27;div#v.classA&#x27;  //节点的选择器</span><br><span class="line">  data: null,       // 一个存储节点属性的对象，对应节点的el[prop]属性，例如onclick , style</span><br><span class="line">  children: [], //存储子节点的数组，每个子节点也是vnode结构</span><br><span class="line">  text: null,    //如果是文本节点，对应文本节点的textContent，否则为null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，el属性引用的是此 virtual dom对应的真实dom，<code>patch</code>的<code>vnode</code>参数的<code>el</code>最初是null，因为<code>patch</code>之前它还没有对应的真实dom。</p>
<p>来到<code>patch</code>的第一部分，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line"> patchVnode(oldVnode, vnode)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><code>sameVnode</code>函数就是看这两个节点是否值得比较，代码相当简单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function sameVnode(oldVnode, vnode)&#123;</span><br><span class="line"> return vnode.key === oldVnode.key &amp;&amp; vnode.sel === oldVnode.sel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个vnode的key和sel相同才去比较它们，比如<code>p</code>和<code>span</code>，<code>div.classA</code>和<code>div.classB</code>都被认为是不同结构而不去比较它们。</p>
<p>如果值得比较会执行<code>patchVnode(oldVnode, vnode)</code>，稍后会详细讲<code>patchVnode</code>函数。</p>
<p>当节点不值得比较，进入else中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">else &#123;</span><br><span class="line">  const oEl = oldVnode.el</span><br><span class="line">  let parentEle = api.parentNode(oEl)</span><br><span class="line">  createEle(vnode)</span><br><span class="line">  if (parentEle !== null) &#123;</span><br><span class="line">   api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl))</span><br><span class="line">   api.removeChild(parentEle, oldVnode.el)</span><br><span class="line">   oldVnode = null</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>过程如下：</p>
<ul>
<li>取得<code>oldvnode.el</code>的父节点，<code>parentEle</code>是真实dom</li>
<li><code>createEle(vnode)</code>会为<code>vnode</code>创建它的真实dom，令<code>vnode.el</code> &#x3D;<code>真实dom</code></li>
<li><code>parentEle</code>将新的dom插入，移除旧的dom<br><strong>当不值得比较时，新节点直接把老节点整个替换了</strong></li>
</ul>
<p>最后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return vnode</span><br></pre></td></tr></table></figure>

<p>patch最后会返回vnode，vnode和进入patch之前的不同在哪？<br>没错，就是vnode.el，<strong>唯一的改变就是之前vnode.el &#x3D; null, 而现在它引用的是对应的真实dom。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var oldVnode = patch (oldVnode, vnode)</span><br></pre></td></tr></table></figure>

<p>至此完成一个patch过程。</p>
<h3 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a>patchVnode</h3><p>两个节点值得比较时，会调用<code>patchVnode</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">patchVnode (oldVnode, vnode) &#123;</span><br><span class="line">    const el = vnode.el = oldVnode.el</span><br><span class="line">    let i, oldCh = oldVnode.children, ch = vnode.children</span><br><span class="line">    if (oldVnode === vnode) return</span><br><span class="line">    if (oldVnode.text !== null &amp;&amp; vnode.text !== null &amp;&amp; oldVnode.text !== vnode.text) &#123;</span><br><span class="line">        api.setTextContent(el, vnode.text)</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        updateEle(el, vnode, oldVnode)</span><br><span class="line">     if (oldCh &amp;&amp; ch &amp;&amp; oldCh !== ch) &#123;</span><br><span class="line">      updateChildren(el, oldCh, ch)</span><br><span class="line">     &#125;else if (ch)&#123;</span><br><span class="line">      createEle(vnode) //create el&#x27;s children dom</span><br><span class="line">     &#125;else if (oldCh)&#123;</span><br><span class="line">      api.removeChildren(el)</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>const el = vnode.el = oldVnode.el</code> 这是很重要的一步，让<code>vnode.el</code>引用到现在的真实dom，当<code>el</code>修改时，<code>vnode.el</code>会同步变化。</p>
<p>节点的比较有5种情况</p>
<ol>
<li><code>if (oldVnode === vnode)</code>，他们的引用一致，可以认为没有变化。</li>
<li><code>if(oldVnode.text !== null &amp;&amp; vnode.text !== null &amp;&amp; oldVnode.text !== vnode.text)</code>，文本节点的比较，需要修改，则会调用<code>Node.textContent = vnode.text</code>。</li>
<li><code>if( oldCh &amp;&amp; ch &amp;&amp; oldCh !== ch )</code>, 两个节点都有子节点，而且它们不一样，这样我们会调用<code>updateChildren</code>函数比较子节点，这是diff的核心，后边会讲到。</li>
<li><code>else if (ch)</code>，只有新的节点有子节点，调用<code>createEle(vnode)</code>，<code>vnode.el</code>已经引用了老的dom节点，<code>createEle</code>函数会在老dom节点上添加子节点。</li>
<li><code>else if (oldCh)</code>，新节点没有子节点，老节点有子节点，直接删除老节点。</li>
</ol>
<h3 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">updateChildren (parentElm, oldCh, newCh) &#123;</span><br><span class="line">    let oldStartIdx = 0, newStartIdx = 0</span><br><span class="line">    let oldEndIdx = oldCh.length - 1</span><br><span class="line">    let oldStartVnode = oldCh[0]</span><br><span class="line">    let oldEndVnode = oldCh[oldEndIdx]</span><br><span class="line">    let newEndIdx = newCh.length - 1</span><br><span class="line">    let newStartVnode = newCh[0]</span><br><span class="line">    let newEndVnode = newCh[newEndIdx]</span><br><span class="line">    let oldKeyToIdx</span><br><span class="line">    let idxInOld</span><br><span class="line">    let elmToMove</span><br><span class="line">    let before</span><br><span class="line">    while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">            if (oldStartVnode == null) &#123;   //对于vnode.key的比较，会把oldVnode = null</span><br><span class="line">                oldStartVnode = oldCh[++oldStartIdx] </span><br><span class="line">            &#125;else if (oldEndVnode == null) &#123;</span><br><span class="line">                oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">            &#125;else if (newStartVnode == null) &#123;</span><br><span class="line">                newStartVnode = newCh[++newStartIdx]</span><br><span class="line">            &#125;else if (newEndVnode == null) &#123;</span><br><span class="line">                newEndVnode = newCh[--newEndIdx]</span><br><span class="line">            &#125;else if (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">                patchVnode(oldStartVnode, newStartVnode)</span><br><span class="line">                oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">                newStartVnode = newCh[++newStartIdx]</span><br><span class="line">            &#125;else if (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">                patchVnode(oldEndVnode, newEndVnode)</span><br><span class="line">                oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">                newEndVnode = newCh[--newEndIdx]</span><br><span class="line">            &#125;else if (sameVnode(oldStartVnode, newEndVnode)) &#123;</span><br><span class="line">                patchVnode(oldStartVnode, newEndVnode)</span><br><span class="line">                api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el))</span><br><span class="line">                oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">                newEndVnode = newCh[--newEndIdx]</span><br><span class="line">            &#125;else if (sameVnode(oldEndVnode, newStartVnode)) &#123;</span><br><span class="line">                patchVnode(oldEndVnode, newStartVnode)</span><br><span class="line">                api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el)</span><br><span class="line">                oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">                newStartVnode = newCh[++newStartIdx]</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">               // 使用key时的比较</span><br><span class="line">                if (oldKeyToIdx === undefined) &#123;</span><br><span class="line">                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) // 有key生成index表</span><br><span class="line">                &#125;</span><br><span class="line">                idxInOld = oldKeyToIdx[newStartVnode.key]</span><br><span class="line">                if (!idxInOld) &#123;</span><br><span class="line">                    api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)</span><br><span class="line">                    newStartVnode = newCh[++newStartIdx]</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    elmToMove = oldCh[idxInOld]</span><br><span class="line">                    if (elmToMove.sel !== newStartVnode.sel) &#123;</span><br><span class="line">                        api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        patchVnode(elmToMove, newStartVnode)</span><br><span class="line">                        oldCh[idxInOld] = null</span><br><span class="line">                        api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el)</span><br><span class="line">                    &#125;</span><br><span class="line">                    newStartVnode = newCh[++newStartIdx]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">            before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].el</span><br><span class="line">            addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx)</span><br><span class="line">        &#125;else if (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">            removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很密集，为了形象的描述这个过程，可以看看这张图。</p>
<p><a href="https://github.com/aooy/blog/blob/master/images/issues-2/diff2.png?raw=true"><img src="/_posts/vue/assets/diff%E7%AE%97%E6%B3%95/diff2.png" alt="img"></a></p>
<p>过程可以概括为：<code>oldCh</code>和<code>newCh</code>各有两个头尾的变量<code>StartIdx</code>和<code>EndIdx</code>，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦<code>StartIdx&gt;EndIdx</code>表明<code>oldCh</code>和<code>newCh</code>至少有一个已经遍历完了，就会结束比较。</p>
<h3 id="具体的diff分析"><a href="#具体的diff分析" class="headerlink" title="具体的diff分析"></a>具体的diff分析</h3><p>设置key和不设置key的区别：<br><strong>不设key，newCh和oldCh只会进行头尾两端的相互比较，设key后，除了头尾两端的比较外，还会从用key生成的对象<code>oldKeyToIdx</code>中查找匹配的节点，所以为节点设置key可以更高效的利用dom。</strong></p>
<p>diff的遍历过程中，只要是对dom进行的操作都调用<code>api.insertBefore</code>，<code>api.insertBefore</code>只是原生<code>insertBefore</code>的简单封装。<br>比较分为两种，一种是有<code>vnode.key</code>的，一种是没有的。但这两种比较对真实dom的操作是一致的。</p>
<p>对于与<code>sameVnode(oldStartVnode, newStartVnode)</code>和<code>sameVnode(oldEndVnode,newEndVnode)</code>为true的情况，不需要对dom进行移动。</p>
<p>总结遍历过程，有3种dom操作：</p>
<ol>
<li>当<code>oldStartVnode</code>，<code>newEndVnode</code>值得比较，说明<code>oldStartVnode.el</code>跑到<code>oldEndVnode.el</code>的后边了。</li>
</ol>
<p>图中假设startIdx遍历到1。</p>
<p><a href="https://github.com/aooy/blog/blob/master/images/issues-2/diff3.png?raw=true"><img src="/_posts/vue/assets/diff%E7%AE%97%E6%B3%95/diff3.png" alt="img"></a></p>
<ol>
<li>当<code>oldEndVnode</code>，<code>newStartVnode</code>值得比较，说明 <code>oldEndVnode.el</code>跑到了<code>newStartVnode.el</code>的前边。（这里笔误，应该是“oldEndVnode.el跑到了oldStartVnode.el的前边”，准确的说应该是oldEndVnode.el需要移动到oldStartVnode.el的前边”）</li>
</ol>
<p><a href="https://github.com/aooy/blog/blob/master/images/issues-2/diff4.png?raw=true"><img src="/_posts/vue/assets/diff%E7%AE%97%E6%B3%95/diff4.png" alt="img"></a></p>
<ol>
<li>newCh中的节点oldCh里没有， 将新节点插入到<code>oldStartVnode.el</code>的前边。</li>
</ol>
<p><a href="https://github.com/aooy/blog/blob/master/images/issues-2/diff5.png?raw=true"><img src="/_posts/vue/assets/diff%E7%AE%97%E6%B3%95/diff5.png" alt="img"></a></p>
<p>在结束时，分为两种情况：</p>
<ol>
<li><code>oldStartIdx &gt; oldEndIdx</code>，可以认为<code>oldCh</code>先遍历完。当然也有可能<code>newCh</code>此时也正好完成了遍历，统一都归为此类。此时<code>newStartIdx</code>和<code>newEndIdx</code>之间的vnode是新增的，调用<code>addVnodes</code>，把他们全部插进<code>before</code>的后边，<code>before</code>很多时候是为null的。<code>addVnodes</code>调用的是<code>insertBefore</code>操作dom节点，我们看看<code>insertBefore</code>的文档：<code>parentElement.insertBefore(newElement, referenceElement)</code><br>如果referenceElement为null则newElement将被插入到子节点的末尾。如果newElement已经在DOM树中，newElement首先会从DOM树中移除。<strong>所以<code>before</code>为null，newElement将被插入到子节点的末尾。</strong></li>
</ol>
<p><a href="https://github.com/aooy/blog/blob/master/images/issues-2/diff6.png?raw=true"><img src="/_posts/vue/assets/diff%E7%AE%97%E6%B3%95/diff6.png" alt="img"></a></p>
<ol>
<li><code>newStartIdx &gt; newEndIdx</code>，可以认为<code>newCh</code>先遍历完。此时<code>oldStartIdx</code>和<code>oldEndIdx</code>之间的vnode在新的子节点里已经不存在了，调用<code>removeVnodes</code>将它们从dom里删除。</li>
</ol>
<p><a href="https://github.com/aooy/blog/blob/master/images/issues-2/diff7.png?raw=true"><img src="/_posts/vue/assets/diff%E7%AE%97%E6%B3%95/diff7.png" alt="img"></a></p>
<h4 id="下面举个例子，画出diff完整的过程，每一步dom的变化都用不同颜色的线标出"><a href="#下面举个例子，画出diff完整的过程，每一步dom的变化都用不同颜色的线标出" class="headerlink" title="下面举个例子，画出diff完整的过程，每一步dom的变化都用不同颜色的线标出"></a>下面举个例子，画出diff完整的过程，每一步dom的变化都用不同颜色的线标出</h4><ol>
<li>a,b,c,d,e假设是4个不同的元素，我们没有设置key时，b没有复用，而是直接创建新的，删除旧的。</li>
</ol>
<p><a href="https://github.com/aooy/blog/blob/master/images/issues-2/diff8.png?raw=true"><img src="/_posts/vue/assets/diff%E7%AE%97%E6%B3%95/diff8.png" alt="img"></a></p>
<ol>
<li>当我们给4个元素加上唯一key时，b得到了的复用。</li>
</ol>
<p><a href="https://github.com/aooy/blog/blob/master/images/issues-2/diff9.png?raw=true"><img src="/_posts/vue/assets/diff%E7%AE%97%E6%B3%95/diff9.png" alt="img"></a></p>
<p>这个例子如果我们使用手工优化，只需要3步就可以达到。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>尽量不要跨层级的修改dom</li>
<li>设置key可以最大化的利用节点</li>
<li>diff的效率并不是每种情况下都是最优的</li>
</ul>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>diff</tag>
      </tags>
  </entry>
  <entry>
    <title>vue问题记录</title>
    <url>/vue/vue%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="v-model-的修饰符"><a href="#v-model-的修饰符" class="headerlink" title="v-model 的修饰符"></a>v-model 的修饰符</h2><h3 id="prop"><a href="#prop" class="headerlink" title=".prop"></a>.prop</h3><p>将属性绑定至dom的原生properties,看下边例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div v-bind:test=&quot;ceshiProp&quot; class=&quot;prop&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div v-bind.prop:test=&quot;ceshiProp&quot; class=&quot;prop&quot;&gt;&lt;/div&gt;</span><br><span class="line">ceshiProp: &#123;</span><br><span class="line">  a:1,</span><br><span class="line">  b:2 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染结果如下：</p>
<p><img src="/_posts/vue/assets/vue%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/image-20210121155711009.png" alt="image-20210121155711009"></p>
<ul>
<li>Property：节点对象在内存中存储的属性，可以访问和设置。</li>
<li>Attribute：节点对象的其中一个属性( property )，值是一个对象，可以通过点访问法 document.getElementById(‘xx’).attributes 或者 document.getElementById(‘xx’).getAttributes(‘xx’) 读取，通过 document.getElementById(‘xx’).setAttribute(‘xx’,value) 新增和修改。<br>在标签里定义的所有属性包括 HTML 属性和自定义属性都会在 attributes 对象里以键值对的方式存在。</li>
</ul>
<p>太深层的暂不探究</p>
<h3 id="number"><a href="#number" class="headerlink" title=".number"></a>.number</h3><p>自动将数值转换为number，和el-input type&#x3D;number 一起用 会有bug</p>
<h2 id="v-on-修饰符"><a href="#v-on-修饰符" class="headerlink" title="v-on 修饰符"></a>v-on 修饰符</h2><h3 id="passive"><a href="#passive" class="headerlink" title=".passive"></a>.passive</h3><p>passive这个修饰符会执行默认方法。你们可能会问，明明默认执行为什么会设置这样一个修饰符。这就要说一下这个修饰符的本意了。</p>
<p>​    【浏览器只有等内核线程执行到事件监听器对应的JavaScript代码时，才能知道内部是否会调用preventDefault函数来阻止事件的默认行为，所以浏览器本身是没有办法对这种场景进行优化的。这种场景下，用户的手势事件无法快速产生，会导致页面无法快速执行滑动逻辑，从而让用户感觉到页面卡顿。】</p>
<p>​    通俗点说就是每次事件产生，浏览器都会去查询一下是否有preventDefault阻止该次事件的默认动作。我们加上<strong>passive就是为了告诉浏览器，不用查询了，我们没用preventDefault阻止默认动作。</strong></p>
<p>​    这里一般用在滚动监听，@scoll，@touchmove 。因为滚动监听过程中，移动每个像素都会产生一次事件，每次都使用内核线程查询prevent会使滑动卡顿。我们通过passive将内核线程查询跳过，可以大大提升滑动的流畅度。</p>
<h2 id="获取初始data"><a href="#获取初始data" class="headerlink" title="获取初始data"></a>获取初始data</h2><p>在某些情况我们可能要重置data上面的某些属性，比如在表单提交后需要清空form</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$data // 组件当前data对象</span><br><span class="line">this.$options.data() // 组件初始化状态下的data对象</span><br><span class="line"></span><br><span class="line">Object.assign(this.$data, this.$options.data()) // 重置data对象到初始化状态</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上这个this.$options.data 是一个函数，也就是组件声明时用来初始化data的函数</p>
</blockquote>
<h2 id="在不刷新页面的情况下，更新页面"><a href="#在不刷新页面的情况下，更新页面" class="headerlink" title="在不刷新页面的情况下，更新页面"></a>在不刷新页面的情况下，更新页面</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 先注册一个名为 `redirect` 的路由</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  beforeCreate() &#123;</span><br><span class="line">    const &#123; params, query &#125; = this.$route</span><br><span class="line">    const &#123; path &#125; = params</span><br><span class="line">    this.$router.replace(&#123; path: &#x27;/&#x27; + path, query &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  render: function(h) &#123;</span><br><span class="line">    return h() // avoid warning message</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 手动重定向页面到 &#x27;/redirect&#x27; 页面 实现更新页面</span><br><span class="line">const &#123; fullPath &#125; = this.$route</span><br><span class="line">this.$router.replace(&#123;</span><br><span class="line">  path: &#x27;/redirect&#x27; + fullPath</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当遇到你需要刷新页面的情况，你就手动重定向页面到<code>redirect</code>页面，它会将页面重新<code>redirect</code>重定向回来，由于页面的 key 发生了变化，从而间接实现了刷新页面组件的效果。</p>
<h2 id="动态清除注册的路由"><a href="#动态清除注册的路由" class="headerlink" title="动态清除注册的路由"></a>动态清除注册的路由</h2><p> 那就是动态添加的路由，并不能动态的删除。这就是导致一个问题，当用户权限发生变化的时候，或者说用户登出的时候，我们只能通过刷新页面的方式，才能清空我们之前注册的路由。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function resetRouter() &#123;</span><br><span class="line"> const newRouter = createRouter()</span><br><span class="line"> router.matcher = newRouter.matcher // reset router</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 它的原理其实很简单，所有的 vue-router 注册的路由信息都是存放在<code>matcher</code>之中的，所以当我们想清空路由的时候，我们只要新建一个空的<code>Router实例</code>，将它的<code>matcher</code>重新赋值给我们之前定义的路由就可以了。巧妙的实现了动态路由的清除。 现在我们只需要调用<code>resetRouter</code>，就能得到一个空的路有实例，之后你就可以重新<code>addRoutes</code>你想要的路由了</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>11.html和css优化</title>
    <url>/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/html&amp;css%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="html的优化"><a href="#html的优化" class="headerlink" title="html的优化"></a>html的优化</h3><ul>
<li>减少iframes的使用<ul>
<li>必须使用的时候 延迟加载，动态赋予src</li>
</ul>
</li>
<li>压缩空白符</li>
<li>避免节点深层次嵌套</li>
<li>避免使用table布局（已经没人用了）</li>
<li>删除注释</li>
<li>css&amp;js 尽量外链</li>
<li>删除元素默认属性</li>
<li>语义化标签</li>
</ul>
<h4 id="借用工具进行优化"><a href="#借用工具进行优化" class="headerlink" title="借用工具进行优化"></a>借用工具进行优化</h4><ul>
<li>html-minifier (webpack已经集成)</li>
</ul>
<h3 id="css优化"><a href="#css优化" class="headerlink" title="css优化"></a>css优化</h3><ul>
<li>降低css对渲染的阻塞</li>
<li>利用gpu完成动画绘制</li>
<li>使用contain属性<ul>
<li><a href="https://www.webhek.com/post/css-contain-property.html">contain介绍</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/contain">MDN-contain</a></li>
</ul>
</li>
<li>使用font-display属性</li>
</ul>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>html和css优化</tag>
      </tags>
  </entry>
  <entry>
    <title>对象的新增方法</title>
    <url>/ES6/%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>对象的详细方法见js高程第四版第八章</p>
<h2 id="对象ES6之后方法的简单总结"><a href="#对象ES6之后方法的简单总结" class="headerlink" title="对象ES6之后方法的简单总结"></a>对象ES6之后方法的简单总结</h2><p>本章介绍 Object 对象的新增方法。</p>
<h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h3><p>它<strong>用来比较两个值是否严格相等，与严格比较运算符（&#x3D;&#x3D;&#x3D;）的行为基本一致</strong>。</p>
<p>不同之处只有两个：<strong>一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">+<span class="number">0</span> === -<span class="number">0</span> <span class="comment">//true</span></span><br><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(+<span class="number">0</span>, -<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="title class_">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p><code>Object.assign</code>方法用于对象的合并，将源对象（source）的所有<strong>可枚举属性</strong>，复制到目标对象（target）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:, c:3&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p><code>Object.assign</code>拷贝的属性是有限制的，</p>
<ul>
<li><p>浅拷贝</p>
</li>
<li><p><strong>只拷贝源对象的自身属性（不拷贝继承属性）</strong></p>
</li>
<li><p><strong>不拷贝不可枚举的属性</strong>（<code>enumerable: false</code>）</p>
</li>
<li><p><code>Object.assign</code>只能进行值的复制，无法复制取值函数，将求值后再复制</p>
</li>
<li><p>数组的处理</p>
<blockquote>
<p>Object.assign([1, 2, 3], [4, 5])<br>&#x2F;&#x2F; [4, 5, 3]</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>属性名为 Symbol 值的属性，也会被<code>Object.assign</code>拷贝。</p>
</blockquote>
<h4 id="完整的复制对象"><a href="#完整的复制对象" class="headerlink" title="完整的复制对象"></a>完整的复制对象</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 写法一 不能复制不可枚举 不能复制取值函数 </span><br><span class="line">const clone2 = Object.assign(</span><br><span class="line">  Object.create(Object.getPrototypeOf(obj)),</span><br><span class="line">  obj</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 写法二  完美复制</span><br><span class="line">const clone3 = Object.create(</span><br><span class="line">  Object.getPrototypeOf(obj),</span><br><span class="line">  Object.getOwnPropertyDescriptors(obj)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h3><p>ES5 的<code>Object.getOwnPropertyDescriptor(obj, prop)</code>方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了<code>Object.getOwnPropertyDescriptors()</code>方法，返回指定对象所有自身属性（<strong>非继承属性</strong>）的描述对象。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">描述对象MDN</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">bar</span>() &#123; <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj)</span><br><span class="line"><span class="comment">// &#123; foo:</span></span><br><span class="line"><span class="comment">//    &#123; value: 123,</span></span><br><span class="line"><span class="comment">//      writable: true,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125;,</span></span><br><span class="line"><span class="comment">//   bar:</span></span><br><span class="line"><span class="comment">//    &#123; get: [Function: get bar],</span></span><br><span class="line"><span class="comment">//      set: undefined,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="原型链方法"><a href="#原型链方法" class="headerlink" title="原型链方法"></a>原型链方法</h3><p>JavaScript 语言的对象继承是通过原型链实现的。ES6 提供了更多原型对象的操作方法。</p>
<h4 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h4><p><code>Object.setPrototypeOf</code>方法的作用与<code>__proto__</code>相同，用来设置一个对象的原型对象（prototype），返回参数对象本身。它是 <strong>ES6 正式推荐的设置原型对象的方法</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==格式==</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(object, prototype)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">const</span> o = <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(&#123;&#125;, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>该方法等同于下面的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setPrototypeOf</span>(<span class="params">obj, proto</span>) &#123;</span><br><span class="line">  obj.<span class="property">__proto__</span> = proto;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h4><p>该方法与<code>Object.setPrototypeOf</code>方法配套，用于读取一个对象的原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj);</span><br></pre></td></tr></table></figure>

<h3 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h3><p><code>Object.keys()</code> <code>Object.values</code> <code>Object.entries</code></p>
<p>都是不可遍历 <strong>对象自身的（不含继承的）所有可遍历（enumerable）属性的键名</strong></p>
<p>ES5 引入了<code>Object.keys</code>方法，返回一个数组，成员是参数<strong>对象自身的（不含继承的）所有可遍历（enumerable）属性的键名</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = &#123; foo: &#x27;bar&#x27;, baz: 42 &#125;;</span><br><span class="line">Object.keys(obj)</span><br><span class="line">// [&quot;foo&quot;, &quot;baz&quot;]</span><br></pre></td></tr></table></figure>

<p>ES2017 <a href="https://github.com/tc39/proposal-object-values-entries">引入</a>了跟<code>Object.keys</code>配套的<code>Object.values</code>和<code>Object.entries</code>，作为遍历一个对象的补充手段，供<code>for...of</code>循环使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;keys, values, entries&#125; = <span class="title class_">Object</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> <span class="title function_">values</span>(obj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title function_">entries</span>(obj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>([key, value]); <span class="comment">// [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2], [&#x27;c&#x27;, 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h2><p><strong><code>Object.fromEntries()</code>方法是<code>Object.entries()</code>的逆操作，用于将一个键值对数组转为对象</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">fromEntries</span>([</span><br><span class="line">  [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;baz&#x27;</span>, <span class="number">42</span>]</span><br><span class="line">])</span><br><span class="line"><span class="comment">// &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br></pre></td></tr></table></figure>

<p>该方法的主要目的，是将键值对的数据结构还原为对象，因此特别适合将 Map 结构转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">const</span> entries = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;baz&#x27;</span>, <span class="number">42</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(entries)</span><br><span class="line"><span class="comment">// &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h2><ul>
<li>语法<br>Object.create(proto, [propertiesObject])</li>
<li>参数  <ul>
<li>proto : 必须。表示新建对象的原型对象，即该参数会被赋值到目标对象(即新对象，或说是最后返回的对象)的原型上。该参数可以是null， 对象， 函数的prototype属性 （创建空的对象时需传null , 否则会抛出TypeError异常）。</li>
<li>propertiesObject : 可选。 如果没有指定为 undefined，则是要添加到新创建对象的不可枚举（默认）属性（即其自身的属性，而不是原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应Object.defineProperties()的第二个参数。</li>
</ul>
</li>
<li>返回值<br>在指定原型对象上添加新属性后的对象</li>
</ul>
<h3 id="框架偏爱"><a href="#框架偏爱" class="headerlink" title="框架偏爱"></a>框架偏爱</h3><p>很多框架源码作者使用它来初始化一个新的对象，难道是最佳实践？<br>原因有二  </p>
<ul>
<li>通过Object.create(null)创建出来的对象，没有任何属性，显示No properties。我们可以将其当成一个干净的 map 来使用，自主定义 toString,hasOwnProperty等方法，并且不必担心将原型链上的同名方法被覆盖。</li>
<li>{…}创建的对象，使用for in遍历对象的时候，会遍历原型链上的属性，带来性能上的损耗。使用Object.create(null)则不必再对其进行遍历了。<br><img src="/_posts/es6/assets/%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95/write1.png" alt="两种方式的比较"></li>
</ul>
<h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><h4 id="1）创建对象的方式不同"><a href="#1）创建对象的方式不同" class="headerlink" title="1）创建对象的方式不同"></a>1）创建对象的方式不同</h4><p>new Object() 通过构造函数来创建对象, 添加的属性是在自身实例下。<br>Object.create() es6创建对象的另一种方式，可以理解为继承一个对象, 添加的属性是在原型下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// new Object() 方式创建</span><br><span class="line">var a = &#123;  rep : &#x27;apple&#x27; &#125;</span><br><span class="line">var b = new Object(a)</span><br><span class="line">console.log(b) // &#123;rep: &quot;apple&quot;&#125;</span><br><span class="line">console.log(b.__proto__) // &#123;&#125;</span><br><span class="line">console.log(b.rep) // &#123;rep: &quot;apple&quot;&#125;</span><br><span class="line"></span><br><span class="line">// Object.create() 方式创建</span><br><span class="line">var a = &#123; rep: &#x27;apple&#x27; &#125;</span><br><span class="line">var b = Object.create(a)</span><br><span class="line">console.log(b)  // &#123;&#125;</span><br><span class="line">console.log(b.__proto__) // &#123;rep: &quot;apple&quot;&#125;</span><br><span class="line">console.log(b.rep) // &#123;rep: &quot;apple&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>Object.create()方法创建的对象时，属性是在原型下面的，也可以直接访问 b.rep &#x2F;&#x2F; {rep: “apple”} ,<br>此时这个值不是吧b自身的，是它通过原型链<strong><strong>proto</strong></strong>来访问到b的值。</p>
<h4 id="2）创建对象属性的性质不同"><a href="#2）创建对象属性的性质不同" class="headerlink" title="2）创建对象属性的性质不同"></a>2）创建对象属性的性质不同</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建一个以另一个空对象为原型,且拥有一个属性p的对象</span><br><span class="line">o = Object.create(&#123;&#125;, &#123; p: &#123; value: 42 &#125; &#125;)</span><br><span class="line"></span><br><span class="line">// 省略了的属性特性默认为false,所以属性p是不可写,不可枚举,不可配置的:</span><br><span class="line">o.p = 24</span><br><span class="line">o.p</span><br><span class="line">//42</span><br><span class="line"></span><br><span class="line">o.q = 12</span><br><span class="line">for (var prop in o) &#123;</span><br><span class="line">   console.log(prop)</span><br><span class="line">&#125;</span><br><span class="line">//&quot;q&quot;</span><br><span class="line"></span><br><span class="line">delete o.p</span><br><span class="line">//false</span><br></pre></td></tr></table></figure>

<p>Object.create() 用第二个参数来创建非空对象的属性描述符默认是为false的，而构造函数或字面量方法创建的对象属性的描述符默认为true。看下图解析：  </p>
<p><img src="/_posts/es6/assets/%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95/objectDes.png" alt="propertiesObject">  </p>
<h4 id="3）创建空对象时不同"><a href="#3）创建空对象时不同" class="headerlink" title="3）创建空对象时不同"></a>3）创建空对象时不同</h4><p><img src="/_posts/es6/assets/%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95/objectNull.png" alt="propertiesObject">  </p>
<p>当用构造函数或对象字面量方法创建空对象时，对象时有原型属性的，即有_proto_;<br>当用Object.create()方法创建空对象时，对象是没有原型属性的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.create()   //Object prototype may only be an Object or null</span><br><span class="line">Object.create(&#x27;&#x27;) //Object prototype may only be an Object or null</span><br></pre></td></tr></table></figure>

<h4 id="4）proto-属性"><a href="#4）proto-属性" class="headerlink" title="4）proto 属性"></a>4）<strong>proto</strong> 属性</h4><p>JavaScript 的对象继承是通过原型链实现的。ES6 提供了更多原型对象的操作方法。<br>__proto__属性，用来读取或设置当前对象的prototype对象。目前只有浏览器环境必须部署有这个属性，其他运行环境不一定要部署，因此不建议使用这个属性，而是使用下面这些来 **Object.setPrototypeOf()<strong>（写操作,<strong>它是 ES6 正式推荐的设置原型对象的方法</strong>）、</strong>Object.getPrototypeOf()<strong>（读操作）、</strong>Object.create()**（生成操作）代替。</p>
<h5 id="应用案例，原型属性的继承"><a href="#应用案例，原型属性的继承" class="headerlink" title="应用案例，原型属性的继承"></a>应用案例，原型属性的继承</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var triangle = &#123;a: 1, b: 2, c: 3&#125;;</span><br><span class="line"></span><br><span class="line">function ColoredTriangle() &#123;</span><br><span class="line">  this.color = &#x27;red&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ColoredTriangle.prototype = triangle;  //ColoredTriangle.prototype.constructor === ColoredTriangle// false</span><br><span class="line">Object.assign(ColoredTriangle.prototype, triangle) //ColoredTriangle.prototype.constructor === ColoredTriangle// true</span><br><span class="line"></span><br><span class="line">var c = new ColoredTriangle();</span><br></pre></td></tr></table></figure>

<p>打印出 实例c 看看结构是怎样的  </p>
<p><img src="/_posts/es6/assets/%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95/object1.png" alt="propertiesObject">  </p>
<p>其中 color 属性在实例上，而其他的原型上。<br>现在来拷贝一个 实例 c2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var c2 = Object.assign(&#123;&#125;,c)</span><br><span class="line">console.log(c2.color); //red</span><br><span class="line">console.log(c2.a); //undefined</span><br></pre></td></tr></table></figure>

<p>因为 Object.assign 是<strong>不能拷贝到继承或原型上的方法的</strong>。所以 实例c2 没有 a 这个属性。那要怎么要才能拷贝到原型上的方法呢？</p>
<ul>
<li>第一种方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var originProto = Object.getPrototypeOf(c);</span><br><span class="line">var originProto2 = Object.create(originProto);</span><br><span class="line">var c2 = Object.assign(originProto2, c);</span><br><span class="line">//var c2 = Object.assign(Object.create(Object.getPrototypeOf(c)), c)</span><br><span class="line"></span><br><span class="line">console.log(c2.color); // red</span><br><span class="line">console.log(c2.a); // 1</span><br></pre></td></tr></table></figure>

<p>这样就实现了原型属性的拷贝。<br>Object.getPrototypeOf(c) 既 originProto 得到的是原型上的 &#x2F;&#x2F;{a: 1, b: 2, c: 3}；<br>Object.create(originProto) 既 originProto2 既是创建了一个 {a: 1, b: 2, c: 3} 在原型上的新对象；<br>Object.assign(originProto2, c) 在源对象originProto2 上合并对象 c (只能合并实例属性)；</p>
<ul>
<li>第二种方法(推荐)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var c = new ColoredTriangle();</span><br><span class="line">var c2 = Object.create(Object.getPrototypeOf(c), Object.getOwnPropertyDescriptors(c));</span><br><span class="line"></span><br><span class="line">console.log(c2.color); // red</span><br><span class="line">console.log(c2.a); // 1</span><br></pre></td></tr></table></figure>

<p>可以把Object.create()的参数理解为：第一个参数是放在新对象的原型上的，第二个参数是放在新对象的实例上的。<br>Object.getPrototypeOf() 得到的是 c 对象的原型，然后作为第一个参数，所以会在新对象c2 的原型上。<br>Object.getOwnPropertyDescriptors() 得到是 c 对象自身的可枚举属性，作为第二个参数，放在 c2 的实例上。</p>
<p><strong>为什么说推荐这个方法呢？因为Object.assign() 方法不能正确拷贝 get ，set 属性。</strong></p>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title>性能指标</title>
    <url>/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/CLS/</url>
    <content><![CDATA[<h2 id="CLS"><a href="#CLS" class="headerlink" title="CLS"></a>CLS</h2><p>Cumulative Layout Shift 累积布局偏移</p>
<p>最常见的影响CLS的分数的有：</p>
<ul>
<li><p>未指定尺寸的图片</p>
</li>
<li><p>未指定尺寸的广告、嵌入元素、iframe</p>
</li>
<li><p>动态插入内容</p>
</li>
<li><p>自定义字体（引发FOIT&#x2F;FOUT）</p>
</li>
<li><p>在更新DOM之前等待网络响应的操作</p>
</li>
</ul>
<h3 id="未指定尺寸的图片"><a href="#未指定尺寸的图片" class="headerlink" title="未指定尺寸的图片"></a>未指定尺寸的图片</h3><p>总而言之：在 <img> 和 <video> 标签上始终加上 width 和 height 属性。或者，使用 CSS aspect ratio boxes 来占据空间。这种方法可以确保在图片加载过程中，浏览器可以分配足够的空间。</p>
<p>历史<br>在web的早期，开发者会给 <img> 标签加上 width 和 height 属性，以确保浏览器开始获取图片之前可以分配好空间，这样可以减少 reflow 和 re-layout。</p>
<p>你也许会注意到这两个属性没有带单位。这些像素尺寸会确保保留640 * 360的区域。图片最终会平铺在这个区域，不管原始尺寸是否一致。</p>
<p>当响应式设计来临的时候，开发者开始忽略 width 和 height，开始使用css来调整图片大小。</p>
<p>这种方法的缺点是，只有图片下载的时候，浏览器才知道图片的宽高并且分配好空间。图片下载完了，每张图片出现在屏幕上的时候，页面都会 reflow 一次，会导致页面频繁的往下弹。这对于用户体验来说非常不友好。</p>
<p>因此而诞生了 aspect ratio。aspect ratio 是图片的宽高比。比如，x:y的宽高比，指的是宽度x单位，高度y单位。</p>
<p>这也意味着只要我们知道宽高之一，就能计算出另一个属性。对于一个16:9的宽高比而言:</p>
<p>如果图片有360px的高度，则宽度为 360 x (16 &#x2F; 9) &#x3D; 640px</p>
<p>如果图片有640px的宽度，则高度为 640 x (9 &#x2F; 16) &#x3D; 360px</p>
<p>现代浏览器最佳体验<br>现代浏览器可以基于 width 和 height 属性设定默认宽高比，这样就能避免布局偏移。开发者只需要如下设置:</p>
<p>这样一来，图片加载之前，浏览器就可以根据宽高属性分配好空间。图片加载之后，就可以根据宽度或者高度属性，按照宽高比来分配实际空间。</p>
<p>图片的 aspect-ratio 属性在chrome和firefox上已经可以使用了，safari也快支持了。</p>
<p>如果图片位于容器内，可以设置宽度为容器宽度，高度为auto，避免高度被固定位360px。</p>
<p>响应式图片<br>在使用响应式图片的时候，srcset 定义了图片可以供浏览器选择的尺寸。为了确保图片 width 和 height 可以被设置，每张图片的宽高比必须一致。</p>
<p>有时候我们希望展示图片的剪切部分，比如长图的中间正方形区域，为了视觉好看。</p>
<p>这样一来图片宽高比就不一致了，浏览器可能更需要针对每一个资源设置特定宽高比。但目前还没有好的解决方案，re-layout 依然存在。</p>
<p>未指定尺寸的广告、嵌入元素、iframe<br>广告<br>广告是造成布局偏移的罪魁祸首之一。经常性，这些广告会有动态尺寸，这样会导致糟糕的用户体验，当你在往下浏览页面的时候，广告突然插入一些可见内容。</p>
<p>在广告的生命周期里，很多点可以导致布局偏移:</p>
<p>广告容器插入到dom的时候</p>
<p>本站代码调整广告容器尺寸的时候</p>
<p>广告代码库加载的时候（导致容器尺寸改变）</p>
<p>广告内容填充容器的时候（如果最终广告的尺寸不一样，导致容器尺寸变化）</p>
<p>好消息是网站可以采用最佳体验，来减少布局偏移。</p>
<p>为广告位静态保留空间。</p>
<p>换句话说，在广告代码库加载之前，就给容器加好样式。</p>
<p>如果要在内容流中插入广告，在插入之前确保通过保留尺寸来消除布局偏移。如果这些广告在屏幕外加载，则没有这个问题。</p>
<p>在视图顶部插入非粘性广告的时候要特别注意。</p>
<p>避免折叠预留的空间，如果广告没有返回，可以在该空间展示占位符。</p>
<p>通过预留广告所需最大尺寸，来避免布局偏移。</p>
<p>这很有效，不过如果广告很小，可能会有大片空白。</p>
<p>根据历史数据，给广告加上合适的尺寸。</p>
<p>如果广告不太可能填满，一些网站会发现在初始的时候折叠广告位可以减少布局偏移。很难做到每一次都能给广告位精准的尺寸，除非这个广告是你自己提供的。</p>
<p>为广告位静态保留空间<br>给广告容器设置固定的样式，避免代码库加载的时候，重新调整广告的尺寸。</p>
<p>要额外注意一下小尺寸的广告，如果预留很大的空间，会导致大片空白。</p>
<p>避免在视图顶部插入广告<br>根据CLS的计算规则，在顶部插入广告比在中间插入，造成的影响更大。</p>
<p>嵌入元素和iframe<br>可嵌入的挂件可以允许你在页面上嵌入web内容（例如，youtube视频、谷歌地图、社交媒体的帖子等）。这些嵌入元素可以采用多种形式。</p>
<p>html fallback，然后js将该fallback转换成嵌入元素</p>
<p>内联html代码块</p>
<p>iframe嵌入</p>
<p>这些嵌入通常不会事先知道嵌入的大小（例如，社交媒体帖子，是否包含图片？视频？或者多行文本？）。结果就是提供嵌入元素的平台经常无法保证预留足够的空间，导致布局偏移。</p>
<p>为了应对这种情况，你可以通过提前计算嵌入元素的足够空间，以最小化CLS。以下工作流可以参考:</p>
<p>使用开发者工具检查最终嵌入的高度</p>
<p>一旦嵌入元素加载，iframe容器根据内容重新调整尺寸。</p>
<p>记下尺寸，并相应设置嵌入元素占位符的样式。你可能还会用到媒体查询来考虑不同的因素。</p>
<p>动态内容<br>总而言之，避免在已存在的内容上方插入新内容，除非为了响应用户交互。这样可以保证任何布局偏移都是可预期的。</p>
<p>你可能经常会遇到从顶部或者底部弹出的一些内容。这经常发生在banner或者表单的地方，让页面的剩余内容产生偏移。</p>
<p>“注册即可领取会员大礼包!”</p>
<p>“最近发表的文章”</p>
<p>“安装我们的APP”</p>
<p>“我们还在接受订单”</p>
<p>“GDPR提示，是否允许使用cookie”</p>
<p>如果你需要展示以上的UI内容，请提前预留好空间，避免产生布局偏移。</p>
<p>自定义字体（引发FOIT&#x2F;FOUT）<br>下载并渲染自定义字体会引发布局偏移，通过以下两种方式:</p>
<p>fallback字体切换到新字体（FOUT - flash of unstyled text）</p>
<p>从不可见变成可见，因为新字体的渲染缘故（FOIT - flash of invisible text）</p>
<p>以下工具可以帮你最小化影响:</p>
<p>font-display 属性可以让你修改自定义字体的渲染表现，通过使用可选值：auto, swap, block, fallback 和 optional。不幸的是，除了 optional 之外的属性都会引发 re-layout，通过以上的其中一种方式。</p>
<p>Font Loading API 可以减少获取必要字体的时间。</p>
<p>Chrome 83版本之后，可以采取以下方案：</p>
<p>针对关键字体使用 <link rel=preload> ，提高优先级，让字体下载有更高概率赶在fcp之前，这样就能避免布局偏移。</p>
<link rel=preload> 和 font-display: optional 结合使用。

<p>动画<br>总而言之，优先考虑 transform，而非会影响布局改变的属性。</p>
<p>在更新DOM之前等待网络响应的操作<br>尽可能的在网络请求时，给一个loading，或者占位符提示，避免用户在这段时间内进行操作。</p>
<p>开发者工具<br>可以使用lighthouse和performce检测CLS。</p>
<p>总结</p>
<p>图片的尺寸，以及其他嵌入元素的尺寸，最开始就设定好，或者预留足够空间，这样可以有效避免布局偏移。</p>
<p>利用图片宽高比的属性，可以在优化CLS的同时，做响应式布局。</p>
<p>尽可能不要往已存在内容上方添加新内容。</p>
<p>web字体尽可能早的加载，避免产生FOIT和FOUT</p>
<p>与UI同事配合在交互上避免布局偏移</p>
<p>参考<br><a href="https://web.dev/optimize-cls/">https://web.dev/optimize-cls/</a> </p>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>CLS</tag>
      </tags>
  </entry>
  <entry>
    <title>4.浏览器渲染</title>
    <url>/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/render/</url>
    <content><![CDATA[<h3 id="浏览器渲染流程"><a href="#浏览器渲染流程" class="headerlink" title="浏览器渲染流程"></a>浏览器渲染流程</h3><p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/render/image-20210122101059973.png" alt="image-20210122101059973"></p>
<ol>
<li>触发视觉变化（不仅仅是js控制还有可能是css）</li>
<li>浏览器对样式进行重新计算</li>
<li>计算出新的元素布局</li>
<li>浏览器进行重新绘制</li>
<li>渲染层的合成</li>
</ol>
<blockquote>
<p>浏览器初次加载会完整的走过整个流程，但是之后我们可以对这个流程进行优化，避免非必要的流程</p>
</blockquote>
<h3 id="布局-layouts-与绘制-paint"><a href="#布局-layouts-与绘制-paint" class="headerlink" title="布局(layouts)与绘制(paint)"></a>布局(layouts)与绘制(paint)</h3><blockquote>
<p><strong>详细的回流重绘见下一篇文章</strong></p>
</blockquote>
<ul>
<li>渲染树只包含网页需要的节点（不包括meta、display：none）</li>
<li>布局计算每个节点接触的位置和大小</li>
<li>绘制是像素化每个节点的过程</li>
</ul>
<p><strong>重新布局被称为reflow 回流，重新绘制被称为repaint 重绘</strong></p>
<ol>
<li>回流(<code>reflow</code>), 布局引擎为<code>frame</code>计算图形, 以确定对象位置, 浏览器根据各种样式来计算结果放在它该出现的位置.<ul>
<li><strong>YaHoo!性能小组总结了一些导致<code>回流</code>发生的一些因素:</strong><ol>
<li>调整窗口大小</li>
<li>改变字体</li>
<li>增加或者移除样式表</li>
<li>内容变化，比如用户在 input 框中输入文字, CSS3 动画等</li>
<li>激活 <code>CSS</code> 伪类，比如 <code>:hover</code></li>
<li>操作<code>class</code>属性</li>
<li>脚本操作<code>DOM</code></li>
<li>计算<code>offsetWidth</code>和<code>offsetHeight</code>属性</li>
<li>设置 style 属性的值</li>
</ol>
</li>
<li>当不可避免的出现回流时，应该避免 layout thrashing 布局抖动<ul>
<li>避免回流（减少次数）</li>
<li>读写分离（可以借助fastdom）</li>
</ul>
</li>
</ul>
</li>
<li>重绘(<code>repaint</code>), 当计算好盒子模型的位置, 大小以及其他属性后, 浏览器就根据各自的特性进行绘制一遍, 显现出来给用户看<ul>
<li>重绘则是视觉效果变化引起的重新绘制。比如 <code>color</code> 或者 <code>background</code> 发生了变化，那就该给触发重绘的元素化化妆，化成它想要的样子。</li>
</ul>
</li>
</ol>
<p>回流与重绘两者之间的联系在于: <strong>触发回流一定会触发重绘, 而触发重绘却不一定会触发回流</strong>。</p>
<h3 id="复合线程-compositor-thread-与图层-layers"><a href="#复合线程-compositor-thread-与图层-layers" class="headerlink" title="复合线程(compositor thread)与图层(layers)"></a>复合线程(compositor thread)与图层(layers)</h3><p>详细介绍见 <a href="https://segmentfault.com/a/1190000014520786">https://segmentfault.com/a/1190000014520786</a></p>
<p>淘宝团队的文章 <a href="https://fed.taobao.org/blog/taofed/do71ct/performance-composite/">https://fed.taobao.org/blog/taofed/do71ct/performance-composite/</a></p>
<p>提升到合成层的最好方法就是 用 <strong>transfrom + opacity 搭配 will-change</strong></p>
<p>京东和淘宝的轮播容器都是采用opacity + transform 3d</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">opacity: 1;</span><br><span class="line">transform: translate3d(0px, 0px, 0px);</span><br><span class="line">transition: none 0s ease 0s;</span><br></pre></td></tr></table></figure>

<h3 id="优化相关的函数"><a href="#优化相关的函数" class="headerlink" title="优化相关的函数"></a>优化相关的函数</h3><p>一帧的声明周期</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/render/image-20210122121308752.png" alt="image-20210122121308752"></p>
<h4 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h4><p>防抖应用，按照实际帧数触发</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let flag = false;</span><br><span class="line">window.addEventListener(&quot;pointermove&quot;, () =&gt; &#123;</span><br><span class="line">  if (flag) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  flag = true;</span><br><span class="line">  window.requestAnimationFrame(() =&gt; &#123;</span><br><span class="line">    /* </span><br><span class="line">     * 处理事件</span><br><span class="line">    */</span><br><span class="line">    flag = false;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="requestIdleCallback"><a href="#requestIdleCallback" class="headerlink" title="requestIdleCallback"></a>requestIdleCallback</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback#Browser_compatibility">mdn上的requestIdleCallback</a></p>
<p>案例： react 16 通过rAF 模拟 rIF 进行事件调度  </p>
<p>下图是rAF 和 rIF 的不同</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/render/image-20210122142533699.png" alt="image-20210122142533699"></p>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>浏览器渲染</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>2.什么是RAIL</title>
    <url>/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/rail/</url>
    <content><![CDATA[<h3 id="RAIL的概念"><a href="#RAIL的概念" class="headerlink" title="RAIL的概念"></a>RAIL的概念</h3><ol>
<li>Response 响应</li>
<li>Animation 动画</li>
<li>Idle 空闲</li>
<li>Load 加载</li>
</ol>
<h3 id="RAIL评估标准"><a href="#RAIL评估标准" class="headerlink" title="RAIL评估标准"></a>RAIL评估标准</h3><ol>
<li>响应： 处理事件应在50ms以内完成</li>
<li>动画：每10ms产生一帧（1&#x2F;60 &#x3D; 16.66）剩余毫秒值 浏览器需要渲染</li>
<li>空闲： 尽可能增加空闲事件</li>
<li>加载：在5s内完成内容加载，并可以交互</li>
</ol>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>RAIL</tag>
      </tags>
  </entry>
  <entry>
    <title>10.JavaScript的开销与优化</title>
    <url>/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/js%E7%9A%84%E5%BC%80%E9%94%80%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="JavaScript的开销"><a href="#JavaScript的开销" class="headerlink" title="JavaScript的开销"></a>JavaScript的开销</h2><p>js的开销主要在</p>
<ul>
<li><p>加载</p>
</li>
<li><p>解析&amp;编译</p>
</li>
<li><p>执行</p>
</li>
</ul>
<p>下图展示了浏览器处理同样大小的<strong>普通资源</strong>和 <strong>js</strong> 所需要的时间</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/js%E7%9A%84%E5%BC%80%E9%94%80%E4%B8%8E%E4%BC%98%E5%8C%96/image-20210122143240501.png" alt="image-20210122143240501"></p>
<h3 id="Loding-is-a-journey"><a href="#Loding-is-a-journey" class="headerlink" title="Loding is a journey"></a>Loding is a journey</h3><p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/js%E7%9A%84%E5%BC%80%E9%94%80%E4%B8%8E%E4%BC%98%E5%8C%96/image-20210122164337959.png" alt="image-20210122164337959"></p>
<h4 id="减少主线程工作量（优化方案）"><a href="#减少主线程工作量（优化方案）" class="headerlink" title="减少主线程工作量（优化方案）"></a>减少主线程工作量（优化方案）</h4><ul>
<li>避免长任务</li>
<li>避免超过1kb的行间脚本（行内脚本，因为解析引擎无法进行优化）</li>
<li>使用rAF和rIC进行时间调度</li>
</ul>
<h3 id="V8-编译原理"><a href="#V8-编译原理" class="headerlink" title="V8 编译原理"></a>V8 编译原理</h3><p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/js%E7%9A%84%E5%BC%80%E9%94%80%E4%B8%8E%E4%BC%98%E5%8C%96/image-20210122164634444.png" alt="image-20210122164634444"></p>
<p> 一般引擎会被代码进行优化后转换为机械码，但是有些代码优化后可能不适合运行，会被回溯到源代码在进行解析，这个过程叫做逆优化，书写过程中尽量避免此类问题。</p>
<h3 id="V8优化机制"><a href="#V8优化机制" class="headerlink" title="V8优化机制"></a>V8优化机制</h3><h4 id="脚本流"><a href="#脚本流" class="headerlink" title="脚本流"></a>脚本流</h4><h4 id="字节码缓存"><a href="#字节码缓存" class="headerlink" title="字节码缓存"></a>字节码缓存</h4><h4 id="懒解析"><a href="#懒解析" class="headerlink" title="懒解析"></a>懒解析</h4><h5 id="函数的解析方式"><a href="#函数的解析方式" class="headerlink" title="函数的解析方式"></a>函数的解析方式</h5><ul>
<li>懒解析 lazy parsing</li>
<li>饥饿解析 eager parsing</li>
</ul>
<p>函数的解析方式，一般来说使用懒解析，函数使用时再进行内容的解析，但是对于立即执行的函数这种优化方式就是逆优化。我们可采取下面的方式告诉解析器直接进行饥饿解析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const fnc = (() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">把函数体用括号包裹起来，webpack的打包已经不会把（）压缩没了</span><br></pre></td></tr></table></figure>

<h4 id="对象优化"><a href="#对象优化" class="headerlink" title="对象优化"></a>对象优化</h4><ul>
<li><p>以相同顺序初始化对象成员，避免<strong>隐藏类</strong>的调整</p>
<blockquote>
<p>动态语言的弊端，解析器会根据推断赋予变量类型（21种），这种类型叫做隐藏类型（hidden class），为了保证hidden class的复用，需要按顺序初始化</p>
</blockquote>
</li>
<li><p>实例化后避免添加新属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// In-object 属性</span><br><span class="line">const car = &#123;color: &#x27;red&#x27;&#125;; </span><br><span class="line"></span><br><span class="line">// normal/fast 属性，存储在property store里，需要通过描述数组间接查找</span><br><span class="line">car.seats = 4;  </span><br></pre></td></tr></table></figure>
</li>
<li><p>尽量使用Array代替array-like对象</p>
<blockquote>
<p>转换的代价比类数组借用call调用数组方法要小（google推荐）</p>
</blockquote>
</li>
<li><p>避免数组越界</p>
<ul>
<li>多数情况下会发生 undefined 类型转换</li>
<li>找不到的数据，会依照原型链向上进行查找（性能相差6倍）</li>
</ul>
</li>
<li><p>避免元素类型转换</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const array = [3, 2, 1]; // PACKED_SMI_ELEMENTS 满的-整型-元素</span><br><span class="line">array.push(4.4);  // PACKED_DOUBLE_ELEMENTS</span><br><span class="line">// 对编译器而言，需要更换类型，造成额外开销</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>JavaScript的开销与优化</tag>
      </tags>
  </entry>
  <entry>
    <title>9 webpack优化</title>
    <url>/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/webpack/</url>
    <content><![CDATA[<h3 id="介绍几个主要的插件"><a href="#介绍几个主要的插件" class="headerlink" title="介绍几个主要的插件"></a>介绍几个主要的插件</h3><h4 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree-shaking"></a>tree-shaking</h4><ul>
<li>删除没有使用的代码</li>
<li>基于ES6的import export</li>
<li>sideEffects选项（忽略设置，一般用于忽略一些css 或者 修改全局作用域的js）</li>
<li>babel 需要设置 modules：false（保留es6语法）</li>
<li>webpack 4 生产模式默认开启</li>
</ul>
<h4 id="Terser-webpack-plugin"><a href="#Terser-webpack-plugin" class="headerlink" title="Terser-webpack-plugin"></a>Terser-webpack-plugin</h4><ul>
<li>压缩js代码，webpack 4 中后期替代了uglifyjs-webpack-plugin</li>
<li>支持ES6语法</li>
</ul>
<h4 id="scope-hoisting（作用域提升）-ModuleConcatenationPlugin"><a href="#scope-hoisting（作用域提升）-ModuleConcatenationPlugin" class="headerlink" title="scope hoisting（作用域提升）  ModuleConcatenationPlugin"></a>scope hoisting（作用域提升）  ModuleConcatenationPlugin</h4><ul>
<li>代码体积减少</li>
<li>提高执行效率</li>
<li>同样需要babel的modules配置</li>
<li>基于ES6 import export</li>
<li>webpack 4 生产环境 默认开启</li>
</ul>
<p>没有启用作用域提升</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/webpack/image-20210124154018793.png" alt="image-20210124154018793"></p>
<p>启用作用域提升之后，会做一个合并</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/webpack/image-20210124154325923.png" alt="image-20210124154325923"></p>
<h4 id="code-spiliting-代码分割-splitchunks"><a href="#code-spiliting-代码分割-splitchunks" class="headerlink" title="code spiliting 代码分割 splitchunks"></a>code spiliting 代码分割 splitchunks</h4><ul>
<li>把单个bundle文件拆分成若干个小bundles&#x2F;chunks</li>
<li>缩短首屏加载时间</li>
<li><strong>相当重要的优化选项，详细介绍见收藏夹</strong><br>对参数做一个小小的解释</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: &#x27;async&#x27;, // async 异步 import() all 同步异步</span><br><span class="line">      minSize: 30000, // 最小体积 3000B</span><br><span class="line">      maxSize: 0,</span><br><span class="line">      minChunks: 1, // 最少被引用了一次</span><br><span class="line">      maxAsyncRequests: 5, // 限制异步模块内部的并行最大请求数的</span><br><span class="line">      maxInitialRequests: 3,</span><br><span class="line">      automaticNameDelimiter: &#x27;~&#x27;,</span><br><span class="line">      name: true,</span><br><span class="line">      cacheGroups: &#123; // cacheGroups</span><br><span class="line">        vendors: &#123;</span><br><span class="line">          test: /[\\/]node_modules[\\/]/,</span><br><span class="line">          priority: -10</span><br><span class="line">        &#125;,</span><br><span class="line">        default: &#123;</span><br><span class="line">          minChunks: 2,</span><br><span class="line">          priority: -20,</span><br><span class="line">          reuseExistingChunk: true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h5 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a><strong>chunk</strong></h5><ul>
<li>chunk是webpack根据功能拆分出来的，包含三种情况：<ol>
<li>通过import()动态引入的代码</li>
<li>通过splitChunks拆分出来的代码</li>
<li>你的项目入口（entry）</li>
</ol>
</li>
</ul>
<h5 id="cacheGroups"><a href="#cacheGroups" class="headerlink" title="cacheGroups"></a><strong>cacheGroups</strong></h5><blockquote>
<p>splitChunks就是根据cacheGroups去拆分模块的，包括之前说的chunks属性和之后要介绍的种种属性其实都是对缓存组进行配置的</p>
</blockquote>
<ul>
<li>入口文件本身算一个请求</li>
<li>如果入口里面有动态加载得模块这个不算在内</li>
<li>通过runtimeChunk拆分出的runtime不算在内</li>
<li>只算js文件的请求，css不算在内</li>
<li>如果同时又两个模块满足cacheGroup的规则要进行拆分，但是maxInitialRequests的值只能允许再拆分一个模块，那尺寸更大的模块会被拆分出来</li>
</ul>
<h5 id="maxInitialRequests"><a href="#maxInitialRequests" class="headerlink" title="maxInitialRequests"></a><strong>maxInitialRequests</strong></h5><blockquote>
<p>表示允许入口并行加载的最大请求数，之所以有这个配置也是为了对拆分数量进行限制，不至于拆分出太多模块导致请求数量过多而得不偿失</p>
</blockquote>
<h5 id="maxAsyncRequests"><a href="#maxAsyncRequests" class="headerlink" title="maxAsyncRequests"></a><strong>maxAsyncRequests</strong></h5><blockquote>
<p>用来限制异步模块内部的并行最大请求数的，说白了你可以理解为是每个import()它里面的最大并行请求数量</p>
</blockquote>
<ul>
<li>import()文件本身算一个请求</li>
<li>并不算js以外的公共资源请求比如css</li>
<li>如果同时有两个模块满足cacheGroup的规则要进行拆分，但是maxInitialRequests的值只能允许再拆分一个模块，那尺寸更大的模块会被拆分出来</li>
</ul>
<h5 id="runtimeChunk"><a href="#runtimeChunk" class="headerlink" title="runtimeChunk"></a>runtimeChunk</h5><p>感觉主要的作用是为了<strong>优化持久化缓存</strong></p>
<blockquote>
<p>形如<code>import(&#39;abc&#39;).then(res=&gt;&#123;&#125;)</code>这种异步加载的代码，在webpack中即为运行时代码。在VueCli工程中常见的异步加载路由即为runtime代码</p>
</blockquote>
<blockquote>
<p>设置runtimeChunk是将包含<code>chunks 映射关系</code>的 list单独从 app.js里提取出来，因为每一个 chunk 的 id 基本都是基于内容 hash 出来的，所以每次改动都会影响它，如果不将它提取出来的话，等于app.js每次都会改变。缓存就失效了。设置runtimeChunk之后，webpack就会生成一个个runtime~xxx.js的文件。<br>然后每次更改所谓的运行时代码文件时，打包构建时app.js的hash值是不会改变的。如果每次项目更新都会更改app.js的hash值，那么用户端浏览器每次都需要重新加载变化的app.js，如果项目大切优化分包没做好的话会导致第一次加载很耗时，导致用户体验变差。现在设置了runtimeChunk，就解决了这样的问题。所以<code>这样做的目的是避免文件的频繁变更导致浏览器缓存失效，所以其是更好的利用缓存。提升用户体验。</code><br>链接：<a href="https://www.jianshu.com/p/714ce38b9fdc">https://www.jianshu.com/p/714ce38b9fdc</a></p>
</blockquote>
<h4 id="Minificaiton-资源压缩"><a href="#Minificaiton-资源压缩" class="headerlink" title="Minificaiton 资源压缩"></a>Minificaiton 资源压缩</h4><ul>
<li>terser 压缩js</li>
<li>Mini-css-extract-plugin 压缩css</li>
<li>HtmlWebpackPlugin 压缩html</li>
</ul>
<h4 id="可持续化缓存"><a href="#可持续化缓存" class="headerlink" title="可持续化缓存"></a>可持续化缓存</h4><p>主要是借助hash，content-hash</p>
<h4 id="babel-7-优化配置"><a href="#babel-7-优化配置" class="headerlink" title="babel 7 优化配置"></a>babel 7 优化配置</h4><ul>
<li>在需要的地方引入polyfill<ul>
<li>useBuiltIns:  “usage”</li>
</ul>
</li>
<li>辅助函数的复用<ul>
<li>配置一个@babel&#x2F;plugin-transform-runtime</li>
</ul>
</li>
</ul>
<h3 id="Webpack-依赖优化"><a href="#Webpack-依赖优化" class="headerlink" title="Webpack 依赖优化"></a>Webpack 依赖优化</h3><h4 id="noParse"><a href="#noParse" class="headerlink" title="noParse"></a>noParse</h4><ul>
<li>提高构建速度</li>
<li>直接通知webpack忽略较大的库</li>
<li>被忽略的库不能有import require define的引入方式</li>
<li>例如 lodash</li>
</ul>
<h4 id="DllPlugin（搭配DllReferencePlugin）"><a href="#DllPlugin（搭配DllReferencePlugin）" class="headerlink" title="DllPlugin（搭配DllReferencePlugin）"></a>DllPlugin（搭配DllReferencePlugin）</h4><ul>
<li>避免打包时对不变的库重复构建</li>
<li>提高构建速度</li>
<li>不会对打包后的文件造成影响</li>
<li>开发环境的web-server 用这个更加的合适，可以提高热部署的速度</li>
</ul>
<h4 id="happypack（多线程打包）"><a href="#happypack（多线程打包）" class="headerlink" title="happypack（多线程打包）"></a>happypack（多线程打包）</h4><h3 id="webpack-监测与分析"><a href="#webpack-监测与分析" class="headerlink" title="webpack 监测与分析"></a>webpack 监测与分析</h3><ul>
<li>Stats 分析与可视化图</li>
<li>webpack-bundle-analyzer 进行体积分析</li>
<li>Speed-measure-webpack-plugin 速度分析</li>
</ul>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>8 图片优化</title>
    <url>/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="图片优化方案"><a href="#图片优化方案" class="headerlink" title="图片优化方案"></a>图片优化方案</h3><p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96/image-20210123111451889.png" alt="image-20210123111451889"></p>
<h4 id="图片格式比较"><a href="#图片格式比较" class="headerlink" title="图片格式比较"></a>图片格式比较</h4><p>jpg&#x2F;jpeg 很高的压缩比，较高的图片质量，纹理边缘表现差</p>
<p>png 支持透明，图片质量较高，纹理边缘表现好，图片大小较大</p>
<p>webp 谷歌推出的格式，兼容性不太好，兼具png 、jpg的优点</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96/gif.png" alt="gif"></p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96/jpeg.png" alt="jpeg"></p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96/png.png" alt="png"></p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96/webp.png" alt="webp"></p>
<h4 id="图片的懒加载"><a href="#图片的懒加载" class="headerlink" title="图片的懒加载"></a>图片的懒加载</h4><h5 id="原生的图片懒加载方案"><a href="#原生的图片懒加载方案" class="headerlink" title="原生的图片懒加载方案"></a>原生的图片懒加载方案</h5> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loading=&quot;lazy&quot;</span><br></pre></td></tr></table></figure>

<h5 id="第三方图片懒加载方案"><a href="#第三方图片懒加载方案" class="headerlink" title="第三方图片懒加载方案"></a>第三方图片懒加载方案</h5><p>verlok&#x2F;lazyload</p>
<p>Yall.js</p>
<p>Blazy</p>
<p>vue-lazyload</p>
<h4 id="使用渐进式图片"><a href="#使用渐进式图片" class="headerlink" title="使用渐进式图片"></a>使用渐进式图片</h4><p>渐进式 jpeg progressive jpeg</p>
<h4 id="使用响应式图片"><a href="#使用响应式图片" class="headerlink" title="使用响应式图片"></a>使用响应式图片</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;100.png&quot; sizes=&quot;50%&quot; srcset=&quot;100.png 100w, 200.png 200w, 400.png 400w&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>sizes</strong></p>
<p>　　这个属性可以写一些css，例如“100px”，“50vm”，‘20rem”，”30vm”，甚至是媒体查询 “(min-width: 600px) 25vw, (min-width: 500px) 50vw, 100vm”。</p>
<p><strong>srcset</strong></p>
<p>　　顾名思义，就是一堆图片来源的预设。例如：“100.png 100w”, 表示预设 100.png 这张图片，并且告诉浏览器，这张图片的宽度是100。</p>
<p>　　我们来看看mdn的描述：</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96/1107494-20190908093939305-1672674307.png" alt="img"></p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96/image-20220323100631910.png" alt="image-20220323100631910"></p>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>压缩与合并</tag>
      </tags>
  </entry>
  <entry>
    <title>12 传输优化</title>
    <url>/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%BC%A0%E8%BE%93%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="GZIP压缩"><a href="#GZIP压缩" class="headerlink" title="GZIP压缩"></a>GZIP压缩</h3><h3 id="启用keep-alive"><a href="#启用keep-alive" class="headerlink" title="启用keep alive"></a>启用keep alive</h3><p>默认http1.1以后默认开启</p>
<ul>
<li>keepalive-timeout  保持时间 s</li>
<li>keepalive-requests 链接数</li>
</ul>
<h3 id="http-缓存"><a href="#http-缓存" class="headerlink" title="http 缓存"></a>http 缓存</h3><ul>
<li>cache control 1.1 &#x2F; expires 1.0</li>
<li>Last-modified  if-modified-since 1.0</li>
<li>Etag  if-none-match  1.1</li>
</ul>
<p>一般设置：html 不缓存, css、js缓存过期时间可以设置的很长，因为一般使用hash命名文件</p>
<p>图片、字体不经常更换的话，缓存时间设置长一点</p>
<blockquote>
<p><strong>server-work和HTTP2 都依赖https</strong>，可以生成自签名的证书</p>
</blockquote>
<h3 id="http2"><a href="#http2" class="headerlink" title="http2"></a>http2</h3><ul>
<li>二进制传输（http1.1是基于文本的，传输效率慢且不安全）</li>
<li>请求响应多路复用</li>
<li>server push （服务器直接推送，没有请求过程）</li>
<li>只能部署在https</li>
<li>适合较高的请求量</li>
</ul>
<h3 id="资源优先级"><a href="#资源优先级" class="headerlink" title="资源优先级"></a>资源优先级</h3><ul>
<li>浏览器默认安排资源加载优先级</li>
<li>使用preload，prefetch调整优先级</li>
<li>preload 提前加载较晚出现，但对于当前页面非常重要的资源<ul>
<li>就是通过标签显式声明一个高优先级资源，强制浏览器提前请求资源，同时不阻塞文档正常onload</li>
<li>preload link必须设置as属性来声明资源的类型（font&#x2F;image&#x2F;style&#x2F;script等)，否则浏览器可能无法正确加载资源。</li>
</ul>
</li>
<li>prefetch 提前加载后继路由需要的资源，优先级低</li>
</ul>
<p>文章写的相当好<br><a href="https://juejin.cn/post/6893681741240909832">pre系列讲解</a><br><a href="./prefetch%E5%92%8Cpreload">同上，防止链接挂掉</a></p>
<h3 id="接口缓存策略"><a href="#接口缓存策略" class="headerlink" title="接口缓存策略"></a>接口缓存策略</h3><ol>
<li>ajax&#x2F;fetch缓存<ul>
<li>前端请求的时间带上cache，依赖浏览器本身缓存机制</li>
</ul>
</li>
<li>本地缓存<ul>
<li>异步接口数据优先使用本地localStorage中的缓存数据</li>
</ul>
</li>
<li>多次请求<ul>
<li>接口数据本地无localStorage缓存数据，重新再次发出ajax请求</li>
</ul>
</li>
</ol>
<h3 id="使用CDN"><a href="#使用CDN" class="headerlink" title="使用CDN"></a>使用CDN</h3><p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%A0%E8%BE%93%E4%BC%98%E5%8C%96/CDN%E4%BC%98%E7%82%B9.png" alt="CDN优点"></p>
<h4 id="cdn回源"><a href="#cdn回源" class="headerlink" title="cdn回源"></a>cdn回源</h4><p>回源是指浏览器访问cdn集群上静态文件时，文件缓存过期，直接穿透cdn集群而访问源站机器的行为。（发生这种情况后，cdn会更新文件及缓存标记）</p>
<h4 id="cdn缓存"><a href="#cdn缓存" class="headerlink" title="cdn缓存"></a>cdn缓存</h4><p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%A0%E8%BE%93%E4%BC%98%E5%8C%96/cdn%E7%BC%93%E5%AD%98.png" alt="cdn缓存"></p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%A0%E8%BE%93%E4%BC%98%E5%8C%96/cdn%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83.png" alt="cdn灰度发布"></p>
<h3 id="减少http请求"><a href="#减少http请求" class="headerlink" title="减少http请求"></a>减少http请求</h3><p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%A0%E8%BE%93%E4%BC%98%E5%8C%96/reducehttp%E8%AF%B7%E6%B1%82.png" alt="减少http请求"></p>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>传输优化</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯企鹅辅导 H5 性能极致优化案例</title>
    <url>/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<p><a href="https://mp.weixin.qq.com/s?__biz=MzI1ODE4NzE1Nw==&mid=2247490349&idx=1&sn=139c52fb354eba09c0c3c5a92dc5ffa2&chksm=ea0d51d7dd7ad8c1be5be5b17fd79f5ccc8d84fe013040232a0861290728112c75fb6061499f&scene=178&cur_album_id=1806166719669796864#rd">原文地址</a></p>
<p>很有实际意义的一片优化文章，防止链接挂掉，特地复制下来</p>
<h2 id="通过案例你可以学到什么"><a href="#通过案例你可以学到什么" class="headerlink" title="通过案例你可以学到什么"></a>通过案例你可以学到什么</h2><p>简单总结一下设计的知识点</p>
<ul>
<li>onload<ul>
<li>DOM 的解析受 JS 加载和执行的影响，尽量对 JS 进行压缩、拆分处理（HTTP2环境下），能减少 DOMContentLoaded 时间。</li>
<li>图片、视频、iframe 等资源，会阻塞 onload 事件的触发，需要优化资源的加载时机，尽快触发 onload。</li>
</ul>
</li>
<li>性能指标</li>
<li>threeshaking</li>
<li>Splitchunks 拆分首屏js</li>
<li>延迟加载非必要js prefetch</li>
<li>lazyload</li>
<li>图片优化</li>
<li>coverage 查看首屏 js css使用比例</li>
<li>critters critters-webpack-plugin 为预渲染&#x2F;SSR 的单页应用程序内联关键 CSS</li>
<li>CLF 页面布局抖动</li>
</ul>
<h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>H5 项目是企鹅辅导的核心项目，已迭代四年多，包括了课程详情页&#x2F;老师详情页&#x2F;报名页&#x2F;支付页面等页面，构建产物用于企鹅辅导 APP&#x2F;H5（微信&#x2F;QQ&#x2F;浏览器），迭代过程中了也累积了一些性能问题导致页面加载、渲染速度变慢，为了提升用户体验，近期启动了 “H5 性能优化” 项目，针对页面加载速度，渲染速度做了专项优化，下面是对本次优化的总结，包括以下几部分内容：</p>
<ol>
<li>性能优化效果展示</li>
<li>性能指标及数据采集</li>
<li>性能分析方法及环境准备</li>
<li>性能优化具体实践</li>
</ol>
<h2 id="一、性能指标及数据采集"><a href="#一、性能指标及数据采集" class="headerlink" title="一、性能指标及数据采集"></a>一、性能指标及数据采集</h2><p>企鹅辅导 H5 采用的性能指标包括：</p>
<p>\1. 页面加载时间 —— 页面以多快的速度加载和渲染元素到页面上，具体如下：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI1ODE4NzE1Nw==&mid=2247490349&idx=1&sn=139c52fb354eba09c0c3c5a92dc5ffa2&chksm=ea0d51d7dd7ad8c1be5be5b17fd79f5ccc8d84fe013040232a0861290728112c75fb6061499f&scene=178&cur_album_id=1806166719669796864">First contentful paint (FCP)</a>：测量页面开始加载到某一块内容显示在页面上的时间。</li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI1ODE4NzE1Nw==&mid=2247490349&idx=1&sn=139c52fb354eba09c0c3c5a92dc5ffa2&chksm=ea0d51d7dd7ad8c1be5be5b17fd79f5ccc8d84fe013040232a0861290728112c75fb6061499f&scene=178&cur_album_id=1806166719669796864">Largest contentful paint (LCP)</a>：测量页面开始加载到最大文本块内容或图片显示在页面中的时间。</li>
<li>DomContentLoaded Event：DOM 解析完成时间。</li>
<li>OnLoad Event：页面资源加载完成时间。</li>
</ul>
<p>\2. 加载后响应时间 —— 页面加载和执行js代码后多久能响应用户交互。</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI1ODE4NzE1Nw==&mid=2247490349&idx=1&sn=139c52fb354eba09c0c3c5a92dc5ffa2&chksm=ea0d51d7dd7ad8c1be5be5b17fd79f5ccc8d84fe013040232a0861290728112c75fb6061499f&scene=178&cur_album_id=1806166719669796864">First input delay (FID)</a>：测量用户首次与网站进行交互(例如点击一个链接、按钮、js自定义控件)到浏览器真正进行响应的时间。</li>
</ul>
<p>\3. 视觉稳定性 —— 页面元素是否会以用户不期望的方式移动，并干扰用户的交互。</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI1ODE4NzE1Nw==&mid=2247490349&idx=1&sn=139c52fb354eba09c0c3c5a92dc5ffa2&chksm=ea0d51d7dd7ad8c1be5be5b17fd79f5ccc8d84fe013040232a0861290728112c75fb6061499f&scene=178&cur_album_id=1806166719669796864">Cumulative layout shift (CLS)</a>：测量从页面开始加载到状态变为隐藏过程中，发生不可预期的 layout shifts 的累积分数。</li>
</ul>
<p>项目使用了 IMLOG 进行数据上报，<strong>ELK 体系进行现网数据监控，Grafana 配置视图</strong>，观察现网情况。</p>
<p>根据指标的数据分布，能及时发现页面数据异常采取措施。</p>
<h2 id="二、性能分析及环境准备"><a href="#二、性能分析及环境准备" class="headerlink" title="二、性能分析及环境准备"></a>二、性能分析及环境准备</h2><p>现网页面情况：</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114724642.gif" alt="图片"></p>
<p><strong>可以看到进度条在页面已经展示后还在持续 loading，加载时间长达十几秒，比较影响了用户体验。</strong></p>
<p>根据<a href="https://mp.weixin.qq.com/s?__biz=MzI1ODE4NzE1Nw==&mid=2247490349&idx=1&sn=139c52fb354eba09c0c3c5a92dc5ffa2&chksm=ea0d51d7dd7ad8c1be5be5b17fd79f5ccc8d84fe013040232a0861290728112c75fb6061499f&scene=178&cur_album_id=1806166719669796864">Google 开发文档</a>对浏览器架构的解释：</p>
<blockquote>
<p>当导航提交完成后，渲染进程开始着手加载资源以及渲染页面。一旦渲染进程“完成”（finished）渲染，它会通过 IPC 告知浏览器进程（注意这发生在页面上所有帧(frames) 的 <strong>onload</strong> 事件都已经被触发了而且对应的处理函数已经执行完成了的时候），然后 UI 线程就会停止导航栏上旋转的圈圈。</p>
</blockquote>
<p><strong>我们可以知道，进度条的加载时长和 onload 时间密切相关，要想进度条尽快结束就要减少 onload 时长。</strong></p>
<p>根据现状，使用 ChromeDevTool 作为基础的性能分析工具，观察页面性能情况：</p>
<ul>
<li>Network：观察网络资源加载耗时及顺序</li>
<li>Performace：观察页面渲染表现及JS执行情况</li>
<li>Lighthouse：对网站进行整体评分，找出可优化项</li>
</ul>
<p>下面以<a href="https://mp.weixin.qq.com/s?__biz=MzI1ODE4NzE1Nw==&mid=2247490349&idx=1&sn=139c52fb354eba09c0c3c5a92dc5ffa2&chksm=ea0d51d7dd7ad8c1be5be5b17fd79f5ccc8d84fe013040232a0861290728112c75fb6061499f&scene=178&cur_album_id=1806166719669796864">企鹅辅导课程详情页</a>为案例进行分析，找出潜在的优化项。</p>
<p><strong>（注意使用 Chrome 隐身窗口并禁用插件，移除其他加载项对页面的影响。）</strong></p>
<h3 id="1-Network-分析"><a href="#1-Network-分析" class="headerlink" title="1. Network 分析"></a>1. Network 分析</h3><p>通常进行网络分析需要禁用缓存、启用网络限速（4g &#x2F; 3g） 模拟移动端弱网情况下的加载情况，因为 wifi 网络可能会抹平性能差距。</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114704018" alt="图片"></p>
<p>可以看到 DOMContentLoaded 的时间在 6.03s ，但 onload 的时间却在 20.92s。</p>
<p>先观察 DOMContentLoaded 阶段，发现<strong>最长请求路径在 vendor.js ，JS大小为 170kB，花费时间为 4.32s。</strong></p>
<p>继续观察 DOMContentLoaded 到 onload 的这段时间：</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114701494" alt="图片"></p>
<p><strong>可以发现 onload 事件被大量媒体资源阻塞了，关于 onload 事件的影响因素，可以参考这篇</strong><strong><a href="https://mp.weixin.qq.com/s?__biz=MzI1ODE4NzE1Nw==&mid=2247490349&idx=1&sn=139c52fb354eba09c0c3c5a92dc5ffa2&chksm=ea0d51d7dd7ad8c1be5be5b17fd79f5ccc8d84fe013040232a0861290728112c75fb6061499f&scene=178&cur_album_id=1806166719669796864">文章</a>。</strong></p>
<p>结论是<strong>浏览器认为资源完全加载完成（HTML解析的资源和动态加载的资源）才会触发 onload。</strong></p>
<p>结合上图<strong>可以发现加载了图片、视频、iframe 等资源，阻塞了 onload 事件的触发。</strong></p>
<p><strong>Network 总结</strong></p>
<ol>
<li>DOM 的解析受 JS 加载和执行的影响，尽量对 JS 进行压缩、拆分处理（HTTP2环境下），能减少 DOMContentLoaded 时间。</li>
<li>图片、视频、iframe 等资源，会阻塞 onload 事件的触发，需要优化资源的加载时机，尽快触发 onload。</li>
</ol>
<h3 id="2-Performance-分析"><a href="#2-Performance-分析" class="headerlink" title="2. Performance 分析"></a>2. Performance 分析</h3><p>使用 Performance 模拟移动端注意手机处理器能力比 PC 差，所以一般将 CPU 设置为 4x slowdown 或 6x slowdown 进行模拟。</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>观察几个核心的数据：</p>
<ol>
<li><strong>Web Vitals ( FP &#x2F; FCP &#x2F; LCP &#x2F; Layout Shift ) 核心页面指标 和 Timings 时长</strong></li>
</ol>
<p>可以看到 LCP、DCL和 Onload Event 时间较长，且出现了多次 Layout Shift。</p>
<p>要 LCP 尽量早触发，需要减少页面大块元素的渲染时间，观察 Frames 或ScreenShots 的截图，关注页面的元素渲染情况。</p>
<p>可以通过在 Experience 行点击Layout Shift ，在 Summary 面板找到具体的偏移内容。</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114701037" alt="图片"></p>
<ol>
<li><strong>Main Long Tasks 长任务数量和时长</strong></li>
</ol>
<p>可以看到页面有大量的 Long Tasks 需要进行优化，其中 couse.js (页面代码)的解析执行时间长达 800ms。</p>
<p>处理 Long Tasks，可以在开发环境进行录制，这样在 Main Timeline 能看到具体的代码执行文件和消耗时长。</p>
<p><strong>Performance 总结</strong></p>
<ol>
<li>页面 LCP 触发时间较晚，且出现多次布局偏移，影响用户体验，需要尽早渲染内容和减少布局偏移。</li>
<li>页面 Long Tasks 较多，需要对 JS 进行合理拆分和加载，减少 Long Tasks 数量，特别是 影响 DCL 和 Onload Event 的 Task。</li>
</ol>
<h3 id="3-Lighthouse-分析"><a href="#3-Lighthouse-分析" class="headerlink" title="3. Lighthouse 分析"></a>3. Lighthouse 分析</h3><p>使用 ChromeDevTool 内置 lighthouse 对页面进行跑分：</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114701427" alt="图片"></p>
<p>分数较低，可以看到 Metrics 给出了核心的数据指标，这边显示的是 TTI SI TBT 不合格，LCP 需要提升，FCP 和 CLS 达到了良好的标准，可以查看<a href="https://mp.weixin.qq.com/s?__biz=MzI1ODE4NzE1Nw==&mid=2247490349&idx=1&sn=139c52fb354eba09c0c3c5a92dc5ffa2&chksm=ea0d51d7dd7ad8c1be5be5b17fd79f5ccc8d84fe013040232a0861290728112c75fb6061499f&scene=178&cur_album_id=1806166719669796864">分数计算标准</a>。</p>
<p>同时 Lighthouse 会提供一些优化建议，在 Oppotunities 和 Diagnostics 项，能看到具体的操作指南，如图片大小、移除无用 JS 等，可以根据指南进行项目的优化。</p>
<p>Lighthouse 的评分内容是根据项目整体加载项目进行打分的，审查出的问题同样包含 Network、Performance 的内容，所以也可以看作是对 Network、Performance 问题的优化建议。</p>
<p><strong>Lighthouse 总结</strong></p>
<ol>
<li>根据评分，可以看出 TTI、SI、TBT、LCP这四项指标需要提高，可以参考<a href="https://mp.weixin.qq.com/s?__biz=MzI1ODE4NzE1Nw==&mid=2247490349&idx=1&sn=139c52fb354eba09c0c3c5a92dc5ffa2&chksm=ea0d51d7dd7ad8c1be5be5b17fd79f5ccc8d84fe013040232a0861290728112c75fb6061499f&scene=178&cur_album_id=1806166719669796864">lighthouse 文档</a>进行优化。</li>
<li>Oppotunities 和 Diagnostics 提供了具体的优化建议，可以参考进行改善。</li>
</ol>
<h3 id="4-环境准备"><a href="#4-环境准备" class="headerlink" title="4. 环境准备"></a>4. 环境准备</h3><p>刚才是对线上网页进行初步的问题分析，要实际进行优化和观察，<strong>需要进行环境的模拟，让优化效果能更真实在测试环境中体现。</strong></p>
<p>代理使用：whistle、charles、fiddler 等。</p>
<p>本地环境、测试环境模拟：nginx、nohost、stke 等。</p>
<p>数据上报：IMLOG、TAM、RUM 等（这三个工具均为团队内部的日志上报工具，类似业界 log4js、sentry）。</p>
<p>前端代码打包分析：webpack-bundle-analyzer 、rollup-plugin-visualizer 等。</p>
<p>分析问题时使用本地代码，本地模拟线上环境验证优化效果，最后再部署到测试环境验证，提高开发效率。</p>
<h2 id="三、性能优化具体实践"><a href="#三、性能优化具体实践" class="headerlink" title="三、性能优化具体实践"></a>三、性能优化具体实践</h2><h3 id="PART1-加载时间优化"><a href="#PART1-加载时间优化" class="headerlink" title="PART1: 加载时间优化"></a>PART1: 加载时间优化</h3><p>Network 中对页面中加载的资源进行分类：<img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114701088" alt="图片"></p>
<p>第一部分是影响 DOM 解析的 JS 资源，可以看到这里分类为关键 JS 和非关键 JS，是根据<strong>是否参与首面渲染划分的。</strong></p>
<p>这里的非关键 JS 我们可以考虑延迟异步加载，关键 JS 进行拆分优化处理。</p>
<h4 id="1-关键-JS-打包优化"><a href="#1-关键-JS-打包优化" class="headerlink" title="1. 关键 JS 打包优化"></a>1. 关键 JS 打包优化</h4><p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114701211" alt="图片"></p>
<p>JS 文件数量8个，总体积 460.8kB，最大文件 170KB</p>
<h5 id="1-1-Splitchunks-的正确配置"><a href="#1-1-Splitchunks-的正确配置" class="headerlink" title="1.1 Splitchunks 的正确配置"></a>1.1 Splitchunks 的正确配置</h5><p>vendor.js 170kB(gzipd) 是所有页面都会加载的公共文件，打包规则是 <strong>miniChunks: 3</strong>，引用超过3次的模块将被打进这个js。</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114701775" alt="图片"></p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114701295" alt="图片"></p>
<p>分析vendor.js的具体构成（上图）</p>
<p>以 string-strip-html.umd.js 为例 大小为34.7KB，占了 vendor.js 的 20%体积，但<strong>只有一个页面多次使用到了这个包，触发了 miniChunks 的规则</strong>，被打进了 vendor.js。</p>
<p>同理对 vendor.js 的其他模块进行分析，iosSelect.js、howler.js、weixin-js-sdk 等模块都只有 3、4 个页面&#x2F;组件依赖，但也同样打进了 vendor.js。</p>
<p>由上面的分析，我们可以得出结论：<strong>不能简单的依靠 miniChunks 规则对页面依赖模块进行抽离打包，要根据具体情况拆分公共依赖。</strong></p>
<p>修改后的 vendor 根据业务具体的需求，提取不同页面和组件都有的共同依赖（imutils&#x2F;imlog&#x2F;qqapi）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vendor: &#123;</span><br><span class="line">  test(&#123; resource &#125;) &#123;</span><br><span class="line">    return/[\\/]node_modules[\\/](@tencent\/imutils|imlog\/)|qqapi/.test(resource);</span><br><span class="line">  &#125;,</span><br><span class="line">  name: &#x27;vendor&#x27;,</span><br><span class="line">  priority: 50,</span><br><span class="line">  minChunks: 1,</span><br><span class="line">  reuseExistingChunk: true,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>而其他未指定的公共依赖，新增一个 common.js，将阈值调高到 20 或更高（当前页面数76），让公共依赖成为大多数页面的依赖，提高依赖缓存利用率，调整完后，vendor.js 的大小减少到 30KB，common.js 大小为 42KB。</p>
<p><strong>两个文件加起来大小为 72KB，相对于优化前体积减少了 60%（100KB）。</strong></p>
<h4 id="1-2-公共组件的按需加载"><a href="#1-2-公共组件的按需加载" class="headerlink" title="1.2 公共组件的按需加载"></a>1.2 公共组件的按需加载</h4><p>course.js 101kB (gzipd) 这个文件是页面业务代码的文件：</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114701809" alt="图片"></p>
<p>观察上图，基本都是业务代码，除了一个巨大的 <strong>component Icon，占了 25k，页面文件1&#x2F;4的体积，<strong><strong>但在代码中</strong></strong>使用到的 Icon 总共才8个。</strong></p>
<p>分析代码，可以看到这里使用 require 加载 svg，<strong>Webpack 将 require 文件夹内的内容一并打包，导致页面 Icon 组件冗余。</strong></p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114701772" alt="图片"></p>
<p>如何解决这类问题实现按需加载？</p>
<p>按需加载的内容应该为独立的组件，我们将之前的单一入口的 Icon 组件（动态 dangerouslySetInnerHTML）<strong>改成单文件组件模式直接引入使用图标。</strong></p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114702059" alt="图片"></p>
<p>但实际开发中这样会有些麻烦，一般需要统一的 import 路径，指定需要的图标再加载，参考 <a href="https://mp.weixin.qq.com/s?__biz=MzI1ODE4NzE1Nw==&mid=2247490349&idx=1&sn=139c52fb354eba09c0c3c5a92dc5ffa2&chksm=ea0d51d7dd7ad8c1be5be5b17fd79f5ccc8d84fe013040232a0861290728112c75fb6061499f&scene=178&cur_album_id=1806166719669796864">babel-plugin-import</a>，我们可以配置 babel 的依赖加载路径调整 Icon 的引入方式，这样就实现了图标的按需加载。</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114701942" alt="图片"></p>
<p>按需加载后，重新编译，查看打包带来的收益，<strong>页面的 Icons 组件 stat size 由 74KB 降到了 20KB，体积减少了 70%。</strong></p>
<h4 id="1-3-业务组件的代码拆分-Code-Splitting"><a href="#1-3-业务组件的代码拆分-Code-Splitting" class="headerlink" title="1.3 业务组件的代码拆分 (Code Splitting)"></a>1.3 业务组件的代码拆分 (Code Splitting)</h4><p>观察页面，可以看到”课程大纲“、”课程详情“、”购课须知“这三个模块并不在页面的首屏渲染内容里：</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114702110" alt="图片"></p>
<p>我们可以考虑对页面这几部分组件进行拆分再延迟加载，减少业务代码 JS 大小和执行时长。</p>
<p>拆分的方式很多，可以使用 react-loadable、@loadable&#x2F;component 等库实现，也可以使用React 官方提供的 React.lazy。</p>
<p>拆分后的代码：</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114702079" alt="图片"></p>
<p><strong>代码拆分会导致组件会有渲染的延迟，所以在项目中使用应该综合用户体验和性能再做决定，通过拆分也能使部分资源延后加载优化加载时间。</strong></p>
<h4 id="1-4-Tree-Shaking-优化"><a href="#1-4-Tree-Shaking-优化" class="headerlink" title="1.4 Tree Shaking 优化"></a>1.4 Tree Shaking 优化</h4><p>项目中使用了 TreeShaking 的优化，用时候要注意 <a href="https://mp.weixin.qq.com/s?__biz=MzI1ODE4NzE1Nw==&mid=2247490349&idx=1&sn=139c52fb354eba09c0c3c5a92dc5ffa2&chksm=ea0d51d7dd7ad8c1be5be5b17fd79f5ccc8d84fe013040232a0861290728112c75fb6061499f&scene=178&cur_album_id=1806166719669796864">sideEffects 的使用场景</a>，以免打包产物和开发不一致。</p>
<p>经过上述优化步骤，整体打包内容：</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114701966" alt="图片"></p>
<p>JS 文件数量6个，总体积 308KB，最大文件体积 109KB</p>
<p>关键 JS 优化数据对比：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">文件总体积</th>
<th align="left">最大文件体积</th>
</tr>
</thead>
<tbody><tr>
<td align="left">优化前</td>
<td align="left">460.8 kb</td>
<td align="left">170 kb</td>
</tr>
<tr>
<td align="left">优化后</td>
<td align="left">308 kb</td>
<td align="left">109 kb</td>
</tr>
<tr>
<td align="left">优化效果</td>
<td align="left">总体积减少 50%</td>
<td align="left">最大文件体积减少 56%</td>
</tr>
</tbody></table>
<h3 id="2-非关键-JS-延迟加载"><a href="#2-非关键-JS-延迟加载" class="headerlink" title="2.非关键 JS 延迟加载"></a>2.非关键 JS 延迟加载</h3><p>页面中包含了一些上报相关的 JS 如 sentry，beacon（灯塔 SDK）等，对于这类资源，如果在弱网情况，可能会成为影响 DOM 解析的因素。</p>
<p>为了减少这类非关键 JS 的影响，可以在页面完成加载后再加载非关键 JS，如 sentry 官方也提供了<a href="https://mp.weixin.qq.com/s?__biz=MzI1ODE4NzE1Nw==&mid=2247490349&idx=1&sn=139c52fb354eba09c0c3c5a92dc5ffa2&chksm=ea0d51d7dd7ad8c1be5be5b17fd79f5ccc8d84fe013040232a0861290728112c75fb6061499f&scene=178&cur_album_id=1806166719669796864">延迟加载的方案</a>。</p>
<p>在项目中还发现了一部分非关键 JS，如验证码组件，为了在下一个页面中能利用缓存尽快加载，<strong>所以在上一个页面提前加载一次生成缓存。</strong></p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114702102" alt="图片"></p>
<p>如果不访问下一个页面，可以认为这是一次无效加载，这类的提前缓存方案反而会影响到页面性能。</p>
<p>针对这里资源，我们可以使用 Resource Hints，针对资源做 Prefetch 处理。</p>
<p>检测浏览器是否支持 Prefech，<strong>支持的情况下我们可以创建 Prefetch 链接</strong>，不支持就使用旧逻辑直接加载，这样能更大程度保证页面性能，为下一个页面提供提前加载的支持。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const isPrefetchSupported = () =&gt; &#123;</span><br><span class="line">  const link = document.createElement(&#x27;link&#x27;);</span><br><span class="line">  const &#123; relList &#125; = link;</span><br><span class="line"> </span><br><span class="line">  if (!relList || !relList.supports) &#123;</span><br><span class="line">    returnfalse;</span><br><span class="line">  &#125;</span><br><span class="line">  return relList.supports(&#x27;prefetch&#x27;);</span><br><span class="line">&#125;;</span><br><span class="line">const prefetch = () =&gt; &#123;</span><br><span class="line">    const isPrefetchSupport = isPrefetchSupported();</span><br><span class="line">    if (isPrefetchSupport) &#123;</span><br><span class="line">      const link = document.createElement(&#x27;link&#x27;);</span><br><span class="line">      link.rel = &#x27;prefetch&#x27;;</span><br><span class="line">      link.as = type;</span><br><span class="line">      link.href = url;</span><br><span class="line">      document.head.appendChild(link);</span><br><span class="line">    &#125; elseif (type === &#x27;script&#x27;) &#123;</span><br><span class="line">            // load script</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>优化效果：非关键JS不影响页面加载</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114702608" alt="图片"></p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="3-媒体资源加载优化"><a href="#3-媒体资源加载优化" class="headerlink" title="3.媒体资源加载优化"></a>3.媒体资源加载优化</h3><h4 id="3-1-加载时序优化"><a href="#3-1-加载时序优化" class="headerlink" title="3.1 加载时序优化"></a>3.1 加载时序优化</h4><p>可以观察到 onload 被大量的图片资源和视频资源阻塞了，但是页面上并没有展示对应的图片或视频，这部分内容应该进行懒加载处理。</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114702456" alt="图片"></p>
<p>处理方式主要是要控制好图片懒加载的逻辑（如 onload 后再加载），可以借助各类 lazyload 的库去实现。H5项目用的是位置检测（getBoundingClientRect ）图片到达页面可视区域再展示。</p>
<p><strong>但要注意懒加载不能阻塞业务的正常展示，应该做好超时处理、重试等兜底措施。</strong></p>
<h4 id="3-2-大小尺寸优化"><a href="#3-2-大小尺寸优化" class="headerlink" title="3.2 大小尺寸优化"></a>3.2 大小尺寸优化</h4><p>课程详情页 每张详情图的宽为 1715px，以 6s 为基准（375px）已经是 4x 图了，大图片在弱网情况下会影响页面加载和渲染速度。</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114702638" alt="图片"></p>
<p>使用 CDN 图床尺寸大小压缩功能，根据不同的设备渲染不同大小的图片调整图片格式，根据网络情况，渲染不同清晰度的图。</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640.gif" alt="图片"></p>
<p>可以看到在弱网（移动 3G 网络）的情况下，同一张图片不同尺寸加载速度最高和最低相差接近 6 倍，给用户的体验截然不同。</p>
<p>CDN 配合业务具体实现：<strong>使用 img 标签 srcset&#x2F;sizes 属性和 picutre 标签实现响应式图片</strong>，具体可参考<a href="https://mp.weixin.qq.com/s?__biz=MzI1ODE4NzE1Nw==&mid=2247490349&idx=1&sn=139c52fb354eba09c0c3c5a92dc5ffa2&chksm=ea0d51d7dd7ad8c1be5be5b17fd79f5ccc8d84fe013040232a0861290728112c75fb6061499f&scene=178&cur_album_id=1806166719669796864">文档</a>。</p>
<p><strong>使用 URL 动态拼接方式构造 URL 请求，根据机型宽度和网络情况，判断当前图片宽度倍数进行调整</strong>（如 iPhone 1x，iPad 2x，弱网 0.5x）。</p>
<p><strong>优化效果：移动端 正常网络情况下图片体积减小 220%、弱网情况下图片体积减小 13 倍。</strong></p>
<p>注意实际业务中需要视觉同学参与，评估图片的清晰度是否符合视觉标准，避免反向优化！</p>
<h4 id="3-3-其他类型资源优化"><a href="#3-3-其他类型资源优化" class="headerlink" title="3.3 其他类型资源优化"></a>3.3 其他类型资源优化</h4><p><strong>iframe</strong></p>
<p>加载 iframe 有可能会对页面的加载产生严重的影响，在 onload 之前加载会阻塞 onload 事件触发，从而阻塞 loading，但是还存在另一个问题。</p>
<p>如下图所示，页面在已经 onload 的情况下触发 iframe 的加载，进度条仍然在不停的转动，直到 iframe 的内容加载完成。</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114703076" alt="图片"></p>
<p>可以将 iframe 的时机放在 onload 之后，并使用 setTimeout 触发异步加载 iframe，可避免 iframe 带来的 loading 影响。</p>
<p><strong>数据上报</strong></p>
<p>项目中使用 image 的数据上报请求，在正常网络情况下可能感受不到对页面性能的影响。</p>
<p>但在一些特殊情况，如其中一个图片请求的耗时特别长就会阻塞页面 onload 事件的触发，延长 loading 时间。</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114702838" alt="图片"></p>
<p>解决上报对性能的影响问题有以下方案：</p>
<ol>
<li>延迟合并上报</li>
<li>使用 Beacon API</li>
<li>使用 post 上报</li>
</ol>
<p>H5项目采用了延迟合并上报的方案，业务可根据实际需要进行选择。</p>
<p><strong>优化效果：全部数据上报在 onload 后处理，避免对性能产生影响。</strong></p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114702897" alt="图片"></p>
<p><strong>字体优化</strong></p>
<p>项目中可能会包含很多视觉指定渲染的字体，当字体文件比较大的时候，也会影响到页面的加载和渲染，可以使用 fontmin 将字体资源进行压缩，生成精简版的字体文件。</p>
<p>优化前：20kB &#x3D;&gt; 优化后：14kB：</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114703084" alt="图片"></p>
<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="PART2-页面渲染优化"><a href="#PART2-页面渲染优化" class="headerlink" title="PART2: 页面渲染优化"></a>PART2: 页面渲染优化</h3><h4 id="1-直出页面-TTFB-时间优化"><a href="#1-直出页面-TTFB-时间优化" class="headerlink" title="1. 直出页面 TTFB 时间优化"></a>1. 直出页面 TTFB 时间优化</h4><p><em>名词解释：</em></p>
<p><em>NGW：内部网关，基于 Node.js。</em></p>
<p><em>STKE：公司内部 TKE。</em></p>
<p>目前我们在 STKE 部署了直出服务，通过监控发现直出平均耗时在 300+ms。</p>
<p><strong>TTFB 时间在 100 ～ 200 之间波动，影响了直出页面的渲染。</strong></p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114703436" alt="图片"></p>
<p>通过日志打点、<strong>查看 Nginx Accesslog 日志、网关监控耗时</strong>，得出以下数据（如图）</p>
<ul>
<li>STKE 直出程序耗时是 20ms 左右</li>
<li>直出网关 NGW -&gt; STKE 耗时 60ms 左右</li>
<li>反向代理网关 Nginx -&gt; NGW 耗时 60ms 左右</li>
</ul>
<p>登录 所在机器，ping STKE 机器，有以下数据</p>
<p><strong>平均时延在 32ms，tcp 三次握手+返回数据（最后一次 ack 时发送数据）&#x3D; 2个 rtt，约 64ms，和日志记录的数据一致</strong></p>
<p><strong>查看 NGW 机器所在区域为天津，STKE 机器所在区域为南京，可以初步判断是由机房物理距离导致的网络时延，如下图所示：</strong></p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114703195" alt="图片"></p>
<p>切换 NGW 到南京机器 ping STKE 南京的机器，有以下数据：</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114703580" alt="图片"></p>
<p>同区域机器 ping 的网络时延只有 0.x毫秒，如下图所示：<img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114703307" alt="图片"></p>
<p>综合上述分析，直出页面TTFB时间过长的根本原因是：<strong>NGW 网关部署和 Nginx、STKE 不在同一区域，导致网络时延的产生。</strong></p>
<p>解决方案是<strong>让网关和直出服务机房部署在同一区域</strong>，执行了以下操作：</p>
<ul>
<li><strong>NGW扩容</strong></li>
<li><strong>北极星开启就近访问</strong></li>
</ul>
<p>优化前：<img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114703586" alt="图片"></p>
<p>优化后：<img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114703703" alt="图片"></p>
<p>优化效果如上图：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">七天网关平均耗时</th>
</tr>
</thead>
<tbody><tr>
<td align="left">优化前</td>
<td align="left">153 ms</td>
</tr>
<tr>
<td align="left">优化后</td>
<td align="left">31 ms 优化 80%（120 ms）</td>
</tr>
</tbody></table>
<h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4><h4 id="2-页面渲染时间优化"><a href="#2-页面渲染时间优化" class="headerlink" title="2. 页面渲染时间优化"></a>2. 页面渲染时间优化</h4><p>模拟弱网情况（slow 3g）Performance 录制页面渲染情况，从下图 Screenshot 中可以发现：<img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114704068" alt="图片"></p>
<ol>
<li>DOM 开始解析，但页面还未渲染</li>
<li>CSS 文件下载完成后页面才正常渲染</li>
</ol>
<p><strong>CSS 不会阻塞页面解析，但会阻塞页面渲染，如果 CSS 文件较大或弱网情况，会影响到页面渲染时间，影响用户体验。</strong></p>
<p>借助 ChromeDevTool 的 Coverage 工具（More Tools 里面），录制页面渲染时 CSS 的使用率：</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114704028" alt="图片"></p>
<p>发现首屏的 CSS 使用率才 15%，可以考虑<strong>对页面首屏的关键 CSS 进行内联</strong>，<strong>让页面渲染不被CSS 阻塞，再把完整 CSS 加载进来。</strong></p>
<p>实现 Critial CSS 的优化可以考虑使用 <a href="https://mp.weixin.qq.com/s?__biz=MzI1ODE4NzE1Nw==&mid=2247490349&idx=1&sn=139c52fb354eba09c0c3c5a92dc5ffa2&chksm=ea0d51d7dd7ad8c1be5be5b17fd79f5ccc8d84fe013040232a0861290728112c75fb6061499f&scene=178&cur_album_id=1806166719669796864">critters</a>。</p>
<p>优化后效果：</p>
<p><strong>CSS 资源正在下载时，页面已经能正常渲染显示了，对比优化前，渲染时间上提升了 1～2 个 CSS 文件加载的时间。</strong></p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114704127" alt="图片"></p>
<h4 id="3-页面布局抖动优化"><a href="#3-页面布局抖动优化" class="headerlink" title="3. 页面布局抖动优化"></a>3. 页面布局抖动优化</h4><p>观察页面的元素变化：</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114717022.gif" alt="图片"></p>
<p>优化前（左图）：图标缺失、背景图缺失、字体大小改变导致页面抖动、出现非预期页面元素导致页面抖动。</p>
<p>优化后：内容相对固定， 页面元素出现无突兀感。</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114704716" alt="图片"></p>
<p>主要优化内容：</p>
<ol>
<li><strong>确定直出页面元素出现位置，根据直出数据做好布局</strong></li>
<li><strong>页面小图可以通过 base64 处理，页面解析的时候就会立即展示</strong></li>
<li><strong>减少动态内容对页面布局的影响，使用脱离文档流的方式或定好宽高</strong></li>
</ol>
<h2 id="四、性能优化效果展示"><a href="#四、性能优化效果展示" class="headerlink" title="四、性能优化效果展示"></a>四、性能优化效果展示</h2><p><strong>优化效果由以下指标量化：</strong></p>
<ul>
<li>首次内容绘制时间FCP（First Contentful Paint）：标记浏览器渲染来自 DOM 第一位内容的时间点。</li>
<li>视窗最大内容渲染时间LCP（Largest Contentful Paint）：代表页面可视区域接近完整渲染。</li>
<li>加载进度条时间：浏览器 onload 事件触发时间，触发后导航栏进度条显示完成。</li>
</ul>
<p><strong>Chrome 模拟器 4G 无缓存对比（左优化前、右优化后）：</strong></p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114716391.gif" alt="图片"></p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">首屏最大内容绘制时间</th>
<th align="left">进度条加载（onload）时间</th>
</tr>
</thead>
<tbody><tr>
<td align="left">优化前</td>
<td align="left">1067 ms</td>
<td align="left">6.18s</td>
</tr>
<tr>
<td align="left">优化后</td>
<td align="left">31 ms 优化 80%（120 ms）</td>
<td align="left">1.19s 优化 81%</td>
</tr>
</tbody></table>
<p>**<br>**</p>
<p><strong>Lighthouse 跑分对比：</strong></p>
<p>优化前：</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114704288" alt="图片"></p>
<p>优化后：<img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114704479" alt="图片"></p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">性能得分</th>
</tr>
</thead>
<tbody><tr>
<td align="left">优化前</td>
<td align="left">平均 40 ～ 50</td>
</tr>
<tr>
<td align="left">优化后</td>
<td align="left">平均 75 ～ 85 提升 47%</td>
</tr>
</tbody></table>
<p><strong>srobot 性能检测一周数据</strong></p>
<p><em>srobot 是团队内的性能检测工具，使用 TRobot 指令一键创建页面健康检测，定时自动化检测页面性能及异常。</em></p>
<p>优化前：<img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114704825" alt="图片"></p>
<p>优化后：<img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/640-20211209114705042" alt="图片"></p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">进度条平均加载（onload）时间（4G）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">优化前</td>
<td align="left">4632ms</td>
</tr>
<tr>
<td align="left">优化后</td>
<td align="left"><strong>2581ms 提升45%</strong></td>
</tr>
</tbody></table>
<p>五、优化总结和未来规划</p>
<ol>
<li>以上优化手段主要是围绕首次加载页面的耗时和渲染优化，但二次加载还有很大的优化空间 如 <strong>PWA 的使用、非直出页面骨架屏处理、CSR 转 SSR等</strong>。</li>
<li>对比竞品发现我们 CDN 的下载耗时较长，近期准备启动 CDN 上云，期待上云后 CDN 的效果提升。</li>
<li>项目迭代一直在进行，需要思考在工程上如何持续保障页面性能</li>
<li>上文是围绕课程详情页进行的分析和优化处理，虽然对项目整体做了优化处理，但性能优化没有银弹，不同页面的优化要根据页面具体需求进行，需要开发同学主动关注。</li>
</ol>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化案例</tag>
        <tag>性能指标</tag>
      </tags>
  </entry>
  <entry>
    <title>1.基本调试</title>
    <url>/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%9F%BA%E7%A1%80%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h2 id="chrome-浏览器调试工具的使用"><a href="#chrome-浏览器调试工具的使用" class="headerlink" title="chrome 浏览器调试工具的使用"></a>chrome 浏览器调试工具的使用</h2><h3 id="network性能测试"><a href="#network性能测试" class="headerlink" title="network性能测试"></a>network性能测试</h3><p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E5%9F%BA%E7%A1%80%E8%B0%83%E8%AF%95/image-20210118103539289.png" alt="image-20210118103539289"></p>
<p>打开调试工具 -&gt; network 注意打钩选项 然后按住刷新，选择清空缓存并硬性重新加载</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E5%9F%BA%E7%A1%80%E8%B0%83%E8%AF%95/image-20210118104323123.png" alt="image-20210118104323123"></p>
<blockquote>
<p>network底部有 transferred over network和 resources loaded by the page. 这两个大小有何区别？后边那个指的是解压后的大小，前边那个指的是源文件</p>
</blockquote>
<p>下面重点研究瀑布图</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E5%9F%BA%E7%A1%80%E8%B0%83%E8%AF%95/image-20210118104749352.png" alt="image-20210118104749352"></p>
<p>  瀑布图由长短不一的条状图构成，处于同一竖线起点的请求，就是并行请求，并行请求数量浏览器有上限，其他的请求必须等上一个请求完成后，才可以发出，瀑布图上可以看到</p>
<p>​ 瀑布图上蓝色竖线表示dom加载完成的时间，红色表示所有资源加载完成的时间。</p>
<p>​ 把鼠标放在到瀑布图上，还可以展示具体的时间构成</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E5%9F%BA%E7%A1%80%E8%B0%83%E8%AF%95/image-20210118105340061.png" alt="image-20210118105340061"></p>
<blockquote>
<p>TTFB(Time To First Byte)</p>
</blockquote>
<p>可以把结果保存至本地</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E5%9F%BA%E7%A1%80%E8%B0%83%E8%AF%95/image-20210118110952135.png" alt="image-20210118110952135"></p>
<h3 id="lighthouse"><a href="#lighthouse" class="headerlink" title="lighthouse"></a>lighthouse</h3><p>主要看两个属性</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E5%9F%BA%E7%A1%80%E8%B0%83%E8%AF%95/image-20210118110414575.png" alt="image-20210118110414575"></p>
<h3 id="帧数"><a href="#帧数" class="headerlink" title="帧数"></a>帧数</h3><p><code>command</code>+<code>shift</code>+<code>p</code>  输入frame 选择展示帧数</p>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>7 字体优化</title>
    <url>/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%AD%97%E4%BD%93%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="字体优化"><a href="#字体优化" class="headerlink" title="字体优化"></a>字体优化</h3><p><a href="https://juejin.cn/post/7022897665302560782">web字体终极优化方案</a></p>
<h4 id="什么是FOIT-和-FOUT-不可避免的问题"><a href="#什么是FOIT-和-FOUT-不可避免的问题" class="headerlink" title="什么是FOIT 和 FOUT(不可避免的问题)"></a>什么是FOIT 和 FOUT(不可避免的问题)</h4><ul>
<li>字体未下载完成时，浏览器隐藏或自动降级，导致字体闪烁</li>
<li>Flash Of Invisible Text</li>
<li>Flash Of Unstyle Text</li>
</ul>
<h4 id="font-display（推荐使用）"><a href="#font-display（推荐使用）" class="headerlink" title="font-display（推荐使用）"></a>font-display（推荐使用）</h4><p>兼容性见下图</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E5%AD%97%E4%BD%93%E4%BC%98%E5%8C%96/image-20210124104344312.png" alt="image-20210124104344312"></p>
<p>font-display有五个属性</p>
<ul>
<li><p>auto</p>
<p>字体显示策略由用户代理定义。</p>
</li>
<li><p>block</p>
<p><code>block</code>给予字体一个较短的阻塞时间（大多数情况下推荐使用 3s）和无限大的交换时间。换言之，如果字体未加载完成，浏览器将首先绘制“隐形”文本；一旦字体加载完成，立即切换字体。为此，浏览器将创建一个匿名字体，其类型与所选字体相似，但所有字形都不含“墨水”。使用特定字体渲染文本之后页面方才可用，只有这种情况下才应该使用 <code>block</code>。</p>
</li>
<li><p><strong>swap</strong></p>
<p>使用 swap，则阻塞阶段时间为 0，交换阶段时间无限大。也就是说，如果字体没有完成加载，浏览器会立即绘制文字，一旦字体加载成功，立即切换字体。与 block 类似，如果使用特定字体渲染文本对页面很重要，且使用其他字体渲染仍将显示正确的信息，才应使用 swap。Logo 文字就很适合使用 swap，因为以合理的后备字体显示公司名称仍将正确传递信息，而且最终会以官方字体的样式展现。</p>
</li>
<li><p><strong>Fallback</strong></p>
<p>使用 fallback时，阻塞阶段时间将非常小（多数情况下推荐小于 100ms），交换阶段也比较短（多数情况下建议使用 3 秒钟）。换言之，如果字体没有加载，则首先会使用后备字体渲染。一旦加载成功，就会切换字体。但如果等待时间过久，则页面将一直使用后备字体。如果希望用户尽快开始阅读，而且不因新字体的载入导致文本样式发生变动而干扰用户体验，fallback 是一个很好的选择。举个例子，正文文本就符合这个条件。</p>
</li>
<li><p><strong>optional</strong></p>
</li>
</ul>
<p>​  使用 optional 时，阻塞阶段时间会非常小（多数情况下建议低于 100ms），交换阶段时间为 0。与 fallback   类似，如果字体能够为页面效果增色不少，但并非特别重要时，使用 optional 正好。使用 optional 时，将由  浏览器来决定是否开始下载字体。可以不下载，也可以给予字体较低的优先级，一切取决于浏览器是否认为  对用户最有利。当用户处于弱网络下，这是非常有用的，下载字体可能并非对资源最好的利用。</p>
<p><strong>属性区分</strong></p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E5%AD%97%E4%BD%93%E4%BC%98%E5%8C%96/image-20210124104835219.png" alt="image-20210124104835219"></p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ font-face &#123;</span><br><span class="line">  font-family：ExampleFont;</span><br><span class="line">  src：url（/path/to/fonts/examplefont.woff）format（&#x27;woff&#x27;），</span><br><span class="line">       url（/path/to/fonts/examplefont.eot）format（&#x27;eot&#x27;）;</span><br><span class="line">  font-weight：400;</span><br><span class="line">  font-style：normal;</span><br><span class="line">  font-display：fallback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字体拆分"><a href="#字体拆分" class="headerlink" title="字体拆分"></a>字体拆分</h4><p><strong>unicode-range</strong> 的作用是为@font-face所设置的字体限定一个应用范围，使用unicode编码来设置范围</p>
<p>可以解决：需求：提供了两种字体文件，要求页面中中文使用方正兰亭黑体，英文使用BlaBlaSans，从而实现中英文使用不同字体。</p>
<p><strong>tips</strong>：你希望数字英文是Helvetica字体，中文是苹方或微软雅黑，直接把英文字体放在前面就可以了！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.font &#123;</span><br><span class="line">    font-family: Helvetica, &#x27;Pingfang SC&#x27;, &#x27;microsoft yahei&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>据我所知，这些英文字体是没有中文字符集映射的，也就是，英文字体实际上对中文是没有任何作用的。考虑到<code>font-family</code>的字体解析是从前往后依次的，所以，自然而然上面的代码数字英文是Helvetica字体，中文是苹方或微软雅黑，完全不需要使用<code>unicode-range</code>做吃力不讨好的事情。</p>
<p>那<code>unicode-range</code>适合使用的场景究竟是什么呢？</p>
<p>在我看来，是对中文内容中的某部分中文字符做特殊字体处理，或者是英文字体中部分字符做特殊字体处理，这个才是适合的。比方说，上面使用宋体引号的案例，因为都是中文字体，因此，才有使用<code>unicode-range</code>的价值。</p>
<p><a href="http://www.zhangxinxu.com/study/201611/chinese-language-unicode-range.html">中文汉字unicode编码范围整理demo</a></p>
<h4 id="Ajax-base64-（不如上述方式，了解）"><a href="#Ajax-base64-（不如上述方式，了解）" class="headerlink" title="Ajax + base64 （不如上述方式，了解）"></a>Ajax + base64 （不如上述方式，了解）</h4><ul>
<li>可以解决兼容性问题</li>
<li>缺点：缓存问题</li>
</ul>
<h4 id="font-spider"><a href="#font-spider" class="headerlink" title="font-spider"></a>font-spider</h4><p>一个本地工具，就是把字体文件中 我们会使用到的文字的样式提取出来<br>大致流程:</p>
<ul>
<li>全局安装font-spider</li>
<li>新建一个html，写入我们使用的文字，并且设置我们要压缩的字体</li>
<li>使用终端运行提取命令，这样我们就得到了精简的ttf文件</li>
</ul>
<h4 id="Fontmin"><a href="#Fontmin" class="headerlink" title="Fontmin"></a>Fontmin</h4><p><a href="http://ecomfe.github.io/fontmin/#source">fontmin</a></p>
<p>和font-spider 功能类似</p>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>字体优化</tag>
      </tags>
  </entry>
  <entry>
    <title>3.性能调试工具</title>
    <url>/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>简单记录工具的本地化，可以跳过</p>
<h3 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h3><ul>
<li>Chrome DevTools  开发调试、性能评测</li>
<li>Lighthouse  网站整体质量评估</li>
<li>WebPackTest 多测试地点、全面性能报告<ul>
<li><a href="https://www.webpagetest.org/runtest.php">地址</a></li>
<li>主要是三个指标，waterfall 、first view、repeat view</li>
</ul>
</li>
</ul>
<h3 id="lighthouse-使用"><a href="#lighthouse-使用" class="headerlink" title="lighthouse 使用"></a>lighthouse 使用</h3><ul>
<li>可以使用npm 全局安装</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g lighthouse</span><br><span class="line"></span><br><span class="line">Lighthouse http://www.bilibili.com</span><br><span class="line">会生成一个本地测试报告</span><br></pre></td></tr></table></figure>

<ul>
<li>直接用chrome浏览器</li>
</ul>
<h3 id="WebPageTest本地部署说明"><a href="#WebPageTest本地部署说明" class="headerlink" title="WebPageTest本地部署说明"></a>WebPageTest本地部署说明</h3><ol>
<li><p>拉取镜像</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull webpagetest/server</span><br><span class="line"></span><br><span class="line">docker pull webpagetest/agent</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行实例</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 4000:80 --rm webpagetest/server</span><br><span class="line"></span><br><span class="line">docker run -d -p 4001:80 --network=&quot;host&quot; -e &quot;SERVER_URL=http://localhost:4000/work/&quot; -e &quot;LOCATION=Test&quot; webpagetest/agent</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="mac-用户自定义镜像"><a href="#mac-用户自定义镜像" class="headerlink" title="mac 用户自定义镜像"></a>mac 用户自定义镜像</h4><ol>
<li><p>创建server目录</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir wpt-mac-server</span><br><span class="line">cd wpt-mac-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建Dockerfile，添加内容</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim Dockerfile</span><br><span class="line"></span><br><span class="line">FROM webpagetest/server</span><br><span class="line">ADD locations.ini /var/www/html/settings/</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建locations.ini配置文件，添加内容</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim locations.ini</span><br><span class="line"></span><br><span class="line">[locations]</span><br><span class="line">1=Test_loc</span><br><span class="line">[Test_loc]</span><br><span class="line">1=Test</span><br><span class="line">label=Test Location</span><br><span class="line">group=Desktop</span><br><span class="line">[Test]</span><br><span class="line">browser=Chrome,Firefox</span><br><span class="line">label=&quot;Test Location&quot;</span><br><span class="line">connectivity=LAN</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建自定义server镜像</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t wpt-mac-server .</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建agent目录</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir wpt-mac-agent</span><br><span class="line">cd wpt-mac-agent</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建Dockerfile，添加内容</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim Dockerfile</span><br><span class="line"></span><br><span class="line">FROM webpagetest/agent</span><br><span class="line">ADD script.sh /</span><br><span class="line">ENTRYPOINT /script.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建script.sh， 添加内容</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim script.sh</span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line">set -e</span><br><span class="line">if [ -z &quot;$SERVER_URL&quot; ]; then</span><br><span class="line">  echo &gt;&amp;2 &#x27;SERVER_URL not set&#x27;</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line">if [ -z &quot;$LOCATION&quot; ]; then</span><br><span class="line">  echo &gt;&amp;2 &#x27;LOCATION not set&#x27;</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line">EXTRA_ARGS=&quot;&quot;</span><br><span class="line">if [ -n &quot;$NAME&quot; ]; then</span><br><span class="line">  EXTRA_ARGS=&quot;$EXTRA_ARGS --name $NAME&quot;</span><br><span class="line">fi</span><br><span class="line">python /wptagent/wptagent.py --server $SERVER_URL --location $LOCATION $EXTRA_ARGS --xvfb --dockerized -vvvvv --shaper none</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改script.sh权限</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod u+x script.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建自定义agent镜像</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t wpt-mac-agent .</span><br></pre></td></tr></table></figure>
</li>
<li><p>用新镜像运行实例 (注意先停掉之前运行的containers)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps 查看docker实例 </span><br><span class="line">docker stop 实例id 实例id 即可停止</span><br><span class="line">docker run -d -p 4000:80 --rm wpt-mac-server</span><br><span class="line">docker run -d -p 4001:80 --network=&quot;host&quot; -e &quot;SERVER_URL=http://localhost:4000/work/&quot; -e &quot;LOCATION=Test&quot; wpt-mac-agent</span><br></pre></td></tr></table></figure>
</li>
<li><p>m1平台构建有问题 应该是需要 设置–platform 暂时不会</p>
</li>
</ol>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>性能调试工具</tag>
      </tags>
  </entry>
  <entry>
    <title>性能指标</title>
    <url>/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><p>在chrome的devtools里有很多性能指标，下面简单介绍一下这些指标</p>
<p>首先是可以在chrome的performance中标识的指标</p>
<ul>
<li>DCL (DOMContentLoaded Event)<ul>
<li>当初始的 <strong>HTML</strong> 文档被完全加载和解析完成之后，**<code>DOMContentLoaded</code>** 事件被触发，而无需等待样式表、图像和子框架的完全加载。(MDN的概念)</li>
<li>更加清晰的结论是，DOMContentLoaded 事件在 html文档加载完毕，并且 html 所引用的内联 js、以及外链 js 的同步代码都执行完毕后触发。</li>
</ul>
</li>
<li>L (Onload Event)<ul>
<li><strong>load</strong> 应该仅用于检测一个完全加载的页面 当一个资源及其依赖资源已完成加载时，将触发load事件</li>
<li>更加清晰的结论是，当页面 DOM 结构中的 js、css、图片，以及 js 异步加载的 js、css 、图片都加载完成之后，才会触发 load 事件。<blockquote>
<p>页面中引用的 js 代码如果有异步加载的 js、css、图片，是会影响 load 事件触发的。<br>video、audio、flash 不会影响 load 事件触发。</p>
</blockquote>
</li>
</ul>
</li>
<li>FP (First Paint)<ul>
<li><code>首次绘制</code>: 标记浏览器渲染任何在视觉上不同于导航前屏幕内容之内容的时间点，<strong>简而言之就是浏览器第一次发生变化的时间</strong></li>
</ul>
</li>
<li>FCP (First Contentful Paint)<ul>
<li><code>首次内容绘制</code> 标记浏览器渲染来自 DOM 第一位内容的时间点，该内容可能是文本、图像、SVG 甚至 元素.</li>
</ul>
</li>
<li>LCP (Largest Contentful Paint)<ul>
<li><code>最大内容渲染</code>: 代表在viewport中最大的页面元素加载的时间. LCP的数据会通过PerformanceEntry对象记录, 每次出现更大的内容渲染, 则会产生一个新的PerformanceEntry对象.(2019年11月新增)</li>
</ul>
</li>
</ul>
<p>然后是在性能分析 lighthouse中出现的六个指标,前两个在performance中也存在</p>
<ul>
<li>FCP (First Contentful Paint)</li>
<li>LCP (Largest Contentful Paint)</li>
<li>SI (Speed Index)<ul>
<li>指标用于显示页面可见部分的显示速度, 单位是时间</li>
</ul>
</li>
<li>TTI (Time to Interactive)<ul>
<li><code>可交互时间</code>: 指标用于标记应用已进行视觉渲染并能可靠响应用户输入的时间点.</li>
</ul>
</li>
<li>TBT (Total Blocking Time)<ul>
<li><code>页面阻塞总时长</code>: TBT汇总所有加载过程中阻塞用户操作的时长，在FCP和TTI之间任何long task中阻塞部分都会被汇总（超过50ms的长任务）</li>
</ul>
</li>
<li>CLS (Cumulative Layout Shift)<ul>
<li><code>累积布局偏移</code>: 总结起来就是一个元素初始时和其hidden之间的任何时间如果元素偏移了, 则会被计算进去，说简单点就是用户不期望的元素位置偏移。</li>
<li>根据 Google 的介绍，CLS 问题产生的原因一般包括：<ul>
<li>图片没有宽高</li>
<li>无尺寸的广告、嵌入式和iframes</li>
<li>动态注入的内容</li>
<li>导致FOIT&#x2F;FOUT的Web字体</li>
<li>在更新DOM之前等待网络响应的操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="LCP"><a href="#LCP" class="headerlink" title="LCP"></a>LCP</h3><p>LCP (Largest Contentful Paint) 是一个以用户为中心的性能指标，可以测试用户感知到的页面加载速度，是一个相当重要的性能指标</p>
<h4 id="如何确定元素类型"><a href="#如何确定元素类型" class="headerlink" title="如何确定元素类型?"></a><strong>如何确定元素类型</strong>?</h4><p>跟 <a href="https://link.zhihu.com/?target=https://wicg.github.io/largest-contentful-paint/">Largest Contentful Paint API</a> 里面定义的一致，包含以下几种元素类型:</p>
<ul>
<li><code>&lt;img&gt;</code> 元素</li>
<li><code>&lt;svg&gt;</code> 中的 <code>&lt;image&gt;</code> 元素</li>
<li><code>&lt;video&gt;</code> 元素（如果定义了封面图，会影响LCP）</li>
<li>带 <code>url()</code> 背景图的元素</li>
<li>块级元素带有文本节点或者内联文本子元素</li>
</ul>
<p>要注意的是，限制元素在这些范围内只是为了一开始简单一点，以后可能会加入更多的元素。</p>
<h4 id="如何确定元素的大小？"><a href="#如何确定元素的大小？" class="headerlink" title="如何确定元素的大小？"></a><strong>如何确定元素的大小</strong>？</h4><p>LCP中元素尺寸的定义就是用户视窗所见到的尺寸。如果元素在视窗外面，或者如果元素被overflow裁剪了，这些部分不计算入LCP的元素尺寸。</p>
<ul>
<li>对于已经被设置过大小的图片元素而言，LCP的尺寸就是设置的尺寸，并非图片原始尺寸。</li>
<li>对于文本元素而言，只有包含所有文本节点的最小矩形才是LCP的尺寸。</li>
<li>对于其他元素而言，css样式里的margin、padding和border都不算。</li>
</ul>
<h4 id="LCP什么时候上报？"><a href="#LCP什么时候上报？" class="headerlink" title="LCP什么时候上报？"></a><strong>LCP什么时候上报</strong>？</h4><p>由于Web页面都是分阶段加载的，所以最大元素可能随时会发生变化。</p>
<p>为了捕获这种变化，浏览器会派发一个类型是 <code>largest-contentful-paint</code> 的 <code>PerformanceEntry</code> 对象，<strong>表示浏览器绘制第一帧的时候最大的元素</strong>。在后来的渲染帧中，如果最大元素发生变化，会再次派发一个 <code>PerformanceEntry</code> 对象。</p>
<h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><p>DCL，当初始的 <strong>HTML</strong> 文档被完全加载和解析完成之后，**<code>DOMContentLoaded</code>** 事件被触发，而无需等待样式表、图像和子框架的完全加载。</p>
<p>简单的说几个注意点，</p>
<ul>
<li>无需等待样式表的加载仅适用于head中的css，body的css会阻塞DCL</li>
<li>DCL始终等待js解析加载完成后触发</li>
</ul>
<h3 id="LOAD"><a href="#LOAD" class="headerlink" title="LOAD"></a>LOAD</h3><p><a href="http://eux.baidu.com/blog/fe/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3window.onload">参考</a></p>
<p><strong>先放结论</strong></p>
<ul>
<li><p><strong>onload的触发时机：</strong> JS 加载并执行完毕且页面中所有外链资源加载完成之后大约 3 - 4ms（这个值跟机型和浏览器有关）</p>
</li>
<li><p><strong>最佳实践：</strong> JS代码的执行要放到onload里。如果是服务端渲染带图片的列表，图片最好由JS异步加载， 避免阻塞onload。</p>
</li>
</ul>
<h4 id="1、onload不是立即触发的"><a href="#1、onload不是立即触发的" class="headerlink" title="1、onload不是立即触发的"></a>1、onload不是立即触发的</h4><p>请问下面哪个alert先触发？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;onload&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;timeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>答案是 <code>timeout</code> 先触发。而在我的电脑上，把 <code>timeout</code> 的值调成 5 或 5 以上，就是 <code>onload</code> 先触发了。</p>
<h4 id="2、JS的执行对onload有影响"><a href="#2、JS的执行对onload有影响" class="headerlink" title="2、JS的执行对onload有影响"></a>2、JS的执行对onload有影响</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;onload&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">    a = a + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你会发现 onload 会等很久才触发，因此JS的执行最好放在onload之后。</p>
<h4 id="3、动态加载的资源可能对onload产生影响"><a href="#3、动态加载的资源可能对onload产生影响" class="headerlink" title="3、动态加载的资源可能对onload产生影响"></a>3、动态加载的资源可能对onload产生影响</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&#x27;onload&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;&lt;img src=&quot;a.png&quot;&gt; .... &lt;img src=&quot;z.png&quot;&gt;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们把网速调的慢一点，我们会很清晰的发现这种 JS 动态加进去的图片也会阻塞 <code>onload</code>，只有 a-z 图片都加载完成，onload 才会触发。而我们改成下面：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;&lt;img src=&quot;a.png&quot;&gt; .... &lt;img src=&quot;z.png&quot;&gt;&#x27;</span>;</span><br><span class="line">    &#125;, <span class="number">10</span>)</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;onload&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时就会发现，onload 马上就触发了，不必等待图片加载完成。</p>
<h4 id="4、再讲一个更实际的例子"><a href="#4、再讲一个更实际的例子" class="headerlink" title="4、再讲一个更实际的例子"></a>4、再讲一个更实际的例子</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;aaa.png&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&#x27;onload&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript">$.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">url</span>: imgList,</span></span><br><span class="line"><span class="language-javascript">   <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">arr</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        arr.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            $(<span class="string">&#x27;body&#x27;</span>).<span class="title function_">append</span>(<span class="string">&#x27;&lt;img src=&quot;&#x27;</span> + arr.<span class="property">imgUrl</span> + <span class="string">&#x27;&quot;&gt;&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>假设 aaa.png 加载时间为 100ms，ajax 接口返回时间为 50ms，那么假设 imgList 中有 100 张图片，那么 onload 的时间就会被推迟到这 100 张图片都加载完成之后。</p>
<p>而如果 aaa.png 加载时间为 50ms，接口请求为 100ms 的时候，就不会有这个问题。但是我们没法保证接口请求一定慢于图片请求。</p>
<p>因此<strong>带图片的列表请求需要放在 window.onload 之后执行</strong>。</p>
<h3 id="CLS"><a href="#CLS" class="headerlink" title="CLS"></a>CLS</h3><p>写的很不错，第一个网址是对第二个网址的总结</p>
<p><a href="https://www.bilibili.com/read/cv7415934/">https://www.bilibili.com/read/cv7415934/</a></p>
<p><a href="https://web.dev/optimize-cls/">https://web.dev/optimize-cls/</a></p>
<h3 id="google性能模型RAIL"><a href="#google性能模型RAIL" class="headerlink" title="google性能模型RAIL"></a>google性能模型RAIL</h3><p>了解下谷歌提出的性能模型 RAIL：</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/640.webp" alt="图片"></p>
<blockquote>
<p>1.响应：输入延迟时间（从点按到绘制）小于 100 毫秒。用户点按按钮（例如打开导航）。</p>
<p>2.动画：每个帧的工作（从 JS 到绘制）完成时间小于 16 毫秒。用户滚动页面，拖动手指（例如，打开菜单）或看到动画。拖动时，应用的响应与手指位置有关（例如，拉动刷新、滑动轮播）。此指标仅适用于拖动的持续阶段，不适用于开始阶段。</p>
<p>3.空闲：主线程 JS 工作分成不大于 50 毫秒的块。用户没有与页面交互，但主线程应足够用于处理下一个用户输入。</p>
<p>4.加载：页面可以在 1000 毫秒内就绪。用户加载页面并看到关键路径内容。</p>
</blockquote>
<h3 id="performance介绍"><a href="#performance介绍" class="headerlink" title="performance介绍"></a><strong>performance介绍</strong></h3><p>performance 对象是专门用来用于性能监控的对象，内置了一些前端需要的性能参数。</p>
<p><strong>performance.now()方法</strong></p>
<p><code>performance.now()</code>返回<code>performance.navigationStart</code>至当前的毫秒数。<code>performance.navigationStart</code>是下文将介绍到的可以说是浏览器访问最初的时间测量点。</p>
<p><strong>performance.timing</strong></p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/640" alt="图片"></p>
<p><strong>performance.getEntries()方法</strong></p>
<p>浏览器获取网页时，会对网页中每一个对象（脚本文件、样式表、图片文件等等）发出一个 HTTP 请求。performance.getEntries() 方法以数组形式，返回一个 PerformanceEntry 列表，这些请求的时间统计信息，有多少个请求，返回数组就会有多少个成员。</p>
<p>name ：资源名称，是资源的绝对路径或调用mark方法自定义的名称 startTime :开始时间 duration ：加载时间 entryType ：资源类型，entryType 类型不同数组中的对象结构也不同！具体见下 initiatorType ：谁发起的请求，具体见下：</p>
<table>
<thead>
<tr>
<th><strong>值</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>mark</td>
<td>通过 mark() 方法添加到数组中的对象</td>
</tr>
<tr>
<td>paint</td>
<td>通过 measure() 方法添加到数组中的对象</td>
</tr>
<tr>
<td>measure</td>
<td>first-contentful-paint 首次内容绘制</td>
</tr>
<tr>
<td>resource</td>
<td>所有资源加载时间，用处最多</td>
</tr>
</tbody></table>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/640-20211209094756888" alt="图片"></p>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>传输优化</tag>
        <tag>性能指标</tag>
      </tags>
  </entry>
  <entry>
    <title>6 渲染层合并</title>
    <url>/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B8%B2%E6%9F%93%E5%B1%82%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<h2 id="梳理浏览器渲染流程"><a href="#梳理浏览器渲染流程" class="headerlink" title="梳理浏览器渲染流程"></a>梳理浏览器渲染流程</h2><p>首先简单了解一下浏览器请求、加载、渲染一个页面的大致过程：</p>
<blockquote>
<ul>
<li>DNS 查询</li>
<li>TCP 连接</li>
<li>HTTP 请求即响应</li>
<li>服务器响应</li>
<li>客户端渲染</li>
</ul>
</blockquote>
<p>这里主要将客户端渲染展开梳理一下，从浏览器器内核拿到内容（渲染线程接收请求，加载网页并渲染网页），渲染大概可以划分成以下几个步骤：</p>
<blockquote>
<ul>
<li>解析html建立dom树</li>
<li>解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）</li>
<li>布局render树（Layout&#x2F;reflow），负责各元素尺寸、位置的计算</li>
<li>绘制render树（paint），绘制页面像素信息</li>
<li>浏览器会将各层的信息发送给GPU（GPU进程：最多一个，用于3D绘制等），GPU会将各层合成（composite），显示在屏幕上。</li>
</ul>
</blockquote>
<p>参考一张图（webkit渲染主要流程）：</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E6%B8%B2%E6%9F%93%E5%B1%82%E5%90%88%E5%B9%B6/bVHJfZ.png" alt="图片描述"></p>
<p>这里先解释一下几个概念，方便大家理解：</p>
<p>　　DOM Tree：浏览器将HTML解析成树形的数据结构。</p>
<p>　　CSS Rule Tree：浏览器将CSS解析成树形的数据结构。</p>
<p>　　Render Tree: DOM和CSSOM合并后生成Render Tree。</p>
<p>　　layout: 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置。</p>
<p>　　painting: 按照算出来的规则，通过显卡，把内容画到屏幕上。</p>
<p>　　reflow（回流）：当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，内行称这个回退的过程叫 reflow。reflow 会从 <html> 这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置。reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。</p>
<p>　　repaint（重绘）：改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。</p>
<p>注意：</p>
<ol>
<li>display:none 的节点不会被加入Render Tree，而visibility: hidden<br>则会，所以，如果某个节点最开始是不显示的，设为display:none是更优的。</li>
<li>display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发现位置变化。</li>
<li>有些情况下，比如修改了元素的样式，浏览器并不会立刻reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次reflow，这又叫异步 reflow 或增量异步 reflow。但是在有些情况下，比如resize窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。</li>
</ol>
<p>再参考一张图理解一下：</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E6%B8%B2%E6%9F%93%E5%B1%82%E5%90%88%E5%B9%B6/bV7TBl.png" alt="图片描述"></p>
<p>细致分离两个环节，其他环节参考上述概念注解：</p>
<p><code>JavaScript</code>：JavaScript实现动画效果，DOM元素操作等。<br><code>Composite（渲染层合并）</code>：对页面中 DOM 元素的绘制是在多个层上进行的。在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上。对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常。</p>
<p>在实际场景下，大致会出现三种常见的渲染流程（Layout和Paint步骤是可避免的，可参考上一张图的注意部分理解）：</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E6%B8%B2%E6%9F%93%E5%B1%82%E5%90%88%E5%B9%B6/bV7TKK.png" alt="图片描述"></p>
<hr>
<h2 id="Composite"><a href="#Composite" class="headerlink" title="Composite"></a>Composite</h2><h4 id="了解层"><a href="#了解层" class="headerlink" title="了解层"></a>了解层</h4><blockquote>
<p><strong>注意：首先说明，这里讨论的是 WebKit，描述的是 Chrome 的实现细节，而并非是 web 平台的功能，因此这里介绍的内容不一定适用于其他浏览器。</strong></p>
<ul>
<li>Chrome 拥有两套不同的渲染路径(rendering path)：硬件加速路径和旧软件路径(older software path)</li>
<li>Chrome 中有不同类型的层： RenderLayer(负责 DOM 子树)和GraphicsLayer(负责 RenderLayer的子树)，只有 GraphicsLayer 是作为纹理(texture)上传给GPU的。</li>
<li>什么是纹理？可以把它想象成一个从主存储器(例如 RAM)移动到图像存储器(例如 GPU 中的 VRAM)的位图图像(bitmapimage)</li>
<li>Chrome 使用纹理来从 GPU上获得大块的页面内容。通过将纹理应用到一个非常简单的矩形网格就能很容易匹配不同的位置(position)和变形(transformation)。这也就是3DCSS 的工作原理，它对于快速滚动也十分有效。</li>
</ul>
</blockquote>
<p>整个图：</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E6%B8%B2%E6%9F%93%E5%B1%82%E5%90%88%E5%B9%B6/bV7URO.png" alt="图片描述"></p>
<p>在 Chrome 中其实有几种不同的层类型：</p>
<ul>
<li>RenderLayers 渲染层，这是负责对应 DOM 子树</li>
<li>GraphicsLayers 图形层，这是负责对应 RenderLayers子树。</li>
</ul>
<p>在浏览器渲染流程中提到了composite概念，在 DOM 树中每个节点都会对应一个 LayoutObject，当他们的 LayoutObject 处于相同的坐标空间时，就会形成一个 RenderLayers ，也就是渲染层。RenderLayers 来保证页面元素以正确的顺序合成，这时候就会出现层合成（composite），从而正确处理透明元素和重叠元素的显示。</p>
<p>某些特殊的渲染层会被认为是合成层（Compositing Layers），合成层拥有单独的 GraphicsLayer，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 父层公用一个。</p>
<p>而每个GraphicsLayer（合成层单独拥有的图层） 都有一个 GraphicsContext，GraphicsContext 会负责输出该层的位图，位图是存储在共享内存中，作为纹理上传到 GPU 中，最后由 GPU 将多个位图进行合成，然后显示到屏幕上。</p>
<h2 id="如何变成合成层"><a href="#如何变成合成层" class="headerlink" title="如何变成合成层"></a>如何变成合成层</h2><blockquote>
<h4 id="合成层创建标准"><a href="#合成层创建标准" class="headerlink" title="合成层创建标准"></a>合成层创建标准</h4><p>什么情况下能使元素获得自己的层？虽然 Chrome的启发式方法(heuristic)随着时间在不断发展进步，但是从目前来说，满足以下任意情况便会创建层：</p>
<ul>
<li>3D 或透视变换(perspective transform) CSS 属性</li>
<li>使用加速视频解码的 <video> 元素 拥有 3D</li>
<li>(WebGL) 上下文或加速的 2D 上下文的 <canvas> 元素</li>
<li>混合插件(如 Flash)</li>
<li>对自己的 opacity 做 CSS动画或使用一个动画变换的元素</li>
<li>拥有加速 CSS 过滤器的元素</li>
<li>元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)</li>
<li>元素有一个z-index较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)</li>
</ul>
</blockquote>
<h2 id="合成层的优点"><a href="#合成层的优点" class="headerlink" title="合成层的优点"></a>合成层的优点</h2><p><a href="http://taobaofed.org/blog/2016/04/25/performance-composite/">淘宝的栗子</a>举的很详细，值得一看，里面提到了一旦renderLayer提升为了合成层就会有自己的绘图上下文，并且会开启硬件加速，有利于性能提升,里面列举了一些特点</p>
<ul>
<li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</li>
<li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li>
<li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li>
</ul>
<p><strong>注意：</strong></p>
<ol>
<li>提升到合成层后合成层的位图会交GPU处理，但请注意，仅仅只是合成的处理（把绘图上下文的位图输出进行组合）需要用到GPU，生成合成层的位图处理（绘图上下文的工作）是需要CPU。</li>
<li>当需要repaint的时候可以只repaint本身，不影响其他层，但是paint之前还有style， layout,那就意味着即使合成层只是repaint了自己，但style和layout本身就很占用时间。</li>
<li>仅仅是transform和opacity不会引发layout 和paint，那么其他的属性不确定。</li>
</ol>
<p>总结合成层的优势：一般一个元素开启硬件加速后会变成合成层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。</p>
<p><strong>性能优化点：</strong></p>
<ol>
<li>提升动画效果的元素 合成层的好处是不会影响到其他元素的绘制，因此，为了减少动画元素对其他元素的影响，从而减少paint，我们需要把动画效果中的元素提升为合成层。 <code>提升合成层的最好方式是使用 CSS 的 will-change属性。从上一节合成层产生原因中，可以知道 will-change 设置为opacity、transform、top、left、bottom、right 可以将元素提升为合成层。</code></li>
<li>使用 transform 或者 opacity 来实现动画效果, 这样只需要做合成层的合并就好了。</li>
<li>减少绘制区域 对于不需要重新绘制的区域应尽量避免绘制，以减少绘制区域，比如一个 fix 在页面顶部的固定不变的导航header，在页面内容某个区域 repaint 时，整个屏幕包括 fix 的 header 也会被重绘。<code>而对于固定不变的区域，我们期望其并不会被重绘，因此可以通过之前的方法，将其提升为独立的合成层。减少绘制区域，需要仔细分析页面，区分绘制区域，减少重绘区域甚至避免重绘。</code></li>
</ol>
<h2 id="利用合成层可能踩到的坑"><a href="#利用合成层可能踩到的坑" class="headerlink" title="利用合成层可能踩到的坑"></a>利用合成层可能踩到的坑</h2><ol>
<li>合成层占用内存的问题</li>
<li>层爆炸，由于某些原因可能导致产生大量不在预期内的合成层，虽然有浏览器的层压缩机制，但是也有很多无法进行压缩的情况，这就可能出现层爆炸的现象（简单理解就是，很多不需要提升为合成层的元素因为某些不当操作成为了合成层）。解决层爆炸的问题，最佳方案是打破 overlap 的条件，也就是说让其他元素不要和合成层元素重叠。简单直接的方式：<code>使用3D硬件加速提升动画性能时，最好给元素增加一个z-index属性，人为干扰合成的排序，可以有效减少chrome创建不必要的合成层，提升渲染性能，移动端优化效果尤为明显。</code> 在这篇<a href="http://div.io/topic/1348">文章</a>中的<a href="http://fouber.github.io/test/layer/">demo</a>可以看出其中厉害。</li>
</ol>
<p>用chremo打开demo页面后，开启浏览器的开发者模式，再按照<strong>如图操作</strong>打开查看工具：</p>
<h2 id="梳理浏览器渲染流程-1"><a href="#梳理浏览器渲染流程-1" class="headerlink" title="梳理浏览器渲染流程"></a>梳理浏览器渲染流程</h2><p>首先简单了解一下浏览器请求、加载、渲染一个页面的大致过程：</p>
<blockquote>
<ul>
<li>DNS 查询</li>
<li>TCP 连接</li>
<li>HTTP 请求即响应</li>
<li>服务器响应</li>
<li>客户端渲染</li>
</ul>
</blockquote>
<p>这里主要将客户端渲染展开梳理一下，从浏览器器内核拿到内容（渲染线程接收请求，加载网页并渲染网页），渲染大概可以划分成以下几个步骤：</p>
<blockquote>
<ul>
<li>解析html建立dom树</li>
<li>解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）</li>
<li>布局render树（Layout&#x2F;reflow），负责各元素尺寸、位置的计算</li>
<li>绘制render树（paint），绘制页面像素信息</li>
<li>浏览器会将各层的信息发送给GPU（GPU进程：最多一个，用于3D绘制等），GPU会将各层合成（composite），显示在屏幕上。</li>
</ul>
</blockquote>
<p>参考一张图（webkit渲染主要流程）：</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E6%B8%B2%E6%9F%93%E5%B1%82%E5%90%88%E5%B9%B6/bVHJfZ-20210122105457454.png" alt="图片描述"></p>
<p>这里先解释一下几个概念，方便大家理解：</p>
<p>　　DOM Tree：浏览器将HTML解析成树形的数据结构。</p>
<p>　　CSS Rule Tree：浏览器将CSS解析成树形的数据结构。</p>
<p>　　Render Tree: DOM和CSSOM合并后生成Render Tree。</p>
<p>　　layout: 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置。</p>
<p>　　painting: 按照算出来的规则，通过显卡，把内容画到屏幕上。</p>
<p>　　reflow（回流）：当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，内行称这个回退的过程叫 reflow。reflow 会从 <html> 这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置。reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。</p>
<p>　　repaint（重绘）：改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。</p>
<p>注意：</p>
<ol>
<li>display:none 的节点不会被加入Render Tree，而visibility: hidden<br>则会，所以，如果某个节点最开始是不显示的，设为display:none是更优的。</li>
<li>display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发现位置变化。</li>
<li>有些情况下，比如修改了元素的样式，浏览器并不会立刻reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次reflow，这又叫异步 reflow 或增量异步 reflow。但是在有些情况下，比如resize窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。</li>
</ol>
<p>再参考一张图理解一下：</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E6%B8%B2%E6%9F%93%E5%B1%82%E5%90%88%E5%B9%B6/bV7TBl-20210122105457544.png" alt="图片描述"></p>
<p>细致分离两个环节，其他环节参考上述概念注解：</p>
<p><code>JavaScript</code>：JavaScript实现动画效果，DOM元素操作等。<br><code>Composite（渲染层合并）</code>：对页面中 DOM 元素的绘制是在多个层上进行的。在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上。对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常。</p>
<p>在实际场景下，大致会出现三种常见的渲染流程（Layout和Paint步骤是可避免的，可参考上一张图的注意部分理解）：</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/https:/segmentfault.com/img/bV7TKK?w=580&h=381" alt="图片描述"></p>
<hr>
<h2 id="Composite-1"><a href="#Composite-1" class="headerlink" title="Composite"></a>Composite</h2><h4 id="了解层-1"><a href="#了解层-1" class="headerlink" title="了解层"></a>了解层</h4><blockquote>
<p><strong>注意：首先说明，这里讨论的是 WebKit，描述的是 Chrome 的实现细节，而并非是 web 平台的功能，因此这里介绍的内容不一定适用于其他浏览器。</strong></p>
<ul>
<li>Chrome 拥有两套不同的渲染路径(rendering path)：硬件加速路径和旧软件路径(older software path)</li>
<li>Chrome 中有不同类型的层： RenderLayer(负责 DOM 子树)和GraphicsLayer(负责 RenderLayer的子树)，只有 GraphicsLayer 是作为纹理(texture)上传给GPU的。</li>
<li>什么是纹理？可以把它想象成一个从主存储器(例如 RAM)移动到图像存储器(例如 GPU 中的 VRAM)的位图图像(bitmapimage)</li>
<li>Chrome 使用纹理来从 GPU上获得大块的页面内容。通过将纹理应用到一个非常简单的矩形网格就能很容易匹配不同的位置(position)和变形(transformation)。这也就是3DCSS 的工作原理，它对于快速滚动也十分有效。</li>
</ul>
</blockquote>
<p>整个图：</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E6%B8%B2%E6%9F%93%E5%B1%82%E5%90%88%E5%B9%B6/bV7URO-20210122105457589.png" alt="图片描述"></p>
<p>在 Chrome 中其实有几种不同的层类型：</p>
<ul>
<li>RenderLayers 渲染层，这是负责对应 DOM 子树</li>
<li>GraphicsLayers 图形层，这是负责对应 RenderLayers子树。</li>
</ul>
<p>在浏览器渲染流程中提到了composite概念，在 DOM 树中每个节点都会对应一个 LayoutObject，当他们的 LayoutObject 处于相同的坐标空间时，就会形成一个 RenderLayers ，也就是渲染层。RenderLayers 来保证页面元素以正确的顺序合成，这时候就会出现层合成（composite），从而正确处理透明元素和重叠元素的显示。</p>
<p>某些特殊的渲染层会被认为是合成层（Compositing Layers），合成层拥有单独的 GraphicsLayer，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 父层公用一个。</p>
<p>而每个GraphicsLayer（合成层单独拥有的图层） 都有一个 GraphicsContext，GraphicsContext 会负责输出该层的位图，位图是存储在共享内存中，作为纹理上传到 GPU 中，最后由 GPU 将多个位图进行合成，然后显示到屏幕上。</p>
<h2 id="如何变成合成层-1"><a href="#如何变成合成层-1" class="headerlink" title="如何变成合成层"></a>如何变成合成层</h2><blockquote>
<h4 id="合成层创建标准-1"><a href="#合成层创建标准-1" class="headerlink" title="合成层创建标准"></a>合成层创建标准</h4><p>什么情况下能使元素获得自己的层？虽然 Chrome的启发式方法(heuristic)随着时间在不断发展进步，但是从目前来说，满足以下任意情况便会创建层：</p>
<ul>
<li>3D 或透视变换(perspective transform) CSS 属性</li>
<li>使用加速视频解码的 <video> 元素 拥有 3D</li>
<li>(WebGL) 上下文或加速的 2D 上下文的 <canvas> 元素</li>
<li>混合插件(如 Flash)</li>
<li>对自己的 opacity 做 CSS动画或使用一个动画变换的元素</li>
<li>拥有加速 CSS 过滤器的元素</li>
<li>元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)</li>
<li>元素有一个z-index较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)</li>
</ul>
</blockquote>
<h2 id="合成层的优点-1"><a href="#合成层的优点-1" class="headerlink" title="合成层的优点"></a>合成层的优点</h2><p><a href="http://taobaofed.org/blog/2016/04/25/performance-composite/">淘宝的栗子</a>举的很详细，值得一看，里面提到了一旦renderLayer提升为了合成层就会有自己的绘图上下文，并且会开启硬件加速，有利于性能提升,里面列举了一些特点</p>
<ul>
<li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</li>
<li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li>
<li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li>
</ul>
<p><strong>注意：</strong></p>
<ol>
<li>提升到合成层后合成层的位图会交GPU处理，但请注意，仅仅只是合成的处理（把绘图上下文的位图输出进行组合）需要用到GPU，生成合成层的位图处理（绘图上下文的工作）是需要CPU。</li>
<li>当需要repaint的时候可以只repaint本身，不影响其他层，但是paint之前还有style， layout,那就意味着即使合成层只是repaint了自己，但style和layout本身就很占用时间。</li>
<li>仅仅是transform和opacity不会引发layout 和paint，那么其他的属性不确定。</li>
</ol>
<p>总结合成层的优势：一般一个元素开启硬件加速后会变成合成层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。</p>
<p><strong>性能优化点：</strong></p>
<ol>
<li>提升动画效果的元素 合成层的好处是不会影响到其他元素的绘制，因此，为了减少动画元素对其他元素的影响，从而减少paint，我们需要把动画效果中的元素提升为合成层。 <code>提升合成层的最好方式是使用 CSS 的 will-change属性。从上一节合成层产生原因中，可以知道 will-change 设置为opacity、transform、top、left、bottom、right 可以将元素提升为合成层。</code></li>
<li>使用 transform 或者 opacity 来实现动画效果, 这样只需要做合成层的合并就好了。</li>
<li>减少绘制区域 对于不需要重新绘制的区域应尽量避免绘制，以减少绘制区域，比如一个 fix 在页面顶部的固定不变的导航header，在页面内容某个区域 repaint 时，整个屏幕包括 fix 的 header 也会被重绘。<code>而对于固定不变的区域，我们期望其并不会被重绘，因此可以通过之前的方法，将其提升为独立的合成层。减少绘制区域，需要仔细分析页面，区分绘制区域，减少重绘区域甚至避免重绘。</code></li>
</ol>
<h2 id="利用合成层可能踩到的坑-1"><a href="#利用合成层可能踩到的坑-1" class="headerlink" title="利用合成层可能踩到的坑"></a>利用合成层可能踩到的坑</h2><ol>
<li>合成层占用内存的问题</li>
<li>层爆炸，由于某些原因可能导致产生大量不在预期内的合成层，虽然有浏览器的层压缩机制，但是也有很多无法进行压缩的情况，这就可能出现层爆炸的现象（简单理解就是，很多不需要提升为合成层的元素因为某些不当操作成为了合成层）。解决层爆炸的问题，最佳方案是打破 overlap 的条件，也就是说让其他元素不要和合成层元素重叠。简单直接的方式：<code>使用3D硬件加速提升动画性能时，最好给元素增加一个z-index属性，人为干扰合成的排序，可以有效减少chrome创建不必要的合成层，提升渲染性能，移动端优化效果尤为明显。</code> 在这篇<a href="http://div.io/topic/1348">文章</a>中的<a href="http://fouber.github.io/test/layer/">demo</a>可以看出其中厉害。</li>
</ol>
<p>用chremo打开demo页面后，开启浏览器的开发者模式，再按照<strong>如图操作</strong>打开查看工具：</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E6%B8%B2%E6%9F%93%E5%B1%82%E5%90%88%E5%B9%B6/view.png" alt="preview"></p>
<p>开启 Rendering 的Layer borders后 观察点击<code>为动画元素设置z-index复选框</code>的页面提示变化：</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E6%B8%B2%E6%9F%93%E5%B1%82%E5%90%88%E5%B9%B6/bV85zk.png" alt="图片描述"></p>
<p>上图中可以明显看出：页面中设置了一个h1标题，应用了translate3d动画，使得它被放到composited layer中渲染，然后在这个元素后面创建了2000个list。在不为h1元素设置z-index的情况下，使得本不需要提升到合成层的ul元素下的每个li元素都提升为一个单独合成层（每个li元素的黄色提示边框），最终会导致GPU资源过度消耗页面滑动时很卡，尤其在移动端（安卓）上更加明显。</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E6%B8%B2%E6%9F%93%E5%B1%82%E5%90%88%E5%B9%B6/bV85Ag.png" alt="图片描述"></p>
<p>如上图操作选中<code>为动画元素设置z-index</code>，可以看出ul下的每个li都回归到普通渲染层，不再是合成层也就不会消耗GPU资源去渲染，从而达到了优化页面性能优化的目的。</p>
<p>大家可以用支持『硬件加速』的『安卓』手机浏览器测试上述页面，给动画元素加z-index前后的性能差距非常明显。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>在实际的前端开发中尤其是移动端开发，很多小伙伴都很喜欢使用类似 translateZ(0)等属性来进行所谓的硬件加速，以提升性能，达到优化页面动态效果的目的，但还是要注意凡事过犹不及，应用硬件加速的同时也要注意到千万别踩坑。<br>关于合成层的更细致具体的讲解，可以仔细学习下下面的参考文章（尤其是前三篇哦）。<br>最后祝愿热爱技术的你我始终坚持在探索技术的路上奋力前行！</p>
<blockquote>
<p>转载自 <a href="https://segmentfault.com/a/1190000014520786">https://segmentfault.com/a/1190000014520786</a></p>
</blockquote>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>浏览器渲染</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>5.回流与重绘</title>
    <url>/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h2><p>本文先从浏览器的渲染过程来从头到尾的讲解一下回流重绘，如果大家想直接看如何减少回流和重绘，可以跳到后面。（这个渲染过程来自<a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn">MDN</a>）</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98%E4%B8%8E%E4%BC%98%E5%8C%96/1460000017329983.png" alt="webkit渲染过程"></p>
<p>从上面这个图上，我们可以看到，浏览器渲染过程如下：</p>
<ol>
<li>解析HTML，生成DOM树，解析CSS，生成CSSOM树</li>
<li>将DOM树和CSSOM树结合，生成渲染树(Render Tree)</li>
<li>Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）</li>
<li>Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</li>
<li>Display:将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层，这里我们不展开，之后有机会会写一篇博客）</li>
</ol>
<p>渲染过程看起来很简单，让我们来具体了解下每一步具体做了什么。</p>
<h3 id="生成渲染树"><a href="#生成渲染树" class="headerlink" title="生成渲染树"></a>生成渲染树</h3><p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98%E4%B8%8E%E4%BC%98%E5%8C%96/1460000017329984.png" alt="生成渲染树"></p>
<p>为了构建渲染树，浏览器主要完成了以下工作：</p>
<ol>
<li>从DOM树的根节点开始遍历每个可见节点。</li>
<li>对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。</li>
<li>根据每个可见节点以及其对应的样式，组合生成渲染树。</li>
</ol>
<p>第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括：</p>
<ul>
<li>一些不会渲染输出的节点，比如script、meta、link等。</li>
<li>一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。</li>
</ul>
<p><strong>注意：渲染树只包含可见的节点</strong></p>
<h3 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h3><p>前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。</p>
<p>为了弄清每个对象在网站上的确切大小和位置，浏览器从渲染树的根节点开始遍历，我们可以以下面这个实例来表示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;</span><br><span class="line">    &lt;title&gt;Critial Path: Hello world!&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div style=&quot;width: 50%&quot;&gt;</span><br><span class="line">      &lt;div style=&quot;width: 50%&quot;&gt;Hello world!&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，第一个div将节点的显示尺寸设置为视口宽度的50%，第二个div将其尺寸设置为父节点的50%。而在回流这个阶段，我们就需要根据视口具体的宽度，将其转为实际的像素值。（如下图）</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98%E4%B8%8E%E4%BC%98%E5%8C%96/1460000017329985.png" alt="img"></p>
<h3 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h3><p>最终，我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。</p>
<p>既然知道了浏览器的渲染过程后，我们就来探讨下，何时会发生回流重绘。</p>
<h2 id="何时发生回流重绘"><a href="#何时发生回流重绘" class="headerlink" title="何时发生回流重绘"></a>何时发生回流重绘</h2><p>我们前面知道了，回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流。比如以下情况：</p>
<ul>
<li>添加或删除可见的DOM元素</li>
<li>元素的位置发生变化</li>
<li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li>
<li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。</li>
<li>页面一开始渲染的时候（这肯定避免不了）</li>
<li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</li>
</ul>
<p><strong>YaHoo!性能小组总结了一些导致<code>回流</code>发生的一些因素:</strong></p>
<ol>
<li><p>调整窗口大小</p>
</li>
<li><p>改变字体</p>
</li>
<li><p>增加或者移除样式表</p>
</li>
<li><p>内容变化，比如用户在 input 框中输入文字, CSS3 动画等</p>
</li>
<li><p>激活 <code>CSS</code> 伪类，比如 <code>:hover</code></p>
</li>
<li><p>操作<code>class</code>属性</p>
</li>
<li><p>脚本操作<code>DOM</code></p>
</li>
<li><p>计算<code>offsetWidth</code>和<code>offsetHeight</code>属性</p>
</li>
<li><p>设置 style 属性的值</p>
</li>
<li><p><strong>注意：回流一定会触发重绘，而重绘不一定会回流</strong></p>
</li>
</ol>
<p>根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。</p>
<h2 id="浏览器的优化机制"><a href="#浏览器的优化机制" class="headerlink" title="浏览器的优化机制"></a>浏览器的优化机制</h2><p>现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！<strong>当你获取布局信息的操作的时候，会强制队列刷新</strong>，比如当你访问以下属性或者使用以下方法：</p>
<ul>
<li>offsetTop、offsetLeft、offsetWidth、offsetHeight</li>
<li>scrollTop、scrollLeft、scrollWidth、scrollHeight</li>
<li>clientTop、clientLeft、clientWidth、clientHeight</li>
<li>getComputedStyle()</li>
<li>getBoundingClientRect</li>
<li>具体可以访问这个网站：<a href="https://gist.github.com/paulirish/5d52fb081b3570c81e3a">https://gist.github.com/pauli...</a>点击预览</li>
</ul>
<p>以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，<strong>最好避免使用上面列出的属性，他们都会刷新渲染队列。</strong>如果要使用它们，最好将值缓存起来。</p>
<h2 id="减少回流和重绘"><a href="#减少回流和重绘" class="headerlink" title="减少回流和重绘"></a>减少回流和重绘</h2><p>好了，到了我们今天的重头戏，前面说了这么多背景和理论知识，接下来让我们谈谈如何减少回流和重绘。</p>
<h3 id="最小化重绘和重排"><a href="#最小化重绘和重排" class="headerlink" title="最小化重绘和重排"></a>最小化重绘和重排</h3><p>由于重绘和重排可能代价比较昂贵，因此最好就是可以减少它的发生次数。为了减少发生次数，我们可以合并多次对DOM和样式的修改，然后一次处理掉。考虑这个例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const el = document.getElementById(&#x27;test&#x27;);</span><br><span class="line">el.style.padding = &#x27;5px&#x27;;</span><br><span class="line">el.style.borderLeft = &#x27;1px&#x27;;</span><br><span class="line">el.style.borderRight = &#x27;2px&#x27;;</span><br></pre></td></tr></table></figure>

<p>例子中，有三个样式属性被修改了，每一个都会影响元素的几何结构，引起回流。当然，大部分现代浏览器都对其做了优化，因此，只会触发一次重排。但是如果在旧版的浏览器或者在上面代码执行的时候，有其他代码访问了布局信息(上文中的会触发回流的布局信息)，那么就会导致三次重排。</p>
<p>因此，我们可以合并所有的改变然后依次处理，比如我们可以采取以下的方式：</p>
<ul>
<li><p>使用cssText</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const el = document.getElementById(&#x27;test&#x27;);</span><br><span class="line">el.style.cssText += &#x27;border-left: 1px; border-right: 2px; padding: 5px;&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改CSS的class</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const el = document.getElementById(&#x27;test&#x27;);</span><br><span class="line">el.className += &#x27; active&#x27;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="批量修改DOM"><a href="#批量修改DOM" class="headerlink" title="批量修改DOM"></a>批量修改DOM</h3><p>当我们需要对DOM对一系列修改的时候，可以通过以下步骤减少回流重绘次数：</p>
<ol>
<li>使元素脱离文档流</li>
<li>对其进行多次修改</li>
<li>将元素带回到文档中。</li>
</ol>
<p>该过程的第一步和第三步可能会引起回流，但是经过第一步之后，对DOM的所有修改都不会引起回流，因为它已经不在渲染树了。</p>
<p>有三种方式可以让DOM脱离文档流：</p>
<ul>
<li>隐藏元素，应用修改，重新显示</li>
<li>使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。</li>
<li>将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。</li>
</ul>
<p>考虑我们要执行一段批量插入节点的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function appendDataToElement(appendToElement, data) &#123;</span><br><span class="line">    let li;</span><br><span class="line">    for (let i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">        li = document.createElement(&#x27;li&#x27;);</span><br><span class="line">        li.textContent = &#x27;text&#x27;;</span><br><span class="line">        appendToElement.appendChild(li);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const ul = document.getElementById(&#x27;list&#x27;);</span><br><span class="line">appendDataToElement(ul, data);</span><br></pre></td></tr></table></figure>

<p>如果我们直接这样执行的话，由于每次循环都会插入一个新的节点，会导致浏览器回流一次。</p>
<p>我们可以使用这三种方式进行优化:</p>
<p><strong>隐藏元素，应用修改，重新显示</strong></p>
<p>这个会在展示和隐藏节点的时候，产生两次重绘</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function appendDataToElement(appendToElement, data) &#123;</span><br><span class="line">    let li;</span><br><span class="line">    for (let i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">        li = document.createElement(&#x27;li&#x27;);</span><br><span class="line">        li.textContent = &#x27;text&#x27;;</span><br><span class="line">        appendToElement.appendChild(li);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const ul = document.getElementById(&#x27;list&#x27;);</span><br><span class="line">ul.style.display = &#x27;none&#x27;;</span><br><span class="line">appendDataToElement(ul, data);</span><br><span class="line">ul.style.display = &#x27;block&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const ul = document.getElementById(&#x27;list&#x27;);</span><br><span class="line">const fragment = document.createDocumentFragment();</span><br><span class="line">appendDataToElement(fragment, data);</span><br><span class="line">ul.appendChild(fragment);</span><br></pre></td></tr></table></figure>

<p><strong>将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const ul = document.getElementById(&#x27;list&#x27;);</span><br><span class="line">const clone = ul.cloneNode(true);</span><br><span class="line">appendDataToElement(clone, data);</span><br><span class="line">ul.parentNode.replaceChild(clone, ul);</span><br></pre></td></tr></table></figure>

<p>对于上述那种情况，我写了一个<a href="https://chenjigeng.github.io/example/share/%E9%81%BF%E5%85%8D%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9DOM.html">demo</a>来测试修改前和修改后的性能。然而实验结果不是很理想。</p>
<p><strong>原因：原因其实上面也说过了，浏览器会使用队列来储存多次修改，进行优化，所以对这个优化方案，我们其实不用优先考虑。</strong></p>
<h3 id="避免触发同步布局事件"><a href="#避免触发同步布局事件" class="headerlink" title="避免触发同步布局事件"></a>避免触发同步布局事件</h3><p>上文我们说过，当我们访问元素的一些属性的时候，会导致浏览器强制清空队列，进行强制同步布局。举个例子，比如说我们想将一个p标签数组的宽度赋值为一个元素的宽度，我们可能写出这样的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function initP() &#123;</span><br><span class="line">    for (let i = 0; i &lt; paragraphs.length; i++) &#123;</span><br><span class="line">        paragraphs[i].style.width = box.offsetWidth + &#x27;px&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码看上去是没有什么问题，可是其实会造成很大的性能问题。在每次循环的时候，都读取了box的一个offsetWidth属性值，然后利用它来更新p标签的width属性。这就导致了每一次循环的时候，浏览器都必须先使上一次循环中的样式更新操作生效，才能响应本次循环的样式读取操作。每一次循环都会强制浏览器刷新队列。我们可以优化为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const width = box.offsetWidth;</span><br><span class="line">function initP() &#123;</span><br><span class="line">    for (let i = 0; i &lt; paragraphs.length; i++) &#123;</span><br><span class="line">        paragraphs[i].style.width = width + &#x27;px&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，我也写了个<a href="https://chenjigeng.github.io/example/share/%E9%81%BF%E5%85%8D%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98/%E9%81%BF%E5%85%8D%E5%BF%AB%E9%80%9F%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%B8%83%E5%B1%80.html">demo</a>来比较两者的性能差异。你可以自己点开这个demo体验下。这个对比差距就比较明显。</p>
<h3 id="对于复杂动画效果-使用绝对定位让其脱离文档流"><a href="#对于复杂动画效果-使用绝对定位让其脱离文档流" class="headerlink" title="对于复杂动画效果,使用绝对定位让其脱离文档流"></a>对于复杂动画效果,使用绝对定位让其脱离文档流</h3><p>对于复杂动画效果，由于会经常的引起回流重绘，因此，我们可以使用绝对定位，让它脱离文档流。否则会引起父元素以及后续元素频繁的回流。这个我们就直接上个<a href="https://chenjigeng.github.io/example/share/%E9%81%BF%E5%85%8D%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98/%E5%B0%86%E5%A4%8D%E6%9D%82%E5%8A%A8%E7%94%BB%E6%B5%AE%E5%8A%A8%E5%8C%96.html">例子</a>。</p>
<p>打开这个例子后，我们可以打开控制台，控制台上会输出当前的帧数(虽然不准)。</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98%E4%B8%8E%E4%BC%98%E5%8C%96/1460000017329986.png" alt="image-20181210223750055"></p>
<p>从上图中，我们可以看到，帧数一直都没到60。这个时候，只要我们点击一下那个按钮，把这个元素设置为绝对定位，帧数就可以稳定60。</p>
<h3 id="css3硬件加速（GPU加速）"><a href="#css3硬件加速（GPU加速）" class="headerlink" title="css3硬件加速（GPU加速）"></a>css3硬件加速（GPU加速）</h3><p>比起考虑如何减少回流重绘，我们更期望的是，根本不要回流重绘。这个时候，css3硬件加速就闪亮登场啦！！</p>
<p><strong>划重点：使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。</strong></p>
<p>本篇文章只讨论如何使用，暂不考虑其原理，之后有空会另外开篇文章说明。</p>
<h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><p>常见的触发硬件加速的css属性：</p>
<ul>
<li>transform</li>
<li>opacity</li>
<li>filters</li>
<li>Will-change</li>
</ul>
<h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p>我们可以先看个<a href="https://chenjigeng.github.io/example/share/%E5%AF%B9%E6%AF%94gpu%E5%8A%A0%E9%80%9F/gpu%E5%8A%A0%E9%80%9F-transform.html">例子</a>。我通过使用chrome的Performance捕获了一段时间的回流重绘情况，实际结果如下图：</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98%E4%B8%8E%E4%BC%98%E5%8C%96/1460000017329987.png" alt="image-20181210225609533"></p>
<p>从图中我们可以看出，在动画进行的时候，没有发生任何的回流重绘。如果感兴趣你也可以自己做下实验。</p>
<h4 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h4><ul>
<li>使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘</li>
<li>对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。</li>
</ul>
<h4 id="css3硬件加速的坑"><a href="#css3硬件加速的坑" class="headerlink" title="css3硬件加速的坑"></a>css3硬件加速的坑</h4><ul>
<li>如果你为太多元素使用css3硬件加速，会导致内存占用较大，会有性能问题。</li>
<li>在GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要讲了浏览器的渲染过程、浏览器的优化机制以及如何减少甚至避免回流和重绘，希望可以帮助大家更好的理解回流重绘。</p>
<blockquote>
<p>转载自 <a href="https://segmentfault.com/a/1190000017329980">https://segmentfault.com/a/1190000017329980</a></p>
</blockquote>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>浏览器渲染</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>阻塞关系</title>
    <url>/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E9%98%BB%E5%A1%9E%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>&#x2F;&#x2F; TODO<br>半成品 半成品 先别看了<br>下面结合实例代码探索html、js、css的阻塞关系,浏览器chrome 版本92</p>
<ul>
<li>html监听了DCL和load事件，拥有两个具有文字内容(可以观测到FCP、LCP)的div</li>
<li>js css 带有sleep3000-的前缀，表示服务器会阻塞3000毫秒后返回，方便观测</li>
</ul>
<blockquote>
<p>js css并存 测试变量太多3*4&#x3D;12种情况，感觉意义不大、、</p>
</blockquote>
<p>首先是html内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line"> &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line"> &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">  document.addEventListener(&#x27;DOMContentLoaded&#x27;,function()&#123;</span><br><span class="line">   console.log(&#x27;DOMContentLoaded&#x27;);</span><br><span class="line">  &#125;);</span><br><span class="line">  window.addEventListener(&#x27;load&#x27;,function()&#123;</span><br><span class="line">   console.log(&#x27;load&#x27;);</span><br><span class="line">  &#125;);</span><br><span class="line"> &lt;/script&gt;</span><br><span class="line"> &lt;style&gt;</span><br><span class="line">  div &#123;</span><br><span class="line">   width: 100px;</span><br><span class="line">   height: 100px;</span><br><span class="line">   background: green;</span><br><span class="line">  &#125;</span><br><span class="line"> &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"> &lt;div&gt;的时光飞逝东莞市地方刮大风&lt;/div&gt;</span><br><span class="line"> &lt;div&gt;asfklasjf&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>css 将div背景设置为blue，html中为green</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">  background: blue!important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>js1 打印获取的div</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const div1 = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">console.log(div1);</span><br></pre></td></tr></table></figure>

<p>Js2 执行复杂操作后 打印div</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [];</span><br><span class="line">for (let i = 0; i &lt; 10000000; i++) &#123;</span><br><span class="line">  arr.push(i);</span><br><span class="line">  arr.splice(i % 3, i % 7, i % 5);</span><br><span class="line">&#125;</span><br><span class="line">const div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">console.log(div);</span><br></pre></td></tr></table></figure>

<h3 id="首先仅测试css"><a href="#首先仅测试css" class="headerlink" title="首先仅测试css"></a>首先仅测试css</h3><h4 id="外链css放在head内"><a href="#外链css放在head内" class="headerlink" title="外链css放在head内"></a>外链css放在head内</h4><p>图上dcl只是被挡住了，几乎是立刻执行，然后等待css下载完成后，触发load时间，然后进行fp、fcp、lcp</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E9%98%BB%E5%A1%9E%E5%85%B3%E7%B3%BB/image-20210812171549248.png" alt="image-20210812171549248"></p>
<p>页面上前五秒并未显示div，但是此时在dom中已经存在div，css并不能阻塞dom的解析，五秒后显示蓝色div</p>
<p>![Kapture 2021-08-12 at 17.34.48](assets&#x2F;阻塞关系&#x2F;Kapture 2021-08-12 at 17.34.48.gif)</p>
<h4 id="外链css放在body最前部"><a href="#外链css放在body最前部" class="headerlink" title="外链css放在body最前部"></a>外链css放在body最前部</h4><p>放在body最前部，浏览器会等待css下载完毕后，才会触发dcl及一系列绘制</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E9%98%BB%E5%A1%9E%E5%85%B3%E7%B3%BB/image-20210812174254853.png" alt="image-20210812174254853"></p>
<p>很明显，放在body前的外链css阻塞的dom的解析，当css下载完毕后，触发了一系列关键事件</p>
<p>![Kapture 2021-08-12 at 17.46.42](assets&#x2F;阻塞关系&#x2F;Kapture 2021-08-12 at 17.46.42.gif)</p>
<h4 id="外链css放在body内，两个div之间"><a href="#外链css放在body内，两个div之间" class="headerlink" title="外链css放在body内，两个div之间"></a>外链css放在body内，两个div之间</h4><p>浏览器会先绘制并渲染css之前的div，待css下载完毕后，会渲染另一个div，并显示蓝色背景，触发dcl及load</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E9%98%BB%E5%A1%9E%E5%85%B3%E7%B3%BB/image-20210812175156074.png" alt="image-20210812175156074"></p>
<p>![Kapture 2021-08-12 at 17.55.14](assets&#x2F;阻塞关系&#x2F;Kapture 2021-08-12 at 17.55.14.gif)</p>
<h4 id="css外链放在body内最后"><a href="#css外链放在body内最后" class="headerlink" title="css外链放在body内最后"></a>css外链放在body内最后</h4><p>performance和放在div之间一样，实际页面表现有一些差异</p>
<p>![Kapture 2021-08-12 at 18.03.58](assets&#x2F;阻塞关系&#x2F;Kapture 2021-08-12 at 18.03.58.gif)</p>
<h4 id="外链css放在body之后"><a href="#外链css放在body之后" class="headerlink" title="外链css放在body之后"></a>外链css放在body之后</h4><p>会被浏览器修复到body内最后</p>
<h3 id="仅测试js"><a href="#仅测试js" class="headerlink" title="仅测试js"></a>仅测试js</h3><h4 id="js放在head内、body头部"><a href="#js放在head内、body头部" class="headerlink" title="js放在head内、body头部"></a>js放在head内、body头部</h4><p>很明显，js的下载和解析（执行）都会阻塞dom元素的解析和渲染，直到js下载解析之后，才会继续解析渲染dom，触发dcl、fp等等</p>
<h4 id=""><a href="#" class="headerlink" title=""></a><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E9%98%BB%E5%A1%9E%E5%85%B3%E7%B3%BB/image-20210813140650543.png" alt="image-20210813140650543"></h4><p>![Kapture 2021-08-12 at 21.36.22](assets&#x2F;阻塞关系&#x2F;Kapture 2021-08-12 at 21.36.22.gif)</p>
<h4 id="js放在div之间"><a href="#js放在div之间" class="headerlink" title="js放在div之间"></a>js放在div之间</h4><p>js会阻塞js之后的dom解析和渲染，对于js之前的dom会正常解析渲染，并触发fp等，但是dcl需要等待js下载解析（执行）完成后</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E9%98%BB%E5%A1%9E%E5%85%B3%E7%B3%BB/image-20210813140535630.png" alt="image-20210813140535630"></p>
<p>![Kapture 2021-08-12 at 21.41.08](assets&#x2F;阻塞关系&#x2F;Kapture 2021-08-12 at 21.41.08.gif)</p>
<h4 id="js放body尾部"><a href="#js放body尾部" class="headerlink" title="js放body尾部"></a>js放body尾部</h4><p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E9%98%BB%E5%A1%9E%E5%85%B3%E7%B3%BB/image-20210813141225951.png" alt="image-20210813141225951"></p>
<p>![Kapture 2021-08-12 at 21.46.00](assets&#x2F;阻塞关系&#x2F;Kapture 2021-08-12 at 21.46.00.gif)</p>
<h3 id="js、css并存"><a href="#js、css并存" class="headerlink" title="js、css并存"></a>js、css并存</h3><h4 id="css处于head"><a href="#css处于head" class="headerlink" title="css处于head"></a>css处于head</h4><h5 id="js处于dom前"><a href="#js处于dom前" class="headerlink" title="js处于dom前"></a>js处于dom前</h5><p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E9%98%BB%E5%A1%9E%E5%85%B3%E7%B3%BB/image-20210813152617775.png" alt="image-20210813152617775"></p>
<h5 id="js处于dom中"><a href="#js处于dom中" class="headerlink" title="js处于dom中"></a>js处于dom中</h5><p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E9%98%BB%E5%A1%9E%E5%85%B3%E7%B3%BB/image-20210813152844462.png" alt="image-20210813152844462"></p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E9%98%BB%E5%A1%9E%E5%85%B3%E7%B3%BB/image-20210813152950225.png" alt="image-20210813152950225"></p>
<h5 id="js处于dom后"><a href="#js处于dom后" class="headerlink" title="js处于dom后"></a>js处于dom后</h5><p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E9%98%BB%E5%A1%9E%E5%85%B3%E7%B3%BB/image-20210813153113295.png" alt="image-20210813153113295"></p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E9%98%BB%E5%A1%9E%E5%85%B3%E7%B3%BB/image-20210813153206303.png" alt="image-20210813153206303"></p>
<h2 id="css和js文件对html的阻塞"><a href="#css和js文件对html的阻塞" class="headerlink" title="css和js文件对html的阻塞"></a>css和js文件对html的阻塞</h2><ul>
<li><p><code>CSS</code> 不会（仅限head内）阻塞 <code>DOM</code> 的解析(document存在)，但会阻塞其后的 <code>DOM</code> 渲染。</p>
</li>
<li><p>在js前的css会阻塞js的解析（不会阻止下载），继而阻止dom的解析和渲染</p>
</li>
<li><p><code>JS</code> 阻塞 <code>DOM</code> 解析，但浏览器会”偷看”<code>DOM</code>，预先下载相关资源。</p>
</li>
</ul>
<h2 id="DCL的结论"><a href="#DCL的结论" class="headerlink" title="DCL的结论"></a>DCL的结论</h2><p>除了放在head里的css，html中的js、css都会阻塞dcl事件</p>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>阻塞关系</tag>
      </tags>
  </entry>
  <entry>
    <title>prefetch和preload</title>
    <url>/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/prefetch%E5%92%8Cpreload/</url>
    <content><![CDATA[<p><a href="https://juejin.cn/post/6893681741240909832">转载自</a></p>
<p><strong>使用 Preload&amp;Prefetch 优化前端页面的资源加载</strong></p>
<p>对于前端页面来说，静态资源的加载对页面性能起着至关重要的作用。本文将介绍浏览器提供的两个资源指令-preload&#x2F;prefetch，它们能够辅助浏览器优化资源加载的顺序和时机，提升页面性能。</p>
<h1 id="一、从一个实例开始"><a href="#一、从一个实例开始" class="headerlink" title="一、从一个实例开始"></a>一、从一个实例开始</h1><p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/prefetch%E5%92%8Cpreload/2542ea0956b9426f95e265bace99c6bd~tplv-k3u1fbpfcp-watermark.gif" alt="img"></p>
<p>如上图所示，我们开发了一个简单的收银台，支付过程中可以展开优惠券列表选择相应的券。从动图可以看到，列表第一次展开时，优惠券背景有一个逐渐显示的过程，体验上不是很好。</p>
<p>问题的原因也很明显，由于背景使用了视觉特意设计的图片，优惠券列表展开时需要去加载图片，背景渐显的过程实际上就是图片加载的过程；当网速慢的时候，这个问题会更加明显。那么，怎样解决这个问题呢？</p>
<p>仔细分析一下，我们会发现问题的原因在于背景图的加载时机太晚。</p>
<p>如果能在优惠券列表渲染前加载好背景图，这个问题就不会出现。从这个思路出发，我们可能想到以下两个方案：</p>
<ol>
<li>使用内联图片，也就是将图片转换为base64编码的data-url。这种方式，其实是将图片的信息集成到css文件中，避免了图片资源的单独加载。但图片内联会增加css文件的大小，增加首屏渲染的时间。</li>
<li>使用js代码对图片进行预加载</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">preloadImage() &#123;</span><br><span class="line">    const imgList = [</span><br><span class="line">        require(&#x27;@/assets/imgs/error.png&#x27;),</span><br><span class="line">        require(&#x27;@/assets/imgs/ticket_bg.png&#x27;)</span><br><span class="line">    ];</span><br><span class="line">    for (let i = 0; i &lt; imgList.length; i++) &#123;</span><br><span class="line">        const newIMG = new Image();</span><br><span class="line">        newIMG.src = imgList[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/https:/juejin.cn/post/6893681741240909832" alt="img"><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/https:/juejin.cn/post/6893681741240909832" alt="点击并拖拽以移动">这种方案主要是利用浏览器的缓存机制，由js代码在特定时机提前加载相应图片，优惠券列表渲染时就可以直接从缓存获取。不过，这种方案增加了额外的代码，需要自己控制好加载时机，并且将图片的url硬编码在了逻辑中。</p>
<p>可以看出，以上两种方案能够解决我们的问题，但都存在一些缺点。</p>
<p>那么，有没有更好的解决方案呢？答案是prefetch-一种由浏览器原生提供的预加载方案。</p>
<h1 id="二、什么是prefetch？"><a href="#二、什么是prefetch？" class="headerlink" title="二、什么是prefetch？"></a>二、什么是prefetch？</h1><p>prefetch(链接预取）是一种浏览器机制，其利用浏览器空闲时间来下载或预取用户在不久的将来可能访问的文档。网页向浏览器提供一组预取提示，并在浏览器完成当前页面的加载后开始静默地拉取指定的文档并将其存储在缓存中。当用户访问其中一个预取文档时，便可以快速的从浏览器缓存中得到。–MDN</p>
<p>具体来说，浏览器通过标签来实现预加载。</p>
<p>其中rel&#x3D;”prefetch”被称为Resource-Hints（资源提示），也就是辅助浏览器进行资源优化的指令。</p>
<p>类似的指令还有rel&#x3D;”preload”，我们会在后文提及。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;link rel=&quot;prefetch&quot; href=&quot;static/img/ticket_bg.a5bb7c33.png&quot;&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>查看现在优惠券列表的加载效果。</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/prefetch%E5%92%8Cpreload/16baed9624c34053875a4202f43f0914~tplv-k3u1fbpfcp-watermark.gif" alt="img"></p>
<p>果然，成功达成了我们期望的效果。那么浏览器是如何做的呢？我们打开Chrome的Network面板一探究竟：</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/prefetch%E5%92%8Cpreload/76468b67df364b48aed4150c90e19276~tplv-k3u1fbpfcp-watermark.gif" alt="img"></p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/prefetch%E5%92%8Cpreload/0172b6234ef2445fb82c9bb230d0768b~tplv-k3u1fbpfcp-watermark.gif" alt="img"></p>
<p>可以看到，在首屏的请求列表中已经出现了优惠券背景图ticket_bg.png的加载请求，请求本身看起来和普通请求没什么不同；展开优惠券列表后，network中增加了一次新的ticket_bg.png访问请求，我们很快发现，这个请求的status虽然也是200，但有一个特殊的标记—prefetch cache，表明这次请求的资源来自prefetch缓存。这个表现验证了上文中prefetch的定义，即浏览器在空闲时间预先加载资源，真正使用时直接从浏览器缓存中快速获取。</p>
<h1 id="三、Preload"><a href="#三、Preload" class="headerlink" title="三、Preload"></a>三、Preload</h1><p>从上面的案例，我们体会到了浏览器预加载资源的强大能力。实际上，预加载是一个广义的概念，prefetch只是具体实现方式之一，本节我们介绍下另外一种预加载方式preload。上文我们提到，preload与prefetch同属于浏览器的Resource-Hints，用于辅助浏览器进行资源优化。为了对两者进行区分，prefetch通常翻译为预提取，preload则翻译为预加载。</p>
<p>元素的rel属性的属性值preload能够让你在你的HTML页面中元素内部书写一些声明式的资源获取请求，可以指明哪些资源是在页面加载完成后即刻需要的。对于这种即刻需要的资源，你可能希望在页面加载的生命周期的早期阶段就开始获取，在浏览器的主渲染机制介入前就进行预加载。这一机制使得资源可以更早的得到加载并可用，且更不易阻塞页面的初步渲染，进而提升性能。</p>
<p>简单来说，就是通过标签显式声明一个高优先级资源，强制浏览器提前请求资源，同时不阻塞文档正常onload。我们同样用一个实际案例进行详细介绍。</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/prefetch%E5%92%8Cpreload/80e08544d9f34106b69503b547d62a52~tplv-k3u1fbpfcp-watermark.gif" alt="img"></p>
<p>上图是我们开发的另外一个收银台，出于本地化的考虑，设计上使用了自定义字体。开发完成后我们发现，页面首次加载时文字会出现短暂的字体样式闪动（FOUT，Flash of Unstyled Text），在网络情况较差时比较明显（如动图所示）。究其原因，是字体文件由css引入，在css解析后才会进行加载，加载完成之前浏览器只能使用降级字体。也就是说，字体文件加载的时机太迟，需要告诉浏览器提前进行加载，这恰恰是preload的用武之地。</p>
<p>我们在入口html文件head加入preload标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;link rel=&quot;preload&quot; as=&quot;font&quot; href=&quot;&lt;%= require(&#x27;/assets/fonts/AvenirNextLTPro-Demi.otf&#x27;) %&gt;&quot; crossorigin&gt;</span><br><span class="line">    &lt;link rel=&quot;preload&quot; as=&quot;font&quot; href=&quot;&lt;%= require(&#x27;/assets/fonts/AvenirNextLTPro-Regular.otf&#x27;) %&gt;&quot; crossorigin&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/https:/juejin.cn/post/6893681741240909832" alt="img"><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/https:/juejin.cn/post/6893681741240909832" alt="点击并拖拽以移动">再次查看页面首次加载的效果：</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/prefetch%E5%92%8Cpreload/186fdb0cbe1044e4a27a5223387354e8~tplv-k3u1fbpfcp-watermark.gif" alt="img"></p>
<p>字体样式闪动的现象没有了！我们对比下使用preload前后的network面板。</p>
<p>使用前：</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/prefetch%E5%92%8Cpreload/4b5ae98d084d455fa61c58ef263fa95e~tplv-k3u1fbpfcp-watermark.gif" alt="img"></p>
<p>使用后：</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/prefetch%E5%92%8Cpreload/23d15957b62e45008f6af71fd4fea271~tplv-k3u1fbpfcp-watermark.gif" alt="img"></p>
<p>可以发现字体文件的加载时机明显提前了，在浏览器接收到html后很快就进行了加载。</p>
<blockquote>
<p>注意：preload link必须设置as属性来声明资源的类型（font&#x2F;image&#x2F;style&#x2F;script等)，否则浏览器可能无法正确加载资源。</p>
</blockquote>
<h1 id="四、Preload-和-Prefetch-的具体实践"><a href="#四、Preload-和-Prefetch-的具体实践" class="headerlink" title="四、Preload 和 Prefetch 的具体实践"></a>四、Preload 和 Prefetch 的具体实践</h1><h2 id="1、preload-webpack-plugin"><a href="#1、preload-webpack-plugin" class="headerlink" title="1、preload-webpack-plugin"></a>1、preload-webpack-plugin</h2><p>前文中我们举的两个例子，都是在入口html手动添加相关代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;link rel=&quot;prefetch&quot; href=&quot;static/img/ticket_bg.a5bb7c33.png&quot;&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">复制代码</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;link rel=&quot;preload&quot; as=&quot;font&quot; href=&quot;&lt;%= require(&#x27;/assets/fonts/AvenirNextLTPro-Demi.otf&#x27;) %&gt;&quot; crossorigin&gt;</span><br><span class="line">    &lt;link rel=&quot;preload&quot; as=&quot;font&quot; href=&quot;&lt;%= require(&#x27;/assets/fonts/AvenirNextLTPro-Regular.otf&#x27;) %&gt;&quot; crossorigin&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/https:/juejin.cn/post/6893681741240909832" alt="img"><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/https:/juejin.cn/post/6893681741240909832" alt="点击并拖拽以移动">这显然不够方便，而且将资源路径硬编码在了页面中（实际上，ticket_bg.a5bb7c33.png后缀中的hash是构建过程自动生成的，所以硬编码的方式很多场景下本身就行不通）。webpack插件preload-webpack-plugin可以帮助我们将该过程自动化，结合htmlWebpackPlugin在构建过程中插入link标签。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const PreloadWebpackPlugin = require(&#x27;preload-webpack-plugin&#x27;);</span><br><span class="line">...</span><br><span class="line">plugins: [</span><br><span class="line">  new PreloadWebpackPlugin(&#123;</span><br><span class="line">    rel: &#x27;preload&#x27;，</span><br><span class="line">    as(entry) &#123;  //资源类型</span><br><span class="line">      if (/\.css$/.test(entry)) return &#x27;style&#x27;;</span><br><span class="line">      if (/\.woff$/.test(entry)) return &#x27;font&#x27;;</span><br><span class="line">      if (/\.png$/.test(entry)) return &#x27;image&#x27;;</span><br><span class="line">      return &#x27;script&#x27;;</span><br><span class="line">    &#125;,</span><br><span class="line">    include: &#x27;asyncChunks&#x27;, // preload模块范围，还可取值&#x27;initial&#x27;|&#x27;allChunks&#x27;|&#x27;allAssets&#x27;,</span><br><span class="line">    fileBlacklist: [/\.svg/] // 资源黑名单</span><br><span class="line">    fileWhitelist: [/\.script/] // 资源白名单</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/https:/juejin.cn/post/6893681741240909832" alt="img"><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/https:/juejin.cn/post/6893681741240909832" alt="点击并拖拽以移动">PreloadWebpackPlugin配置总体上比较简单，需要注意的是include属性。该属性默认取值’asyncChunks’，表示仅预加载异步js模块；如果需要预加载图片、字体等资源，则需要将其设置为’allAssets’，表示处理所有类型的资源。</p>
<p>但一般情况下我们不希望把预加载范围扩得太大，所以需要通过fileBlacklist或fileWhitelist进行控制。</p>
<p>对于异步加载的模块，还可以通过webpack内置的&#x2F;<em>webpackPreload: true</em>&#x2F;标记进行更细粒度的控制。</p>
<p>以下面的代码为例，webpack会生成标签添加到html页面头部。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import(/* webpackPreload: true */ &#x27;AsyncModule&#x27;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：prefetch的配置与preload类似，但无需对as属性进行设置。</p>
</blockquote>
<h2 id="2、使用场景"><a href="#2、使用场景" class="headerlink" title="2、使用场景"></a>2、使用场景</h2><p>从前文的介绍可知，preload的设计初衷是为了尽早加载首屏需要的关键资源，从而提升页面渲染性能。</p>
<p>目前浏览器基本上都具备预测解析能力，可以提前解析入口html中外链的资源，因此入口脚本文件、样式文件等不需要特意进行preload。</p>
<p>但是一些隐藏在CSS和JavaScript中的资源，如字体文件，本身是首屏关键资源，但当css文件解析之后才会被浏览器加载。这种场景适合使用preload进行声明，尽早进行资源加载，避免页面渲染延迟。</p>
<p>与preload不同，prefetch声明的是将来可能访问的资源，因此适合对异步加载的模块、可能跳转到的其他路由页面进行资源缓存；对于一些将来大概率会访问的资源，如上文案例中优惠券列表的背景图、常见的加载失败icon等，也较为适用。</p>
<h2 id="3、最佳实践"><a href="#3、最佳实践" class="headerlink" title="3、最佳实践"></a>3、最佳实践</h2><p>基于上面对使用场景的分享，我们可以总结出一个比较通用的最佳实践：</p>
<blockquote>
<ul>
<li>大部分场景下无需特意使用preload</li>
<li>类似字体文件这种隐藏在脚本、样式中的首屏关键资源，建议使用preload</li>
<li>异步加载的模块（典型的如单页系统中的非首页）建议使用prefetch</li>
<li>大概率即将被访问到的资源可以使用prefetch提升性能和体验</li>
</ul>
</blockquote>
<h2 id="4、vue-cli3的默认配置"><a href="#4、vue-cli3的默认配置" class="headerlink" title="4、vue-cli3的默认配置"></a>4、vue-cli3的默认配置</h2><ul>
<li><strong>preload</strong></li>
</ul>
<p>默认情况下，一个Vue CLI应用会为所有初始化渲染需要的文件自动生成preload提示。这些提示会被@vue&#x2F;preload-webpack-plugin注入，并且可以通过chainWebpack的config.plugin(‘preload’)进行修改和删除。</p>
<ul>
<li><strong>prefetch</strong></li>
</ul>
<p>默认情况下，一个Vue CLI应用会为所有作为async chunk生成的JavaScript文件(通过动态import()按需code splitting的产物)自动生成prefetch提示。这些提示会被@vue&#x2F;preload-webpack-plugin注入，并且可以通过chainWebpack的config.plugin(‘prefetch’)进行修改和删除。</p>
<h1 id="五、总结和踩坑"><a href="#五、总结和踩坑" class="headerlink" title="五、总结和踩坑"></a>五、总结和踩坑</h1><p>1、preload和prefetch的本质都是预加载，即先加载、后执行，加载与执行解耦。</p>
<p>2、preload和prefetch不会阻塞页面的onload。</p>
<p>3、preload用来声明当前页面的关键资源，强制浏览器尽快加载；而prefetch用来声明将来可能用到的资源，在浏览器空闲时进行加载。</p>
<p>4、不要滥用preload和prefetch，需要在合适的场景中使用。</p>
<p>5、preload的字体资源必须设置crossorigin属性，否则会导致重复加载。</p>
<p>原因是如果不指定crossorigin属性(即使同源)，浏览器会采用匿名模式的CORS去preload，导致两次请求无法共用缓存。</p>
<p>6、关于preload和prefetch资源的缓存，在Google开发者的一篇文章中是这样说明的：如果资源可以被缓存（比如说存在有效的cache-control和max-age），它被存储在HTTP缓存（也就是disk cache)中，可以被现在或将来的任务使用；如果资源不能被缓存在HTTP缓存中，作为代替，它被放在内存缓存中直到被使用。</p>
<p>然而我们在Chrome浏览器（版本号80）中进行测试，结果却并非如此。将服务器的缓存策略设置为no-store，观察下资源加载情况。</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/prefetch%E5%92%8Cpreload/4a85d488397e4b65abf13ec00760c1df~tplv-k3u1fbpfcp-watermark.gif" alt="img"></p>
<p>可以发现ticket_bg.png第二次加载并未从本地缓存获取，仍然是从服务器加载。因此，如果要使用prefetch，相应的资源必须做好合理的缓存控制。</p>
<p>7、没有合法https证书的站点无法使用prefetch，预提取的资源不会被缓存（实际使用过程中发现，原因未知）。</p>
<p>8、最后我们来看下preload和prefetch的浏览器兼容性。</p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/prefetch%E5%92%8Cpreload/f12f50cef0ce46f596cd1e4756ad23c6~tplv-k3u1fbpfcp-watermark.gif" alt="img"><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/prefetch%E5%92%8Cpreload/e13b12dbdb4e4499ba1d22788cd30b02~tplv-k3u1fbpfcp-watermark.gif" alt="img">可以看到，两者的兼容性目前都还不是太好。好在不支持preload和prefetch的浏览器会自动忽略它，因此可以将它们作为一种渐进增强功能，优化我们页面的资源加载，提升性能和用户体验。</p>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>prefetch</tag>
        <tag>preload</tag>
      </tags>
  </entry>
  <entry>
    <title>13 预加载和懒加载</title>
    <url>/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%87%92%E5%8A%A0%E8%BD%BD/%E6%87%92%E5%8A%A0%E8%BD%BD.png" alt="懒加载"></p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%87%92%E5%8A%A0%E8%BD%BD/%E9%A2%84%E5%8A%A0%E8%BD%BD.png" alt="预加载"></p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%87%92%E5%8A%A0%E8%BD%BD/%E9%A2%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F1.png" alt="预加载方式1"></p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%87%92%E5%8A%A0%E8%BD%BD/%E9%A2%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F2.png" alt="预加载方式2"></p>
<p><img src="/_posts/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/assets/%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%87%92%E5%8A%A0%E8%BD%BD/%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%A5%BD%E5%A4%84.png" alt="预加载好处"></p>
<p><a href="https://www.jianshu.com/p/61298b51a5fb">pre系列讲解</a></p>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>预加载</tag>
        <tag>懒加载</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 风格指南</title>
    <url>/javascript/JavaScript%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/</url>
    <content><![CDATA[<p>Original Repository: <a href="https://github.com/ryanmcdermott/clean-code-javascript">ryanmcdermott&#x2F;clean-code-javascript</a></p>
<h1 id="JavaScript-风格指南"><a href="#JavaScript-风格指南" class="headerlink" title="JavaScript 风格指南"></a>JavaScript 风格指南</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li><a href="#%E4%BB%8B%E7%BB%8D">介绍</a></li>
<li><a href="#%E5%8F%98%E9%87%8F">变量</a></li>
<li><a href="#%E5%87%BD%E6%95%B0">函数</a></li>
<li><a href="#objects-and-data-structures">对象和数据结构</a></li>
<li><a href="#%E7%B1%BB">类</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95">测试</a></li>
<li><a href="#%E5%B9%B6%E5%8F%91">并发</a></li>
<li><a href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">错误处理</a></li>
<li><a href="#%E6%A0%BC%E5%BC%8F%E5%8C%96">格式化</a></li>
<li><a href="#%E6%B3%A8%E9%87%8A">注释</a></li>
</ol>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://github.com/ryanmcdermott">作者</a>根据 Robert C. Martin <a href="https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882"><em>《代码整洁之道》</em></a>总结了适用于 JavaScript 的软件工程原则<a href="https://github.com/ryanmcdermott/clean-code-javascript">《Clean Code JavaScript》</a>。</p>
<p>本文是对其的翻译。</p>
<p>不必严格遵守本文的所有原则，有时少遵守一些效果可能会更好，具体应根据实际情况决定。这是根据《代码整洁之道》作者多年经验整理的代码优化建议，但也仅仅只是一份建议。</p>
<p>软件工程已经发展了 50 多年，至今仍在不断前进。现在，把这些原则当作试金石，尝试将他们作为团队代码质量考核的标准之一吧。</p>
<p>最后你需要知道的是，这些东西不会让你立刻变成一个优秀的工程师，长期奉行他们也并不意味着你能够高枕无忧不再犯错。千里之行，始于足下。我们需要时常和同行们进行代码评审，不断优化自己的代码。不要惧怕改善代码质量所需付出的努力，加油。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h2><h3 id="使用有意义，可读性好的变量名"><a href="#使用有意义，可读性好的变量名" class="headerlink" title="使用有意义，可读性好的变量名"></a>使用有意义，可读性好的变量名</h3><p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> yyyymmdstr = <span class="title function_">moment</span>().<span class="title function_">format</span>(<span class="string">&#x27;YYYY/MM/DD&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> yearMonthDay = <span class="title function_">moment</span>().<span class="title function_">format</span>(<span class="string">&#x27;YYYY/MM/DD&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="使用-ES6-的-const-定义常量"><a href="#使用-ES6-的-const-定义常量" class="headerlink" title="使用 ES6 的 const 定义常量"></a>使用 ES6 的 const 定义常量</h3><p>反例中使用”var”定义的”常量”是可变的。</p>
<p>在声明一个常量时，该常量在整个程序中都应该是不可变的。</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable constant_">FIRST_US_PRESIDENT</span> = <span class="string">&quot;George Washington&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">FIRST_US_PRESIDENT</span> = <span class="string">&quot;George Washington&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="对功能类似的变量名采用统一的命名风格"><a href="#对功能类似的变量名采用统一的命名风格" class="headerlink" title="对功能类似的变量名采用统一的命名风格"></a>对功能类似的变量名采用统一的命名风格</h3><p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getUserInfo</span>();</span><br><span class="line"><span class="title function_">getClientData</span>();</span><br><span class="line"><span class="title function_">getCustomerRecord</span>();</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getUser</span>();</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="使用易于检索名称"><a href="#使用易于检索名称" class="headerlink" title="使用易于检索名称"></a>使用易于检索名称</h3><p>我们需要阅读的代码远比自己写的要多，使代码拥有良好的可读性且易于检索非常重要。阅读变量名晦涩难懂的代码对读者来说是一种相当糟糕的体验。<br>让你的变量名易于检索。</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 525600 是什么?</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">525600</span>; i++) &#123;</span><br><span class="line">  <span class="title function_">runCronJob</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Declare them as capitalized `var` globals.</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">MINUTES_IN_A_YEAR</span> = <span class="number">525600</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="variable constant_">MINUTES_IN_A_YEAR</span>; i++) &#123;</span><br><span class="line">  <span class="title function_">runCronJob</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="使用说明变量-即有意义的变量名"><a href="#使用说明变量-即有意义的变量名" class="headerlink" title="使用说明变量(即有意义的变量名)"></a>使用说明变量(即有意义的变量名)</h3><p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cityStateRegex = <span class="regexp">/^(.+)[,\\s]+(.+?)\s*(\d&#123;5&#125;)?$/</span>;</span><br><span class="line"><span class="title function_">saveCityState</span>(cityStateRegex.<span class="title function_">match</span>(cityStateRegex)[<span class="number">1</span>], cityStateRegex.<span class="title function_">match</span>(cityStateRegex)[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">ADDRESS</span> = <span class="string">&#x27;One Infinite Loop, Cupertino 95014&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cityStateRegex = <span class="regexp">/^(.+)[,\\s]+(.+?)\s*(\d&#123;5&#125;)?$/</span>;</span><br><span class="line"><span class="keyword">var</span> match = <span class="variable constant_">ADDRESS</span>.<span class="title function_">match</span>(cityStateRegex)</span><br><span class="line"><span class="keyword">var</span> city = match[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> state = match[<span class="number">2</span>];</span><br><span class="line"><span class="title function_">saveCityState</span>(city, state);</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="不要绕太多的弯子"><a href="#不要绕太多的弯子" class="headerlink" title="不要绕太多的弯子"></a>不要绕太多的弯子</h3><p>显式优于隐式。</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> locations = [<span class="string">&#x27;Austin&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;San Francisco&#x27;</span>];</span><br><span class="line">locations.<span class="title function_">forEach</span>(<span class="function">(<span class="params">l</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">doStuff</span>();</span><br><span class="line">  <span class="title function_">doSomeOtherStuff</span>();</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// l是什么？</span></span><br><span class="line">  <span class="title function_">dispatch</span>(l);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> locations = [<span class="string">&#x27;Austin&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;San Francisco&#x27;</span>];</span><br><span class="line">locations.<span class="title function_">forEach</span>(<span class="function">(<span class="params">location</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">doStuff</span>();</span><br><span class="line">  <span class="title function_">doSomeOtherStuff</span>();</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  <span class="title function_">dispatch</span>(location);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="避免重复的描述"><a href="#避免重复的描述" class="headerlink" title="避免重复的描述"></a>避免重复的描述</h3><p>当类&#x2F;对象名已经有意义时，对其变量进行命名不需要再次重复。</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Car</span> = &#123;</span><br><span class="line">  <span class="attr">carMake</span>: <span class="string">&#x27;Honda&#x27;</span>,</span><br><span class="line">  <span class="attr">carModel</span>: <span class="string">&#x27;Accord&#x27;</span>,</span><br><span class="line">  <span class="attr">carColor</span>: <span class="string">&#x27;Blue&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">paintCar</span>(<span class="params">car</span>) &#123;</span><br><span class="line">  car.<span class="property">carColor</span> = <span class="string">&#x27;Red&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Car</span> = &#123;</span><br><span class="line">  <span class="attr">make</span>: <span class="string">&#x27;Honda&#x27;</span>,</span><br><span class="line">  <span class="attr">model</span>: <span class="string">&#x27;Accord&#x27;</span>,</span><br><span class="line">  <span class="attr">color</span>: <span class="string">&#x27;Blue&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">paintCar</span>(<span class="params">car</span>) &#123;</span><br><span class="line">  car.<span class="property">color</span> = <span class="string">&#x27;Red&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="避免无意义的条件判断"><a href="#避免无意义的条件判断" class="headerlink" title="避免无意义的条件判断"></a>避免无意义的条件判断</h3><p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createMicrobrewery</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> breweryName;</span><br><span class="line">  <span class="keyword">if</span> (name) &#123;</span><br><span class="line">    breweryName = name;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    breweryName = <span class="string">&#x27;Hipster Brew Co.&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createMicrobrewery</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> breweryName = name || <span class="string">&#x27;Hipster Brew Co.&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h2><h3 id="函数参数-理想情况下应不超过-2-个"><a href="#函数参数-理想情况下应不超过-2-个" class="headerlink" title="函数参数 (理想情况下应不超过 2 个)"></a>函数参数 (理想情况下应不超过 2 个)</h3><p>限制函数参数数量很有必要，这么做使得在测试函数时更加轻松。过多的参数将导致难以采用有效的测试用例对函数的各个参数进行测试。</p>
<p>应避免三个以上参数的函数。通常情况下，参数超过两个意味着函数功能过于复杂，这时需要重新优化你的函数。当确实需要多个参数时，大多情况下可以考虑这些参数封装成一个对象。</p>
<p>JS 定义对象非常方便，当需要多个参数时，可以使用一个对象进行替代。</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createMenu</span>(<span class="params">title, body, buttonText, cancellable</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> menuConfig = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;Foo&#x27;</span>,</span><br><span class="line">  <span class="attr">body</span>: <span class="string">&#x27;Bar&#x27;</span>,</span><br><span class="line">  <span class="attr">buttonText</span>: <span class="string">&#x27;Baz&#x27;</span>,</span><br><span class="line">  <span class="attr">cancellable</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createMenu</span>(<span class="params">menuConfig</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="函数功能的单一性"><a href="#函数功能的单一性" class="headerlink" title="函数功能的单一性"></a>函数功能的单一性</h3><p>这是软件功能中最重要的原则之一。</p>
<p>功能不单一的函数将导致难以重构、测试和理解。功能单一的函数易于重构，并使代码更加干净。</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">emailClients</span>(<span class="params">clients</span>) &#123;</span><br><span class="line">  clients.<span class="title function_">forEach</span>(<span class="function"><span class="params">client</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> clientRecord = database.<span class="title function_">lookup</span>(client);</span><br><span class="line">    <span class="keyword">if</span> (clientRecord.<span class="title function_">isActive</span>()) &#123;</span><br><span class="line">      <span class="title function_">email</span>(client);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">emailClients</span>(<span class="params">clients</span>) &#123;</span><br><span class="line">  clients.<span class="title function_">forEach</span>(<span class="function"><span class="params">client</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">emailClientIfNeeded</span>(client);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">emailClientIfNeeded</span>(<span class="params">client</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isClientActive</span>(client)) &#123;</span><br><span class="line">    <span class="title function_">email</span>(client);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isClientActive</span>(<span class="params">client</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> clientRecord = database.<span class="title function_">lookup</span>(client);</span><br><span class="line">  <span class="keyword">return</span> clientRecord.<span class="title function_">isActive</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="函数名应明确表明其功能"><a href="#函数名应明确表明其功能" class="headerlink" title="函数名应明确表明其功能"></a>函数名应明确表明其功能</h3><p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dateAdd</span>(<span class="params">date, month</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 很难理解dateAdd(date, 1)是什么意思</span></span><br><span class="line"><span class="title function_">dateAdd</span>(date, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dateAddMonth</span>(<span class="params">date, month</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="title function_">dateAddMonth</span>(date, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="函数应该只做一层抽象"><a href="#函数应该只做一层抽象" class="headerlink" title="函数应该只做一层抽象"></a>函数应该只做一层抽象</h3><p>当函数的需要的抽象多于一层时通常意味着函数功能过于复杂，需将其进行分解以提高其可重用性和可测试性。</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">parseBetterJSAlternative</span>(<span class="params">code</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable constant_">REGEXES</span> = [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> statements = code.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> tokens;</span><br><span class="line">  <span class="variable constant_">REGEXES</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">REGEX</span>) =&gt;</span> &#123;</span><br><span class="line">    statements.<span class="title function_">forEach</span>(<span class="function">(<span class="params">statement</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> ast;</span><br><span class="line">  tokens.<span class="title function_">forEach</span>(<span class="function">(<span class="params">token</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// lex...</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  ast.<span class="title function_">forEach</span>(<span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// parse...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">tokenize</span>(<span class="params">code</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable constant_">REGEXES</span> = [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> statements = code.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> tokens;</span><br><span class="line">  <span class="variable constant_">REGEXES</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">REGEX</span>) =&gt;</span> &#123;</span><br><span class="line">    statements.<span class="title function_">forEach</span>(<span class="function">(<span class="params">statement</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> tokens;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">lexer</span>(<span class="params">tokens</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> ast;</span><br><span class="line">  tokens.<span class="title function_">forEach</span>(<span class="function">(<span class="params">token</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// lex...</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ast;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">parseBetterJSAlternative</span>(<span class="params">code</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> tokens = <span class="title function_">tokenize</span>(code);</span><br><span class="line">  <span class="keyword">let</span> ast = <span class="title function_">lexer</span>(tokens);</span><br><span class="line">  ast.<span class="title function_">forEach</span>(<span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// parse...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="移除重复的代码"><a href="#移除重复的代码" class="headerlink" title="移除重复的代码"></a>移除重复的代码</h3><p>永远、永远、永远不要在任何循环下有重复的代码。</p>
<p>这种做法毫无意义且潜在危险极大。重复的代码意味着逻辑变化时需要对不止一处进行修改。JS 弱类型的特点使得函数拥有更强的普适性。好好利用这一优点吧。</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showDeveloperList</span>(<span class="params">developers</span>) &#123;</span><br><span class="line">  developers.<span class="title function_">forEach</span>(<span class="function"><span class="params">developer</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> expectedSalary = developer.<span class="title function_">calculateExpectedSalary</span>();</span><br><span class="line">    <span class="keyword">var</span> experience = developer.<span class="title function_">getExperience</span>();</span><br><span class="line">    <span class="keyword">var</span> githubLink = developer.<span class="title function_">getGithubLink</span>();</span><br><span class="line">    <span class="keyword">var</span> data = &#123;</span><br><span class="line">      <span class="attr">expectedSalary</span>: expectedSalary,</span><br><span class="line">      <span class="attr">experience</span>: experience,</span><br><span class="line">      <span class="attr">githubLink</span>: githubLink</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showManagerList</span>(<span class="params">managers</span>) &#123;</span><br><span class="line">  managers.<span class="title function_">forEach</span>(<span class="function"><span class="params">manager</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> expectedSalary = manager.<span class="title function_">calculateExpectedSalary</span>();</span><br><span class="line">    <span class="keyword">var</span> experience = manager.<span class="title function_">getExperience</span>();</span><br><span class="line">    <span class="keyword">var</span> portfolio = manager.<span class="title function_">getMBAProjects</span>();</span><br><span class="line">    <span class="keyword">var</span> data = &#123;</span><br><span class="line">      <span class="attr">expectedSalary</span>: expectedSalary,</span><br><span class="line">      <span class="attr">experience</span>: experience,</span><br><span class="line">      <span class="attr">portfolio</span>: portfolio</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showList</span>(<span class="params">employees</span>) &#123;</span><br><span class="line">  employees.<span class="title function_">forEach</span>(<span class="function"><span class="params">employee</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> expectedSalary = employee.<span class="title function_">calculateExpectedSalary</span>();</span><br><span class="line">    <span class="keyword">var</span> experience = employee.<span class="title function_">getExperience</span>();</span><br><span class="line">    <span class="keyword">var</span> portfolio;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (employee.<span class="property">type</span> === <span class="string">&#x27;manager&#x27;</span>) &#123;</span><br><span class="line">      portfolio = employee.<span class="title function_">getMBAProjects</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      portfolio = employee.<span class="title function_">getGithubLink</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> data = &#123;</span><br><span class="line">      <span class="attr">expectedSalary</span>: expectedSalary,</span><br><span class="line">      <span class="attr">experience</span>: experience,</span><br><span class="line">      <span class="attr">portfolio</span>: portfolio</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="采用默认参数精简代码"><a href="#采用默认参数精简代码" class="headerlink" title="采用默认参数精简代码"></a>采用默认参数精简代码</h3><p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">writeForumComment</span>(<span class="params">subject, body</span>) &#123;</span><br><span class="line">  subject = subject || <span class="string">&#x27;No Subject&#x27;</span>;</span><br><span class="line">  body = body || <span class="string">&#x27;No text&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">writeForumComment</span>(<span class="params">subject = <span class="string">&#x27;No subject&#x27;</span>, body = <span class="string">&#x27;No text&#x27;</span></span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="使用-Object-assign-设置默认对象"><a href="#使用-Object-assign-设置默认对象" class="headerlink" title="使用 Object.assign 设置默认对象"></a>使用 Object.assign 设置默认对象</h3><p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> menuConfig = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">body</span>: <span class="string">&#x27;Bar&#x27;</span>,</span><br><span class="line">  <span class="attr">buttonText</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">cancellable</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createMenu</span>(<span class="params">config</span>) &#123;</span><br><span class="line">  config.<span class="property">title</span> = config.<span class="property">title</span> || <span class="string">&#x27;Foo&#x27;</span></span><br><span class="line">  config.<span class="property">body</span> = config.<span class="property">body</span> || <span class="string">&#x27;Bar&#x27;</span></span><br><span class="line">  config.<span class="property">buttonText</span> = config.<span class="property">buttonText</span> || <span class="string">&#x27;Baz&#x27;</span></span><br><span class="line">  config.<span class="property">cancellable</span> = config.<span class="property">cancellable</span> === <span class="literal">undefined</span> ? config.<span class="property">cancellable</span> : <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">createMenu</span>(menuConfig);</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> menuConfig = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;Order&#x27;</span>,</span><br><span class="line">  <span class="comment">// User did not include &#x27;body&#x27; key</span></span><br><span class="line">  <span class="attr">buttonText</span>: <span class="string">&#x27;Send&#x27;</span>,</span><br><span class="line">  <span class="attr">cancellable</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createMenu</span>(<span class="params">config</span>) &#123;</span><br><span class="line">  config = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;Foo&#x27;</span>,</span><br><span class="line">    <span class="attr">body</span>: <span class="string">&#x27;Bar&#x27;</span>,</span><br><span class="line">    <span class="attr">buttonText</span>: <span class="string">&#x27;Baz&#x27;</span>,</span><br><span class="line">    <span class="attr">cancellable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;, config);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// config now equals: &#123;title: &quot;Order&quot;, body: &quot;Bar&quot;, buttonText: &quot;Send&quot;, cancellable: true&#125;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">createMenu</span>(menuConfig);</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="不要使用标记-Flag-作为函数参数"><a href="#不要使用标记-Flag-作为函数参数" class="headerlink" title="不要使用标记(Flag)作为函数参数"></a>不要使用标记(Flag)作为函数参数</h3><p>这通常意味着函数的功能的单一性已经被破坏。此时应考虑对函数进行再次划分。</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createFile</span>(<span class="params">name, temp</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (temp) &#123;</span><br><span class="line">    fs.<span class="title function_">create</span>(<span class="string">&#x27;./temp/&#x27;</span> + name);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fs.<span class="title function_">create</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createTempFile</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  fs.<span class="title function_">create</span>(<span class="string">&#x27;./temp/&#x27;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createFile</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  fs.<span class="title function_">create</span>(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="避免副作用"><a href="#避免副作用" class="headerlink" title="避免副作用"></a>避免副作用</h3><p>当函数产生了除了“接受一个值并返回一个结果”之外的行为时，称该函数产生了副作用。比如写文件、修改全局变量或将你的钱全转给了一个陌生人等。</p>
<p>程序在某些情况下确实需要副作用这一行为，如先前例子中的写文件。这时应该将这些功能集中在一起，不要用多个函数&#x2F;类修改某个文件。用且只用一个 service 完成这一需求。</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Global variable referenced by following function.</span></span><br><span class="line"><span class="comment">// If we had another function that used this name, now it&#x27;d be an array and it could break it.</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Ryan McDermott&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">splitIntoFirstAndLastName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  name = name.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">splitIntoFirstAndLastName</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// [&#x27;Ryan&#x27;, &#x27;McDermott&#x27;];</span></span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">splitIntoFirstAndLastName</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> name.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Ryan McDermott&#x27;</span></span><br><span class="line"><span class="keyword">var</span> newName = <span class="title function_">splitIntoFirstAndLastName</span>(name);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// &#x27;Ryan McDermott&#x27;;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newName); <span class="comment">// [&#x27;Ryan&#x27;, &#x27;McDermott&#x27;];</span></span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="不要写全局函数"><a href="#不要写全局函数" class="headerlink" title="不要写全局函数"></a>不要写全局函数</h3><p>在 JS 中污染全局是一个非常不好的实践，这么做可能和其他库起冲突，且调用你的 API 的用户在实际环境中得到一个 exception 前对这一情况是一无所知的。</p>
<p>想象以下例子：如果你想扩展 JS 中的 Array，为其添加一个 <code>diff</code> 函数显示两个数组间的差异，此时应如何去做？你可以将 diff 写入 <code>Array.prototype</code>，但这么做会和其他有类似需求的库造成冲突。如果另一个库对 diff 的需求为比较一个数组中首尾元素间的差异呢？</p>
<p>使用 ES6 中的 class 对全局的 Array 做简单的扩展显然是一个更棒的选择。</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">diff</span> = <span class="keyword">function</span>(<span class="params">comparisonArray</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> values = [];</span><br><span class="line">  <span class="keyword">var</span> hash = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">of</span> comparisonArray) &#123;</span><br><span class="line">    hash[i] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">of</span> <span class="variable language_">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hash[i]) &#123;</span><br><span class="line">      values.<span class="title function_">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">diff</span>(<span class="params">comparisonArray</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> values = [];</span><br><span class="line">    <span class="keyword">var</span> hash = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">of</span> comparisonArray) &#123;</span><br><span class="line">      hash[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">of</span> <span class="variable language_">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hash[i]) &#123;</span><br><span class="line">        values.<span class="title function_">push</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="采用函数式编程"><a href="#采用函数式编程" class="headerlink" title="采用函数式编程"></a>采用函数式编程</h3><p>函数式的编程具有更干净且便于测试的特点。尽可能的使用这种风格吧。</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> programmerOutput = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Uncle Bobby&#x27;</span>,</span><br><span class="line">    <span class="attr">linesOfCode</span>: <span class="number">500</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Suzie Q&#x27;</span>,</span><br><span class="line">    <span class="attr">linesOfCode</span>: <span class="number">1500</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Jimmy Gosling&#x27;</span>,</span><br><span class="line">    <span class="attr">linesOfCode</span>: <span class="number">150</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Gracie Hopper&#x27;</span>,</span><br><span class="line">    <span class="attr">linesOfCode</span>: <span class="number">1000</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> totalOutput = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; programmerOutput.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  totalOutput += programmerOutput[i].<span class="property">linesOfCode</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> programmerOutput = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Uncle Bobby&#x27;</span>,</span><br><span class="line">    <span class="attr">linesOfCode</span>: <span class="number">500</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Suzie Q&#x27;</span>,</span><br><span class="line">    <span class="attr">linesOfCode</span>: <span class="number">1500</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Jimmy Gosling&#x27;</span>,</span><br><span class="line">    <span class="attr">linesOfCode</span>: <span class="number">150</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Gracie Hopper&#x27;</span>,</span><br><span class="line">    <span class="attr">linesOfCode</span>: <span class="number">1000</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> totalOutput = programmerOutput</span><br><span class="line">  .<span class="title function_">map</span>(<span class="function">(<span class="params">programmer</span>) =&gt;</span> programmer.<span class="property">linesOfCode</span>)</span><br><span class="line">  .<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, linesOfCode</span>) =&gt;</span> acc + linesOfCode, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="封装判断条件"><a href="#封装判断条件" class="headerlink" title="封装判断条件"></a>封装判断条件</h3><p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fsm.<span class="property">state</span> === <span class="string">&#x27;fetching&#x27;</span> &amp;&amp; <span class="title function_">isEmpty</span>(listNode)) &#123;</span><br><span class="line">  <span class="comment">/// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shouldShowSpinner</span>(<span class="params">fsm, listNode</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> fsm.<span class="property">state</span> === <span class="string">&#x27;fetching&#x27;</span> &amp;&amp; <span class="title function_">isEmpty</span>(listNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">shouldShowSpinner</span>(fsmInstance, listNodeInstance)) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="避免“否定情况”的判断"><a href="#避免“否定情况”的判断" class="headerlink" title="避免“否定情况”的判断"></a>避免“否定情况”的判断</h3><p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isDOMNodeNotPresent</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="title function_">isDOMNodeNotPresent</span>(node)) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isDOMNodePresent</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isDOMNodePresent</span>(node)) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="避免条件判断"><a href="#避免条件判断" class="headerlink" title="避免条件判断"></a>避免条件判断</h3><p>这看起来似乎不太可能。</p>
<p>大多人听到这的第一反应是：“怎么可能不用 if 完成其他功能呢？”许多情况下通过使用多态(polymorphism)可以达到同样的目的。</p>
<p>第二个问题在于采用这种方式的原因是什么。答案是我们之前提到过的：保持函数功能的单一性。</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Airplane</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="title function_">getCruisingAltitude</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="variable language_">this</span>.<span class="property">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;777&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">getMaxAltitude</span>() - <span class="title function_">getPassengerCount</span>();</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;Air Force One&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">getMaxAltitude</span>();</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;Cessna&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">getMaxAltitude</span>() - <span class="title function_">getFuelExpenditure</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Airplane</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boeing777</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Airplane</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="title function_">getCruisingAltitude</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">getMaxAltitude</span>() - <span class="title function_">getPassengerCount</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AirForceOne</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Airplane</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="title function_">getCruisingAltitude</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">getMaxAltitude</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cessna</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Airplane</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="title function_">getCruisingAltitude</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">getMaxAltitude</span>() - <span class="title function_">getFuelExpenditure</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="避免类型判断-part-1"><a href="#避免类型判断-part-1" class="headerlink" title="避免类型判断(part 1)"></a>避免类型判断(part 1)</h3><p>JS 是弱类型语言，这意味着函数可接受任意类型的参数。</p>
<p>有时这会对你带来麻烦，你会对参数做一些类型判断。有许多方法可以避免这些情况。</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">travelToTexas</span>(<span class="params">vehicle</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (vehicle <span class="keyword">instanceof</span> <span class="title class_">Bicycle</span>) &#123;</span><br><span class="line">    vehicle.<span class="title function_">peddle</span>(<span class="variable language_">this</span>.<span class="property">currentLocation</span>, <span class="keyword">new</span> <span class="title class_">Location</span>(<span class="string">&#x27;texas&#x27;</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vehicle <span class="keyword">instanceof</span> <span class="title class_">Car</span>) &#123;</span><br><span class="line">    vehicle.<span class="title function_">drive</span>(<span class="variable language_">this</span>.<span class="property">currentLocation</span>, <span class="keyword">new</span> <span class="title class_">Location</span>(<span class="string">&#x27;texas&#x27;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">travelToTexas</span>(<span class="params">vehicle</span>) &#123;</span><br><span class="line">  vehicle.<span class="title function_">move</span>(<span class="variable language_">this</span>.<span class="property">currentLocation</span>, <span class="keyword">new</span> <span class="title class_">Location</span>(<span class="string">&#x27;texas&#x27;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="避免类型判断-part-2"><a href="#避免类型判断-part-2" class="headerlink" title="避免类型判断(part 2)"></a>避免类型判断(part 2)</h3><p>如果需处理的数据为字符串，整型，数组等类型，无法使用多态并仍有必要对其进行类型检测时，可以考虑使用 TypeScript。</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">combine</span>(<span class="params">val1, val2</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val1 == <span class="string">&quot;number&quot;</span> &amp;&amp; <span class="keyword">typeof</span> val2 == <span class="string">&quot;number&quot;</span> ||</span><br><span class="line">      <span class="keyword">typeof</span> val1 == <span class="string">&quot;string&quot;</span> &amp;&amp; <span class="keyword">typeof</span> val2 == <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> val1 + val2;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Must be of type String or Number&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">combine</span>(<span class="params">val1, val2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> val1 + val2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="避免过度优化"><a href="#避免过度优化" class="headerlink" title="避免过度优化"></a>避免过度优化</h3><p>现代的浏览器在运行时会对代码自动进行优化。有时人为对代码进行优化可能是在浪费时间。</p>
<p><a href="https://github.com/petkaantonov/bluebird/wiki/Optimization-killers">这里可以找到许多真正需要优化的地方</a></p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 这里使用变量len是因为在老式浏览器中，</span></span><br><span class="line"><span class="comment">// 直接使用正例中的方式会导致每次循环均重复计算list.length的值，</span></span><br><span class="line"><span class="comment">// 而在现代浏览器中会自动完成优化，这一行为是没有必要的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = list.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="删除无效的代码"><a href="#删除无效的代码" class="headerlink" title="删除无效的代码"></a>删除无效的代码</h3><p>不再被调用的代码应及时删除。</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">oldRequestModule</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">newRequestModule</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> req = newRequestModule;</span><br><span class="line"><span class="title function_">inventoryTracker</span>(<span class="string">&#x27;apples&#x27;</span>, req, <span class="string">&#x27;www.inventory-awesome.io&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">newRequestModule</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> req = newRequestModule;</span><br><span class="line"><span class="title function_">inventoryTracker</span>(<span class="string">&#x27;apples&#x27;</span>, req, <span class="string">&#x27;www.inventory-awesome.io&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h2 id="对象和数据结构"><a href="#对象和数据结构" class="headerlink" title="对象和数据结构"></a><strong>对象和数据结构</strong></h2><h3 id="使用-getters-和-setters"><a href="#使用-getters-和-setters" class="headerlink" title="使用 getters 和 setters"></a>使用 getters 和 setters</h3><p>JS 没有接口或类型，因此实现这一模式是很困难的，因为我们并没有类似 <code>public</code> 和 <code>private</code> 的关键词。</p>
<p>然而，使用 getters 和 setters 获取对象的数据远比直接使用点操作符具有优势。为什么呢？</p>
<ol>
<li>当需要对获取的对象属性执行额外操作时。</li>
<li>执行 <code>set</code> 时可以增加规则对要变量的合法性进行判断。</li>
<li>封装了内部逻辑。</li>
<li>在存取时可以方便的增加日志和错误处理。</li>
<li>继承该类时可以重载默认行为。</li>
<li>从服务器获取数据时可以进行懒加载。</li>
</ol>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BankAccount</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">balance</span> = <span class="number">1000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bankAccount = <span class="keyword">new</span> <span class="title class_">BankAccount</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Buy shoes...</span></span><br><span class="line">bankAccount.<span class="property">balance</span> = bankAccount.<span class="property">balance</span> - <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BankAccount</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">balance</span> = <span class="number">1000</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// It doesn&#x27;t have to be prefixed with `get` or `set` to be a getter/setter</span></span><br><span class="line">  <span class="title function_">withdraw</span>(<span class="params">amount</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="title function_">verifyAmountCanBeDeducted</span>(amount)) &#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">balance</span> -= amount;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bankAccount = <span class="keyword">new</span> <span class="title class_">BankAccount</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Buy shoes...</span></span><br><span class="line">bankAccount.<span class="title function_">withdraw</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="让对象拥有私有成员"><a href="#让对象拥有私有成员" class="headerlink" title="让对象拥有私有成员"></a>让对象拥有私有成员</h3><p>可以通过闭包完成</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Employee</span> = <span class="keyword">function</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Employee</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> employee = <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&#x27;John Doe&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Employee name: &#x27;</span> + employee.<span class="title function_">getName</span>()); <span class="comment">// Employee name: John Doe</span></span><br><span class="line"><span class="keyword">delete</span> employee.<span class="property">name</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Employee name: &#x27;</span> + employee.<span class="title function_">getName</span>()); <span class="comment">// Employee name: undefined</span></span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Employee</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Employee</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Employee</span>;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> employee = <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&#x27;John Doe&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Employee name: &#x27;</span> + employee.<span class="title function_">getName</span>()); <span class="comment">// Employee name: John Doe</span></span><br><span class="line"><span class="keyword">delete</span> employee.<span class="property">name</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Employee name: &#x27;</span> + employee.<span class="title function_">getName</span>()); <span class="comment">// Employee name: John Doe</span></span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a><strong>类</strong></h2><h3 id="单一职责原则-SRP"><a href="#单一职责原则-SRP" class="headerlink" title="单一职责原则 (SRP)"></a>单一职责原则 (SRP)</h3><p>如《代码整洁之道》一书中所述，“修改一个类的理由不应该超过一个”。</p>
<p>将多个功能塞进一个类的想法很诱人，但这将导致你的类无法达到概念上的内聚，并经常不得不进行修改。</p>
<p>最小化对一个类需要修改的次数是非常有必要的。如果一个类具有太多太杂的功能，当你对其中一小部分进行修改时，将很难想象到这一修够对代码库中依赖该类的其他模块会带来什么样的影响。</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserSettings</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">user</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">user</span> = user;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">changeSettings</span>(<span class="params">settings</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">verifyCredentials</span>(user)) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">verifyCredentials</span>(<span class="params">user</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserAuth</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">user</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">user</span> = user;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">verifyCredentials</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserSettings</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">user</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">user</span> = user;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">auth</span> = <span class="keyword">new</span> <span class="title class_">UserAuth</span>(user)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">changeSettings</span>(<span class="params">settings</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">auth</span>.<span class="title function_">verifyCredentials</span>()) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="开-闭原则-OCP"><a href="#开-闭原则-OCP" class="headerlink" title="开&#x2F;闭原则 (OCP)"></a>开&#x2F;闭原则 (OCP)</h3><p>“代码实体(类，模块，函数等)应该易于扩展，难于修改。”</p>
<p>这一原则指的是我们应允许用户方便的扩展我们代码模块的功能，而不需要打开 js 文件源码手动对其进行修改。</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AjaxRequester</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// What if we wanted another HTTP Method, like DELETE? We would have to</span></span><br><span class="line">    <span class="comment">// open this file up and modify this and put it in manually.</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">HTTP_METHODS</span> = [<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;PUT&#x27;</span>, <span class="string">&#x27;GET&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AjaxRequester</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">HTTP_METHODS</span> = [<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;PUT&#x27;</span>, <span class="string">&#x27;GET&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addHTTPMethod</span>(<span class="params">method</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">HTTP_METHODS</span>.<span class="title function_">push</span>(method);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="利斯科夫替代原则-LSP"><a href="#利斯科夫替代原则-LSP" class="headerlink" title="利斯科夫替代原则 (LSP)"></a>利斯科夫替代原则 (LSP)</h3><p>“子类对象应该能够替换其超类对象被使用”。</p>
<p>也就是说，如果有一个父类和一个子类，当采用子类替换父类时不应该产生错误的结果。</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">width</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">height</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setColor</span>(<span class="params">color</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params">area</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setWidth</span>(<span class="params">width</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">width</span> = width;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setHeight</span>(<span class="params">height</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">height</span> = height;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getArea</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">width</span> * <span class="variable language_">this</span>.<span class="property">height</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Rectangle</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setWidth</span>(<span class="params">width</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">width</span> = width;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">height</span> = width;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setHeight</span>(<span class="params">height</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">width</span> = height;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">height</span> = height;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">renderLargeRectangles</span>(<span class="params">rectangles</span>) &#123;</span><br><span class="line">  rectangles.<span class="title function_">forEach</span>(<span class="function">(<span class="params">rectangle</span>) =&gt;</span> &#123;</span><br><span class="line">    rectangle.<span class="title function_">setWidth</span>(<span class="number">4</span>);</span><br><span class="line">    rectangle.<span class="title function_">setHeight</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> area = rectangle.<span class="title function_">getArea</span>(); <span class="comment">// BAD: Will return 25 for Square. Should be 20.</span></span><br><span class="line">    rectangle.<span class="title function_">render</span>(area);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rectangles = [<span class="keyword">new</span> <span class="title class_">Rectangle</span>(), <span class="keyword">new</span> <span class="title class_">Rectangle</span>(), <span class="keyword">new</span> <span class="title class_">Square</span>()];</span><br><span class="line"><span class="title function_">renderLargeRectangles</span>(rectangles);</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setColor</span>(<span class="params">color</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params">area</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">width</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">height</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setWidth</span>(<span class="params">width</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">width</span> = width;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setHeight</span>(<span class="params">height</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">height</span> = height;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getArea</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">width</span> * <span class="variable language_">this</span>.<span class="property">height</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setLength</span>(<span class="params">length</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span> = length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getArea</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span> * <span class="variable language_">this</span>.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">renderLargeShapes</span>(<span class="params">shapes</span>) &#123;</span><br><span class="line">  shapes.<span class="title function_">forEach</span>(<span class="function">(<span class="params">shape</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (shape.<span class="property">constructor</span>.<span class="property">name</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;Square&#x27;</span>:</span><br><span class="line">        shape.<span class="title function_">setLength</span>(<span class="number">5</span>);</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;Rectangle&#x27;</span>:</span><br><span class="line">        shape.<span class="title function_">setWidth</span>(<span class="number">4</span>);</span><br><span class="line">        shape.<span class="title function_">setHeight</span>(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> area = shape.<span class="title function_">getArea</span>();</span><br><span class="line">    shape.<span class="title function_">render</span>(area);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> shapes = [<span class="keyword">new</span> <span class="title class_">Rectangle</span>(), <span class="keyword">new</span> <span class="title class_">Rectangle</span>(), <span class="keyword">new</span> <span class="title class_">Square</span>()];</span><br><span class="line"><span class="title function_">renderLargeShapes</span>(shapes);</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="接口隔离原则-ISP"><a href="#接口隔离原则-ISP" class="headerlink" title="接口隔离原则 (ISP)"></a>接口隔离原则 (ISP)</h3><p>“客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。”</p>
<p>在 JS 中，当一个类需要许多参数设置才能生成一个对象时，或许大多时候不需要设置这么多的参数。此时减少对配置参数数量的需求是有益的。</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DOMTraverser</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">settings</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">settings</span> = settings;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setup</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">rootNode</span> = <span class="variable language_">this</span>.<span class="property">settings</span>.<span class="property">rootNode</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">animationModule</span>.<span class="title function_">setup</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">traverse</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> $ = <span class="keyword">new</span> <span class="title class_">DOMTraverser</span>(&#123;</span><br><span class="line">  <span class="attr">rootNode</span>: <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;body&#x27;</span>),</span><br><span class="line">  <span class="attr">animationModule</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125; <span class="comment">// Most of the time, we won&#x27;t need to animate when traversing.</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DOMTraverser</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">settings</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">settings</span> = settings;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">options</span> = settings.<span class="property">options</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setup</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">rootNode</span> = <span class="variable language_">this</span>.<span class="property">settings</span>.<span class="property">rootNode</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setupOptions</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setupOptions</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">options</span>.<span class="property">animationModule</span>) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">traverse</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> $ = <span class="keyword">new</span> <span class="title class_">DOMTraverser</span>(&#123;</span><br><span class="line">  <span class="attr">rootNode</span>: <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;body&#x27;</span>),</span><br><span class="line">  <span class="attr">options</span>: &#123;</span><br><span class="line">    <span class="attr">animationModule</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="依赖反转原则-DIP"><a href="#依赖反转原则-DIP" class="headerlink" title="依赖反转原则 (DIP)"></a>依赖反转原则 (DIP)</h3><p>该原则有两个核心点：</p>
<ol>
<li>高层模块不应该依赖于低层模块。他们都应该依赖于抽象接口。</li>
<li>抽象接口应该脱离具体实现，具体实现应该依赖于抽象接口。</li>
</ol>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InventoryTracker</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">items</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = items;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BAD: We have created a dependency on a specific request implementation.</span></span><br><span class="line">    <span class="comment">// We should just have requestItems depend on a request method: `request`</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">requester</span> = <span class="keyword">new</span> <span class="title class_">InventoryRequester</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">requestItems</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">requester</span>.<span class="title function_">requestItem</span>(item);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InventoryRequester</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">REQ_METHODS</span> = [<span class="string">&#x27;HTTP&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">requestItem</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inventoryTracker = <span class="keyword">new</span> <span class="title class_">InventoryTracker</span>([<span class="string">&#x27;apples&#x27;</span>, <span class="string">&#x27;bananas&#x27;</span>]);</span><br><span class="line">inventoryTracker.<span class="title function_">requestItems</span>();</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InventoryTracker</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">items, requester</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = items;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">requester</span> = requester;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">requestItems</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">requester</span>.<span class="title function_">requestItem</span>(item);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InventoryRequesterV1</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">REQ_METHODS</span> = [<span class="string">&#x27;HTTP&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">requestItem</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InventoryRequesterV2</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">REQ_METHODS</span> = [<span class="string">&#x27;WS&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">requestItem</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// By constructing our dependencies externally and injecting them, we can easily</span></span><br><span class="line"><span class="comment">// substitute our request module for a fancy new one that uses WebSockets.</span></span><br><span class="line"><span class="keyword">let</span> inventoryTracker = <span class="keyword">new</span> <span class="title class_">InventoryTracker</span>([<span class="string">&#x27;apples&#x27;</span>, <span class="string">&#x27;bananas&#x27;</span>], <span class="keyword">new</span> <span class="title class_">InventoryRequesterV2</span>());</span><br><span class="line">inventoryTracker.<span class="title function_">requestItems</span>();</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="使用-ES6-的-classes-而不是-ES5-的-Function"><a href="#使用-ES6-的-classes-而不是-ES5-的-Function" class="headerlink" title="使用 ES6 的 classes 而不是 ES5 的 Function"></a>使用 ES6 的 classes 而不是 ES5 的 Function</h3><p>典型的 ES5 的类(function)在继承、构造和方法定义方面可读性较差。</p>
<p>当需要继承时，优先选用 classes。</p>
<p>但是，当在需要更大更复杂的对象时，最好优先选择更小的 function 而非 classes。</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Animal</span> = <span class="keyword">function</span>(<span class="params">age</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Animal</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Instantiate Animal with `new`&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">move</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Mammal</span> = <span class="keyword">function</span>(<span class="params">age, furColor</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Mammal</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Instantiate Mammal with `new`&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Animal</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, age);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">furColor</span> = furColor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Mammal</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Mammal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Mammal</span>;</span><br><span class="line"><span class="title class_">Mammal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">liveBirth</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Human</span> = <span class="keyword">function</span>(<span class="params">age, furColor, languageSpoken</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Human</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Instantiate Human with `new`&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Mammal</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, age, furColor);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">languageSpoken</span> = languageSpoken;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Human</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Mammal</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Human</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Human</span>;</span><br><span class="line"><span class="title class_">Human</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">speak</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">age</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">move</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mammal</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">age, furColor</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(age);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">furColor</span> = furColor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">liveBirth</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Mammal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">age, furColor, languageSpoken</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(age, furColor);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">languageSpoken</span> = languageSpoken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">speak</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="使用方法链"><a href="#使用方法链" class="headerlink" title="使用方法链"></a>使用方法链</h3><p>这里我们的理解与《代码整洁之道》的建议有些不同。</p>
<p>有争论说方法链不够干净且违反了<a href="https://en.wikipedia.org/wiki/Law_of_Demeter">德米特法则</a>，也许这是对的，但这种方法在 JS 及许多库(如 JQuery)中显得非常实用。</p>
<p>因此，我认为在 JS 中使用方法链是非常合适的。在 class 的函数中返回 this，能够方便的将类需要执行的多个方法链接起来。</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">make</span> = <span class="string">&#x27;Honda&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">model</span> = <span class="string">&#x27;Accord&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = <span class="string">&#x27;white&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setMake</span>(<span class="params">make</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setModel</span>(<span class="params">model</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">model</span> = model;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setColor</span>(<span class="params">color</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">save</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">make</span>, <span class="variable language_">this</span>.<span class="property">model</span>, <span class="variable language_">this</span>.<span class="property">color</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">car.<span class="title function_">setColor</span>(<span class="string">&#x27;pink&#x27;</span>);</span><br><span class="line">car.<span class="title function_">setMake</span>(<span class="string">&#x27;Ford&#x27;</span>);</span><br><span class="line">car.<span class="title function_">setModel</span>(<span class="string">&#x27;F-150&#x27;</span>)</span><br><span class="line">car.<span class="title function_">save</span>();</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">make</span> = <span class="string">&#x27;Honda&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">model</span> = <span class="string">&#x27;Accord&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = <span class="string">&#x27;white&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setMake</span>(<span class="params">make</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Returning this for chaining</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setModel</span>(<span class="params">model</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">model</span> = model;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Returning this for chaining</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setColor</span>(<span class="params">color</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Returning this for chaining</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">save</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">make</span>, <span class="variable language_">this</span>.<span class="property">model</span>, <span class="variable language_">this</span>.<span class="property">color</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> <span class="title class_">Car</span>()</span><br><span class="line">  .<span class="title function_">setColor</span>(<span class="string">&#x27;pink&#x27;</span>)</span><br><span class="line">  .<span class="title function_">setMake</span>(<span class="string">&#x27;Ford&#x27;</span>)</span><br><span class="line">  .<span class="title function_">setModel</span>(<span class="string">&#x27;F-150&#x27;</span>)</span><br><span class="line">  .<span class="title function_">save</span>();</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="优先使用组合模式而非继承"><a href="#优先使用组合模式而非继承" class="headerlink" title="优先使用组合模式而非继承"></a>优先使用组合模式而非继承</h3><p>在著名的<a href="https://en.wikipedia.org/wiki/Design_Patterns">设计模式</a>一书中提到，应多使用组合模式而非继承。</p>
<p>这么做有许多优点，在想要使用继承前，多想想能否通过组合模式满足需求吧。</p>
<p>那么，在什么时候继承具有更大的优势呢？这取决于你的具体需求，但大多情况下，可以遵守以下三点：</p>
<ol>
<li>继承关系表现为”是一个”而非”有一个”(如动物-&gt;人 和 用户-&gt;用户细节)</li>
<li>可以复用基类的代码(“Human”可以看成是”All animal”的一种)</li>
<li>希望当基类改变时所有派生类都受到影响(如修改”all animals”移动时的卡路里消耗量)</li>
</ol>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, email</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">email</span> = email;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bad because Employees &quot;have&quot; tax data. EmployeeTaxData is not a type of Employee</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmployeeTaxData</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Employee</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">ssn, salary</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ssn</span> = ssn;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">salary</span> = salary;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, email</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">email</span> = email;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setTaxData</span>(<span class="params">ssn, salary</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">taxData</span> = <span class="keyword">new</span> <span class="title class_">EmployeeTaxData</span>(ssn, salary);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmployeeTaxData</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">ssn, salary</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ssn</span> = ssn;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">salary</span> = salary;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a><strong>测试</strong></h2><p><a href="http://gotwarlost.github.io/istanbul/">一些好的覆盖工具</a>。</p>
<p><a href="http://jstherightway.org/#testing-tools">一些好的 JS 测试框架</a>。</p>
<h3 id="单一的测试每个概念"><a href="#单一的测试每个概念" class="headerlink" title="单一的测试每个概念"></a>单一的测试每个概念</h3><p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">&#x27;assert&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;MakeMomentJSGreatAgain&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&#x27;handles date boundaries&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> date;</span><br><span class="line"></span><br><span class="line">    date = <span class="keyword">new</span> <span class="title class_">MakeMomentJSGreatAgain</span>(<span class="string">&#x27;1/1/2015&#x27;</span>);</span><br><span class="line">    date.<span class="title function_">addDays</span>(<span class="number">30</span>);</span><br><span class="line">    date.<span class="title function_">shouldEqual</span>(<span class="string">&#x27;1/31/2015&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    date = <span class="keyword">new</span> <span class="title class_">MakeMomentJSGreatAgain</span>(<span class="string">&#x27;2/1/2016&#x27;</span>);</span><br><span class="line">    date.<span class="title function_">addDays</span>(<span class="number">28</span>);</span><br><span class="line">    assert.<span class="title function_">equal</span>(<span class="string">&#x27;02/29/2016&#x27;</span>, date);</span><br><span class="line"></span><br><span class="line">    date = <span class="keyword">new</span> <span class="title class_">MakeMomentJSGreatAgain</span>(<span class="string">&#x27;2/1/2015&#x27;</span>);</span><br><span class="line">    date.<span class="title function_">addDays</span>(<span class="number">28</span>);</span><br><span class="line">    assert.<span class="title function_">equal</span>(<span class="string">&#x27;03/01/2015&#x27;</span>, date);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">&#x27;assert&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;MakeMomentJSGreatAgain&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&#x27;handles 30-day months&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="title class_">MakeMomentJSGreatAgain</span>(<span class="string">&#x27;1/1/2015&#x27;</span>);</span><br><span class="line">    date.<span class="title function_">addDays</span>(<span class="number">30</span>);</span><br><span class="line">    date.<span class="title function_">shouldEqual</span>(<span class="string">&#x27;1/31/2015&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&#x27;handles leap year&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="title class_">MakeMomentJSGreatAgain</span>(<span class="string">&#x27;2/1/2016&#x27;</span>);</span><br><span class="line">    date.<span class="title function_">addDays</span>(<span class="number">28</span>);</span><br><span class="line">    assert.<span class="title function_">equal</span>(<span class="string">&#x27;02/29/2016&#x27;</span>, date);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&#x27;handles non-leap year&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="title class_">MakeMomentJSGreatAgain</span>(<span class="string">&#x27;2/1/2015&#x27;</span>);</span><br><span class="line">    date.<span class="title function_">addDays</span>(<span class="number">28</span>);</span><br><span class="line">    assert.<span class="title function_">equal</span>(<span class="string">&#x27;03/01/2015&#x27;</span>, date);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a><strong>并发</strong></h2><h3 id="用-Promises-替代回调"><a href="#用-Promises-替代回调" class="headerlink" title="用 Promises 替代回调"></a>用 Promises 替代回调</h3><p>回调不够整洁并会造成大量的嵌套。ES6 内嵌了 Promises，使用它吧。</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;request&#x27;</span>).<span class="title function_">get</span>(<span class="string">&#x27;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, response</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>).<span class="title function_">writeFile</span>(<span class="string">&#x27;article.html&#x27;</span>, response.<span class="property">body</span>, <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;File written&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;request-promise&#x27;</span>).<span class="title function_">get</span>(<span class="string">&#x27;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">&#x27;fs-promise&#x27;</span>).<span class="title function_">writeFile</span>(<span class="string">&#x27;article.html&#x27;</span>, response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;File written&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="Async-Await-是较-Promises-更好的选择"><a href="#Async-Await-是较-Promises-更好的选择" class="headerlink" title="Async&#x2F;Await 是较 Promises 更好的选择"></a>Async&#x2F;Await 是较 Promises 更好的选择</h3><p>Promises 是较回调而言更好的一种选择，但 ES7 中的 async 和 await 更胜过 Promises。</p>
<p>在能使用 ES7 特性的情况下可以尽量使用他们替代 Promises。</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;request-promise&#x27;</span>).<span class="title function_">get</span>(<span class="string">&#x27;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">&#x27;fs-promise&#x27;</span>).<span class="title function_">writeFile</span>(<span class="string">&#x27;article.html&#x27;</span>, response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;File written&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getCleanCodeArticle</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">await</span> <span class="built_in">require</span>(<span class="string">&#x27;request-promise&#x27;</span>)</span><br><span class="line">    <span class="keyword">var</span> response = <span class="keyword">await</span> request.<span class="title function_">get</span>(<span class="string">&#x27;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> fileHandle = <span class="keyword">await</span> <span class="built_in">require</span>(<span class="string">&#x27;fs-promise&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> fileHandle.<span class="title function_">writeFile</span>(<span class="string">&#x27;article.html&#x27;</span>, response);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;File written&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a><strong>错误处理</strong></h2><p>错误抛出是个好东西！这使得你能够成功定位运行状态中的程序产生错误的位置。</p>
<h3 id="别忘了捕获错误"><a href="#别忘了捕获错误" class="headerlink" title="别忘了捕获错误"></a>别忘了捕获错误</h3><p>对捕获的错误不做任何处理是没有意义的。</p>
<p>代码中 <code>try/catch</code> 的意味着你认为这里可能出现一些错误，你应该对这些可能的错误存在相应的处理方案。</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">functionThatMightThrow</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">functionThatMightThrow</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="comment">// One option (more noisy than console.log):</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">  <span class="comment">// Another option:</span></span><br><span class="line">  <span class="title function_">notifyUserOfError</span>(error);</span><br><span class="line">  <span class="comment">// Another option:</span></span><br><span class="line">  <span class="title function_">reportErrorToService</span>(error);</span><br><span class="line">  <span class="comment">// OR do all three!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不要忽略被拒绝的-promises"><a href="#不要忽略被拒绝的-promises" class="headerlink" title="不要忽略被拒绝的 promises"></a>不要忽略被拒绝的 promises</h3><p>理由同 <code>try/catch</code>。</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getdata</span>()</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">functionThatMightThrow</span>(data);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getdata</span>()</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">functionThatMightThrow</span>(data);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// One option (more noisy than console.log):</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">  <span class="comment">// Another option:</span></span><br><span class="line">  <span class="title function_">notifyUserOfError</span>(error);</span><br><span class="line">  <span class="comment">// Another option:</span></span><br><span class="line">  <span class="title function_">reportErrorToService</span>(error);</span><br><span class="line">  <span class="comment">// OR do all three!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a><strong>格式化</strong></h2><p>格式化是一件主观的事。如同这里的许多规则一样，这里并没有一定&#x2F;立刻需要遵守的规则。可以在<a href="http://standardjs.com/rules.html">这里</a>完成格式的自动化。</p>
<h3 id="大小写一致"><a href="#大小写一致" class="headerlink" title="大小写一致"></a>大小写一致</h3><p>JS 是弱类型语言，合理的采用大小写可以告诉你关于变量&#x2F;函数等的许多消息。</p>
<p>这些规则是主观定义的，团队可以根据喜欢进行选择。重点在于无论选择何种风格，都需要注意保持一致性。</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable constant_">DAYS_IN_WEEK</span> = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">var</span> daysInMonth = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> songs = [<span class="string">&#x27;Back In Black&#x27;</span>, <span class="string">&#x27;Stairway to Heaven&#x27;</span>, <span class="string">&#x27;Hey Jude&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Artists</span> = [<span class="string">&#x27;ACDC&#x27;</span>, <span class="string">&#x27;Led Zeppelin&#x27;</span>, <span class="string">&#x27;The Beatles&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">eraseDatabase</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">restore_database</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Alpaca</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable constant_">DAYS_IN_WEEK</span> = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">DAYS_IN_MONTH</span> = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> songs = [<span class="string">&#x27;Back In Black&#x27;</span>, <span class="string">&#x27;Stairway to Heaven&#x27;</span>, <span class="string">&#x27;Hey Jude&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> artists = [<span class="string">&#x27;ACDC&#x27;</span>, <span class="string">&#x27;Led Zeppelin&#x27;</span>, <span class="string">&#x27;The Beatles&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">eraseDatabase</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">restoreDatabase</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Alpaca</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="调用函数的函数和被调函数应放在较近的位置"><a href="#调用函数的函数和被调函数应放在较近的位置" class="headerlink" title="调用函数的函数和被调函数应放在较近的位置"></a>调用函数的函数和被调函数应放在较近的位置</h3><p>当函数间存在相互调用的情况时，应将两者置于较近的位置。</p>
<p>理想情况下，应将调用其他函数的函数写在被调用函数的上方。</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PerformanceReview</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">employee</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">employee</span> = employee;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">lookupPeers</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> db.<span class="title function_">lookup</span>(<span class="variable language_">this</span>.<span class="property">employee</span>, <span class="string">&#x27;peers&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">lookupMananger</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> db.<span class="title function_">lookup</span>(<span class="variable language_">this</span>.<span class="property">employee</span>, <span class="string">&#x27;manager&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getPeerReviews</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> peers = <span class="variable language_">this</span>.<span class="title function_">lookupPeers</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">perfReview</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">getPeerReviews</span>();</span><br><span class="line">      <span class="title function_">getManagerReview</span>();</span><br><span class="line">      <span class="title function_">getSelfReview</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getManagerReview</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> manager = <span class="variable language_">this</span>.<span class="title function_">lookupManager</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getSelfReview</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> review = <span class="keyword">new</span> <span class="title class_">PerformanceReview</span>(user);</span><br><span class="line">review.<span class="title function_">perfReview</span>();</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PerformanceReview</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">employee</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">employee</span> = employee;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">perfReview</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">getPeerReviews</span>();</span><br><span class="line">      <span class="title function_">getManagerReview</span>();</span><br><span class="line">      <span class="title function_">getSelfReview</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getPeerReviews</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> peers = <span class="variable language_">this</span>.<span class="title function_">lookupPeers</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">lookupPeers</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> db.<span class="title function_">lookup</span>(<span class="variable language_">this</span>.<span class="property">employee</span>, <span class="string">&#x27;peers&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getManagerReview</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> manager = <span class="variable language_">this</span>.<span class="title function_">lookupManager</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">lookupMananger</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> db.<span class="title function_">lookup</span>(<span class="variable language_">this</span>.<span class="property">employee</span>, <span class="string">&#x27;manager&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getSelfReview</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> review = <span class="keyword">new</span> <span class="title class_">PerformanceReview</span>(employee);</span><br><span class="line">review.<span class="title function_">perfReview</span>();</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a><strong>注释</strong></h2><h3 id="只对存在一定业务逻辑复杂性的代码进行注释"><a href="#只对存在一定业务逻辑复杂性的代码进行注释" class="headerlink" title="只对存在一定业务逻辑复杂性的代码进行注释"></a>只对存在一定业务逻辑复杂性的代码进行注释</h3><p>注释并不是必须的，好的代码是能够让人一目了然，不用过多无谓的注释。</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hashIt</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="comment">// The hash</span></span><br><span class="line">  <span class="keyword">var</span> hash = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Length of string</span></span><br><span class="line">  <span class="keyword">var</span> length = data.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Loop through every character in data</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="comment">// Get character code.</span></span><br><span class="line">    <span class="keyword">var</span> char = data.<span class="title function_">charCodeAt</span>(i);</span><br><span class="line">    <span class="comment">// Make the hash</span></span><br><span class="line">    hash = ((hash &lt;&lt; <span class="number">5</span>) - hash) + char;</span><br><span class="line">    <span class="comment">// Convert to 32-bit integer</span></span><br><span class="line">    hash = hash &amp; hash;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hashIt</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> hash = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> length = data.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> char = data.<span class="title function_">charCodeAt</span>(i);</span><br><span class="line">    hash = ((hash &lt;&lt; <span class="number">5</span>) - hash) + char;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert to 32-bit integer</span></span><br><span class="line">    hash = hash &amp; hash;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="不要在代码库中遗留被注释掉的代码"><a href="#不要在代码库中遗留被注释掉的代码" class="headerlink" title="不要在代码库中遗留被注释掉的代码"></a>不要在代码库中遗留被注释掉的代码</h3><p>版本控制的存在是有原因的。让旧代码存在于你的 history 里吧。</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">doStuff</span>();</span><br><span class="line"><span class="comment">// doOtherStuff();</span></span><br><span class="line"><span class="comment">// doSomeMoreStuff();</span></span><br><span class="line"><span class="comment">// doSoMuchStuff();</span></span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">doStuff</span>();</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="不需要版本更新类型注释"><a href="#不需要版本更新类型注释" class="headerlink" title="不需要版本更新类型注释"></a>不需要版本更新类型注释</h3><p>记住，我们可以使用版本控制。废代码、被注释的代码及用注释记录代码中的版本更新说明都是没有必要的。</p>
<p>需要时可以使用 <code>git log</code> 获取历史版本。</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2016-12-20: Removed monads, didn&#x27;t understand them (RM)</span></span><br><span class="line"><span class="comment"> * 2016-10-01: Improved using special monads (JP)</span></span><br><span class="line"><span class="comment"> * 2016-02-03: Removed type-checking (LI)</span></span><br><span class="line"><span class="comment"> * 2015-03-14: Added combine with type-checking (JR)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">combine</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">combine</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="避免位置标记"><a href="#避免位置标记" class="headerlink" title="避免位置标记"></a>避免位置标记</h3><p>这些东西通常只能代码麻烦，采用适当的缩进就可以了。</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Scope Model Instantiation</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">let</span> $scope.<span class="property">model</span> = &#123;</span><br><span class="line">  <span class="attr">menu</span>: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">  <span class="attr">nav</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Action setup</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">let</span> actions = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> $scope.<span class="property">model</span> = &#123;</span><br><span class="line">  <span class="attr">menu</span>: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">  <span class="attr">nav</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> actions = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
<h3 id="避免在源文件中写入法律评论"><a href="#避免在源文件中写入法律评论" class="headerlink" title="避免在源文件中写入法律评论"></a>避免在源文件中写入法律评论</h3><p>将你的 <code>LICENSE</code> 文件置于源码目录树的根目录。</p>
<p><strong>反例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">The MIT License (MIT)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Copyright (c) 2016 Ryan McDermott</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Permission is hereby granted, free of charge, to any person obtaining a copy</span></span><br><span class="line"><span class="comment">of this software and associated documentation files (the &quot;Software&quot;), to deal</span></span><br><span class="line"><span class="comment">in the Software without restriction, including without limitation the rights</span></span><br><span class="line"><span class="comment">to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span></span><br><span class="line"><span class="comment">copies of the Software, and to permit persons to whom the Software is</span></span><br><span class="line"><span class="comment">furnished to do so, subject to the following conditions:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The above copyright notice and this permission notice shall be included in all</span></span><br><span class="line"><span class="comment">copies or substantial portions of the Software.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span></span><br><span class="line"><span class="comment">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span></span><br><span class="line"><span class="comment">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span></span><br><span class="line"><span class="comment">AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span></span><br><span class="line"><span class="comment">LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span></span><br><span class="line"><span class="comment">OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span></span><br><span class="line"><span class="comment">SOFTWARE</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calculateBill</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">calculateBill</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">回到目录</a></strong></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>风格指南</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript的内存空间</title>
    <url>/javascript/js%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<h3 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h3><p>众所众知，JavaScript是一种弱类型、动态语言。这意味着：</p>
<ul>
<li><p><strong>弱类型</strong>，意味着你不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型，JavaScript 引擎在运行代码的时候自己会计算出来。</p>
</li>
<li><p><strong>动态</strong>，意味着你可以使用同一个变量保存不同类型的数据。</p>
</li>
</ul>
<p>其实 JavaScript 中的数据类型一种有 8 种，它们分别是：</p>
<p><img src="/_posts/javascript/assets/js%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/image-20210720140409634.png" alt="image-20210720140409634"></p>
<p>我们把前面的 7 种数据类型称为<strong>原始类型</strong>，把最后一个对象类型称为<strong>引用类型</strong>，之所以把它们区分为两种不同的类型，<strong>是因为它们在内存中存放的位置不一样</strong></p>
<h3 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h3><p>要理解 JavaScript 在运行过程中数据是如何存储的，你就得先搞清楚其存储空间的种类。下面是JavaScript 的内存模型，可以参考：</p>
<p><img src="/_posts/javascript/assets/js%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/image-20210720140604983.png" alt="image-20210720140604983"></p>
<p> 在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是<strong>代码空间、栈空间</strong>和<strong>堆空间</strong></p>
<h4 id="栈空间和堆空间"><a href="#栈空间和堆空间" class="headerlink" title="栈空间和堆空间"></a>栈空间和堆空间</h4><p>这里的栈空间就是<strong>我们之前反复提及的调用栈，是用来存储执行上下文的</strong>。为了搞清楚栈空间是如何存储数据的，我们还是先看下面这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line"> var a = &quot; 极客时间 &quot;</span><br><span class="line"> var b = a</span><br><span class="line"> var c = &#123;name:&quot; 极客时间 &quot;&#125;</span><br><span class="line"> var d = c</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>最终分配好内存的示意图如下所示：</p>
<p><img src="/_posts/javascript/assets/js%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/image-20210720140826201.png" alt="image-20210720140826201"></p>
<p><strong>可以认为简单类型的值都是存放在栈空间中，对象类型是存放在堆空间的，在栈空间中只是保留了对象的引用地址</strong></p>
<h4 id="为什么一定要分堆和栈两个存储空间"><a href="#为什么一定要分堆和栈两个存储空间" class="headerlink" title="为什么一定要分堆和栈两个存储空间"></a>为什么一定要分堆和栈两个存储空间</h4><p>​ 这是因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。</p>
<p>​ 下面简单介绍一下上下文的切换，比如文中的 foo 函数执行结束了，JavaScript 引擎需要离开当前的执行上下文，只需要将指针下移到上个执行上下文的地址就可以了，foo 函数执行上下文栈区空间全部回收。</p>
<p><img src="/_posts/javascript/assets/js%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/image-20210720141334853.png" alt="image-20210720141334853"></p>
<h4 id="再谈闭包"><a href="#再谈闭包" class="headerlink" title="再谈闭包"></a>再谈闭包</h4><p>这里简单的探讨下闭包的内存模型，看下述代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line"> var myName = &quot; 极客时间 &quot;</span><br><span class="line"> let test1 = 1</span><br><span class="line"> const test2 = 2</span><br><span class="line"> var innerBar = &#123; </span><br><span class="line">  setName:function(newName)&#123;</span><br><span class="line">   myName = newName</span><br><span class="line">  &#125;,</span><br><span class="line">  getName:function()&#123;</span><br><span class="line">   console.log(test1)</span><br><span class="line">   return myName</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> return innerBar</span><br><span class="line">&#125;</span><br><span class="line">var bar = foo()</span><br><span class="line">bar.setName(&quot; 极客邦 &quot;)</span><br><span class="line">bar.getName()</span><br><span class="line">console.log(bar.getName())</span><br></pre></td></tr></table></figure>

<p>由闭包知识我们可以知道：了当 foo 函数的执行上下文销毁时，由于 foo 函数产生了闭包，所以变量 myName 和 test1 并没有被销毁，而是保存在内存中，那么应该如何解释这个现象呢？</p>
<p>要解释这个现象，我们就得站在内存模型的角度来分析这段代码的执行流程。</p>
<ul>
<li><p>当 JavaScript 引擎执行到 foo 函数时，首先会编译，并创建一个空执行上下文。</p>
</li>
<li><p>在编译过程中，遇到内部函数 setName，JavaScript 引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了 foo 函数中的 myName 变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建换一个“closure(foo)”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 myName 变量。</p>
</li>
<li><p>接着继续扫描到 getName 方法时，发现该函数内部还引用变量 test1，于是JavaScript 引擎又将 test1 添加到“closure(foo)”对象中。这时候堆中的“closure(foo)”对象中就包含了 myName 和 test1 两个变量了。</p>
</li>
<li><p>由于 test2 并没有被内部函数引用，所以 test2 依然保存在调用栈中。</p>
</li>
<li><p>当foo执行上下文销毁了，foo函数中的对closure(foo)的引用也断开了，但是setName和getName里面又重新建立起来了对closure(foo)引用</p>
<blockquote>
<ul>
<li>打开“开发者工具”</li>
<li>在控制台执行上述代码</li>
<li>然后选择“Memory”标签，点击”take snapshot” 获取V8的堆内存快照。</li>
<li>然后“command+f”(mac) 或者 “ctrl+f”(win),搜索“setName”，然后你就会发现setName对象下面包含了 <strong>raw_outer_scope_info_or_feedback_metadata</strong>，对闭包的引用数据就在这里面。（实际上也看不到闭包的数据）</li>
</ul>
</blockquote>
</li>
</ul>
<p><img src="/_posts/javascript/assets/js%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/image-20210720143331806.png" alt="image-20210720143331806"></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JavaScript的内存空间</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>词法作用域与动态作用域</title>
    <url>/javascript/%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log( a ); // 2</span><br><span class="line">&#125; </span><br><span class="line">function bar() &#123;</span><br><span class="line">  var a = 3;</span><br><span class="line">  foo(); </span><br><span class="line">&#125; </span><br><span class="line">var a = 2; </span><br><span class="line">bar();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h2><p>动态作用域让作用域作为一个在运行时就被动态确定的形式，而不是在写代码时进行静态确定的形式</p>
<blockquote>
<p>需要明确的是，<strong>事实上 JavaScript 并不具有动态作用域</strong>。它只有词法作用域，简单明了。 但是 this 机制某种程度上很像动态作用域。<br>主要区别：词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。（this 也是！）词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。</p>
</blockquote>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>作用域</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title>变量提升的本质</title>
    <url>/javascript/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E7%9A%84%E6%9C%AC%E8%B4%A8/</url>
    <content><![CDATA[<h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">showName()</span><br><span class="line">console.log(myname)</span><br><span class="line">var myname = &#x27;极客时间&#x27;</span><br><span class="line">function showName() &#123;</span><br><span class="line"> console.log(&#x27;函数 showName 被执行&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">// 函数 showName 被执行</span><br><span class="line">// undefined</span><br></pre></td></tr></table></figure>

<p>最后输出的结果不太符合预期，其中的本质与js的执行过程有关，这种现象被称为变量提升</p>
<p><strong>所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined。</strong></p>
<blockquote>
<p>声明部分 指 var myname &#x3D; 这部分 以及 完整的函数声明</p>
<p>var bar &#x3D; function(){} 这种与var bar &#x3D; 1 并无大的区别，与function bar(){} 从编译过程来说截然不同</p>
</blockquote>
<p><strong>实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中</strong></p>
<h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p><img src="/_posts/javascript/assets/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20210719142421766.png" alt="image-20210719142421766"></p>
<p>从上图可以看出，输入一段代码，经过编译后，会生成两部分内容：<strong>执行上下文（Execution context）和可执行代码</strong>。</p>
<blockquote>
<p>执行上下文也是一个特别重要的概念，会在后边具体分析</p>
</blockquote>
<p>由此不难分析出打印的结果，但是如果存在<strong>相同的命名</strong>怎么处理，可以参考下述规则：</p>
<ul>
<li><p>如果是同名的函数，JavaScript编译阶段会选择最后声明的那个。</p>
</li>
<li><p>如果变量和函数同名，那么在编译阶段，变量的声明会被忽略</p>
</li>
</ul>
<h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>执行上下文（以下简称“上下文”）的概念在 JavaScript 中是颇为重要的。变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的<strong>变量对象</strong>（variable object），而这个上下文中定义的所有变量和函数都存在于这个对象上。</p>
<p><strong>执行上下文的组成代码示例：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const ExecutionContextObj = &#123;</span><br><span class="line">    VO: window, // 变量对象</span><br><span class="line">    ScopeChain: &#123;&#125;, // 作用域链</span><br><span class="line">    this: window</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>执行上下文的组成图例示例：</strong></p>
<p><img src="/_posts/javascript/assets/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E7%9A%84%E6%9C%AC%E8%B4%A8/v2-197a2714b1f1069f3fffebcdd630531c_1440w.jpg" alt="img"></p>
<p>**上下文基本上有三类(包括ES6)**：</p>
<ul>
<li>全局上下文 在浏览器环境下即为window</li>
<li>函数上下文（当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文）</li>
<li>eval上下文 （不考虑）</li>
</ul>
<p>上下文中的代码在执行的时候，会创建<strong>变量对象</strong>的一个<strong>作用域链</strong>。</p>
<blockquote>
<p>作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象</p>
</blockquote>
<h4 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h4><p><strong>如果上下文是函数，则其活动对象（activation object）用作变量对象，下面以函数为例具体分析一下</strong></p>
<blockquote>
<p>为什么称其为活动对象呢，因为只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，并且只有被激活的变量对象，其属性才能被访问。</p>
</blockquote>
<p>以下面的例子为例，结合着之前讲的变量对象和执行上下文栈，我们来总结一下函数执行上下文中作用域链和变量对象的创建过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var scope = &#x27;global scope&#x27;;</span><br><span class="line">function checkscope(s) &#123;  </span><br><span class="line"> var scope = &#x27;local scope&#x27;;  </span><br><span class="line"> function f() &#123;    </span><br><span class="line">  return scope;</span><br><span class="line">  &#125;  </span><br><span class="line">  return f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope(&#x27;scope&#x27;);</span><br></pre></td></tr></table></figure>

<p>执行过程如下：</p>
<p>1.checkscope 函数被创建，保存作用域链到 内部属性<code>[[scope]]</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">checkscope.[[scope]] = [</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>2.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    checkscopeContext,</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>3.checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数<code>[[scope]]</code>属性创建<strong>作用域链</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    Scope: checkscope.[[scope]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">          0: &#x27;scope&#x27;,</span><br><span class="line">          length: 1,</span><br><span class="line">        &#125;,</span><br><span class="line">        s: &#x27;scope&#x27;, // 传入的参数</span><br><span class="line">        f: pointer to function f(),</span><br><span class="line">        scope: undefined, // 此时声明的变量为undefined</span><br><span class="line">    &#125;，</span><br><span class="line">    Scope: checkscope.[[scope]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.第三步：将活动对象压入 checkscope 作用域链顶端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">          0: &#x27;scope&#x27;,</span><br><span class="line">          length: 1,</span><br><span class="line">        &#125;,</span><br><span class="line">        s: &#x27;scope&#x27;, // 传入的参数</span><br><span class="line">        f: pointer to function f(),</span><br><span class="line">        scope: undefined, // 此时声明的变量为undefined</span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, [[Scope]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">          0: &#x27;scope&#x27;,</span><br><span class="line">          length: 1,</span><br><span class="line">        &#125;,</span><br><span class="line">        s: &#x27;scope&#x27;, // 传入的参数</span><br><span class="line">        f: pointer to function f(),</span><br><span class="line">        scope: &#x27;local scope&#x27;, // 变量赋值</span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, [[Scope]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h4 id="执行上下文的维护"><a href="#执行上下文的维护" class="headerlink" title="执行上下文的维护"></a>执行上下文的维护</h4><p>说在执行 JavaScript 时，可能会存在多个执行上下文，那么 JavaScript 引擎是如何管理这些执行上下文的呢？</p>
<p>答案是<strong>通过一种叫栈的数据结构来管理的</strong>。</p>
<p>JavaScript 引擎正是利用栈的这种结构来管理执行上下文的。在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为<strong>执行上下文栈，又称调用栈</strong>。</p>
<p>看如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 2</span><br><span class="line">function add(b,c)&#123;</span><br><span class="line"> return b+c</span><br><span class="line">&#125; </span><br><span class="line">function addAll(b,c)&#123;</span><br><span class="line"> var d = 10</span><br><span class="line"> result = add(b,c)</span><br><span class="line"> return a+result+d</span><br><span class="line">&#125;</span><br><span class="line">addAll(3,6)</span><br></pre></td></tr></table></figure>

<p><strong>第一步，创建全局上下文，并将其压入栈底</strong>。</p>
<p><img src="/_posts/javascript/assets/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20210719153100763.png" alt="image-20210719153100763"></p>
<p><strong>第二步是调用 addAll 函数</strong>。当调用该函数时，JavaScript 引擎会编译该函数，并为其创建一个执行上下文，最后还将该函数的执行上下文压入栈中，如下图所示：</p>
<p><img src="/_posts/javascript/assets/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20210719153303513.png" alt="image-20210719153303513"></p>
<p><strong>第三步，当执行到 add 函数</strong>调用语句时，同样会为其创建执行上下文，并将其压入调用栈，如下图所示：</p>
<p><img src="/_posts/javascript/assets/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20210719153352832.png" alt="image-20210719153352832"></p>
<p>当 add 函数返回时，该函数的执行上下文就会从栈顶弹出，并将 result 的值设置为 add函数的返回值，也就是 9。如下图所示：</p>
<p><img src="/_posts/javascript/assets/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20210719153501404.png" alt="image-20210719153501404"></p>
<p>紧接着 addAll 执行最后一个相加操作后并返回，addAll 的执行上下文也会从栈顶部弹出，此时调用栈中就只剩下全局上下文了。最终如下图所示：</p>
<p><img src="/_posts/javascript/assets/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20210719153551914.png" alt="image-20210719153551914"></p>
<p>至此，整个 JavaScript 流程执行结束了。</p>
<blockquote>
<p>调用栈的跟踪可以借助chorme调试工具中的call stack 或者借助 console.trace()</p>
</blockquote>
<h4 id="解决变量提升的弊端"><a href="#解决变量提升的弊端" class="headerlink" title="解决变量提升的弊端"></a>解决变量提升的弊端</h4><p>ES6 通过 let const 解决了变量提升的问题，那么 ES6 又是如何在函数级作用域的基础之上，实现对块级作用域的支持呢？</p>
<p>变量对象应该包括 变量环境 和 词法环境</p>
<p>下面我们来看如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  var a = 1</span><br><span class="line">  let b = 2</span><br><span class="line">  &#123;</span><br><span class="line">    let b = 3</span><br><span class="line">    var c = 4</span><br><span class="line">    let d = 5</span><br><span class="line">    console.log(a)</span><br><span class="line">    console.log(b)</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(b)</span><br><span class="line">  console.log(c)</span><br><span class="line">  console.log(d)</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p><strong>第一步是编译并创建执行上下文</strong>，下面是我画出来的执行上下文示意图，你可以参考下：</p>
<p><img src="/_posts/javascript/assets/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20210719180147793.png" alt="image-20210719180147793"></p>
<p>通过上图，我们可以得出以下结论：</p>
<ul>
<li><p>函数内部通过 var 声明的变量，在编译阶段全都被存放到<strong>变量环境</strong>里面了。</p>
</li>
<li><p>通过 let 声明的变量，在编译阶段会被存放到<strong>词法环境（Lexical Environment）</strong>中。</p>
</li>
<li><p>在函数的作用域内部，通过 let 声明的变量并（<strong>暂时</strong>）没有被存放到词法环境中。</p>
</li>
</ul>
<p>接下来，<strong>第二步继续执行代码</strong>，当执行到代码块里面时，变量环境中 a 的值已经被设置成了 1，词法环境中 b 的值已经被设置成了 2，这时候函数的执行上下文就如下图所示：</p>
<p><img src="/_posts/javascript/assets/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20210719180806940.png" alt="image-20210719180806940"></p>
<p>​ 从图中可以看出，当进入函数的作用域块时，作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量，比如在作用域外面声明了变量 b，在该作用域块内部也声明了变量 b，当执行到作用域内部时，它们都是独立的存在。</p>
<p>​ 其实，<strong>在词法环境内部，维护了一个小型栈结构</strong>，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。需要注意下，我这里所讲的变量是指通过 let 或者 const 声明的变量。</p>
<p>​ 再接下来，当执行到作用域块中的console.log(a)这行代码时，就需要在词法环境和变量环境中查找变量 a 的值了，具体查找方式是：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，那么继续在变量环境中查找。</p>
<p><img src="/_posts/javascript/assets/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20210719181101068.png" alt="image-20210719181101068"></p>
<p>当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出，最终执行上下文</p>
<p>如下图所示：</p>
<p><img src="/_posts/javascript/assets/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E7%9A%84%E6%9C%AC%E8%B4%A8/image-20210719181919678.png" alt="image-20210719181919678"></p>
<p>通过上面的分析，想必你已经理解了词法环境的结构和工作机制，<strong>块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现</strong>，通过这两者的结合，JavaScript 引擎也就同时支持了变量提升和块级作用域了。</p>
<h4 id="查缺补漏–优秀blog文章"><a href="#查缺补漏–优秀blog文章" class="headerlink" title="查缺补漏–优秀blog文章"></a>查缺补漏–优秀blog文章</h4><ol>
<li><h4 id="JavaScript深入之执行上下文栈"><a href="#JavaScript深入之执行上下文栈" class="headerlink" title="JavaScript深入之执行上下文栈"></a><a href="https://github.com/mqyqingfeng/Blog/issues/4">JavaScript深入之执行上下文栈</a></h4></li>
<li><h4 id="JavaScript深入之变量对象"><a href="#JavaScript深入之变量对象" class="headerlink" title="JavaScript深入之变量对象"></a><a href="https://github.com/mqyqingfeng/Blog/issues/5">JavaScript深入之变量对象</a></h4></li>
<li><h4 id="JavaScript深入之作用域链"><a href="#JavaScript深入之作用域链" class="headerlink" title="JavaScript深入之作用域链"></a><a href="https://github.com/mqyqingfeng/Blog/issues/6">JavaScript深入之作用域链</a></h4></li>
</ol>
<blockquote>
<p>该作者其余文章  <a href="https://github.com/mqyqingfeng/Blog">https://github.com/mqyqingfeng/Blog</a></p>
</blockquote>
<h4 id="Tips-为了防止链接失效，请看-深入执行上下文"><a href="#Tips-为了防止链接失效，请看-深入执行上下文" class="headerlink" title="Tips 为了防止链接失效，请看 深入执行上下文"></a>Tips 为了防止链接失效，请看 深入执行上下文</h4>]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>变量提升</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的阐述原型链</title>
    <url>/javascript/%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<h2 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h2><p>我们先使用构造函数创建一个对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var person = new Person();</span><br><span class="line">person.name = &#x27;Kevin&#x27;;</span><br><span class="line">console.log(person.name) // Kevin</span><br></pre></td></tr></table></figure>

<p>在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。</p>
<p>很简单吧，接下来进入正题：</p>
<h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>每个函数都有一个 prototype 属性，就是我们经常在各种例子中看到的那个 prototype ，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 虽然写在注释里，但是你要注意：</span><br><span class="line">// prototype是函数才会有的属性</span><br><span class="line">Person.prototype.name = &#x27;Kevin&#x27;;</span><br><span class="line">var person1 = new Person();</span><br><span class="line">var person2 = new Person();</span><br><span class="line">console.log(person1.name) // Kevin</span><br><span class="line">console.log(person2.name) // Kevin</span><br></pre></td></tr></table></figure>

<p>那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？</p>
<p>其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的<strong>实例</strong>的原型，也就是这个例子中的 person1 和 person2 的原型。</p>
<p>那什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。</p>
<p>让我们用一张图表示构造函数和实例原型之间的关系：</p>
<p><a href="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype1.png"><img src="/_posts/javascript/assets/https:/github.com/mqyqingfeng/Blog/raw/master/Images/prototype1.png" alt="构造函数和实例原型的关系图"></a></p>
<p>在这张图中我们用 Object.prototype 表示实例原型。</p>
<p>那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性：</p>
<h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h2><p>这是每一个JavaScript对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。</p>
<p>为了证明这一点,我们可以在火狐或者谷歌中输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var person = new Person();</span><br><span class="line">console.log(person.__proto__ === Person.prototype); // true</span><br></pre></td></tr></table></figure>

<p>于是我们更新下关系图：</p>
<p><a href="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype2.png"><img src="/_posts/javascript/assets/%E5%8E%9F%E5%9E%8B%E9%93%BE/prototype2.png" alt="实例与实例原型的关系图"></a></p>
<p>既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？</p>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor，每个原型都有一个 constructor 属性指向关联的构造函数。</p>
<p>为了验证这一点，我们可以尝试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(Person === Person.prototype.constructor); // true</span><br></pre></td></tr></table></figure>

<p>所以再更新下关系图：</p>
<p><a href="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype3.png"><img src="/_posts/javascript/assets/%E5%8E%9F%E5%9E%8B%E9%93%BE/prototype3.png" alt="实例原型与构造函数的关系图"></a></p>
<p>综上我们已经得出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person();</span><br><span class="line"></span><br><span class="line">console.log(person.__proto__ == Person.prototype) // true</span><br><span class="line">console.log(Person.prototype.constructor == Person) // true</span><br><span class="line">// 顺便学习一个ES5的方法,可以获得对象的原型</span><br><span class="line">console.log(Object.getPrototypeOf(person) === Person.prototype) // true</span><br></pre></td></tr></table></figure>

<p>了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系：</p>
<h2 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h2><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = &#x27;Kevin&#x27;;</span><br><span class="line"></span><br><span class="line">var person = new Person();</span><br><span class="line"></span><br><span class="line">person.name = &#x27;Daisy&#x27;;</span><br><span class="line">console.log(person.name) // Daisy</span><br><span class="line"></span><br><span class="line">delete person.name;</span><br><span class="line">console.log(person.name) // Kevin</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。</p>
<p>但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.<strong>proto</strong> ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。</p>
<p>但是万一还没有找到呢？原型的原型又是什么呢？</p>
<h2 id="原型的原型"><a href="#原型的原型" class="headerlink" title="原型的原型"></a>原型的原型</h2><p>在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = new Object();</span><br><span class="line">obj.name = &#x27;Kevin&#x27;</span><br><span class="line">console.log(obj.name) // Kevin</span><br></pre></td></tr></table></figure>

<p>其实原型对象就是通过 Object 构造函数生成的，结合之前所讲，实例的 <strong>proto</strong> 指向构造函数的 prototype ，所以我们再更新下关系图：</p>
<p><a href="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype4.png"><img src="/_posts/javascript/assets/%E5%8E%9F%E5%9E%8B%E9%93%BE/prototype4.png" alt="原型的原型关系图"></a></p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>那 Object.prototype 的原型呢？</p>
<p>null，我们可以打印：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(Object.prototype.__proto__ === null) // true</span><br></pre></td></tr></table></figure>

<p>然而 null 究竟代表了什么呢？</p>
<p>引用阮一峰老师的 <a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html">《undefined与null的区别》</a> 就是：</p>
<blockquote>
<p>null 表示“没有对象”，即该处不应该有值。</p>
</blockquote>
<p>所以 Object.prototype.<strong>proto</strong> 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。</p>
<p>所以查找属性的时候查到 Object.prototype 就可以停止查找了。</p>
<p>最后一张关系图也可以更新为：</p>
<p><a href="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype5.png"><img src="/_posts/javascript/assets/https:/github.com/mqyqingfeng/Blog/raw/master/Images/prototype5.png" alt="原型链示意图"></a></p>
<p>顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>最后，补充三点大家可能不会注意的地方：</p>
<h3 id="constructor"><a href="#constructor" class="headerlink" title="constructor"></a>constructor</h3><p>首先是 constructor 属性，我们看个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var person = new Person();</span><br><span class="line">console.log(person.constructor === Person); // true</span><br></pre></td></tr></table></figure>

<p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">person.constructor === Person.prototype.constructor</span><br></pre></td></tr></table></figure>

<h3 id="proto-1"><a href="#proto-1" class="headerlink" title="proto"></a><strong>proto</strong></h3><p>其次是 <strong>proto</strong> ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter&#x2F;setter，当使用 obj.<strong>proto</strong> 时，可以理解成返回了 Object.getPrototypeOf(obj)。</p>
<h3 id="真的是继承吗？"><a href="#真的是继承吗？" class="headerlink" title="真的是继承吗？"></a>真的是继承吗？</h3><p>最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》 上册中的话，就是：</p>
<p>​ 继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title>深入执行上下文</title>
    <url>/javascript/%E6%B7%B1%E5%85%A5%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<p>转载于  <a href="https://github.com/mqyqingfeng/Blog">https://github.com/mqyqingfeng/Blog</a></p>
<h3 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h3><h4 id="顺序执行？"><a href="#顺序执行？" class="headerlink" title="顺序执行？"></a>顺序执行？</h4><p>如果要问到 JavaScript 代码执行顺序的话，想必写过 JavaScript 的开发者都会有个直观的印象，那就是顺序执行，毕竟：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var foo = function () &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&#x27;foo1&#x27;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();  // foo1</span><br><span class="line"></span><br><span class="line">var foo = function () &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&#x27;foo2&#x27;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); // foo2</span><br></pre></td></tr></table></figure>

<p>然而去看这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&#x27;foo1&#x27;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();  // foo2</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&#x27;foo2&#x27;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); // foo2</span><br></pre></td></tr></table></figure>

<p>打印的结果却是两个 <code>foo2</code>。</p>
<p>刷过面试题的都知道这是因为 JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”，比如第一个例子中的变量提升，和第二个例子中的函数提升。</p>
<p>但是本文真正想让大家思考的是：这个“一段一段”中的“段”究竟是怎么划分的呢？</p>
<p>到底JavaScript引擎遇到一段怎样的代码时才会做“准备工作”呢？</p>
<h4 id="可执行代码"><a href="#可执行代码" class="headerlink" title="可执行代码"></a>可执行代码</h4><p>这就要说到 JavaScript 的可执行代码(executable code)的类型有哪些了？</p>
<p>其实很简单，就三种，全局代码、函数代码、eval代码。</p>
<p>举个例子，当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做”执行上下文(execution context)”。</p>
<h4 id="执行上下文栈-1"><a href="#执行上下文栈-1" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h4><p>接下来问题来了，我们写的函数多了去了，如何管理创建的那么多执行上下文呢？</p>
<p>所以 JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文</p>
<p>为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ECStack = [];</span><br></pre></td></tr></table></figure>

<p>试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 globalContext：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>现在 JavaScript 遇到下面的这段代码了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fun3() &#123;</span><br><span class="line">    console.log(&#x27;fun3&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fun2() &#123;</span><br><span class="line">    fun3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fun1() &#123;</span><br><span class="line">    fun2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun1();</span><br></pre></td></tr></table></figure>

<p>当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。知道了这样的工作原理，让我们来看看如何处理上面这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 伪代码</span><br><span class="line"></span><br><span class="line">// fun1()</span><br><span class="line">ECStack.push(&lt;fun1&gt; functionContext);</span><br><span class="line"></span><br><span class="line">// fun1中竟然调用了fun2，还要创建fun2的执行上下文</span><br><span class="line">ECStack.push(&lt;fun2&gt; functionContext);</span><br><span class="line"></span><br><span class="line">// 擦，fun2还调用了fun3！</span><br><span class="line">ECStack.push(&lt;fun3&gt; functionContext);</span><br><span class="line"></span><br><span class="line">// fun3执行完毕</span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br><span class="line">// fun2执行完毕</span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br><span class="line">// fun1执行完毕</span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br><span class="line">// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext</span><br></pre></td></tr></table></figure>

<h4 id="解答思考题"><a href="#解答思考题" class="headerlink" title="解答思考题"></a>解答思考题</h4><p>好啦，现在我们已经了解了执行上下文栈是如何处理执行上下文的，所以让我们看看上篇文章<a href="https://github.com/mqyqingfeng/Blog/issues/3">《JavaScript深入之词法作用域和动态作用域》</a>最后的问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var scope = &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope = &quot;local scope&quot;;</span><br><span class="line">    function f()&#123;</span><br><span class="line">        return scope;</span><br><span class="line">    &#125;</span><br><span class="line">    return f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br><span class="line">var scope = &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope = &quot;local scope&quot;;</span><br><span class="line">    function f()&#123;</span><br><span class="line">        return scope;</span><br><span class="line">    &#125;</span><br><span class="line">    return f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()();</span><br></pre></td></tr></table></figure>

<p>两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？</p>
<p>答案就是执行上下文栈的变化不一样。</p>
<p>让我们模拟第一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ECStack.push(&lt;checkscope&gt; functionContext);</span><br><span class="line">ECStack.push(&lt;f&gt; functionContext);</span><br><span class="line">ECStack.pop();</span><br><span class="line">ECStack.pop();</span><br></pre></td></tr></table></figure>

<p>让我们模拟第二段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ECStack.push(&lt;checkscope&gt; functionContext);</span><br><span class="line">ECStack.pop();</span><br><span class="line">ECStack.push(&lt;f&gt; functionContext);</span><br><span class="line">ECStack.pop();</span><br></pre></td></tr></table></figure>

<p>是不是有些不同呢？</p>
<p>当然了，这样概括的回答执行上下文栈的变化不同，是不是依然有一种意犹未尽的感觉呢，为了更详细讲解两个函数执行上的区别，我们需要探究一下执行上下文到底包含了哪些内容，所以欢迎阅读下一篇《JavaScript深入之变量对象》。</p>
<h3 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在上篇<a href="https://github.com/mqyqingfeng/Blog/issues/4">《JavaScript深入之执行上下文栈》</a>中讲到，当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。</p>
<p>对于每个执行上下文，都有三个重要属性：</p>
<ul>
<li>变量对象(Variable object，VO)</li>
<li>作用域链(Scope chain)</li>
<li>this</li>
</ul>
<p>今天重点讲讲创建变量对象的过程。</p>
<h4 id="变量对象-1"><a href="#变量对象-1" class="headerlink" title="变量对象"></a>变量对象</h4><p>变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。</p>
<p>因为不同执行上下文下的变量对象稍有不同，所以我们来聊聊全局上下文下的变量对象和函数上下文下的变量对象。</p>
<h4 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h4><p>我们先了解一个概念，叫全局对象。在 <a href="http://www.w3school.com.cn/jsref/jsref_obj_global.asp">W3School</a> 中也有介绍：</p>
<blockquote>
<p>全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。</p>
</blockquote>
<blockquote>
<p>在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。</p>
</blockquote>
<blockquote>
<p>例如，当JavaScript 代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 属性。全局对象是作用域链的头，还意味着在顶层 JavaScript 代码中声明的所有变量都将成为全局对象的属性。</p>
</blockquote>
<p>如果看的不是很懂的话，容我再来介绍下全局对象:</p>
<p>1.可以通过 this 引用，在客户端 JavaScript 中，全局对象就是 Window 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(this);</span><br></pre></td></tr></table></figure>

<p>2.全局对象是由 Object 构造函数实例化的一个对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(this instanceof Object);</span><br></pre></td></tr></table></figure>

<p>3.预定义了一堆，嗯，一大堆函数和属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 都能生效</span><br><span class="line">console.log(Math.random());</span><br><span class="line">console.log(this.Math.random());</span><br></pre></td></tr></table></figure>

<p>4.作为全局变量的宿主。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">console.log(this.a);</span><br></pre></td></tr></table></figure>

<p>5.客户端 JavaScript 中，全局对象有 window 属性指向自身。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">console.log(window.a);</span><br><span class="line"></span><br><span class="line">this.window.b = 2;</span><br><span class="line">console.log(this.b);</span><br></pre></td></tr></table></figure>

<p>花了一个大篇幅介绍全局对象，其实就想说：</p>
<p>全局上下文中的变量对象就是全局对象呐！</p>
<h4 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h4><p>在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。</p>
<p>活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。</p>
<p>活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。</p>
<h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><p>执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做：</p>
<ol>
<li>进入执行上下文</li>
<li>代码执行</li>
</ol>
<h4 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h4><p>当进入执行上下文时，这时候还没有执行代码，</p>
<p>变量对象会包括：</p>
<ol>
<li>函数的所有形参 (如果是函数上下文)<ul>
<li>由名称和对应值组成的一个变量对象的属性被创建</li>
<li>没有实参，属性值设为 undefined</li>
</ul>
</li>
<li>函数声明<ul>
<li>由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建</li>
<li>如果变量对象已经存在相同名称的属性，则完全替换这个属性</li>
</ul>
</li>
<li>变量声明<ul>
<li>由名称和对应值（undefined）组成一个变量对象的属性被创建；</li>
<li>如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</li>
</ul>
</li>
</ol>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line">  var b = 2;</span><br><span class="line">  function c() &#123;&#125;</span><br><span class="line">  var d = function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  b = 3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(1);</span><br></pre></td></tr></table></figure>

<p>在进入执行上下文后，这时候的 AO 是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: 1,</span><br><span class="line">        length: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    a: 1,</span><br><span class="line">    b: undefined,</span><br><span class="line">    c: reference to function c()&#123;&#125;,</span><br><span class="line">    d: undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h4><p>在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值</p>
<p>还是上面的例子，当代码执行完后，这时候的 AO 是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: 1,</span><br><span class="line">        length: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 3,</span><br><span class="line">    c: reference to function c()&#123;&#125;,</span><br><span class="line">    d: reference to FunctionExpression &quot;d&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里变量对象的创建过程就介绍完了，让我们简洁的总结我们上述所说：</p>
<ol>
<li>全局上下文的变量对象初始化是全局对象</li>
<li>函数上下文的变量对象初始化只包括 Arguments 对象</li>
<li>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</li>
<li>在代码执行阶段，会再次修改变量对象的属性值</li>
</ol>
<h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p>最后让我们看几个例子：</p>
<p>1.第一题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    a = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); // ???</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    a = 1;</span><br><span class="line">    console.log(a);</span><br><span class="line">&#125;</span><br><span class="line">bar(); // ???</span><br></pre></td></tr></table></figure>

<p>第一段会报错：<code>Uncaught ReferenceError: a is not defined</code>。</p>
<p>第二段会打印：<code>1</code>。</p>
<p>这是因为函数中的 “a” 并没有通过 var 关键字声明，所有不会被存放在 AO 中。</p>
<p>第一段执行 console 的时候， AO 的值是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        length: 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有 a 的值，然后就会到全局去找，全局也没有，所以会报错。</p>
<p>当第二段执行 console 的时候，全局对象已经被赋予了 a 属性，这时候就可以从全局找到 a 的值，所以会打印 1。</p>
<p>2.第二题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(foo);</span><br><span class="line"></span><br><span class="line">function foo()&#123;</span><br><span class="line">    console.log(&quot;foo&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo = 1;</span><br></pre></td></tr></table></figure>

<p>会打印函数，而不是 undefined 。</p>
<p>这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。</p>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p><strong>补充：</strong><a href="https://time.geekbang.org/column/article/127495">极客时间</a></p>
<h4 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h4><p>在<a href="https://github.com/mqyqingfeng/Blog/issues/4">《JavaScript深入之执行上下文栈》</a>中讲到，当JavaScript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。</p>
<p>对于每个执行上下文，都有三个重要属性：</p>
<ul>
<li>变量对象(Variable object，VO)</li>
<li>作用域链(Scope chain)</li>
<li>this</li>
</ul>
<p>今天重点讲讲作用域链。</p>
<h4 id="作用域链-1"><a href="#作用域链-1" class="headerlink" title="作用域链"></a>作用域链</h4><p>在<a href="https://github.com/mqyqingfeng/Blog/issues/5">《JavaScript深入之变量对象》</a>中讲到，当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p>
<p>下面，让我们以一个函数的创建和激活两个时期来讲解作用域链是如何创建和变化的。</p>
<h4 id="函数创建"><a href="#函数创建" class="headerlink" title="函数创建"></a>函数创建</h4><p>在<a href="https://github.com/mqyqingfeng/Blog/issues/3">《JavaScript深入之词法作用域和动态作用域》</a>中讲到，函数的作用域在函数定义的时候就决定了。</p>
<p>这是因为函数有一个内部属性 <code>[[scope]]</code>，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 <code>[[scope]]</code> 就是所有父变量对象的层级链，但是注意：<code>[[scope]]</code> 并不代表完整的作用域链！</p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    function bar() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数创建时，各自的<code>[[scope]]</code>为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">foo.[[scope]] = [</span><br><span class="line">  globalContext.VO</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">bar.[[scope]] = [</span><br><span class="line">    fooContext.AO,</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h4 id="函数激活"><a href="#函数激活" class="headerlink" title="函数激活"></a>函数激活</h4><p>当函数激活时，进入函数上下文，创建 VO&#x2F;AO 后，就会将活动对象添加到作用链的前端。</p>
<p>这时候执行上下文的作用域链，我们命名为 Scope：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Scope = [AO].concat([[Scope]]);</span><br></pre></td></tr></table></figure>

<p>至此，作用域链创建完毕。</p>
<h4 id="捋一捋"><a href="#捋一捋" class="headerlink" title="捋一捋"></a>捋一捋</h4><p>以下面的例子为例，结合着之前讲的变量对象和执行上下文栈，我们来总结一下函数执行上下文中作用域链和变量对象的创建过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var scope = &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope2 = &#x27;local scope&#x27;;</span><br><span class="line">    return scope2;</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure>

<p>执行过程如下：</p>
<p>1.checkscope 函数被创建，保存作用域链到内部属性<code>[[scope]]</code>，所以<strong>说函数创建的时候已经确定了哪些变量可以被访问到</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">checkscope.[[scope]] = [</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>2.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    checkscopeContext,</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>3.checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数<code>[[scope]]</code>属性创建作用域链</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    Scope: checkscope.[[scope]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            length: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        scope2: undefined</span><br><span class="line">    &#125;，</span><br><span class="line">    Scope: checkscope.[[scope]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.第三步：将活动对象压入 checkscope 作用域链顶端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            length: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        scope2: undefined</span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, [[Scope]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            length: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        scope2: &#x27;local scope&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, [[Scope]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p><a href="/javascript/this/this">可以看这个</a></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>执行上下文</tag>
        <tag>作用域链</tag>
        <tag>变量对象</tag>
        <tag>活动对象</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包</title>
    <url>/javascript/%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<p>补充： <a href="https://time.geekbang.org/column/article/127495">极客时间</a></p>
<p>看着简单，实际隐藏了很多东西</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function count()&#123;</span><br><span class="line">    let countNum = 0</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">        return ++countNum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//独立</span><br><span class="line">console.log((count())()); //1</span><br><span class="line">console.log((count())()); //1</span><br><span class="line">console.log((count())()); //1</span><br><span class="line">//闭包</span><br><span class="line">let countFunc = count()</span><br><span class="line">console.log(countFunc()); //1</span><br><span class="line">console.log(countFunc()); //2</span><br><span class="line">console.log(countFunc()); //3</span><br></pre></td></tr></table></figure>

<p>直接写成自执行函数，更加简单</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const countUp = (() =&gt; &#123;</span><br><span class="line">  let count = 0;</span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    return ++count;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line">console.log(countUp()); // 1</span><br><span class="line">console.log(countUp()); // 2</span><br></pre></td></tr></table></figure>

<h2 id="闭包和this"><a href="#闭包和this" class="headerlink" title="闭包和this"></a>闭包和this</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var name = &quot;The Window&quot;; </span><br><span class="line">var object = &#123;     </span><br><span class="line">    name : &quot;My Object&quot;, </span><br><span class="line">    getNameFunc : function()&#123;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            return this.name;</span><br><span class="line">        &#125;;     </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line">alert(object.getNameFunc()());  //&quot;The Window&quot;（在非严格模式下）</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述代码，看似利用闭包得到了想要的this指向，实际上并不是<br>每个函数在被调用时都会自动取得两个特殊变量：this 和 arguments。内部函数在搜索这两个变量时，<strong>只会搜索到其活动对象为止</strong>，因此永远不可能直接访问外部函数中的这两个变量</p>
</blockquote>
<h2 id="控制台看闭包"><a href="#控制台看闭包" class="headerlink" title="控制台看闭包"></a>控制台看闭包</h2><p>一图胜千言</p>
<p><img src="/_posts/javascript/assets/%E9%97%AD%E5%8C%85/image-20210720105848139.png" alt="image-20210720105848139"></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>对象属性方法总结</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>总结一下方便记忆</p>
<ul>
<li>in 操作符 所有属性都可以访问到，<strong>下面就不提及in操作符了</strong></li>
<li>继承属性<ul>
<li>只有for in 可以访问</li>
</ul>
</li>
<li>不可枚举属性<ul>
<li>只有Object(Reflect).getOwnPropertyXXXX静态方法可以访问到</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">不可枚举属性</th>
<th align="center">继承属性</th>
<th align="center">symbol属性</th>
<th align="center">自身属性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">in</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">for…in</td>
<td align="center">❌</td>
<td align="center">✅</td>
<td align="center">❌</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">JSON.stringfy()</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">Object.assign()</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">… 扩展运算符</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">Object.keys()、Object.values()、Object.entries()</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">Object.getOwnPropertyNames()</td>
<td align="center">✅</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">Object.getOwnPropertySymbols(obj)</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">✅</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">Reflect.ownKeys(obj)</td>
<td align="center">✅</td>
<td align="center">❌</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">Object.getOwnPropertyDescriptor(s)</td>
<td align="center">✅</td>
<td align="center">❌</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">Object.hasOwn(s)</td>
<td align="center">✅</td>
<td align="center">❌</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">Object.prototype.hasOwnProperty(s)</td>
<td align="center">✅</td>
<td align="center">❌</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
</tbody></table>
<style>
table th:nth-of-type(1){
  width: 40%;
}
table th:nth-of-type(2){
width: 15%;
}
table th:nth-of-type(3){
width: 15%;
}
table th:nth-of-type(4){
width: 15%;
}
table th:nth-of-type(5){
width: 15%;
}
</style>
<p><strong>下面是验证代码</strong>,首先创建一个测试对象，拥有</p>
<ul>
<li>self自身属性</li>
<li>parent继承属性</li>
<li>sym symbol属性</li>
<li>noEnumerable 不可枚举属性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const parent = &#123;</span><br><span class="line">  parent: &#x27;parent&#x27;</span><br><span class="line">&#125;</span><br><span class="line">const sym = Symbol(&quot;sym&quot;)</span><br><span class="line">// 很重要的一个点</span><br><span class="line">// 在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中</span><br><span class="line">const child = &#123;</span><br><span class="line">  self: &#x27;self&#x27;,</span><br><span class="line">  [sym]: &quot;Symbol&quot;</span><br><span class="line">&#125;</span><br><span class="line">Object.setPrototypeOf(child, parent)</span><br><span class="line"></span><br><span class="line">Object.defineProperty(child, &#x27;noEnumerable&#x27;, &#123;</span><br><span class="line">  enumerable: false,</span><br><span class="line">  value: 0</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>测试代码如下，在nodejs 14+环境下运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&quot;\n for ... in \n&quot;);</span><br><span class="line"></span><br><span class="line">for (const key in child) &#123;</span><br><span class="line">  console.log(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&quot;\n in \n&quot;);</span><br><span class="line"></span><br><span class="line">console.log(&#x27;parent&#x27; in child);</span><br><span class="line">console.log(&#x27;self&#x27; in child);</span><br><span class="line">console.log(&#x27;noEnumerable&#x27; in child);</span><br><span class="line">console.log(sym in child);</span><br><span class="line"></span><br><span class="line">console.log(&quot;\n Object.keys \n&quot;);</span><br><span class="line"></span><br><span class="line">for (const key of Object.keys(child)) &#123;</span><br><span class="line">  console.log(key);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&quot;\n Object.getOwnPropertyNames \n&quot;);</span><br><span class="line"></span><br><span class="line">console.log(Object.getOwnPropertyNames(child));</span><br><span class="line"></span><br><span class="line">console.log(&quot;\n Object.getOwnPropertySymbols \n&quot;);</span><br><span class="line"></span><br><span class="line">console.log(Object.getOwnPropertySymbols(child));</span><br><span class="line"></span><br><span class="line">console.log(&quot;\n Reflect.ownKeys \n&quot;);</span><br><span class="line"></span><br><span class="line">console.log(Reflect.ownKeys(child));</span><br><span class="line"></span><br><span class="line">console.log(&quot;\n JSON.stringify \n&quot;);</span><br><span class="line"></span><br><span class="line">console.log(JSON.stringify(child));</span><br><span class="line">console.log(JSON.parse(JSON.stringify(child)));</span><br><span class="line"></span><br><span class="line">console.log(&quot;\n Object.assign \n&quot;);</span><br><span class="line"></span><br><span class="line">console.log(Object.assign(child));</span><br><span class="line">console.log(Object.assign(&#123;&#125;, child));</span><br><span class="line"></span><br><span class="line">console.log(&quot;\n 扩展运算符 ... \n&quot;);</span><br><span class="line"></span><br><span class="line">console.log(&#123; ...child &#125;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;\n Object.getOwnPropertyDescriptors() \n&quot;);</span><br><span class="line"></span><br><span class="line">console.log(Object.getOwnPropertyDescriptors(child));</span><br></pre></td></tr></table></figure>

<p>运行结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> for ... in </span><br><span class="line"></span><br><span class="line">self</span><br><span class="line">parent</span><br><span class="line"></span><br><span class="line"> in </span><br><span class="line"></span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line"></span><br><span class="line"> Object.keys </span><br><span class="line"></span><br><span class="line">self</span><br><span class="line"></span><br><span class="line"> Object.getOwnPropertyNames </span><br><span class="line"></span><br><span class="line">[ &#x27;self&#x27;, &#x27;noEnumerable&#x27; ]</span><br><span class="line"></span><br><span class="line"> Object.getOwnPropertySymbols </span><br><span class="line"></span><br><span class="line">[ Symbol(sym) ]</span><br><span class="line"></span><br><span class="line"> Reflect.ownKeys </span><br><span class="line"></span><br><span class="line">[ &#x27;self&#x27;, &#x27;noEnumerable&#x27;, Symbol(sym) ]</span><br><span class="line"></span><br><span class="line"> JSON.stringify </span><br><span class="line"></span><br><span class="line">&#123;&quot;self&quot;:&quot;self&quot;&#125;</span><br><span class="line">&#123; self: &#x27;self&#x27; &#125;</span><br><span class="line"></span><br><span class="line"> Object.assign </span><br><span class="line"></span><br><span class="line">&#123; self: &#x27;self&#x27;, [Symbol(sym)]: &#x27;Symbol&#x27; &#125;</span><br><span class="line">&#123; self: &#x27;self&#x27;, [Symbol(sym)]: &#x27;Symbol&#x27; &#125;</span><br><span class="line"></span><br><span class="line"> 扩展运算符 ... </span><br><span class="line"></span><br><span class="line">&#123; self: &#x27;self&#x27;, [Symbol(sym)]: &#x27;Symbol&#x27; &#125;</span><br><span class="line"></span><br><span class="line"> Object.getOwnPropertyDescriptors() </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  self: &#123;</span><br><span class="line">    value: &#x27;self&#x27;,</span><br><span class="line">    writable: true,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;,</span><br><span class="line">  noEnumerable: &#123; value: 0, writable: false, enumerable: false, configurable: false &#125;,</span><br><span class="line">  [Symbol(sym)]: &#123;</span><br><span class="line">    value: &#x27;Symbol&#x27;,</span><br><span class="line">    writable: true,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据类型</category>
      </categories>
      <tags>
        <tag>对象遍历</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>对象的新增方法</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>对象的详细方法见js高程第四版第八章</p>
<h2 id="对象ES6之后方法的简单总结"><a href="#对象ES6之后方法的简单总结" class="headerlink" title="对象ES6之后方法的简单总结"></a>对象ES6之后方法的简单总结</h2><p>本章介绍 Object 对象的新增方法。</p>
<h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h3><p>它<strong>用来比较两个值是否严格相等，与严格比较运算符（&#x3D;&#x3D;&#x3D;）的行为基本一致</strong>。</p>
<p>不同之处只有两个：<strong>一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">+<span class="number">0</span> === -<span class="number">0</span> <span class="comment">//true</span></span><br><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(+<span class="number">0</span>, -<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="title class_">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p><code>Object.assign</code>方法用于对象的合并，将源对象（source）的所有<strong>可枚举属性</strong>，复制到目标对象（target）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:, c:3&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p><code>Object.assign</code>拷贝的属性是有限制的，</p>
<ul>
<li><p>浅拷贝</p>
</li>
<li><p><strong>只拷贝源对象的自身属性（不拷贝继承属性）</strong></p>
</li>
<li><p><strong>不拷贝不可枚举的属性</strong>（<code>enumerable: false</code>）</p>
</li>
<li><p><code>Object.assign</code>只能进行值的复制，无法复制取值函数，将求值后再复制</p>
</li>
<li><p>数组的处理</p>
<blockquote>
<p>Object.assign([1, 2, 3], [4, 5])<br>&#x2F;&#x2F; [4, 5, 3]</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>属性名为 Symbol 值的属性，也会被<code>Object.assign</code>拷贝。</p>
</blockquote>
<h4 id="完整的复制对象"><a href="#完整的复制对象" class="headerlink" title="完整的复制对象"></a>完整的复制对象</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 写法一 不能复制不可枚举 不能复制取值函数 </span><br><span class="line">const clone2 = Object.assign(</span><br><span class="line">  Object.create(Object.getPrototypeOf(obj)),</span><br><span class="line">  obj</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 写法二  完美复制</span><br><span class="line">const clone3 = Object.create(</span><br><span class="line">  Object.getPrototypeOf(obj),</span><br><span class="line">  Object.getOwnPropertyDescriptors(obj)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h3><p>ES5 的<code>Object.getOwnPropertyDescriptor(obj, prop)</code>方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了<code>Object.getOwnPropertyDescriptors()</code>方法，返回指定对象所有自身属性（<strong>非继承属性</strong>）的描述对象。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">描述对象MDN</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">bar</span>() &#123; <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj)</span><br><span class="line"><span class="comment">// &#123; foo:</span></span><br><span class="line"><span class="comment">//    &#123; value: 123,</span></span><br><span class="line"><span class="comment">//      writable: true,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125;,</span></span><br><span class="line"><span class="comment">//   bar:</span></span><br><span class="line"><span class="comment">//    &#123; get: [Function: get bar],</span></span><br><span class="line"><span class="comment">//      set: undefined,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="原型链方法"><a href="#原型链方法" class="headerlink" title="原型链方法"></a>原型链方法</h3><p>JavaScript 语言的对象继承是通过原型链实现的。ES6 提供了更多原型对象的操作方法。</p>
<h4 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h4><p><code>Object.setPrototypeOf</code>方法的作用与<code>__proto__</code>相同，用来设置一个对象的原型对象（prototype），返回参数对象本身。它是 <strong>ES6 正式推荐的设置原型对象的方法</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==格式==</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(object, prototype)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">const</span> o = <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(&#123;&#125;, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>该方法等同于下面的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setPrototypeOf</span>(<span class="params">obj, proto</span>) &#123;</span><br><span class="line">  obj.<span class="property">__proto__</span> = proto;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h4><p>该方法与<code>Object.setPrototypeOf</code>方法配套，用于读取一个对象的原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj);</span><br></pre></td></tr></table></figure>

<h3 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h3><p><code>Object.keys()</code> <code>Object.values</code> <code>Object.entries</code></p>
<p>都是不可遍历 <strong>对象自身的（不含继承的）所有可遍历（enumerable）属性的键名</strong></p>
<p>ES5 引入了<code>Object.keys</code>方法，返回一个数组，成员是参数<strong>对象自身的（不含继承的）所有可遍历（enumerable）属性的键名</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = &#123; foo: &#x27;bar&#x27;, baz: 42 &#125;;</span><br><span class="line">Object.keys(obj)</span><br><span class="line">// [&quot;foo&quot;, &quot;baz&quot;]</span><br></pre></td></tr></table></figure>

<p>ES2017 <a href="https://github.com/tc39/proposal-object-values-entries">引入</a>了跟<code>Object.keys</code>配套的<code>Object.values</code>和<code>Object.entries</code>，作为遍历一个对象的补充手段，供<code>for...of</code>循环使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;keys, values, entries&#125; = <span class="title class_">Object</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> <span class="title function_">values</span>(obj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title function_">entries</span>(obj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>([key, value]); <span class="comment">// [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2], [&#x27;c&#x27;, 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h2><p><strong><code>Object.fromEntries()</code>方法是<code>Object.entries()</code>的逆操作，用于将一个键值对数组转为对象</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">fromEntries</span>([</span><br><span class="line">  [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;baz&#x27;</span>, <span class="number">42</span>]</span><br><span class="line">])</span><br><span class="line"><span class="comment">// &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br></pre></td></tr></table></figure>

<p>该方法的主要目的，是将键值对的数据结构还原为对象，因此特别适合将 Map 结构转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">const</span> entries = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;baz&#x27;</span>, <span class="number">42</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(entries)</span><br><span class="line"><span class="comment">// &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h2><ul>
<li>语法<br>Object.create(proto, [propertiesObject])</li>
<li>参数  <ul>
<li>proto : 必须。表示新建对象的原型对象，即该参数会被赋值到目标对象(即新对象，或说是最后返回的对象)的原型上。该参数可以是null， 对象， 函数的prototype属性 （创建空的对象时需传null , 否则会抛出TypeError异常）。</li>
<li>propertiesObject : 可选。 如果没有指定为 undefined，则是要添加到新创建对象的不可枚举（默认）属性（即其自身的属性，而不是原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应Object.defineProperties()的第二个参数。</li>
</ul>
</li>
<li>返回值<br>在指定原型对象上添加新属性后的对象</li>
</ul>
<h3 id="框架偏爱"><a href="#框架偏爱" class="headerlink" title="框架偏爱"></a>框架偏爱</h3><p>很多框架源码作者使用它来初始化一个新的对象，难道是最佳实践？<br>原因有二  </p>
<ul>
<li>通过Object.create(null)创建出来的对象，没有任何属性，显示No properties。我们可以将其当成一个干净的 map 来使用，自主定义 toString,hasOwnProperty等方法，并且不必担心将原型链上的同名方法被覆盖。</li>
<li>{…}创建的对象，使用for in遍历对象的时候，会遍历原型链上的属性，带来性能上的损耗。使用Object.create(null)则不必再对其进行遍历了。<br><img src="/_posts/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/assets/%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95/write1.png" alt="两种方式的比较"></li>
</ul>
<h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><h4 id="1）创建对象的方式不同"><a href="#1）创建对象的方式不同" class="headerlink" title="1）创建对象的方式不同"></a>1）创建对象的方式不同</h4><p>new Object() 通过构造函数来创建对象, 添加的属性是在自身实例下。<br>Object.create() es6创建对象的另一种方式，可以理解为继承一个对象, 添加的属性是在原型下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// new Object() 方式创建</span><br><span class="line">var a = &#123;  rep : &#x27;apple&#x27; &#125;</span><br><span class="line">var b = new Object(a)</span><br><span class="line">console.log(b) // &#123;rep: &quot;apple&quot;&#125;</span><br><span class="line">console.log(b.__proto__) // &#123;&#125;</span><br><span class="line">console.log(b.rep) // &#123;rep: &quot;apple&quot;&#125;</span><br><span class="line"></span><br><span class="line">// Object.create() 方式创建</span><br><span class="line">var a = &#123; rep: &#x27;apple&#x27; &#125;</span><br><span class="line">var b = Object.create(a)</span><br><span class="line">console.log(b)  // &#123;&#125;</span><br><span class="line">console.log(b.__proto__) // &#123;rep: &quot;apple&quot;&#125;</span><br><span class="line">console.log(b.rep) // &#123;rep: &quot;apple&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>Object.create()方法创建的对象时，属性是在原型下面的，也可以直接访问 b.rep &#x2F;&#x2F; {rep: “apple”} ,<br>此时这个值不是吧b自身的，是它通过原型链<strong><strong>proto</strong></strong>来访问到b的值。</p>
<h4 id="2）创建对象属性的性质不同"><a href="#2）创建对象属性的性质不同" class="headerlink" title="2）创建对象属性的性质不同"></a>2）创建对象属性的性质不同</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建一个以另一个空对象为原型,且拥有一个属性p的对象</span><br><span class="line">o = Object.create(&#123;&#125;, &#123; p: &#123; value: 42 &#125; &#125;)</span><br><span class="line"></span><br><span class="line">// 省略了的属性特性默认为false,所以属性p是不可写,不可枚举,不可配置的:</span><br><span class="line">o.p = 24</span><br><span class="line">o.p</span><br><span class="line">//42</span><br><span class="line"></span><br><span class="line">o.q = 12</span><br><span class="line">for (var prop in o) &#123;</span><br><span class="line">   console.log(prop)</span><br><span class="line">&#125;</span><br><span class="line">//&quot;q&quot;</span><br><span class="line"></span><br><span class="line">delete o.p</span><br><span class="line">//false</span><br></pre></td></tr></table></figure>

<p>Object.create() 用第二个参数来创建非空对象的属性描述符默认是为false的，而构造函数或字面量方法创建的对象属性的描述符默认为true。看下图解析：  </p>
<p><img src="/_posts/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/assets/%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95/objectDes.png" alt="propertiesObject">  </p>
<h4 id="3）创建空对象时不同"><a href="#3）创建空对象时不同" class="headerlink" title="3）创建空对象时不同"></a>3）创建空对象时不同</h4><p><img src="/_posts/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/assets/%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95/objectNull.png" alt="propertiesObject">  </p>
<p>当用构造函数或对象字面量方法创建空对象时，对象时有原型属性的，即有_proto_;<br>当用Object.create()方法创建空对象时，对象是没有原型属性的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.create()   //Object prototype may only be an Object or null</span><br><span class="line">Object.create(&#x27;&#x27;) //Object prototype may only be an Object or null</span><br></pre></td></tr></table></figure>

<h4 id="4）proto-属性"><a href="#4）proto-属性" class="headerlink" title="4）proto 属性"></a>4）<strong>proto</strong> 属性</h4><p>JavaScript 的对象继承是通过原型链实现的。ES6 提供了更多原型对象的操作方法。<br>__proto__属性，用来读取或设置当前对象的prototype对象。目前只有浏览器环境必须部署有这个属性，其他运行环境不一定要部署，因此不建议使用这个属性，而是使用下面这些来 **Object.setPrototypeOf()<strong>（写操作,<strong>它是 ES6 正式推荐的设置原型对象的方法</strong>）、</strong>Object.getPrototypeOf()<strong>（读操作）、</strong>Object.create()**（生成操作）代替。</p>
<h5 id="应用案例，原型属性的继承"><a href="#应用案例，原型属性的继承" class="headerlink" title="应用案例，原型属性的继承"></a>应用案例，原型属性的继承</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var triangle = &#123;a: 1, b: 2, c: 3&#125;;</span><br><span class="line"></span><br><span class="line">function ColoredTriangle() &#123;</span><br><span class="line">  this.color = &#x27;red&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ColoredTriangle.prototype = triangle;  //ColoredTriangle.prototype.constructor === ColoredTriangle// false</span><br><span class="line">Object.assign(ColoredTriangle.prototype, triangle) //ColoredTriangle.prototype.constructor === ColoredTriangle// true</span><br><span class="line"></span><br><span class="line">var c = new ColoredTriangle();</span><br></pre></td></tr></table></figure>

<p>打印出 实例c 看看结构是怎样的  </p>
<p><img src="/_posts/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/assets/%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95/object1.png" alt="propertiesObject">  </p>
<p>其中 color 属性在实例上，而其他的原型上。<br>现在来拷贝一个 实例 c2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var c2 = Object.assign(&#123;&#125;,c)</span><br><span class="line">console.log(c2.color); //red</span><br><span class="line">console.log(c2.a); //undefined</span><br></pre></td></tr></table></figure>

<p>因为 Object.assign 是<strong>不能拷贝到继承或原型上的方法的</strong>。所以 实例c2 没有 a 这个属性。那要怎么要才能拷贝到原型上的方法呢？</p>
<ul>
<li>第一种方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var originProto = Object.getPrototypeOf(c);</span><br><span class="line">var originProto2 = Object.create(originProto);</span><br><span class="line">var c2 = Object.assign(originProto2, c);</span><br><span class="line">//var c2 = Object.assign(Object.create(Object.getPrototypeOf(c)), c)</span><br><span class="line"></span><br><span class="line">console.log(c2.color); // red</span><br><span class="line">console.log(c2.a); // 1</span><br></pre></td></tr></table></figure>

<p>这样就实现了原型属性的拷贝。<br>Object.getPrototypeOf(c) 既 originProto 得到的是原型上的 &#x2F;&#x2F;{a: 1, b: 2, c: 3}；<br>Object.create(originProto) 既 originProto2 既是创建了一个 {a: 1, b: 2, c: 3} 在原型上的新对象；<br>Object.assign(originProto2, c) 在源对象originProto2 上合并对象 c (只能合并实例属性)；</p>
<ul>
<li>第二种方法(推荐)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var c = new ColoredTriangle();</span><br><span class="line">var c2 = Object.create(Object.getPrototypeOf(c), Object.getOwnPropertyDescriptors(c));</span><br><span class="line"></span><br><span class="line">console.log(c2.color); // red</span><br><span class="line">console.log(c2.a); // 1</span><br></pre></td></tr></table></figure>

<p>可以把Object.create()的参数理解为：第一个参数是放在新对象的原型上的，第二个参数是放在新对象的实例上的。<br>Object.getPrototypeOf() 得到的是 c 对象的原型，然后作为第一个参数，所以会在新对象c2 的原型上。<br>Object.getOwnPropertyDescriptors() 得到是 c 对象自身的可枚举属性，作为第二个参数，放在 c2 的实例上。</p>
<p><strong>为什么说推荐这个方法呢？因为Object.assign() 方法不能正确拷贝 get ，set 属性。</strong></p>
]]></content>
      <categories>
        <category>数据类型</category>
      </categories>
      <tags>
        <tag>Object</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>数字常用方法</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B0%E5%AD%97%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h2><ul>
<li><p>Number.isFinite()<br>用来检查一个数值是否为有限的（finite），即不是Infinity。</p>
</li>
<li><p>Number.isNaN()<br>用来检查一个值是否为NaN。</p>
</li>
<li><p>Number.parseInt()</p>
</li>
<li><p>Number.parseFloat()</p>
<blockquote>
<p>ES6 将全局方法<code>parseInt()</code>和<code>parseFloat()</code>，移植到<code>Number</code>对象上面，行为完全保持不变。</p>
</blockquote>
</li>
<li><p><code>Number.isInteger()</code></p>
<p>用来判断一个数值是否为整数。</p>
<p>JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="title function_">isInteger</span>(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="title function_">isInteger</span>(<span class="number">25.0</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Number.isSafeInteger()</p>
<p>JavaScript 能够准确表示的整数范围在<code>-2^53</code>到<code>2^53</code>之间（不含两个端点），超过这个范围，无法精确表示这个值。ES6 引入了<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>这两个常量，用来表示这个范围的上下限。</p>
<p><code>Number.isSafeInteger()</code>则是用来判断一个整数是否落在这个范围之内。</p>
</li>
</ul>
<h3 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h3><ul>
<li>Math.trunc()</li>
</ul>
<p>​  <code>Math.trunc</code>方法用于去除一个数的小数部分，返回整数部分。</p>
<p>​  对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="property">trunc</span> = <span class="title class_">Math</span>.<span class="property">trunc</span> || <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x &lt; <span class="number">0</span> ? <span class="title class_">Math</span>.<span class="title function_">ceil</span>(x) : <span class="title class_">Math</span>.<span class="title function_">floor</span>(x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据类型</category>
      </categories>
      <tags>
        <tag>Number</tag>
      </tags>
  </entry>
  <entry>
    <title>数组常用方法</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>最详细、最权威的方法见js高级程序设计 6.2 Array（推荐阅读）</p>
<h2 id="数组的遍历方法"><a href="#数组的遍历方法" class="headerlink" title="数组的遍历方法"></a>数组的遍历方法</h2><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><ul>
<li>可以响应 break continue, return报错</li>
<li>改变原数组<br>使用临时变量，将长度缓存起来，避免重复获取数组长度，当数组较大时优化效果才会比较明显</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(var j = 0,len=arr.length; j &lt; len; j++) &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="for-in-循环-不建议用来遍历数组"><a href="#for-in-循环-不建议用来遍历数组" class="headerlink" title="for-in 循环(不建议用来遍历数组)"></a>for-in 循环(不建议用来遍历数组)</h3><ul>
<li>可以响应 break continue, return报错</li>
<li>改变原数组</li>
<li>能遍历到实例的属性或者是原型上的属性(所以不推荐数组使用)<br>for-in循环是为了<strong>遍历对象</strong>而设计的，事实上for-in也能用来遍历数组，但<strong>定义的索引i是字符</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//for-in遍历数组</span><br><span class="line">for(var i in arrTmp)&#123;</span><br><span class="line">    console.log(i+&quot;: &quot;+arrTmp[i])</span><br><span class="line">&#125;</span><br><span class="line">//for-in会遍历到数组的可枚举属性</span><br><span class="line">arrTmp.name=&quot;myTest&quot;;</span><br><span class="line">for(var i in arrTmp)&#123;</span><br><span class="line">    console.log(i+&quot;:&quot;+arrTmp[i])</span><br><span class="line">&#125;</span><br><span class="line">//输出 0:value1  1:value2  2:value3  name:myTest</span><br></pre></td></tr></table></figure>

<h3 id="for…of遍历"><a href="#for…of遍历" class="headerlink" title="for…of遍历"></a>for…of遍历</h3><p>(ES6语法，推荐使用) 不能用于遍历对象，详细见[Iterator 和 for…of 循环]</p>
<ul>
<li>可以正确响应break、continue和return语句</li>
<li>改变原始数组</li>
<li>只能读取<strong>键值</strong>item,如有需要可以使用索引index<ul>
<li>经典 for循环，foreach，array.entries()，array.keys()</li>
</ul>
</li>
</ul>
<h4 id="数组的实例方法"><a href="#数组的实例方法" class="headerlink" title="数组的实例方法"></a>数组的实例方法</h4><p>entries()，keys()和 values()，经常和for…of 配合使用</p>
<p>它们都返回一个遍历器对象，可以用for…of循环进行遍历，<strong>唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (let index of [&#x27;a&#x27;, &#x27;b&#x27;].keys()) &#123;</span><br><span class="line">  console.log(index);</span><br><span class="line">&#125;</span><br><span class="line">// 0</span><br><span class="line">// 1</span><br><span class="line"></span><br><span class="line">for (let elem of [&#x27;a&#x27;, &#x27;b&#x27;].values()) &#123;</span><br><span class="line">  console.log(elem);</span><br><span class="line">&#125;</span><br><span class="line">// &#x27;a&#x27;</span><br><span class="line">// &#x27;b&#x27;</span><br><span class="line"></span><br><span class="line">for (let [index, elem] of [&#x27;a&#x27;, &#x27;b&#x27;].entries()) &#123;</span><br><span class="line">  console.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line">// 0 &quot;a&quot;</span><br><span class="line">// 1 &quot;b&quot;</span><br></pre></td></tr></table></figure>

<h3 id="foreach-循环"><a href="#foreach-循环" class="headerlink" title="foreach 循环"></a>foreach 循环</h3><ul>
<li>不响应break、continue和return</li>
<li>没有返回值</li>
<li>改变原数组</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr.forEach((item,index,array)=&gt;&#123;</span><br><span class="line">  //执行代码</span><br><span class="line">&#125;)</span><br><span class="line">//参数：item数组中的当前项, index当前项的索引, array原始数组；</span><br></pre></td></tr></table></figure>

<h3 id="map循环"><a href="#map循环" class="headerlink" title="map循环"></a>map循环</h3><p>映射，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</p>
<ul>
<li>不响应break、continue</li>
<li>返回经过处理的新数组</li>
<li>不改变原始数组</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var ary = [12,23,24,42,1]; </span><br><span class="line">var res = ary.map(function (item,index,ary ) &#123; </span><br><span class="line">    return item*10; </span><br><span class="line">&#125;) </span><br><span class="line">console.log(res);//--&gt;[120,230,240,420,10];  原数组拷贝了一份，并进行了修改</span><br><span class="line">console.log(ary);//--&gt;[12,23,24,42,1]；  原数组并未发生变化</span><br></pre></td></tr></table></figure>

<h3 id="filter循环"><a href="#filter循环" class="headerlink" title="filter循环"></a>filter循环</h3><p>过滤，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。</p>
<ul>
<li>不响应break、continue</li>
<li>返回经过处理的新数组</li>
<li>不改变原始数组</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//示例功能，筛选偶数</span><br><span class="line">const arr = [1,2,3,4,5,6,7,8]</span><br><span class="line">const arrHandle1 = arr.filter(item =&gt; &#123;</span><br><span class="line">  if(item%2===0)&#123;</span><br><span class="line">    return item</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">const arrHandle2 = arr.filter(item =&gt; &#123;</span><br><span class="line">  if(item%2===0)&#123;</span><br><span class="line">    return item</span><br><span class="line">  &#125;</span><br><span class="line">  return false</span><br><span class="line">&#125;)</span><br><span class="line">const arrHandle3 = arr.filter(item =&gt; &#123;</span><br><span class="line">  if(item%2===0)&#123;</span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line">  return false</span><br><span class="line">&#125;)</span><br><span class="line">console.log(arrHandle1); [ 2, 4, 6, 8 ]</span><br><span class="line">console.log(arrHandle2); [ 2, 4, 6, 8 ]</span><br><span class="line">console.log(arrHandle3); [ 2, 4, 6, 8 ]</span><br></pre></td></tr></table></figure>

<h3 id="every"><a href="#every" class="headerlink" title="every"></a>every</h3><p>判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true</p>
<ul>
<li>不响应break、continue</li>
<li>不改变原始数组</li>
<li>返回Boolean</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">var</span> brr = arr.<span class="title function_">every</span>(<span class="function"><span class="params">item</span> =&gt;</span> item%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr) <span class="comment">//[1,2,3,1,6,4,6]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(brr) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h3 id="some"><a href="#some" class="headerlink" title="some"></a>some</h3><p>判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true</p>
<ul>
<li>不响应break、continue</li>
<li>不改变原始数组</li>
<li>返回Boolean</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">var</span> brr = arr.<span class="title function_">some</span>(<span class="function"><span class="params">item</span> =&gt;</span> item%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr) <span class="comment">//[1,2,3,1,6,4,6]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(brr) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="reduce-reduceRight"><a href="#reduce-reduceRight" class="headerlink" title="reduce.reduceRight"></a>reduce.reduceRight</h3><p>这两个方法都会迭代数 组的所有项，并在此基础上构建一个终返回值</p>
<h2 id="数组的操作方法"><a href="#数组的操作方法" class="headerlink" title="数组的操作方法"></a>数组的操作方法</h2><h3 id="改变原始数组的方法"><a href="#改变原始数组的方法" class="headerlink" title="改变原始数组的方法"></a>改变原始数组的方法</h3><ul>
<li>pop(): 删除 array 的最后一个元素，把数组长度减 1，并且返回它删除的元素的值。如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值。<ul>
<li>返回它删除的元素的值</li>
</ul>
</li>
<li>push(): 可以接收<strong>任意数量</strong>的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。<ul>
<li>返回修改后数组的长度</li>
</ul>
</li>
<li>unshift(): 将参数添加到原数组开头，并返回数组的长度<ul>
<li>返回修改后数组长度</li>
</ul>
</li>
<li>shift(): 数组的第一个元素从其中删除，并返回第一个元素的值,如果数组是空的，那么 shift() 方法将不进行任何操作，并返回 undefined 值。<ul>
<li>返回第一个元素的值</li>
</ul>
</li>
<li>reverse(): 用于颠倒数组中元素的顺序。<ul>
<li>返回原数组</li>
</ul>
</li>
<li>sort(): 排序，默认为升序排列，如果想按照其他标准进行排序，sort()方法是可以传入一个函数，函数通过返回一个值来决定</li>
<li>splice(): <strong>功能强大</strong>的数组方法，向从数组中添加删除项目，然后返回被删除的项目<ul>
<li>返回被删除的项目</li>
<li>语法 <code>arrayObject.splice(index,howmany,item1,.....,itemX)</code><ul>
<li>index    必需。整数，规定添加&#x2F;删除项目的位置，使用负数可从数组结尾处规定位置。</li>
<li>howmany  必需。要删除的项目数量。如果设置为 0，则不会删除项目。</li>
<li>item1, …, itemX    可选。向数组添加的新项目。</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://es6.ruanyifeng.com/#docs/array#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84-copyWithin">copyWithin()</a>  在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组</li>
<li><a href="https://es6.ruanyifeng.com/#docs/array#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84-fill">fill()</a><ul>
<li>fill方法使用给定值，填充一个数组,fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;].fill(7)</span><br><span class="line">// [7, 7, 7]</span><br><span class="line"></span><br><span class="line">new Array(3).fill(7)</span><br><span class="line">// [7, 7, 7]</span><br><span class="line"></span><br><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;].fill(7, 1, 2)</span><br><span class="line">// [&#x27;a&#x27;, 7, &#x27;c&#x27;]</span><br></pre></td></tr></table></figure>

<h3 id="不改变原始数组的方法"><a href="#不改变原始数组的方法" class="headerlink" title="不改变原始数组的方法"></a>不改变原始数组的方法</h3><p>&#x2F;&#x2F; TODO</p>
<ul>
<li>join</li>
<li>toLocalString</li>
<li>toString</li>
<li>valueOf</li>
<li>slice</li>
<li>cancat</li>
<li>indexOf</li>
<li>lastIndexOf</li>
<li>includes</li>
<li>flat</li>
<li>flatMap</li>
<li>find</li>
<li>findIndex</li>
</ul>
<h2 id="类数组转换为数组"><a href="#类数组转换为数组" class="headerlink" title="类数组转换为数组"></a>类数组转换为数组</h2><p>直接上代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arrayLike = &#123;0: &#x27;name&#x27;, 1: &#x27;age&#x27;, 2: &#x27;sex&#x27;, length: 3 &#125;</span><br><span class="line">// 1. slice</span><br><span class="line">Array.prototype.slice.call(arrayLike); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] </span><br><span class="line">// 2. splice</span><br><span class="line">Array.prototype.splice.call(arrayLike, 0); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] </span><br><span class="line">// 3. ES6 Array.from</span><br><span class="line">Array.from(arrayLike); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] </span><br><span class="line">// 4. apply</span><br><span class="line">Array.prototype.concat.apply([], arrayLike)</span><br></pre></td></tr></table></figure>

<p>如果是有iterator接口的类数组，还可以用扩展运算符进行转换</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[...<span class="title class_">NodeList</span>]</span><br></pre></td></tr></table></figure>

<h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><blockquote>
<p>数组的方法详细见js高程第四版6.2 Array</p>
</blockquote>
<h3 id="克隆一个数组-浅拷贝-不会改变原始数组"><a href="#克隆一个数组-浅拷贝-不会改变原始数组" class="headerlink" title="克隆一个数组(浅拷贝),不会改变原始数组"></a>克隆一个数组(浅拷贝),不会改变原始数组</h3><ul>
<li>concat()<ul>
<li><code>array.concat()</code></li>
</ul>
</li>
<li>slice() 另一个常用方法:<code>Array.prototype.slice.call(arguments,0?)</code>能将具有length属性的对象转成数组,功能类似于<code>Array.from()</code><ul>
<li><code>array.slice(0?)</code></li>
</ul>
</li>
<li>Array.from() 将两类对象转为真正的数组：类似数组的对象（array-like object 有length属性就可以）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）</li>
<li>扩展运算符 …<ul>
<li><code>[...array]</code></li>
</ul>
</li>
<li>Object.assign()<ul>
<li><code>Object.assign([],arr)</code></li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [&#123; <span class="attr">b</span>: <span class="number">1</span> &#125;,&#123; <span class="attr">c</span>: <span class="number">1</span> &#125;,&#123; <span class="attr">d</span>: <span class="number">1</span> &#125;,&#123; <span class="attr">e</span>: <span class="number">1</span> &#125;]</span><br><span class="line"><span class="keyword">let</span> brr = arr.<span class="title function_">concat</span>([])</span><br><span class="line">brr[<span class="number">0</span>].<span class="property">b</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> crr = arr.<span class="title function_">slice</span>()</span><br><span class="line">crr[<span class="number">1</span>].<span class="property">c</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> drr = [...arr]</span><br><span class="line">drr[<span class="number">2</span>].<span class="property">d</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> err = <span class="title class_">Object</span>.<span class="title function_">assign</span>([],arr)</span><br><span class="line">err[<span class="number">3</span>].<span class="property">e</span> = <span class="number">2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr) <span class="comment">//[&#123; b: 2 &#125;,&#123; c: 2 &#125;,&#123; d: 2 &#125;,&#123; e: 2 &#125;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(brr) <span class="comment">//[&#123; b: 2 &#125;,&#123; c: 2 &#125;,&#123; d: 2 &#125;,&#123; e: 2 &#125;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(crr) <span class="comment">//[&#123; b: 2 &#125;,&#123; c: 2 &#125;,&#123; d: 2 &#125;,&#123; e: 2 &#125;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(drr) <span class="comment">//[&#123; b: 2 &#125;,&#123; c: 2 &#125;,&#123; d: 2 &#125;,&#123; e: 2 &#125;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(err) <span class="comment">//[&#123; b: 2 &#125;,&#123; c: 2 &#125;,&#123; d: 2 &#125;,&#123; e: 2 &#125;]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据类型</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串常用方法</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>字符串对象是不可变的，所以字符串对象提供的涉及到字符串“修改”的方法都是返回修改后的新字符串，并不对原始字符串做任何修改，无一例外<br>JavaScript字符串由 16位码元（code unit）组成。对多数字符来说，每 16位码元对应一个字符。<br>JavaScript字符串使用了两种 Unicode编码混合的策略：UCS-2和 UTF-16。对于可以采用 16位编码 的字符（U+0000~U+FFFF）16的四次方</p>
<h2 id="charAt"><a href="#charAt" class="headerlink" title="charAt()"></a>charAt()</h2><p>charAt()方法返回给定索引位置的字符，由传给方法的整数参数指定。具体来说，这个方法查找指定索引位置的 16位码元，并返回该码元对应的字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let message = &quot;abcde&quot;; </span><br><span class="line"> </span><br><span class="line">console.log(message.charAt(2)); // &quot;c&quot; </span><br></pre></td></tr></table></figure>

<h2 id="charCodeAt"><a href="#charCodeAt" class="headerlink" title="charCodeAt()"></a>charCodeAt()</h2><p>使用 charCodeAt()方法可以查看指定码元的字符编码。这个方法返回指定索引位置的码元值，索引以整数指定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let message = &quot;abcde&quot;; </span><br><span class="line">// Unicode &quot;Latin small letter C&quot;的编码是 U+0063 </span><br><span class="line">console.log(message.charCodeAt(2));  // 99 </span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h2 id="fromCharCode-原型方法"><a href="#fromCharCode-原型方法" class="headerlink" title="fromCharCode() 原型方法"></a>fromCharCode() 原型方法</h2><p>fromCharCode() 方法用于根据给定的 UTF-16 码元创建字符串中的字符。这个方法可以接受任意多个数值，并返回将所有数值对应的字符拼接起来的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(String.fromCharCode(0x61, 0x62, 0x63, 0x64, 0x65));  // &quot;abcde&quot; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于 U+0000~U+FFFF范围内的字符，length、charAt()、charCodeAt()和 fromCharCode() 返回的结果都跟预期是一样的。<br>为正确解析既包含单码元字符又包含代理对字符的字符串，与charCodeAt()有对应的 codePointAt()一样，fromCharCode()也有一个对应的 fromCodePoint()</p>
</blockquote>
<h2 id="normalize-非诚不常用"><a href="#normalize-非诚不常用" class="headerlink" title="normalize() 非诚不常用"></a>normalize() 非诚不常用</h2><p>，Unicode提供了4种规范化形式，可以将类似上面的字符规范化为一致的格式，无论 底层字符的代码是什么。这 4种规范化形式是：NFD（Normalization Form D）、NFC（Normalization Form C）、 NFKD（Normalization Form KD）和 NFKC（Normalization Form KC）。可以使用 normalize()方法对字 符串应用上述规范化形式，使用时需要传入表示哪种形式的字符串：”NFD”、”NFC”、”NFKD”或”NFKC”。</p>
<h2 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h2><p>首先是 concat()，用于将一个或多个字符串拼接成一个新字符串。concat()方法可以接收任意多个参数，因此可以一次性拼接多个字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let stringValue = &quot;hello &quot;; </span><br><span class="line">let result = stringValue.concat(&quot;world&quot;, &quot;!&quot;); </span><br><span class="line">console.log(result);      // &quot;hello world!&quot; </span><br><span class="line">console.log(stringValue); // &quot;hello &quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>虽然 concat()方法可以拼接字符串，但更常用的方式是使用加号操作符（+）。而且多数情况下，对于拼接多个字符串来说，使用加号更方便。</p>
</blockquote>
<h2 id="slice-、substr-和-substring-截取字符串"><a href="#slice-、substr-和-substring-截取字符串" class="headerlink" title="slice()、substr() 和 substring() 截取字符串"></a>slice()、substr() 和 substring() 截取字符串</h2><p>这3个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。第一个参数表示子字符串开始的位置，第二个参数表示子字符串结束的位置。<br>对<code>slice()</code>和<code>substring()</code>而言，第二个参数是提取结束的位置（即该位置之前的字符会被提取出来）。<br>对<code>substr()</code>而言，第二个参数表示返回的子字符串数量。任何情况下，省略第二个参数都意味着提取到字符串末尾。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let stringValue = &quot;hello world&quot;; </span><br><span class="line">console.log(stringValue.slice(3));       // &quot;lo world&quot; </span><br><span class="line">console.log(stringValue.substring(3));   // &quot;lo world&quot; </span><br><span class="line">console.log(stringValue.substr(3));      // &quot;lo world&quot; </span><br><span class="line">console.log(stringValue.slice(3, 7));    // &quot;lo w&quot; </span><br><span class="line">console.log(stringValue.substring(3,7)); // &quot;lo w&quot; </span><br><span class="line">console.log(stringValue.substr(3, 7));   // &quot;lo worl&quot;</span><br></pre></td></tr></table></figure>

<p>当某个参数是负值时，这3个方法的行为又有不同。<br>比如，slice()方法将所有负值参数都当成字符串长度加上负参数值。<br>而substr()方法将第一个负参数值当成字符串长度加上该值，将第二个负参数值转换为 0。<br>substring()方法会将所有负参数值都转换为 0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let stringValue = &quot;hello world&quot;; </span><br><span class="line">console.log(stringValue.slice(-3));         // &quot;rld&quot; </span><br><span class="line">console.log(stringValue.substring(-3));     // &quot;hello world&quot; </span><br><span class="line">console.log(stringValue.substr(-3));        // &quot;rld&quot; </span><br><span class="line">console.log(stringValue.slice(3, -4));      // &quot;lo w&quot; </span><br><span class="line">console.log(stringValue.substring(3, -4));  // &quot;hel&quot; </span><br><span class="line">console.log(stringValue.substr(3, -4));     // &quot;&quot; (empty string) </span><br></pre></td></tr></table></figure>

<h2 id="indexOf-和-lastIndexOf-字符串位置方法"><a href="#indexOf-和-lastIndexOf-字符串位置方法" class="headerlink" title="indexOf() 和 lastIndexOf() 字符串位置方法"></a>indexOf() 和 lastIndexOf() 字符串位置方法</h2><p>这两个方法从字符串中搜索传入的字符串，并返回位置（如果没找到，则返回-1）。两者的区别在于，indexOf()方法 从字符串开头开始查找子字符串，而 lastIndexOf()方法从字符串末尾开始查找子字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let stringValue = &quot;hello world&quot;; </span><br><span class="line">console.log(stringValue.indexOf(&quot;o&quot;));     // 4 </span><br><span class="line">console.log(stringValue.lastIndexOf(&quot;o&quot;)); // 7 </span><br></pre></td></tr></table></figure>

<p>这两个方法都可以接收可选的第二个参数，表示开始搜索的位置。这意味着，indexOf()会从这个参数指定的位置开始向字符串末尾搜索，<strong>忽略该位置之前</strong>的字符；lastIndexOf()则会从这个参数指定的位置开始向字符串开头搜索，<strong>忽略该位置之后</strong>直到字符串末尾的字符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let stringValue = &quot;hello world&quot;; </span><br><span class="line">console.log(stringValue.indexOf(&quot;o&quot;, 6));     // 7 </span><br><span class="line">console.log(stringValue.lastIndexOf(&quot;o&quot;, 6)); // 4 </span><br></pre></td></tr></table></figure>

<h2 id="startsWith-、endsWith-和-includes-字符串包含方法"><a href="#startsWith-、endsWith-和-includes-字符串包含方法" class="headerlink" title="startsWith()、endsWith() 和 includes() 字符串包含方法"></a>startsWith()、endsWith() 和 includes() 字符串包含方法</h2><p>这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。它们的区别在于，startsWith()检查开始于索引 0 的匹配项，endsWith()检查开始于索引(string.length - substring.length)的匹配项，而 includes()检查整个字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let message = &quot;foobarbaz&quot;; </span><br><span class="line">console.log(message.startsWith(&quot;foo&quot;));  // true </span><br><span class="line">console.log(message.startsWith(&quot;bar&quot;));  // false </span><br><span class="line">console.log(message.endsWith(&quot;baz&quot;));    // true </span><br><span class="line">console.log(message.endsWith(&quot;bar&quot;));    // false  </span><br><span class="line">console.log(message.includes(&quot;bar&quot;));    // true </span><br><span class="line">console.log(message.includes(&quot;qux&quot;));    // false </span><br></pre></td></tr></table></figure>

<p>startsWith()和 includes()方法接收可选的第二个参数，表示开始搜索的位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let message = &quot;foobarbaz&quot;; </span><br><span class="line"> </span><br><span class="line">console.log(message.startsWith(&quot;foo&quot;));     // true </span><br><span class="line">console.log(message.startsWith(&quot;foo&quot;, 1));  // false </span><br><span class="line"> </span><br><span class="line">console.log(message.includes(&quot;bar&quot;));       // true </span><br><span class="line">console.log(message.includes(&quot;bar&quot;, 4));    // false </span><br></pre></td></tr></table></figure>

<p>endsWith()方法接收可选的第二个参数，表示应该当作字符串末尾的位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let message = &quot;foobarbaz&quot;; </span><br><span class="line"> </span><br><span class="line">console.log(message.endsWith(&quot;bar&quot;));     // false </span><br><span class="line">console.log(message.endsWith(&quot;bar&quot;, 6));  // true </span><br></pre></td></tr></table></figure>

<h2 id="trim-、-trimLeft-和-trimRight"><a href="#trim-、-trimLeft-和-trimRight" class="headerlink" title="trim()、 trimLeft() 和 trimRight()"></a>trim()、 trimLeft() 和 trimRight()</h2><p>trim()这个方法会创建字符串的一个副本，删除前、 后所有空格符，再返回结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let stringValue = &quot;  hello world  &quot;; </span><br><span class="line">let trimmedStringValue = stringValue.trim(); </span><br><span class="line">console.log(stringValue);         // &quot;  hello world &quot; </span><br><span class="line">console.log(trimmedStringValue);  // &quot;hello world&quot; </span><br></pre></td></tr></table></figure>

<p>trimLeft()和 trimRight()方法分别用于从字符串开始和末尾清理空格符。</p>
<h2 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h2><p>这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let stringValue = &quot;na &quot;; </span><br><span class="line">console.log(stringValue.repeat(16) + &quot;batman&quot;); </span><br><span class="line">// na na na na na na na na na na na na na na na na batman </span><br></pre></td></tr></table></figure>

<h2 id="padStart-和-padEnd"><a href="#padStart-和-padEnd" class="headerlink" title="padStart()和 padEnd()"></a>padStart()和 padEnd()</h2><p><code>padStart()</code>和<code>padEnd()</code>方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格（U+0020）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let stringValue = &quot;foo&quot;; </span><br><span class="line"> </span><br><span class="line">console.log(stringValue.padStart(6));       // &quot;   foo&quot; </span><br><span class="line">console.log(stringValue.padStart(9, &quot;.&quot;));  // &quot;......foo&quot; </span><br><span class="line"> </span><br><span class="line">console.log(stringValue.padEnd(6));         // &quot;foo   &quot; </span><br><span class="line">console.log(stringValue.padEnd(9, &quot;.&quot;));    // &quot;foo......&quot; </span><br></pre></td></tr></table></figure>

<p>可选的第二个参数并不限于一个字符。如果提供了多个字符的字符串，则会将其拼接并截断以匹配指定长度。此外，<strong>如果长度小于或等于字符串长度，则会返回原始字符串</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let stringValue = &quot;foo&quot;; </span><br><span class="line"> </span><br><span class="line">console.log(stringValue.padStart(8, &quot;bar&quot;)); // &quot;barbafoo&quot; </span><br><span class="line">console.log(stringValue.padStart(2));        // &quot;foo&quot; </span><br><span class="line"> </span><br><span class="line">console.log(stringValue.padEnd(8, &quot;bar&quot;));   // &quot;foobarba&quot; </span><br><span class="line">console.log(stringValue.padEnd(2));          // &quot;foo&quot;</span><br></pre></td></tr></table></figure>

<h2 id="toLowerCase-、toLocaleLowerCase-、toUpperCase-和-toLocaleUpperCase-大小写转换"><a href="#toLowerCase-、toLocaleLowerCase-、toUpperCase-和-toLocaleUpperCase-大小写转换" class="headerlink" title="toLowerCase()、toLocaleLowerCase()、toUpperCase() 和 toLocaleUpperCase() 大小写转换"></a>toLowerCase()、toLocaleLowerCase()、toUpperCase() 和 toLocaleUpperCase() 大小写转换</h2><p>toLowerCase()和toUpperCase()方法是原来就有的方法， 与 java.lang.String 中的方法同名。toLocaleLowerCase()和 toLocaleUpperCase()方法旨在基于特定地区实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let stringValue = &quot;hello world&quot;; </span><br><span class="line">console.log(stringValue.toLocaleUpperCase());  // &quot;HELLO WORLD&quot; </span><br><span class="line">console.log(stringValue.toUpperCase());        // &quot;HELLO WORLD&quot; </span><br><span class="line">console.log(stringValue.toLocaleLowerCase());  // &quot;hello world&quot; </span><br><span class="line">console.log(stringValue.toLowerCase());        // &quot;hello world&quot; </span><br></pre></td></tr></table></figure>

<h2 id="match-search-和-replace-字符串模式匹配方法"><a href="#match-search-和-replace-字符串模式匹配方法" class="headerlink" title="match() search() 和 replace() 字符串模式匹配方法"></a>match() search() 和 replace() 字符串模式匹配方法</h2><p>match()方法本质上跟 RegExp 对象的exec()方法相同。match()方法接收一个参数，可以是一个正则表达式字 符串，也可以是一个 RegExp 对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let text = &quot;cat, bat, sat, fat&quot;; </span><br><span class="line">let pattern = /.at/; </span><br><span class="line"> </span><br><span class="line">// 等价于 pattern.exec(text) </span><br><span class="line">let matches = text.match(pattern); </span><br><span class="line">console.log(matches.index);      // 0 </span><br><span class="line">console.log(matches[0]);         // &quot;cat&quot; </span><br><span class="line">console.log(pattern.lastIndex);  // 0 </span><br></pre></td></tr></table></figure>

<p>search()这个方法返回模式第一个匹配的位置索引，如果没找到则返回-1。search()始终从字符串开头向后匹配模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let text = &quot;cat, bat, sat, fat&quot;; </span><br><span class="line">let pos = text.search(/at/); </span><br><span class="line">console.log(pos);  // 1 </span><br></pre></td></tr></table></figure>

<p>replace()方法。这个方法接收两个参数，第一个参数可以是一个 RegExp 对象或一个字符串（这个字符串不会转换为正则表达式），第二个参数可以是一个字符串或一个函数。<br>如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，第一个参数必须为正则表达式并且带全局标记</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let text = &quot;cat, bat, sat, fat&quot;; </span><br><span class="line">let result = text.replace(&quot;at&quot;, &quot;ond&quot;); </span><br><span class="line">console.log(result);  // &quot;cond, bat, sat, fat&quot; </span><br><span class="line"> </span><br><span class="line">result = text.replace(/at/g, &quot;ond&quot;); </span><br><span class="line">console.log(result);  // &quot;cond, bond, sond, fond&quot; </span><br></pre></td></tr></table></figure>

<h2 id="localeCompare"><a href="#localeCompare" class="headerlink" title="localeCompare()"></a>localeCompare()</h2><p>这个方法比较两个字符串，返回如下 3个值中的一个。</p>
<ul>
<li>如果按照字母表顺序，字符串应该排在字符串参数前头，则返回负值。（通常是-1，具体还要看与实际值相关的实现。） </li>
<li>如果字符串与字符串参数相等，则返回 0。 </li>
<li>如果按照字母表顺序，字符串应该排在字符串参数后头，则返回正值。（通常是 1，具体还要看与实际值相关的实现。）</li>
</ul>
<figure class="highlight plaintext"><figcaption><span>stringValue </span></figcaption><table><tr><td class="code"><pre><span class="line">console.log(stringValue.localeCompare(&quot;brick&quot;));  // 1 </span><br><span class="line">console.log(stringValue.localeCompare(&quot;yellow&quot;)); // 0 </span><br><span class="line">console.log(stringValue.localeCompare(&quot;zoo&quot;));    // -1 </span><br></pre></td></tr></table></figure>

<h2 id="matchAll"><a href="#matchAll" class="headerlink" title="matchAll()"></a>matchAll()</h2><p>matchAll()方法返回一个正则表达式在当前字符串的所有匹配，详见ES6深入浅出《正则的扩展》的一章。</p>
<h2 id="replaceAll"><a href="#replaceAll" class="headerlink" title="replaceAll()"></a>replaceAll()</h2><p>历史上，字符串的实例方法replace()只能替换第一个匹配。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;aabbcc&#x27;.replace(&#x27;b&#x27;, &#x27;_&#x27;)</span><br><span class="line">// &#x27;aa_bcc&#x27;</span><br></pre></td></tr></table></figure>

<p>上面例子中，replace()只将第一个b替换成了下划线。</p>
<p>如果要替换所有的匹配，不得不使用正则表达式的g修饰符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;aabbcc&#x27;.replace(/b/g, &#x27;_&#x27;)</span><br><span class="line">// &#x27;aa__cc&#x27;</span><br></pre></td></tr></table></figure>

<p>正则表达式毕竟不是那么方便和直观，<strong>ES2021</strong> 引入了replaceAll()方法，可以一次性替换所有匹配。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;aabbcc&#x27;.replaceAll(&#x27;b&#x27;, &#x27;_&#x27;)</span><br><span class="line">// &#x27;aa__cc&#x27;</span><br></pre></td></tr></table></figure>

<p>它的用法与replace()相同，返回一个新字符串，不会改变原字符串。</p>
<blockquote>
<p>更多详细用法见ES6深入浅出 string 方法章节</p>
</blockquote>
]]></content>
      <categories>
        <category>数据类型</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ul>
<li>基本数据类型<ul>
<li>Undefined</li>
<li>Null</li>
<li>Boolean</li>
<li>Number</li>
<li>String</li>
<li>Symbol</li>
</ul>
</li>
<li>复杂类型：<ul>
<li>Object</li>
</ul>
</li>
</ul>
<h1 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h1><p>对一个值使用 typeof 操作符会返回下列字符串之一：</p>
<ul>
<li>“undefined”表示值未定义</li>
<li>“boolean”表示值为布尔值</li>
<li>“string”表示值为字符串</li>
<li>“number”表示值为数值</li>
<li>“object”表示值为对象（而不是函数）或 null</li>
<li>“function”表示值为函数</li>
<li>“symbol”表示值为符号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let message = &quot;some string&quot;; </span><br><span class="line">console.log(typeof message);    // &quot;string&quot; </span><br><span class="line">console.log(typeof(message));   // &quot;string&quot; </span><br><span class="line">console.log(typeof 95);         // &quot;number&quot; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>typeof 是一个操作符而不是函数，所以不需要参数（但可以使用参数）</p>
</blockquote>
<h1 id="数据类型简介"><a href="#数据类型简介" class="headerlink" title="数据类型简介"></a>数据类型简介</h1><h2 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h2><p>Undefined 类型只有一个值，就是特殊值 undefined。<br>包含 undefined 值的变量跟未定义变量是有区别的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let message;    // 这个变量被声明了，只是值为 undefined </span><br><span class="line">// 确保没有声明过这个变量 // let age </span><br><span class="line">console.log(message); // &quot;undefined&quot; </span><br><span class="line">console.log(age);     // 报错</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是 <code>typeof</code> 操作符返回的结果是没有区别的,都是”undefined”</p>
</blockquote>
<h2 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h2><p>Null 类型同样只有一个值，即特殊值 null。逻辑上讲，null 值表示一个空对象指针，这也是给 typeof 传一个 null 会返回”object”的原因<br>undefined 值是由 null 值派生而来的，因此 ECMA-262将它们定义为表面上相等，如下面的例子所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(null == undefined);  // true </span><br><span class="line">console.log(null === undefined);  // false </span><br></pre></td></tr></table></figure>

<h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><p>Boolean（布尔值）类型有两个字面值：true 和 false。<br>虽然布尔值只有两个，但所有其他 ECMAScript类型的值都有相应布尔值的等价形式。要将一个其他类型的值转换为布尔值，可以调用特定的 Boolean()转型函数：<br>转换规则如下：  </p>
<p><img src="/_posts/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/assets/%E6%A6%82%E8%A7%88/Dingtalk_20210407163159.jpg" alt="Dingtalk_20210407163159"></p>
<h2 id="number"><a href="#number" class="headerlink" title="number"></a>number</h2><p>Number 类型使用的是双精度浮点型，也就是其他语言中的double类型。而双精度浮点数使用64 bit来进行存储</p>
<p><img src="/_posts/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/assets/%E6%A6%82%E8%A7%88/16144bd12f9b3376~tplv-t2oaga2asx-watermark.gif" alt="img"></p>
<p><a href="https://juejin.cn/post/6844903557326454791">双精度浮点数详细介绍</a></p>
<h3 id="三种基本类型"><a href="#三种基本类型" class="headerlink" title="三种基本类型"></a>三种基本类型</h3><h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><p>最基本的数值字面量格式是<strong>十进制整数</strong>，直接写出来即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let intNum = 55; // 整数 </span><br></pre></td></tr></table></figure>

<p>整数也可以用<strong>八进制</strong>（以 8 为基数）或<strong>十六进制</strong>（以 16 为基数）字面量表示。</p>
<p>如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let octalNum1 = 070; // 八进制的 56  </span><br><span class="line">let octalNum2 = 079; // 无效的八进制值，当成 79 处理 </span><br><span class="line">let octalNum3 = 08; // 无效的八进制值，当成 8 处理 </span><br></pre></td></tr></table></figure>

<p>八进制字面量在严格模式下是无效的，会导致 JavaScript 引擎抛出语法错误。</p>
<p>要创建十六进制字面量，必须让真正的数值前缀 0x（区分大小写），</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let hexNum1 = 0xA; // 十六进制 10  </span><br><span class="line">let hexNum2 = 0x1f; // 十六进制 31  </span><br></pre></td></tr></table></figure>

<p>使用八进制和十六进制格式创建的数值在所有数学操作中都被视为十进制数值。</p>
<h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。</p>
<p>因为存储浮点值使用的内存空间是存储整数值的两倍，所以 ECMAScript 总是想方设法把值转换为 整数。</p>
<p><strong>如下例所示：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let floatNum1 = 1.; // 小数点后面没有数字，当成整数 1 处理</span><br><span class="line">let floatNum2 = 10.0; // 小数点后面是零，当成整数 10 处理</span><br></pre></td></tr></table></figure>

<p>浮点值的精确度最高可达 17 位小数，但在算术计算中远不如整数精确。例如，0.1 加 0.2 得到的不 是 0.3，而是 0.300 000 000 000 000 04。</p>
<h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p>有一个特殊的数值叫 NaN，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作 失败了（而不是抛出错误）。</p>
<p>NaN 有几个独特的属性：</p>
<ul>
<li><p>任何涉及 NaN 的操作始终返回 NaN（如 NaN&#x2F;10）</p>
</li>
<li><p>NaN 不等于包括 NaN 在内的任何值</p>
<ul>
<li>ECMAScript 提供了 isNaN()函数</li>
</ul>
<blockquote>
<p>把一个值传给 isNaN()后，该函数会尝试把它转换为数值。（使用哪种转换规则未知）<strong>待补充</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(isNaN(NaN)); // true </span><br><span class="line">console.log(isNaN(10)); // false，10 是数值</span><br><span class="line">console.log(isNaN(&quot;10&quot;)); // false，可以转换为数值 10 </span><br><span class="line">console.log(isNaN(&quot;blue&quot;)); // true，不可以转换为数值</span><br><span class="line">console.log(isNaN(true)); // false，可以转换为数值 1 </span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><p><code>Number()</code>、<code>parseInt()</code>和 <code>parseFloat()</code></p>
<p><strong>Number()是 转型函数，可用于<em>任何数据类型</em>。后两个函数主要用于将<em>字符串</em>转换为数值</strong></p>
<h4 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h4><p>Number()是 转型函数，可用于任何数据类型。</p>
<p>Number()函数基于如下规则执行转换(<strong>一元加操作符</strong>与 Number()函数遵循相同的转换规则)。</p>
<ul>
<li>布尔值，true 转换为 1，false 转换为 0。</li>
<li>数值，直接返回。</li>
<li>null，返回 0。</li>
<li>undefined，返回 NaN。</li>
<li><h2 id="字符串，应用以下规则。-如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。-因此，Number-“1”-返回-1，Number-“123”-返回-123，Number-“011”-返回-11（忽略前面-的零）。-如果字符串包含有效的浮点值格式如”1-1”，则会转换为相应的浮点值（同样，忽略前面的零）。-如果字符串包含有效的十六进制格式如”0xf”，则会转换为与该十六进制值对应的十进制整-数值。-如果是空字符串（不包含字符），则返回-0。-如果字符串包含除上述情况之外的其他字符，则返回-NaN。"><a href="#字符串，应用以下规则。-如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。-因此，Number-“1”-返回-1，Number-“123”-返回-123，Number-“011”-返回-11（忽略前面-的零）。-如果字符串包含有效的浮点值格式如”1-1”，则会转换为相应的浮点值（同样，忽略前面的零）。-如果字符串包含有效的十六进制格式如”0xf”，则会转换为与该十六进制值对应的十进制整-数值。-如果是空字符串（不包含字符），则返回-0。-如果字符串包含除上述情况之外的其他字符，则返回-NaN。" class="headerlink" title="字符串，应用以下规则。- 如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。 因此，Number(“1”)返回 1，Number(“123”)返回 123，Number(“011”)返回 11（忽略前面 的零）。- 如果字符串包含有效的浮点值格式如”1.1”，则会转换为相应的浮点值（同样，忽略前面的零）。- 如果字符串包含有效的十六进制格式如”0xf”，则会转换为与该十六进制值对应的十进制整 数值。- 如果是空字符串（不包含字符），则返回 0。- 如果字符串包含除上述情况之外的其他字符，则返回 NaN。"></a>字符串，应用以下规则。<br>- 如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。 因此，Number(“1”)返回 1，Number(“123”)返回 123，Number(“011”)返回 11（忽略前面 的零）。<br>- 如果字符串包含有效的浮点值格式如”1.1”，则会转换为相应的浮点值（同样，忽略前面的零）。<br>- 如果字符串包含有效的十六进制格式如”0xf”，则会转换为与该十六进制值对应的十进制整 数值。<br>- 如果是空字符串（不包含字符），则返回 0。<br>- <strong>如果字符串包含除上述情况之外的其他字符，则返回 NaN。</strong></h2><ul>
<li></li>
<li><pre><code>Number(&quot;a1&quot;); NaN
let num1 = Number(&quot;Hello world!&quot;); // NaN 
let num2 = Number(&quot;&quot;); // 0 
let num3 = Number(&quot;000011&quot;); // 11 
let num4 = Number(true); // 1 
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 对象，调用 valueOf()方法，并按照上述规则转换返回的值。如果转换结果是 NaN，则调用 toString()方法，再按照转换字符串的规则转换。</span><br><span class="line"></span><br><span class="line">#### parseInit()</span><br><span class="line"></span><br><span class="line">parseInt()函数更专注于字符串是否包含数值模式，接收第二个参数，用于指定**底数（进制数）**。。</span><br><span class="line"></span><br><span class="line">parseInt()函数基于如下规则执行转换</span><br><span class="line"></span><br><span class="line">- 字符串最前面的空格会被 忽略，从第一个非空格字符开始转换</span><br><span class="line">- 如果第一个字符不是数值字符、加号或减号，parseInt()立即 返回 NaN</span><br><span class="line">- 如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，**直到字符串末尾，或碰到非数值字符**</span><br><span class="line">- 字符串以&quot;0x&quot;开头，就会被解释为十六进制整数。如果字符串以&quot;0&quot; 开头，且紧跟着数值字符，在**非严格模式**下会被**某些实现**解释为八进制整数</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>let num1 &#x3D; parseInt(“1234blue”); &#x2F;&#x2F; 1234<br>let num2 &#x3D; parseInt(“”); &#x2F;&#x2F; NaN<br>let num3 &#x3D; parseInt(“0xA”); &#x2F;&#x2F; 10，解释为十六进制整数<br>let num4 &#x3D; parseInt(22.5); &#x2F;&#x2F; 22<br>let num5 &#x3D; parseInt(“70”); &#x2F;&#x2F; 70，解释为十进制值<br>let num6 &#x3D; parseInt(“0xf”); &#x2F;&#x2F; 15，解释为十六进制整数<br>let num1 &#x3D; parseInt(“AF”, 16); &#x2F;&#x2F; 175<br>let num2 &#x3D; parseInt(“AF”); &#x2F;&#x2F; NaN </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### parseFloat()</span><br><span class="line"></span><br><span class="line">parseFloat()函数的工作方式跟 parseInt()函数类似，但是**只能解析十进制值**</span><br><span class="line"></span><br><span class="line">- 始终忽略字符串开头的零</span><br><span class="line"></span><br><span class="line">- 解析到字符串末尾或者解析到一个无效的浮点数值字符为止</span><br><span class="line"></span><br><span class="line">  &gt; 第一次出现的小数点是有 效的，但第二次出现的小数点就无效 &quot;22.34.5&quot;将转换 成 22.34</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>let num1 &#x3D; parseFloat(“1234blue”); &#x2F;&#x2F; 1234，按整数解析<br>let num2 &#x3D; parseFloat(“0xA”); &#x2F;&#x2F; 0<br>let num3 &#x3D; parseFloat(“22.5”); &#x2F;&#x2F; 22.5<br>let num4 &#x3D; parseFloat(“22.34.5”); &#x2F;&#x2F; 22.34<br>let num5 &#x3D; parseFloat(“0908.5”); &#x2F;&#x2F; 908.5<br>let num6 &#x3D; parseFloat(“3.125e7”); &#x2F;&#x2F; 31250000 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## Srting</span><br><span class="line"></span><br><span class="line">String（字符串）数据类型表示零或多个 16 位 Unicode 字符序列。</span><br><span class="line"></span><br><span class="line">&gt; ECMAScript 中的字符串是不可变的，要修改 某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量,**所有字符串方法都不会影响原字符串，无一例外**</span><br><span class="line"></span><br><span class="line">### 转换为字符串</span><br><span class="line"></span><br><span class="line">几乎所有值都有的 `toString()`方法。这个方法唯 一的用途就是返回当前值的字符串等价物。</span><br><span class="line"></span><br><span class="line">&gt; 用加号操作符给一个值加上一个空字符串&quot;&quot;也可以将其转换为字符串</span><br><span class="line"></span><br><span class="line">toString()方法可见于数值、布尔值、对象和字符串值。null 和 undefined 值没有 toString()方法（直接返回这两个值的字面量文本）</span><br><span class="line"></span><br><span class="line">&gt; 没错，字符串值也有 toString()方法， 该方法只是简单地返回自身的一个副本。</span><br><span class="line"></span><br><span class="line">&gt; 多数情况下，toString()不接收任何参数。不过，在对数值调用这个方法时，toString()可以接受以什么底数来输出数值的字符串表示</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>let num &#x3D; 10;<br>console.log(num.toString()); &#x2F;&#x2F; “10”<br>console.log(num.toString(2)); &#x2F;&#x2F; “1010”<br>console.log(num.toString(8)); &#x2F;&#x2F; “12”<br>console.log(num.toString(10)); &#x2F;&#x2F; “10”<br>console.log(num.toString(16)); &#x2F;&#x2F; “a”<br>&#96;&#96;</p>
<pre><code>
</code></pre>
</blockquote>
<blockquote>
<p>详细见js高程第四版 5.3.3</p>
</blockquote>
]]></content>
      <categories>
        <category>数据类型</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>类型判断</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JavaScript 是一种<code>弱类型</code>或者说<code>动态类型</code>，这就意味着你不需要提前声明变量的类型，在程序运行的过程中，类型会被自动确定。这就意味着你可以使用同一个变量保存不同类型的数据：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="number">5</span> <span class="comment">// data is Number now</span></span><br><span class="line">data = <span class="string">&#x27;5&#x27;</span> <span class="comment">// data is String now</span></span><br><span class="line">data = <span class="literal">true</span> <span class="comment">// data is Boolean now</span></span><br><span class="line">.......</span><br></pre></td></tr></table></figure>

<p>相信不管是在学习还是平常写业务的过程中，或多或少的都会碰到类似于— <code>如何判断数据类型</code> 的这种问题。尤其是在面试中，经常被问到 — <code>请说出判断数组的几种方法</code> <code>你知道判断数据类型有哪几种方法</code>等等。</p>
<p>虽然看起来仅仅只是判断数据类型的方法，但是涉及到<code>数据类型</code>，<code>原型链</code>等各种js基础，话不多说，直接开始吧。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>最新的 ECMAScript 标准定义了 8 种数据类型:</p>
<ul>
<li>7种原始类型：<ul>
<li>Boolean</li>
<li>Null</li>
<li>Undefined</li>
<li>Number</li>
<li>BigInt</li>
<li>String</li>
<li>Symbol</li>
</ul>
</li>
<li>Object</li>
</ul>
<h3 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h3><p><code>除Object 以外的所有类型(基本类型)都是不可以变的（值本身无法被改变）</code> 例如：js中字符串是不可变的（js对字符串的操作返回了一个新字符串，但是原始字符串并没有被改变），我们称这些类型的值为“原始值”。</p>
<h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h4><p>对于布尔类型，永远只有<code>true</code>和<code>false</code>两个值。</p>
<h4 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h4><p>null 是一个字面量，不像 undefined ，它不是一个全局对象的一个属性。null 是表示缺少的标识，指示变量未指向任何对象。把 null 作为尚未创建的对象，也许更好理解。</p>
<p>在 API 中，null 常在返回类型应是一个对象，但没有关联的值的地方使用。</p>
<h4 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h4><p>一个没有被赋值的变量会有个默认值 undefined; undefined是全局对象的一个属性。</p>
<h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><p>根据 ECMAScript 标准，JavaScript 中只有一种数字类型：基于 IEEE 754 标准的双精度 64 位二进制格式的值（-(2^53 -1) 到 2^53 -1）。它并没有为整数给出一种特定的类型。除了能够表示浮点数外，还有一些带符号的值：+Infinity，-Infinity 和 NaN (非数值，Not-a-Number)。</p>
<h4 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h4><p>使用 BigInt，可以安全地存储和操作大整数. 常常通过在整数末尾附加 n 或调用构造函数来创建的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const a = BigInt(&#x27;43243242424242424242342432&#x27;)</span><br><span class="line">// 43243242424242424242342432n</span><br><span class="line"></span><br><span class="line">const b = 43243242424242424242342432n</span><br><span class="line">// 43243242424242424242342432n</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>字符串的长度是它的元素的数量。字符串一旦被创建，就不能被修改。但是，可以基于原始字符串的操作来创建新的字符串。例如：</p>
<ul>
<li>String.concat() 拼接字符串</li>
</ul>
<p>插一个问题：<code>&#39;1&#39;.toString()为什么可以调用?</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = new Object(&#x27;1&#x27;);</span><br><span class="line">a.toString();</span><br><span class="line">console.log(&#x27;-----a&#x27;,a); // [String: &#x27;1&#x27;]</span><br><span class="line">a = null</span><br><span class="line">console.log(&#x27;-----a最终&#x27;,a); // null</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li>第一步：创建Object类实例。注意为什么不是String ？由于Symbol和BigInt的出现，对它们调用new都会报错，目前ES6规范也不建议用new来创建基本类型的包装类。</li>
<li>第二步：调用实例方法。</li>
<li>第三步：执行完方法立即销毁这个实例。</li>
</ul>
<h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><p>Symbol 是ES6新增的一种基本数据类型。我们可以通过调用内置函数 Symbol() 创建，这个函数会动态的生成一个匿名、全局唯一的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const a = Symbol();</span><br><span class="line">const b = Symbol();</span><br><span class="line">a === b // false</span><br><span class="line"></span><br><span class="line">const c = Symbol(&#x27;c&#x27;); // Symbol(c)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<hr>
<p>Symbol 函数栈不能用 new 命令，因为 Symbol 是原始数据类型，不是对象。可以接受一个字符串作为参数，为新创建的 Symbol 提供描述，用来显示在控制台或者作为字符串的时候使用，便于区分。</p>
<hr>
<p>Symbol最大的用处就是：<code>避免对象的键被覆盖。</code></p>
<h4 id="基本数据和引用数据的区别"><a href="#基本数据和引用数据的区别" class="headerlink" title="基本数据和引用数据的区别"></a>基本数据和引用数据的区别</h4><h5 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h5><ul>
<li>按值访问，可操作保存在变量中实际的值</li>
<li>值被保存在 <code>栈内存</code> 中，占据固定大小的空间</li>
</ul>
<h5 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h5><ul>
<li>引用类型的值是按引用访问的</li>
<li>保存在堆内存中的对象，不能直接访问操作对象的内存空间</li>
</ul>
<p>回归正题，下面来说说判断数据类型的方法👇</p>
<hr>
<h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typeof &#x27;5&#x27; // string</span><br><span class="line">typeof 5 // number</span><br><span class="line">typeof null // object</span><br><span class="line">typeof undefined // undefined</span><br><span class="line">typeof true // boolean</span><br><span class="line">typeof Symbol(&#x27;5&#x27;) // symbol</span><br><span class="line">typeof 5n // bigint</span><br><span class="line">typeof new Object(); // object</span><br><span class="line">typeof new Function(); // function</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>上面的例子，对于基本数据类型来说，除了null返回的是object，其他都可返回正确的类型。 调用null为空，是因为</p>
<ul>
<li>null被认为是一个空对象，因此返回了object</li>
<li>因为任何对象都会被转化为二进制，null转为二进制则表示全为0，如果前三个均为0，js就会把它当作是对象，这是js早期遗留下来的bug</li>
</ul>
<p>所以<strong>typeof</strong>：</p>
<ul>
<li><code>适用于判断（除null）基础类型,</code></li>
<li><code>判断引用类型，除了function 全返回object类型</code></li>
</ul>
<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><ul>
<li>只能用来判断<code>变量的原型链上是否有构造函数的prototype属性（两个对象是否属于原型链的关系）</code>，不一定能获取对象的具体类型</li>
<li>Instanceof 不适用判断原始类型的值，只能用于判断对象是否从属关系</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[] instanceof Array; // true</span><br><span class="line">[] instanceof Object; // true</span><br><span class="line"></span><br><span class="line">function Person() &#123;&#125;;</span><br><span class="line">const person = new Person();</span><br><span class="line"></span><br><span class="line">person instanceof Person; // true</span><br><span class="line">person instanceof Object; // true</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>首先来分析一下，为什么 <code>[] instanceof Array</code> 为true。</p>
<ul>
<li>首先，[].<strong>proto</strong> 的原型 是指向Array.prototype 的，说明两个对象是属于同一条原型链的，返回true</li>
<li>同理，从代码中可以得知<code>person instanceof Person</code>也是返回true的，那么为什么<code>person instanceof Object</code>也为true呢？</li>
<li>基于原型链的原理：从实例对象的构造函数的原型开始向上寻找，构造函数的原型又有其原型，一直向上找，直到找到原型链的顶端Object.prototype为止。如果没有，则返回null</li>
<li>可以看出，person和Object是属于原型链的关系，所以返回true</li>
</ul>
<p><img src="/_posts/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/assets/%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/17d691db030245548cd7859fb16123e7~tplv-k3u1fbpfcp-watermark.gif" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意：空对象&#123;&#125;的判断问题</span><br><span class="line">let obj1 = &#123;&#125;</span><br><span class="line">console.log(obj1 instanceof Object) // true</span><br><span class="line"></span><br><span class="line">let obj2 = Object.create(null)</span><br><span class="line">console.log(obj2 instanceof Object) // false</span><br><span class="line"></span><br><span class="line">let obj3 = Object.create(&#123;&#125;)</span><br><span class="line">console.log(obj3 instanceof Object) // true</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>原理：<code>每一个实例对象都可通过constructor来访问它的构造函数</code>,其实也是根据原型链的原理来的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;5&#x27;.__proto__.constructor === String // true</span><br><span class="line">[5].__proto__.constructor === Array // true</span><br><span class="line"></span><br><span class="line">undefined.__proto__.constructor // Cannot read property &#x27;__proto__&#x27; of undefined</span><br><span class="line"></span><br><span class="line">null.__proto__.constructor // Cannot read property &#x27;__proto__&#x27; of undefined</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>由于undefined和null是无效的对象，因此是没有constructor属性的,这两个值不能用这种方法判断.</p>
<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h2><ul>
<li>Object.prototype.toString方法返回对象的类型字符串，因此可用来判断一个值的类型。</li>
<li>因为实例对象有可能会自定义toString方法，会覆盖Object.prototype.toString，所以在使用时，最好加上call</li>
<li>所有的数据类型都可以使用此方法进行检测，且非常精准</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/118793721">关于原理</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.prototype.toString.call(&#x27;5&#x27;) // [object String]</span><br><span class="line">Object.prototype.toString.call(5) // [object Number]</span><br><span class="line">Object.prototype.toString.call([5]) // [object Array]</span><br><span class="line">Object.prototype.toString.call(true) // [object Boolean]</span><br><span class="line">Object.prototype.toString.call(undefined) // [object Undefined]</span><br><span class="line">Object.prototype.toString.call(null) // [object Null]</span><br><span class="line">Object.prototype.toString.call(new Function()); // [object Function]</span><br><span class="line">Object.prototype.toString.call(new Date()); // [object Date]</span><br><span class="line">Object.prototype.toString.call(new RegExp()); // [object RegExp]</span><br><span class="line">Object.prototype.toString.call(new Error()); // [object Error]</span><br><span class="line">Object.prototype.toString.call(&#123;df:1&#125;); // [object Object]</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>typeof 适合基本类型和function类型的检测，无法判断null与object</li>
<li>instanceof 适合自定义对象，也可以用来检测原生对象，在不同的iframe 和 window间检测时失效，还需要注意Object.create(null)对象的问题</li>
<li>constructor 基本能判断所有类型，除了null和undefined，但是constructor容易被修改，也不能跨iframe使用</li>
<li>tostring能判断所有类型，可将其封装为全能的DataType()判断所有数据类型</li>
</ul>
]]></content>
      <categories>
        <category>数据类型</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
        <tag>类型判断</tag>
      </tags>
  </entry>
  <entry>
    <title>commonjs循环加载</title>
    <url>/nodejs/circle-load/</url>
    <content><![CDATA[<h2 id="介绍一下commonjs循环加载的处理方式"><a href="#介绍一下commonjs循环加载的处理方式" class="headerlink" title="介绍一下commonjs循环加载的处理方式"></a>介绍一下commonjs循环加载的处理方式</h2><p><a href="https://juejin.cn/post/6994224541312483336#heading-3">有循环加载的原理解释，理解起来更加清晰</a></p>
<p>先介绍下require的特性</p>
<p>​        1 module 被加载的时候执行，模块的所有语句都会被执行</p>
<p>​        2 module 加载后缓存，以后使用会在内存中寻找，不会二次加载</p>
<p>​        3 一旦出现某个模块被循环加载，就只输出已经执行的部分，还未执行的部分不会输出（下方解释）</p>
<p>脚本文件<code>a.js</code>代码如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">done</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b.js&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;在 a.js 之中，b.done = %j&#x27;</span>, b.<span class="property">done</span>);</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">done</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a.js 执行完毕&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码之中，<code>a.js</code>脚本先输出一个<code>done</code>变量，然后加载另一个脚本文件<code>b.js</code>。注意，此时<code>a.js</code>代码就停在这里，等待<code>b.js</code>执行完毕，再往下执行。</p>
<p>再看<code>b.js</code>的代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">done</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;在 b.js 之中，a.done = %j&#x27;</span>, a.<span class="property">done</span>);</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">done</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b.js 执行完毕&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码之中，<code>b.js</code>执行到第二行，就会去加载<code>a.js</code>，这时，就发生了“循环加载”。系统会去<code>a.js</code>模块对应对象的<code>exports</code>属性取值，可是因为<code>a.js</code>还没有执行完，从<code>exports</code>属性只能取回已经执行的部分，而不是最后的值。</p>
<p><code>a.js</code>已经执行的部分，只有一行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">done</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>因此，对于<code>b.js</code>来说，它从<code>a.js</code>只输入一个变量<code>done</code>，值为<code>false</code>。</p>
<p>然后，<code>b.js</code>接着往下执行，等到全部执行完毕，再把执行权交还给<code>a.js</code>。于是，<code>a.js</code>接着往下执行，直到执行完毕。我们写一个脚本<code>main.js</code>，验证这个过程。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b.js&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;在 main.js 之中, a.done=%j, b.done=%j&#x27;</span>, a.<span class="property">done</span>, b.<span class="property">done</span>);</span><br></pre></td></tr></table></figure>

<p>执行<code>main.js</code>，运行结果如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ node main.<span class="property">js</span></span><br><span class="line"></span><br><span class="line">在 b.<span class="property">js</span> 之中，a.<span class="property">done</span> = <span class="literal">false</span></span><br><span class="line">b.<span class="property">js</span> 执行完毕</span><br><span class="line">在 a.<span class="property">js</span> 之中，b.<span class="property">done</span> = <span class="literal">true</span></span><br><span class="line">a.<span class="property">js</span> 执行完毕</span><br><span class="line">在 main.<span class="property">js</span> 之中, a.<span class="property">done</span>=<span class="literal">true</span>, b.<span class="property">done</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>具体执行顺序如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b.js&#x27;</span>); <span class="comment">// 12</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;在 main.js 之中, a.done=%j, b.done=%j&#x27;</span>, a.<span class="property">done</span>, b.<span class="property">done</span>); <span class="comment">// 13</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">done</span> = <span class="literal">false</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b.js&#x27;</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;在 a.js 之中，b.done = %j&#x27;</span>, b.<span class="property">done</span>); <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">done</span> = <span class="literal">true</span>; <span class="comment">// 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a.js 执行完毕&#x27;</span>); <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">done</span> = <span class="literal">false</span>; <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;在 b.js 之中，a.done = %j&#x27;</span>, a.<span class="property">done</span>); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">done</span> = <span class="literal">true</span>; <span class="comment">// 7</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b.js 执行完毕&#x27;</span>); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>循环加载</tag>
        <tag>commonjs</tag>
      </tags>
  </entry>
  <entry>
    <title>redis</title>
    <url>/%E5%A4%A7%E5%89%8D%E7%AB%AF/redis/</url>
    <content><![CDATA[<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/redis/image-20210428205046181.png" alt="image-20210428205046181"></p>
<h3 id="redis特点"><a href="#redis特点" class="headerlink" title="redis特点"></a>redis特点</h3><ul>
<li>高性能，可持久化</li>
<li>key-value结构，支持多种数据类型</li>
<li>支持事务，数据的原子性</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>缓存（读写性能优异）</li>
<li>计数&amp;消息系统（高并发、发布&#x2F;订阅阻塞队列功能）</li>
<li>分布式回话session&amp;分布式锁（秒杀）</li>
</ul>
<h3 id="redis-vs-mongo"><a href="#redis-vs-mongo" class="headerlink" title="redis vs mongo"></a>redis vs mongo</h3><ul>
<li>储存方式不一样：key-value vs document</li>
<li>使用方式&amp;可靠性不一样： MongoDB SQL &amp; ACDI支持</li>
<li>应用场景不一样：高性能缓存 vs 海量数据分析</li>
</ul>
<h3 id="使用docker-安装redis"><a href="#使用docker-安装redis" class="headerlink" title="使用docker 安装redis"></a>使用docker 安装redis</h3><h4 id="Docker-compose配置"><a href="#Docker-compose配置" class="headerlink" title="Docker-compose配置"></a>Docker-compose配置</h4><p>在linux服务器中，新建<code>/home/redistest/docker-compose.yml</code>，并书写以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services: </span><br><span class="line">  redis-test:</span><br><span class="line">    image: &quot;redis&quot;</span><br><span class="line">    restart: always</span><br><span class="line">    container_name: &quot;redis-test&quot;</span><br><span class="line">    ports: </span><br><span class="line">      - 15001:6379</span><br><span class="line">    volumes: </span><br><span class="line">      - /home/redistest:/data // 持久化</span><br><span class="line">    command: [&quot;redis-server&quot;,&quot;--requirepass&quot;,&quot;123456&quot;] // 设置密码</span><br></pre></td></tr></table></figure>

<p>然后在当前目录运行<code>docker-compose up -d</code> 会自动抓取redis 并运行在15001端口</p>
<p>然后运行linux端口放行<code>firewall-cmd --zone=public --add-port=15001/tcp --permanent</code></p>
<h4 id="使用redis-cli"><a href="#使用redis-cli" class="headerlink" title="使用redis-cli"></a>使用redis-cli</h4><p><a href="http://doc.redisfans.com/">redis命令</a></p>
<ul>
<li>进入容器交互终端  <code>docker exec -it redis-test /bin/bash</code></li>
<li>输入 redis-cli 回车</li>
<li>输入 auth 123456 &#x2F;&#x2F; 密码登陆</li>
<li>输出OK表示成功</li>
</ul>
<blockquote>
<p>想从镜像终端中出来，输入exit</p>
</blockquote>
<h5 id="常用的redis命令"><a href="#常用的redis命令" class="headerlink" title="常用的redis命令"></a>常用的redis命令</h5><ul>
<li><p>ping ，如果运行正确 会返回pong</p>
</li>
<li><p>quit 断开当前redis 服务</p>
</li>
<li><p>auth 123456 &#x2F;&#x2F; 登陆</p>
</li>
<li><p>select  number 切换自动数据库，默认有0 - 15</p>
</li>
<li><p>设置数据</p>
<ul>
<li>set key value 设置键值</li>
<li>get key 获取键值</li>
<li>incr 变量自增 例如 set index 0 ；incr inde ；&#x2F;&#x2F; 1 计数器</li>
<li>decr 递减</li>
<li>keys 正则 （*所有）查看符合条件的键值</li>
<li>exists  key  […key] 看键值是否存在 1 存在 0 不存在</li>
<li>del  key 删除键值 1成功 0失败</li>
</ul>
</li>
<li><p>设置过期时间</p>
<ul>
<li>set key value  ‘EX’  seconds</li>
</ul>
</li>
<li><p>Hash</p>
<ul>
<li><p>hset obj key value</p>
</li>
<li><pre><code>就像给一个对象设置键值对一样 
hset brian name &quot;brian&quot;
hset brian age 19
brian = &#123;
 name: &quot;brian&quot;,
  age: 20
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- hgetall obj  返回对象的key value对</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  hgetall brian</span><br><span class="line">  name</span><br><span class="line">  brian</span><br><span class="line">  age</span><br><span class="line">  19</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>Hmset 设置多对键值对</p>
</li>
<li><pre><code>hmset brian name xxx age 19 email ueih@122
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- Hmget 获取多个键值</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  hmget brian name age</span><br><span class="line">  xxx</span><br><span class="line">  19</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>list list操作</p>
</li>
<li><p>pub&#x2F;sub 发布订阅</p>
</li>
<li><p>server命令</p>
<ul>
<li>client list 可以查看redis-cli连接的哪些redis-client服务 通过idle空闲时间判断当前使用的</li>
<li>client kill host:port 断开</li>
<li>flushdb 清空当前数据库的数据</li>
<li>flushall 清空所有数据库</li>
</ul>
</li>
<li><p>slowlog  slow log是用来记录执行时间的日子系统</p>
</li>
</ul>
<h3 id="redis备份"><a href="#redis备份" class="headerlink" title="redis备份"></a>redis备份</h3><p>save 命令备份（同步任务，会阻塞，使用bgsave） 会生成一个dump.rdb，quit停止服务</p>
<p>CONFIG get dir 找到数据存在位置，把dump.rdb放入，重启服务就可以了</p>
<h3 id="Redis-GUI"><a href="#Redis-GUI" class="headerlink" title="Redis GUI"></a>Redis GUI</h3><p>安装一个破解版的redis desktop manage，可以修改语言为中文，通过gui中的终端服务，可以很轻松的使用</p>
<h3 id="Nodejs-集成-redis"><a href="#Nodejs-集成-redis" class="headerlink" title="Nodejs 集成 redis"></a>Nodejs 集成 redis</h3><p>首先安装redis <code>npm install redis --save</code></p>
<p>redis配置示例如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import redis from &quot;redis&quot;</span><br><span class="line">const &#123; promisify &#125; = require(&quot;util&quot;);</span><br><span class="line">const options = &#123;</span><br><span class="line">  host: &quot;39.106.100.189&quot;, // 切记不需要写http之类的</span><br><span class="line">  port: 15001,</span><br><span class="line">  password: &quot;123456&quot;,</span><br><span class="line">  detect_buffers: true, // 不转换二进制</span><br><span class="line">  retry_strategy: function(options) &#123; // 重连错误处理</span><br><span class="line">    if (options.error &amp;&amp; options.error.code === &quot;ECONNREFUSED&quot;) &#123;</span><br><span class="line">      // End reconnecting on a specific error and flush all commands with</span><br><span class="line">      // a individual error</span><br><span class="line">      return new Error(&quot;The server refused the connection&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (options.total_retry_time &gt; 1000 * 60 * 60) &#123;</span><br><span class="line">      // End reconnecting after a specific timeout and flush all commands</span><br><span class="line">      // with a individual error</span><br><span class="line">      return new Error(&quot;Retry time exhausted&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (options.attempt &gt; 10) &#123;</span><br><span class="line">      // End reconnecting with built in error</span><br><span class="line">      return undefined;</span><br><span class="line">    &#125;</span><br><span class="line">    // reconnect after</span><br><span class="line">    return Math.min(options.attempt * 100, 3000);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 创建一个redis实例</span><br><span class="line">const client = redis.createClient(options)</span><br><span class="line"></span><br><span class="line">// set方法</span><br><span class="line">const setValue = (key, value) =&gt; &#123;</span><br><span class="line">   return client.set(key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建promise</span><br><span class="line">const getAsync = promisify(client.get).bind(client);</span><br><span class="line"></span><br><span class="line">// get方法</span><br><span class="line">const getValue = (key) =&gt; &#123;</span><br><span class="line">  return getAsync(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123;</span><br><span class="line">  client,</span><br><span class="line">  setValue,</span><br><span class="line">  getValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setValue(&quot;ceshi&quot;, 122333)</span><br><span class="line">getValue(&quot;ceshi&quot;).then(res =&gt; &#123;</span><br><span class="line">  console.log(res);</span><br><span class="line">&#125;)</span><br><span class="line">// 122333 成功</span><br></pre></td></tr></table></figure>

<p>get 、set方法生产模式再次封装一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ set方法</span><br><span class="line">const setValue = (key, value) =&gt; &#123;</span><br><span class="line">  if (typeof value === &quot;undefined&quot; || value == null || value === &quot;&quot;) &#123;</span><br><span class="line">    // == null 包含null 和 undefined</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  if (typeof value === &quot;string&quot;) &#123;</span><br><span class="line">    return client.set(key, value)</span><br><span class="line">  &#125; else if (typeof value === &quot;object&quot;) &#123;</span><br><span class="line">    // 对象层级应该只有能一层，不能多级嵌套</span><br><span class="line">    Object.keys(value).forEach((keyC) =&gt; &#123;</span><br><span class="line">      client.hset(key, keyC, value[keyC], redis.print)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建promise</span><br><span class="line">const getAsync = promisify(client.get).bind(client);</span><br><span class="line">// get方法</span><br><span class="line">const getValue = (key) =&gt; &#123;</span><br><span class="line">  return getAsync(key)</span><br><span class="line">&#125;</span><br><span class="line">// hash get方法</span><br><span class="line">const getHValue = (key) =&gt; &#123;</span><br><span class="line">  return promisify(client.hgetall).bind(client)(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>大前端</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>koa2</title>
    <url>/%E5%A4%A7%E5%89%8D%E7%AB%AF/koa2/</url>
    <content><![CDATA[<p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/koa2/Snipaste_2021-04-23_10-08-28.png" alt="Snipaste_2021-04-23_10-08-28"></p>
<p><a href="https://koa.bootcss.com/#links">koa中文网</a>  有比较详细的介绍<br>详细可运行的配置在 <a href="https://github.com/mst123/bfe">个人git项目</a></p>
<blockquote>
<p>和文章略有出入（很多插件都有更新的版本）</p>
</blockquote>
<h2 id="koa常用的中间件"><a href="#koa常用的中间件" class="headerlink" title="koa常用的中间件"></a>koa常用的中间件</h2><ul>
<li>kao-router 路由相关 接口必备</li>
<li>koa-combine-routers 当路由文件较多时，合并路由，只需要一个app.use就可以搞定</li>
<li>koa-body 解析前端发送的数据，支持<ul>
<li>can handle requests such as:<ul>
<li><strong>multipart&#x2F;form-data</strong></li>
<li><strong>application&#x2F;x-www-urlencoded</strong></li>
<li><strong>application&#x2F;json</strong></li>
<li><strong>application&#x2F;json-patch+json</strong></li>
<li><strong>application&#x2F;vnd.api+json</strong></li>
<li><strong>application&#x2F;csp-report</strong></li>
<li><strong>text&#x2F;xml</strong></li>
</ul>
</li>
<li>option for patch to Koa or Node, or either</li>
<li>file uploads</li>
<li>body, fields and files size limiting</li>
</ul>
</li>
<li>Koa-json 美化json</li>
<li>@koa-cors 跨域请求</li>
<li>koa-views 渲染页面</li>
<li>koa-helmet 前端安全 设置安全头</li>
<li>koa-send 静态文件服务中间件 可以实现下载功能，也是koa-static的依赖</li>
<li>Koa-static 静态资源服务器</li>
<li>koa-compose 整合中间件 ompose[midleware, ….]  替代带多次 use()</li>
</ul>
<h2 id="使用webpack-开发-koa-项目"><a href="#使用webpack-开发-koa-项目" class="headerlink" title="使用webpack 开发 koa 项目"></a>使用webpack 开发 koa 项目</h2><ul>
<li><p>首先需要安装webpack webpack-cli <code>npm install webpack webpack-cli -D</code></p>
</li>
<li><p>安装几个webpack plugin</p>
<ul>
<li>clean-webpack-plugin 清理dist目录</li>
<li>webpack-node-externals 对node_modules文件做排除处理（貌似是为了nodejs准备的）</li>
</ul>
</li>
<li><p>安装babel相关的plugin或loader</p>
<ul>
<li>@babel&#x2F;core  </li>
<li>@babel&#x2F;node</li>
<li>@babel&#x2F;preset-env</li>
<li>babel-loader</li>
</ul>
</li>
<li><p>书写webpack.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const path = require(&quot;path&quot;)</span><br><span class="line">const nodeExcternals = require(&quot;webpack-node-externals&quot;)</span><br><span class="line">const &#123; CleanWebpackPlugin &#125; = require(&quot;clean-webpack-plugin&quot;)</span><br><span class="line">const webpackconfig = &#123;</span><br><span class="line"> target: &quot;node&quot;,</span><br><span class="line"> mode: &quot;development&quot;,</span><br><span class="line"> entry: &#123;</span><br><span class="line">  server: path.join(__dirname, &quot;./src/index.js&quot;)</span><br><span class="line"> &#125;,</span><br><span class="line"> output: &#123;</span><br><span class="line">  filename: &quot;[name].bundle.js&quot;,</span><br><span class="line">  path: path.join(__dirname, &quot;./dist&quot;)</span><br><span class="line"> &#125;,</span><br><span class="line"> devtool: &#123;</span><br><span class="line">  &quot;eval-source-map&quot;</span><br><span class="line"> &#125;,</span><br><span class="line"> modules: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">   &#123;</span><br><span class="line">    test: /\.(js|jsx)$/,</span><br><span class="line">    use: &#123;</span><br><span class="line">     loader: &quot;babel-loader&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    exclude: [path.join(__dirname, &quot;/node-modules&quot;)]</span><br><span class="line">   &#125;</span><br><span class="line">  ]</span><br><span class="line"> &#125;,</span><br><span class="line"> externals: [nodeExcternals()],</span><br><span class="line"> plugins: [</span><br><span class="line">  new CleanWebpackPlugin(),</span><br><span class="line">  new webpack.DefinePlugin(&#123;</span><br><span class="line">   &#x27;process.env&#x27;: &#123;</span><br><span class="line">    NODE_ENV: JOSN.stringfy(process.env.NODE_ENV) (就算是字符串还是需要)类似于“‘production’”</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"> ],</span><br><span class="line"> node: &#123;</span><br><span class="line">  console: true,</span><br><span class="line">    global: true,</span><br><span class="line">    process: true,</span><br><span class="line">    __filename: true,</span><br><span class="line">    __dirname: true,</span><br><span class="line">    Buffer: true,</span><br><span class="line">    setImmediate: true,</span><br><span class="line">    path: true ?webapck 5 好像没了</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建 <code>.babelrc</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> presets: [</span><br><span class="line">  [</span><br><span class="line">   &quot;@babel/preset-env&quot;,</span><br><span class="line">   &#123;</span><br><span class="line">    targets: &#123;</span><br><span class="line">     node: &quot;current&quot;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  ]</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>打包项目 <code>npx webpack</code></p>
</li>
<li><p>启动项目 <code>npx babel-node ./src/index.js</code></p>
<ul>
<li><p>如果需要热更新，安装nodemon</p>
</li>
<li><p>然后 <code>npx nodemon --exec babel-node ./src/index.js</code></p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--watch 监听哪些文件的变化，当变化的时候自动重启</span><br><span class="line">--<span class="built_in">exec</span> 配置运行命令</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
<li><p>拆分webpack配置 对应开发环境及生产环境</p>
<ul>
<li>需要webpack-merge插件进行webpack配置合并</li>
<li>cross-env 设置环境变量，保证跨平台正确的环境变量</li>
<li>terser-webpack-plugin 压缩代码</li>
</ul>
</li>
<li><p>建立三个webapck.config.env.js文件</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> base</span><br><span class="line"> const path = require(&quot;path&quot;)</span><br><span class="line">const nodeExcternals = require(&quot;webpack-node-externals&quot;)</span><br><span class="line">const webpack = require(&#x27;webpack&#x27;);</span><br><span class="line">const &#123; CleanWebpackPlugin &#125; = require(&quot;clean-webpack-plugin&quot;)</span><br><span class="line">const webpackconfig = &#123;</span><br><span class="line"> target: &quot;node&quot;,</span><br><span class="line"> mode: &quot;development&quot;,</span><br><span class="line"> entry: &#123;</span><br><span class="line">  server: path.join(__dirname, &quot;./src/index.js&quot;)</span><br><span class="line"> &#125;,</span><br><span class="line"> output: &#123;</span><br><span class="line">  filename: &quot;[name].bundle.js&quot;,</span><br><span class="line">  path: path.join(__dirname, &quot;./dist&quot;)</span><br><span class="line"> &#125;,</span><br><span class="line"> modules: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">   &#123;</span><br><span class="line">    test: /\.(js|jsx)$/,</span><br><span class="line">    use: &#123;</span><br><span class="line">     loader: &quot;babel-loader&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    exclude: [path.join(__dirname, &quot;/node-modules&quot;)]</span><br><span class="line">   &#125;</span><br><span class="line">  ]</span><br><span class="line"> &#125;,</span><br><span class="line"> externals: [nodeExcternals()],</span><br><span class="line"> plugins: [</span><br><span class="line">  new CleanWebpackPlugin(),</span><br><span class="line">  new webpack.DefinePlugin(&#123;</span><br><span class="line">   &#x27;process.env&#x27;: &#123;</span><br><span class="line">    NODE_ENV: JOSN.stringfy(process.env.NODE_ENV) // (就算是字符串还是需要)类似于“‘production’”</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"> ],</span><br><span class="line"> node: &#123;</span><br><span class="line">  console: true,</span><br><span class="line">    global: true,</span><br><span class="line">    process: true,</span><br><span class="line">    __filename: true,</span><br><span class="line">    __dirname: true,</span><br><span class="line">    Buffer: true,</span><br><span class="line">    setImmediate: true,</span><br><span class="line">    path: true // ?webapck 5 好像没了</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">dev</span><br><span class="line">const webpackMerge = require(&#x27;webpack-merge&#x27;);</span><br><span class="line">const baseWebpackConfig = require(&#x27;./webpack.config.base&#x27;);</span><br><span class="line">const webpackConfig = webpackMerge(baseWebpackConfig, &#123;</span><br><span class="line"> mode: &#x27;development&#x27;,</span><br><span class="line"> devtool: &quot;eval-source-map&quot;,</span><br><span class="line"> stats: &#123;</span><br><span class="line">  children: false // 关闭日志消息</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">module.exports = webpackConfig;</span><br><span class="line">prod</span><br><span class="line">const webpackMerge = require(&#x27;webpack-merge&#x27;);</span><br><span class="line">const baseWebpackConfig = require(&#x27;./webpack.config.base&#x27;);</span><br><span class="line">const TerserPlugin = require(&#x27;terser-webpack-plugin&#x27;);</span><br><span class="line"></span><br><span class="line">const webpackConfig = webpackMerge(baseWebpackConfig, &#123;</span><br><span class="line"> mode: &#x27;production&#x27;,</span><br><span class="line"> stats: &#123;</span><br><span class="line">  children: false, // 关闭日志消息</span><br><span class="line">  warnings: false</span><br><span class="line"> &#125;,</span><br><span class="line"> optimization: &#123;</span><br><span class="line">  minimizer: [new TerserPlugin(&#123;</span><br><span class="line">   terserOptions: &#123;</span><br><span class="line">    compress: &#123;</span><br><span class="line">     warnings: false,</span><br><span class="line">     drop_console: false, //注释掉console</span><br><span class="line">     dead_code: true,</span><br><span class="line">     drop_debugger: true //注释掉debugger</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123; // 最新的貌似没这属性</span><br><span class="line">     comments: false,</span><br><span class="line">     beautify: false</span><br><span class="line">    &#125;,</span><br><span class="line">    mangle: true // 混淆</span><br><span class="line">   &#125;,</span><br><span class="line">   parallel: true, // 并行化执行</span><br><span class="line">   sourceMap: false // 使用源映射将错误消息位置映射到模块（这会减慢编译速度）</span><br><span class="line">  &#125;)],</span><br><span class="line">  splitChunks: &#123; // 视频里配的不太好，仅做示例吧</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        commons: &#123;</span><br><span class="line">     name: &#x27;commons&#x27;,</span><br><span class="line">     chunks: &#x27;initial&#x27;,</span><br><span class="line">     minChunks: 3,</span><br><span class="line">     enforce: true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">module.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>大前端</category>
      </categories>
      <tags>
        <tag>koa2</tag>
      </tags>
  </entry>
  <entry>
    <title>linux基本命令</title>
    <url>/%E5%A4%A7%E5%89%8D%E7%AB%AF/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="linux基本命令"><a href="#linux基本命令" class="headerlink" title="linux基本命令"></a>linux基本命令</h1><h2 id="查看版本、内核"><a href="#查看版本、内核" class="headerlink" title="查看版本、内核"></a>查看版本、内核</h2><p>查看系统版本<code>lsp_release -a</code><br>查看内核版本<code>uname -a</code></p>
<h2 id="磁盘命令"><a href="#磁盘命令" class="headerlink" title="磁盘命令"></a>磁盘命令</h2><p>查看磁盘空间 <code>df -Th</code> 以G为单位</p>
<h2 id="linux目录-文件权限"><a href="#linux目录-文件权限" class="headerlink" title="linux目录&amp;文件权限"></a>linux目录&amp;文件权限</h2><p>进入根目录 <code>cd /</code><br>文件目录及权限查看 <code>ls -la</code></p>
<p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/Snipaste_2021-04-20_15-10-14.png" alt="Snipaste_2021-04-20_15-10-14"></p>
<ul>
<li>第一列代码文件的各种quanxian r-read w-write x-执行 r-remove</li>
<li>home目录相当于个人目录</li>
<li>etc 存放软件配置文件</li>
<li>sys 系统目录</li>
<li>usr 存放着系统的可执行文件</li>
<li>var 日志文件</li>
</ul>
<h2 id="CPU-内存-进程"><a href="#CPU-内存-进程" class="headerlink" title="CPU&#x2F;内存&#x2F;进程"></a>CPU&#x2F;内存&#x2F;进程</h2><p>查看运行中的进程<code>top</code>  可以按M看详细内存</p>
<p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/Snipaste_2021-04-20_15-18-17-8903123.png" alt="Snipaste_2021-04-20_15-18-17"></p>
<h2 id="文档相关"><a href="#文档相关" class="headerlink" title="文档相关"></a>文档相关</h2><ul>
<li>进入文件夹 cd 路径</li>
<li>pwd 显示当前文件夹</li>
<li>ls 查看文件下所有文件夹及文件</li>
<li>mkdir 新建文件夹</li>
<li>touch 新建文件</li>
<li>vi 文件名 使用vim编辑器打开文件<ul>
<li>输入 i 进入编辑-insert–模式</li>
<li>按esc，然后输入:wq 保存退出<ul>
<li>:q! 不对其进行保存</li>
</ul>
</li>
</ul>
</li>
<li><code>echo ‘1111’  &gt;&gt;  test.txt</code> 向文件内添加内容 1111<ul>
<li><code>&gt;</code>单箭头是覆盖内容  <code>&gt;&gt;</code> 是添加内容</li>
</ul>
</li>
<li><code>rm demo.txt</code>  删除文件 提示是否删除 输入Y回车确认删除</li>
<li><code>rm -r demo/</code>  删除目录 提示是否删除 输入Y回车确认删除</li>
<li><code>rm -rf</code> 强制删除 尽量不要使用</li>
</ul>
<h2 id="下载-解压-安装命令"><a href="#下载-解压-安装命令" class="headerlink" title="下载&#x2F;解压&#x2F;安装命令"></a>下载&#x2F;解压&#x2F;安装命令</h2><p>以nodejs作为例子</p>
<ul>
<li>下载资源 <code>wget https://cdn.npm.taobao.org/dist/node/v14.16.1/node-v14.16.1.tar.gz</code><ul>
<li>下载完成后，用ls查看</li>
</ul>
</li>
<li>解压资源，tar格式<ul>
<li><code>tar zxvf node-v14.16.1.tar.gz</code><ul>
<li>z 是.gz结尾的压缩文件</li>
<li>x 解压</li>
<li>v 显示所有解压过程</li>
<li>f 使用归档的名字</li>
</ul>
</li>
</ul>
</li>
<li>压缩文件 <code>tar zcvf 文件名 文件目录</code></li>
</ul>
<h2 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h2><ul>
<li>查看进程 <code>ps -ef | grep docker</code> grep 相当于搜索，限定docker程序<ul>
<li>root 后面跟着的数值是进程的id，杀死进程可以用 <code>kill -9 id</code> - 9表示强制终止</li>
</ul>
</li>
</ul>
<h2 id="查看服务的命令"><a href="#查看服务的命令" class="headerlink" title="查看服务的命令"></a>查看服务的命令</h2><ul>
<li><p>查看服务状态</p>
<ul>
<li>例如查看ssh的运行状态,可以看到客户端通过ssh连接到服务器的记录 <code>service sshd status</code></li>
</ul>
</li>
<li><p>停止服务</p>
<ul>
<li>例如停止ssh <code>service sshd stop</code></li>
</ul>
</li>
<li><p>重启服务</p>
<ul>
<li>例如重启ssh <code>service sshd restart</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>还有一个<code>systemtcl</code>命令</p>
</blockquote>
]]></content>
      <categories>
        <category>大前端</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>插件记录</title>
    <url>/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E6%8F%92%E4%BB%B6%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="svg-captcha"><a href="#svg-captcha" class="headerlink" title="svg-captcha"></a>svg-captcha</h2><p>图形验证码插件</p>
<h2 id="nodemailer"><a href="#nodemailer" class="headerlink" title="nodemailer"></a>nodemailer</h2><p>邮件服务依赖包</p>
<h2 id="moment-js"><a href="#moment-js" class="headerlink" title="moment.js"></a>moment.js</h2><p>date操作库</p>
<h2 id="接口文档管理"><a href="#接口文档管理" class="headerlink" title="接口文档管理"></a>接口文档管理</h2><p>showDoc</p>
]]></content>
      <categories>
        <category>大前端</category>
      </categories>
      <tags>
        <tag>插件记录</tag>
      </tags>
  </entry>
  <entry>
    <title>类型转换</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>类型转换内容相当繁杂</p>
<p>参考</p>
<p><a href="https://github.com/mqyqingfeng/Blog/issues/159">冴羽blog-显式类型转换</a></p>
<p>​ 没有针对不同类型的对象做转换函数分析 valueOf toString，js高程第五章有介绍</p>
<p><a href="https://github.com/mqyqingfeng/Blog/issues/164">冴羽blog-隐式类型转换</a></p>
<p>javaScript权威指南</p>
<p>持续补充，后期整理格式</p>
<h1 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h1><blockquote>
<p>来自于js高程第四版</p>
<p>记住 <code>Number()</code> 转换规则很重要</p>
</blockquote>
<h2 id="一元加和减-特指放在头部"><a href="#一元加和减-特指放在头部" class="headerlink" title="一元加和减(特指放在头部)"></a>一元加和减(特指放在头部)</h2><p>如果将<strong>一元加</strong>应用到非数值，则会执行与使用 **Number()**转型函数一样的类型转换。<br>Number转换规则如下：</p>
<ul>
<li>布尔值，true 转换为 1，false 转换为 0。</li>
<li>数值，直接返回。</li>
<li>null，返回 0。</li>
<li>undefined，返回 NaN。</li>
<li><h2 id="字符串，应用以下规则。-如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。-因此，Number-“1”-返回-1，Number-“123”-返回-123，Number-“011”-返回-11（忽略前面-的零）。-如果字符串包含有效的浮点值格式如”1-1”，则会转换为相应的浮点值（同样，忽略前面的零）。-如果字符串包含有效的十六进制格式如”0xf”，则会转换为与该十六进制值对应的十进制整-数值。-如果是空字符串（不包含字符），则返回-0。-如果字符串包含除上述情况之外的其他字符，则返回-NaN。"><a href="#字符串，应用以下规则。-如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。-因此，Number-“1”-返回-1，Number-“123”-返回-123，Number-“011”-返回-11（忽略前面-的零）。-如果字符串包含有效的浮点值格式如”1-1”，则会转换为相应的浮点值（同样，忽略前面的零）。-如果字符串包含有效的十六进制格式如”0xf”，则会转换为与该十六进制值对应的十进制整-数值。-如果是空字符串（不包含字符），则返回-0。-如果字符串包含除上述情况之外的其他字符，则返回-NaN。" class="headerlink" title="字符串，应用以下规则。- 如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。 因此，Number(“1”)返回 1，Number(“123”)返回 123，Number(“011”)返回 11（忽略前面 的零）。- 如果字符串包含有效的浮点值格式如”1.1”，则会转换为相应的浮点值（同样，忽略前面的零）。- 如果字符串包含有效的十六进制格式如”0xf”，则会转换为与该十六进制值对应的十进制整 数值。- 如果是空字符串（不包含字符），则返回 0。- 如果字符串包含除上述情况之外的其他字符，则返回 NaN。"></a>字符串，应用以下规则。<br>- 如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。 因此，Number(“1”)返回 1，Number(“123”)返回 123，Number(“011”)返回 11（忽略前面 的零）。<br>- 如果字符串包含有效的浮点值格式如”1.1”，则会转换为相应的浮点值（同样，忽略前面的零）。<br>- 如果字符串包含有效的十六进制格式如”0xf”，则会转换为与该十六进制值对应的十进制整 数值。<br>- 如果是空字符串（不包含字符），则返回 0。<br>- <strong>如果字符串包含除上述情况之外的其他字符，则返回 NaN。</strong></h2><ul>
<li></li>
<li></li>
<li><pre><code>Number(&quot;a1&quot;); NaN
let num1 = Number(&quot;Hello world!&quot;); // NaN 
let num2 = Number(&quot;&quot;); // 0 
let num3 = Number(&quot;000011&quot;); // 11 
let num4 = Number(true); // 1 
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 对象，调用 valueOf()方法，并按照上述规则转换返回的值。如果转换结果是 NaN，则调用 toString()方法，再按照转换字符串的规则转换。</span><br><span class="line"></span><br><span class="line">**`-` 、`--`、 `++`   会先执行相同转换后，然后再进行运算操作**</span><br><span class="line"></span><br><span class="line">## 关于运算操作符</span><br><span class="line"></span><br><span class="line">对于NaN +-0 +-Infinity 的操作，这里不深究</span><br><span class="line"></span><br><span class="line">## 乘性操作符</span><br><span class="line"></span><br><span class="line">ECMAScript定义了3个乘性操作符：乘法、除法和取模，如果乘性操作符有 不是数值的操作数，则该操作数会在后台被使用 `Number()` 转型函数转换为数值。</span><br><span class="line"></span><br><span class="line">## 加性操作符</span><br><span class="line"></span><br><span class="line">### 加法操作符</span><br><span class="line"></span><br><span class="line">加法操作符（+）用于求两个数的和.</span><br><span class="line"></span><br><span class="line">- 如果有一个操作数是字符串，则要应用如下规则：</span><br><span class="line">  - 如果两个操作数都是字符串，则将第二个字符串拼接到第一个字符串后面</span><br><span class="line">  - 如果**只有一个操作数是字符串，则将另一个操作数转换为字符串**，再将两个字符串拼接在一起。</span><br><span class="line">- 如果有任一操作数是对象、数值或布尔值，则调用它们的 toString()方法以获取字符串，然后再应用前面的关于字符串的规则。对于 `undefined` 和 `null`，则调用 `String()`函数，分别获取 &quot;undefined&quot; 和 &quot;null&quot;。</span><br><span class="line"></span><br><span class="line">### 减法操作符</span><br><span class="line"></span><br><span class="line">转换规则如下:</span><br><span class="line"></span><br><span class="line">- 如果有任一操作数是字符串、布尔值、null 或 undefined，则先在后台使用 Number()将其转换为数值，然后再根据前面的规则执行数学运算。如果转换结果是 NaN，则减法计算的结果是 NaN。</span><br><span class="line">- 如果有任一操作数是对象，则调用其 valueOf()方法取得表示它的数值。如果该值是 NaN，则 减法计算的结果是 NaN。如果对象没有 valueOf()方法，则调用其 toString()方法，然后再将得到的字符串转换为数值</span><br><span class="line"></span><br><span class="line">## 关系操作符</span><br><span class="line"></span><br><span class="line">关系操作符执行比较两个值的操作，包括小于（&lt;）、大于（&gt;）、小于等于（&lt;=）和大于等于（&gt;=），用法跟数学课上学的一样。这几个操作符都返回布尔值  </span><br><span class="line">与ECMAScript中的其他操作符一样，在将它们应用到不同数据类型时也会发生类型转换和其他行为:</span><br><span class="line"></span><br><span class="line">- 如果操作数都是数值，则执行数值比较。</span><br><span class="line">- 如果操作数都是字符串，则逐个比较字符串中对应字符的编码。</span><br><span class="line">- 如果有任一操作数是数值，则将另一个操作数转换为数值，执行数值比较。</span><br><span class="line">- 如果有任一操作数是对象，则调用其 valueOf()方法，取得结果后再根据前面的规则执行比较。如果没有 valueOf()操作符，则调用 toString()方法，取得结果后再根据前面的规则执行比较。</span><br><span class="line">- 如果有任一操作数是布尔值，则将其转换为数值再执行比较。</span><br><span class="line"></span><br><span class="line">&gt; 任何关系 操作符在涉及比较 NaN 时都返回 false</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
&gt; let result1 = NaN &lt; 3;  // false 
&gt; let result2 = NaN &gt;= 3; // false 
&gt; ```
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h2><h3 id="等于和不等于"><a href="#等于和不等于" class="headerlink" title="等于和不等于"></a>等于和不等于</h3><p>ECMAScript中的等于操作符用两个等于号（&#x3D;&#x3D;）表示，如果操作数相等，则会返回 true。不等于 操作符用叹号和等于号（!&#x3D;）表示，如果两个操作数不相等，则会返回 true。这两个操作符都会先进 行类型转换（通常称为强制类型转换）再确定操作数是否相等。<br>在转换操作数的类型时，相等和不相等操作符遵循如下规则:</p>
<ul>
<li>如果任一操作数是布尔值，则将其转换为数值再比较是否相等。false 转换为 0，true 转换 为 1。</li>
<li>如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等。</li>
<li>如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法取得其原始值，再根据前面的规则进行比较。</li>
<li>null 和 undefined 相等。</li>
<li>null 和 undefined 不能转换为其他类型的值再进行比较。</li>
<li>如果有任一操作数是 NaN，则相等操作符返回 false，不相等操作符返回 true。记住：即使两个操作数都是 NaN，相等操作符也返回 false，因为按照规则，NaN 不等于 NaN。</li>
<li>如果两个操作数都是对象，则比较它们是不是同一个对象。</li>
</ul>
<h3 id="全等和不全等"><a href="#全等和不全等" class="headerlink" title="全等和不全等"></a>全等和不全等</h3><p>全等和不全等操作符与相等和不相等操作符类似，只不过它们在比较相等时不转换操作数。</p>
]]></content>
      <categories>
        <category>数据类型</category>
      </categories>
      <tags>
        <tag>类型转换</tag>
      </tags>
  </entry>
  <entry>
    <title>websocket</title>
    <url>/%E5%A4%A7%E5%89%8D%E7%AB%AF/websocket/</url>
    <content><![CDATA[<blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">websocket–阮一峰</a></p>
</blockquote>
<h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>websocket是一种网络传输协议，可在单个TCP连接上进行全双工通信，位于OSI模型的应用层。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>tcp连接，与http协议兼容</li>
<li>双向通信，主动推送</li>
<li>无同源限制，协议标识符是ws（加密wss）</li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>聊天、消息、点赞</li>
<li>直播评论（弹幕）</li>
<li>游戏、协同编辑、基于位置的应用</li>
</ul>
<h4 id="ws常用前端库"><a href="#ws常用前端库" class="headerlink" title="ws常用前端库"></a>ws常用前端库</h4><ul>
<li>ws（实现原生协议，特点：通用、性能强，定制性强）推荐</li>
<li>socket.io（向下兼容协议，特点：适配性强，性能一般）</li>
</ul>
<h3 id="基础示例-ws"><a href="#基础示例-ws" class="headerlink" title="基础示例 ws"></a>基础示例 ws</h3><h4 id="web端"><a href="#web端" class="headerlink" title="web端"></a>web端</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const ws = new WebSocket(&quot;ws://127.0.0.1:3000&quot;)</span><br><span class="line">  ws.onopen = () =&gt; &#123;</span><br><span class="line">    // 向服务端发送数据</span><br><span class="line">    ws.send(&quot;hello server&quot;)</span><br><span class="line">    // 接收服务端发送的请求</span><br><span class="line">  &#125;</span><br><span class="line">  ws.onmessage = (event) =&gt; &#123;</span><br><span class="line">    console.log(event);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  绑定多种时间，可以使用addEventListener</span><br><span class="line">  ws.addEventListener(&quot;message&quot;, function(event) &#123;</span><br><span class="line">  var data = event.data;</span><br><span class="line">  // 处理数据</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const WebSocket = require(&#x27;ws&#x27;);</span><br><span class="line">const wss = new WebSocket.Server(&#123;</span><br><span class="line">  port: 3000</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">wss.on(&quot;connection&quot;, (ws) =&gt; &#123; // ws在这</span><br><span class="line">  ws.on(&quot;message&quot;, (res) =&gt; &#123;</span><br><span class="line">    console.log(&quot;提供3000服务的&quot;);</span><br><span class="line">    console.log(res);</span><br><span class="line">  &#125;)</span><br><span class="line">  ws.send(&quot;来自客户端&quot;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">也可以</span><br><span class="line">const ws = new WebSocket(&quot;ws://127.0.0.1:3000&quot;) // ws在这</span><br><span class="line"></span><br><span class="line">ws.on(&quot;open&quot;, () =&gt; &#123;</span><br><span class="line">  ws.send(&quot;hello web&quot;)</span><br><span class="line">  ws.on(&quot;message&quot;, (res) =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>大前端</category>
      </categories>
      <tags>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云服务器配置</title>
    <url>/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%85%8D%E7%BD%AEssh%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91/</url>
    <content><![CDATA[<p>解决方案最好去官网查看</p>
<h2 id="简短的记录一下步骤"><a href="#简短的记录一下步骤" class="headerlink" title="简短的记录一下步骤"></a>简短的记录一下步骤</h2><ul>
<li><p>申请阿里云服务器</p>
</li>
<li><p>创建秘钥对，然后绑定到实例</p>
</li>
<li><p>运行长命令</p>
<ul>
<li>ssh -i {ff6b954c664adf1ba473194b3b620b7d .pem ~&#x2F;.ssh&#x2F;alien-linux.pem} {root}@{39.106.100.189}</li>
<li>应该会出现权限问题</li>
</ul>
</li>
<li><p>运行命令，获取权限 chmod 400 .pem文件的完整路径  chmod 400 ~&#x2F;.ssh&#x2F;alien-linux.pem</p>
</li>
<li><p>配置config文件 vim ~&#x2F;.ssh&#x2F;config</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host Aliyun #自定义别名</span><br><span class="line">HostName 39.106.100.189 #ssh服务器公网IP</span><br><span class="line">Port 22 #ssh服务器端口，默认22</span><br><span class="line">User root #ssh服务器用户名，默认root</span><br><span class="line">IdentityFile ~/.ssh/alien-linux.pem #秘钥文件路径</span><br></pre></td></tr></table></figure>
</li>
<li><p>这样差不多就ok了</p>
</li>
</ul>
<h2 id="在阿里云安装docker"><a href="#在阿里云安装docker" class="headerlink" title="在阿里云安装docker"></a>在阿里云安装docker</h2><p><a href="https://github.com/docker/docker-install">docker-install</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">sh get-docker.sh</span><br></pre></td></tr></table></figure>

<p>然后 需要安装 docker-compose 查找linux安装方法,mac docker客户端集成了docker-compose<br><a href="https://docs.docker.com/compose/install/">compose</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.29.1/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>

<p>然后需要给脚本执行权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>

<h2 id="安装mongo"><a href="#安装mongo" class="headerlink" title="安装mongo"></a>安装mongo</h2><h3 id="下载mongo"><a href="#下载mongo" class="headerlink" title="下载mongo"></a>下载mongo</h3><p>docker pull mongo</p>
<p>如果失败的话，可以配置中国镜像, 编写<code>/etc/docker/daemon.json</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://&lt;my-docker-mirror-host&gt;&quot;]</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line"> &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后重启docker  <code>systemctl restart docker.service</code></p>
<h3 id="运行mongo"><a href="#运行mongo" class="headerlink" title="运行mongo"></a>运行mongo</h3><p><code>docker run -d --name some-mongo -p 10050:27017 mongo</code></p>
<ul>
<li>-d 表示后台运行</li>
<li>-p 定义端口 10050:27017  容器端口27017映射到宿主机10050</li>
<li>–name 命名</li>
<li>mongo 可以接:tag 比如 mongo:4  版本4</li>
</ul>
<p>检查docker下边运行的镜像 <code>docker ps</code>，如下图所示</p>
<p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/%E9%85%8D%E7%BD%AEssh%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91/Snipaste_2021-04-20_10-22-34.png" alt="Snipaste_2021-04-20_10-22-34"></p>
<h2 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h2><p>简单粗暴法</p>
<p>ubuntu：service ufw stop</p>
<p>Centos service firewalld stop</p>
<p>B格高的方法，放行特定端口</p>
<p>ubuntu： ufw allow Port端口号</p>
<p>centos：<code>firewall-cmd --zone=public --add-port=10050/tcp --permanent</code>  –permanent 永久生肖</p>
<p>服务器提示 FirewallD is not running 未开启防火墙，先把防火墙开启（不知道有无必要）,<code>systemctl start firewalld</code></p>
<p>然后继续执行上一条命令，输出success，然后运行<code>firewall-cmd --reload</code>,重启生效</p>
<p>现在验证是否可以访问，通过robo 3T 或者 Navicat连接测试，<strong>需要修改阿里云安全组策略，要不然无法连接</strong></p>
<h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h2><p>1.wget <a href="https://nodejs.org/dist/v6.10.3/node-v6.10.3-linux-x64.tar.xz">https://nodejs.org/dist/v6.10.3/node-v6.10.3-linux-x64.tar.xz</a> &#x2F;&#x2F;下载最新的稳定版 v6.10.3 到本地</p>
<p>（最新 <a href="https://links.jianshu.com/go?to=https://nodejs.org/dist/v14.15.1/node-v14.15.1-linux-x64.tar.xz">https://nodejs.org/dist/v14.15.1/node-v14.15.1-linux-x64.tar.xz</a>）</p>
<p>2.tar xvJf node-v6.10.3-linux-x64.tar.xz                       &#x2F;&#x2F;下载完成后, 将其解压</p>
<p>3.mv node-v6.10.3-linux-x64 &#x2F;usr&#x2F;local&#x2F;node-v6                &#x2F;&#x2F;将解压的 Node.js 目录移动到 &#x2F;usr&#x2F;local 目录下</p>
<p>4.ln -s &#x2F;usr&#x2F;local&#x2F;node-v6&#x2F;bin&#x2F;node &#x2F;bin&#x2F;node                  &#x2F;&#x2F;配置 node 软链接到 &#x2F;bin 目录</p>
<p>5.ln -s &#x2F;usr&#x2F;local&#x2F;node-v6&#x2F;bin&#x2F;npm &#x2F;bin&#x2F;npm                   &#x2F;&#x2F;下载 node 的压缩包中已经包含了 npm , 我们只需要将其软链接到 bin 目录下即可</p>
<p>6.echo ‘export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;node-v6&#x2F;bin:$PATH’ &gt;&gt; &#x2F;etc&#x2F;profile &#x2F;&#x2F;将&#x2F;usr&#x2F;local&#x2F;node−v6&#x2F;bin目录添加到PATH′&gt;&gt;&#x2F;etc&#x2F;profile&#x2F;&#x2F;将&#x2F;usr&#x2F;local&#x2F;node−v6&#x2F;bin目录添加到PATH 环境变量中可以方便地使用通过 npm 全局安装的第三方工具</p>
<p>7.source &#x2F;etc&#x2F;profile 有时候需要更新</p>
<blockquote>
<p>第六、七步可能不需要，试一下npm -v 能不能ok，如果不可以的话，在运行第六步</p>
</blockquote>
<h2 id="docker的基本命令"><a href="#docker的基本命令" class="headerlink" title="docker的基本命令"></a>docker的基本命令</h2><h3 id="一、基本命令"><a href="#一、基本命令" class="headerlink" title="一、基本命令"></a>一、基本命令</h3><p>docker version查看docker版本<br>docker info查看docker详细信息<br>docker –help查看docker命令</p>
<h3 id="二、镜像命令"><a href="#二、镜像命令" class="headerlink" title="二、镜像命令"></a>二、镜像命令</h3><p>docker images查看docker镜像</p>
<p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/%E9%85%8D%E7%BD%AEssh%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91/20190407133555456.png" alt="img"></p>
<p>PEPOSITORY：镜像的仓库源<br>TAG：镜像的标签<br>IMAGE ID：镜像ID<br>CREATED：镜像创建时间<br>SIZE：镜像大小<br> 同一个仓库源可以有多个TAG，表示这个仓库源的不同版本，我们使用REPOSITORY:TAG来定义不同的镜像。如果不指定一个镜像的版本标签，例如只使用tomcat，docker将默认使用tomcat:latest镜像<br>docker images -a列出本地所有的镜像<br>docker images -p只显示镜像ID<br>docker images –digests显示镜像的摘要信息<br>docker images –no-trunc显示完整的镜像信息</p>
<p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/%E9%85%8D%E7%BD%AEssh%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpemhpcWlhbmcxMjE3,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<p>docker search tomcat从Docker Hub上查找tomcat镜像</p>
<p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/%E9%85%8D%E7%BD%AEssh%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpemhpcWlhbmcxMjE3,size_16,color_FFFFFF,t_70-20210421214616330.png" alt="img"></p>
<p>STARS：关注度<br>docker search -s 30 tomcat从Docker Hub上查找关注度大于30的tomcat镜像<br>docker pull tomcat从Docker Hub上下载tomcat镜像。等价于：docker pull tomcat:latest<br>docker commit -m “提交的描述信息” -a “作者” 容器ID 要创建的目标镜像名称:[标签名]提交容器使之成为一个新的镜像。<br>如：docker commit -m “新的tomcat” -a “lizq” f9e29e8455a5 mytomcat:1.2<br>docker rmi hello-world从Docker中删除hello-world镜像<br>docker rmi -f hello-world从Docker中强制删除hello-world镜像<br>docker rmi -f hello-world nginx从Docker中强制删除hello-world镜像和nginx镜像<br>docker rmi -f $(docker images -p)通过docker images -p查询到的镜像ID来删除所有镜像</p>
<h3 id="三、容器命令"><a href="#三、容器命令" class="headerlink" title="三、容器命令"></a>三、容器命令</h3><p>docker run [OPTIONS] IMAGE根据镜像新建并启动容器。IMAGE是镜像ID或镜像名称<br>OPTIONS说明：<br> –name&#x3D;“容器新名字”：为容器指定一个名称<br> -d：后台运行容器，并返回容器ID，也即启动守护式容器<br> -i：以交互模式运行容器，通常与-t同时使用<br> -t：为容器重新分配一个伪输入终端，通常与-i同时使用<br> -P：随机端口映射<br> -p：指定端口映射，有以下四种格式：<br>  ip:hostPort:containerPort<br>  ip::containerPort<br>  hostPort:containerPort<br>  containerPort<br>docker ps列出当前所有正在运行的容器<br>docker ps -a列出所有的容器<br>docker ps -l列出最近创建的容器<br>docker ps -n 3列出最近创建的3个容器<br>docker ps -q只显示容器ID<br>docker ps –no-trunc显示当前所有正在运行的容器完整信息<br>exit退出并停止容器<br>Ctrl+p+q只退出容器，不停止容器<br>docker start 容器ID或容器名称启动容器<br>docker restart 容器ID或容器名称重新启动容器<br>docker stop容器ID或容器名称停止容器<br>docker kill 容器ID或容器名称强制停止容器<br>docker rm 容器ID或容器名称删除容器<br>docker rm -f 容器ID或容器名称强制删除容器<br>docker rm -f $(docker ps -a -q)删除多个容器<br>docker logs -f -t –since –tail 容器ID或容器名称查看容器日志<br>如：docker logs -f -t –since&#x3D;”2018-09-10” –tail&#x3D;10 f9e29e8455a5<br> -f : 查看实时日志<br> -t : 查看日志产生的日期<br> –since : 此参数指定了输出日志开始日期，即只输出指定日期之后的日志<br> –tail&#x3D;10 : 查看最后的10条日志<br>docker top 容器ID或容器名称查看容器内运行的进程<br>docker inspect 容器ID或容器名称查看容器内部细节<br>docker attach 容器ID进到容器内<br>docker exec 容器ID进到容器内<br>docker cp 容器ID:容器内的文件路径 宿主机路径从容器内拷贝文件到宿主机.<br>如：docker cp f9e29e8455a5:&#x2F;tmp&#x2F;yum.log &#x2F;root</p>
]]></content>
      <categories>
        <category>大前端</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack热更新</title>
    <url>/webpack/HMR/</url>
    <content><![CDATA[<p><code>Hot Module Replacement</code>，简称<code>HMR</code>，无需完全刷新整个页面的同时，更新模块。<code>HMR</code>的好处，在日常开发工作中体会颇深：<strong>节省宝贵的开发时间、提升开发体验</strong>。</p>
<p>在这里简单介绍一个 HMR 的原理</p>
<h3 id="HMR-初始化"><a href="#HMR-初始化" class="headerlink" title="HMR 初始化"></a>HMR 初始化</h3><h4 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h4><p>Webpack-dev-server 的执行过程，其实也是一个 HMR 开启的过程</p>
<ul>
<li><p>修改 webpackOptions，添加两个入口文件，一个是 websocket 客户端代码，一个是热更新客户端代码(主要是用于检查更新逻辑)。</p>
</li>
<li><p>启动<code>webpack</code>，生成<code>compiler</code>实例。<code>compiler</code>上有很多方法，比如可以启动 <code>webpack</code> 所有<strong>编译</strong>工作，以及<strong>监听</strong>本地文件的变化。</p>
</li>
<li><p>使用<code>express</code>框架启动本地<code>server</code>，让浏览器可以请求本地的<strong>静态资源</strong>。</p>
<ul>
<li>启动 server 的时候，监听 compiler 的 done 事件，当监听到一次<code>webpack</code>编译结束，就会调用<code>_sendStats</code>方法通过<code>websocket</code>给浏览器发送通知，<code>ok</code>和<code>hash</code>事件，这样浏览器就可以拿到最新的<code>hash</code>值了，做检查更新逻辑</li>
<li>生成 <strong>webpack-dev-middleware</strong> 中间件实例，保存在 this.middleware（主要是本地文件的<strong>编译</strong>和<strong>输出</strong>以及<strong>监听</strong>）</li>
</ul>
</li>
<li><p>本地<code>server</code>启动之后，再去启动<code>websocket</code>服务，通过<code>websocket</code>，可以建立本地服务和浏览器的双向通信。这样就可以实现当本地文件发生变化，立马告知浏览器可以热更新代码啦！</p>
</li>
</ul>
<h4 id="webpack-dev-middleware"><a href="#webpack-dev-middleware" class="headerlink" title="webpack-dev-middleware"></a>webpack-dev-middleware</h4><p>文件相关的操作都抽离到<code>webpack-dev-middleware</code>库了，主要是本地文件的<strong>编译</strong>和<strong>输出</strong>以及<strong>监听</strong></p>
<p>主要流程都在下述代码中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">share.setOptions(context.options);</span><br><span class="line">share.setFs(context.compiler);</span><br><span class="line"></span><br><span class="line">context.compiler.plugin(&quot;done&quot;, share.compilerDone);</span><br><span class="line">context.compiler.plugin(&quot;invalid&quot;, share.compilerInvalid);</span><br><span class="line">context.compiler.plugin(&quot;watch-run&quot;, share.compilerInvalid);</span><br><span class="line">context.compiler.plugin(&quot;run&quot;, share.compilerInvalid);</span><br><span class="line"></span><br><span class="line">share.startWatch();</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化配置，利用<code>memory-fs</code>库将文件打包到内存中(访问文件系统中的文件更快，而且也减少了代码写入文件的开销)</li>
<li>注册一系列事件。</li>
<li>开启对本地文件的监听，当文件发生变化，重新编译，编译完成之后继续监听</li>
</ul>
<h3 id="一次完整的-HMR-流程"><a href="#一次完整的-HMR-流程" class="headerlink" title="一次完整的 HMR 流程"></a>一次完整的 HMR 流程</h3><ol>
<li><p>当文件发生变化，就触发重新编译。当监听到一次<code>webpack</code>编译结束，<code>_sendStats</code>方法就通过<code>websoket</code>给浏览器发送通知</p>
<ol>
<li><code>hash</code>事件，更新最新一次打包后的<code>hash</code>值</li>
<li><code>ok</code>事件，进行热更新检查</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.sockWrite(sockets, &#x27;hash&#x27;, stats.hash);</span><br><span class="line"> if (stats.errors.length &gt; 0) &#123;</span><br><span class="line">  this.sockWrite(sockets, &#x27;errors&#x27;, stats.errors);</span><br><span class="line"> &#125; else if (stats.warnings.length &gt; 0) &#123;</span><br><span class="line">  this.sockWrite(sockets, &#x27;warnings&#x27;, stats.warnings);</span><br><span class="line"> &#125; else &#123; this.sockWrite(sockets, &#x27;ok&#x27;); &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/_posts/webpack/assets/HMR/image-20220111134320575.png" alt="image-20220111134320575"></p>
</li>
<li><p>客户端接受到 ws 消息后，<code>hash</code>事件更新当前<code>hash</code>值，ok 事件触发<code>hotEmitter</code></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// webpack-dev-server/client/index.js</span><br><span class="line">var socket = require(&#x27;./socket&#x27;);</span><br><span class="line">var onSocketMessage = &#123;</span><br><span class="line">    hash: function hash(_hash) &#123;</span><br><span class="line">        // 更新currentHash值</span><br><span class="line">        status.currentHash = _hash;</span><br><span class="line">    &#125;,</span><br><span class="line">    ok: function ok() &#123;</span><br><span class="line">        sendMessage(&#x27;Ok&#x27;);</span><br><span class="line">        // 进行更新检查等操作</span><br><span class="line">        reloadApp(options, status);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">// 连接服务地址socketUrl，?http://localhost:8080，本地服务地址</span><br><span class="line">socket(socketUrl, onSocketMessage);</span><br><span class="line"></span><br><span class="line">function reloadApp() &#123;</span><br><span class="line"> if (hot) &#123;</span><br><span class="line">        log.info(&#x27;[WDS] App hot update...&#x27;);</span><br><span class="line"></span><br><span class="line">        // hotEmitter其实就是EventEmitter的实例</span><br><span class="line">        var hotEmitter = require(&#x27;webpack/hot/emitter&#x27;);</span><br><span class="line">        hotEmitter.emit(&#x27;webpackHotUpdate&#x27;, currentHash);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>web-dev-server 插入的客户端的另一个入口文件 <code>webpack/hot/dev-server.js</code>，监听<code>hotEmitter</code>事件，进行热更新检查 <code>check</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// webpack/hot/dev-server.js</span><br><span class="line">var check = function check() &#123;</span><br><span class="line">  // 热更新核心代码</span><br><span class="line">    module.hot.check(true)</span><br><span class="line">        .then(function(updatedModules) &#123;</span><br><span class="line">            // 容错，直接刷新页面</span><br><span class="line">            if (!updatedModules) &#123;</span><br><span class="line">                window.location.reload();</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            // 热更新结束，打印信息</span><br><span class="line">            if (upToDate()) &#123;</span><br><span class="line">                log(&quot;info&quot;, &quot;[HMR] App is up to date.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">        .catch(function(err) &#123;</span><br><span class="line">            window.location.reload();</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var hotEmitter = require(&quot;./emitter&quot;);</span><br><span class="line">hotEmitter.on(&quot;webpackHotUpdate&quot;, function(currentHash) &#123;</span><br><span class="line">    lastHash = currentHash;</span><br><span class="line">    check();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>check</code>代码<code>module.hot.check</code>在<code>HotModuleReplacementPlugin.runtime.js</code>中</p>
<p><code>hotCheck</code>主要做了三件事</p>
<ol>
<li><p>利用上一次保存的<code>hash</code>值，调用<code>hotDownloadManifest</code>发送<code>xxx/hash.hot-update.json</code>的<code>ajax</code>请求；</p>
</li>
<li><p>请求结果获取热更新模块，以及下次热更新的<code>Hash</code> 标识，并进入热更新准备阶段。</p>
</li>
<li><p>调用<code>hotDownloadUpdateChunk</code>发送<code>xxx/hash.hot-update.js</code> 请求，通过<code>JSONP</code>方式。</p>
<p><img src="/_posts/webpack/assets/HMR/16ec04316d6ac5e3~tplv-t2oaga2asx-watermark.gif" alt="img"></p>
</li>
<li><p>返回结果后，要立即执行<code>webpackHotUpdate</code>这个方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window[&quot;webpackHotUpdate&quot;] = function (chunkId, moreModules) &#123;</span><br><span class="line">    hotAddUpdateChunk(chunkId, moreModules);</span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>hotAddUpdateChunk</code>方法<strong>会把更新的模块</strong><code>moreModules</code>赋值给全局全量<code>hotUpdate</code>。</p>
</li>
<li><p><code>hotUpdateDownloaded</code>方法会调用<code>hotApply</code>进行代码的替换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function hotAddUpdateChunk(chunkId, moreModules) &#123;</span><br><span class="line">    // 更新的模块moreModules赋值给全局全量hotUpdate</span><br><span class="line">    for (var moduleId in moreModules) &#123;</span><br><span class="line">        if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123;</span><br><span class="line">        hotUpdate[moduleId] = moreModules[moduleId];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 调用hotApply进行模块的替换</span><br><span class="line">    hotUpdateDownloaded();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>hotApply 热更新模块替换</p>
<ol>
<li>删除过期的模块，就是需要替换的模块</li>
</ol>
<p>通过<code>hotUpdate</code>可以找到旧模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var queue = outdatedModules.slice();</span><br><span class="line">while (queue.length &gt; 0) &#123;</span><br><span class="line">    moduleId = queue.pop();</span><br><span class="line">    // 从缓存中删除过期的模块</span><br><span class="line">    module = installedModules[moduleId];</span><br><span class="line">    // 删除过期的依赖</span><br><span class="line">    delete outdatedDependencies[moduleId];</span><br><span class="line"></span><br><span class="line">    // 存储了被删掉的模块id，便于更新代码</span><br><span class="line">    outdatedSelfAcceptedModules.push(&#123;</span><br><span class="line">        module: moduleId</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将新的模块添加到 modules 中</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appliedUpdate[moduleId] = hotUpdate[moduleId];</span><br><span class="line">for (moduleId in appliedUpdate) &#123;</span><br><span class="line">    if (Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) &#123;</span><br><span class="line">        modules[moduleId] = appliedUpdate[moduleId];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>通过<strong>webpack_require</strong>执行相关模块的代码</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (i = 0; i &lt; outdatedSelfAcceptedModules.length; i++) &#123;</span><br><span class="line">    var item = outdatedSelfAcceptedModules[i];</span><br><span class="line">    moduleId = item.module;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 执行最新的代码</span><br><span class="line">        __webpack_require__(moduleId);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">        // ...容错处理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>HMR</tag>
      </tags>
  </entry>
  <entry>
    <title>git温故知新</title>
    <url>/%E5%A4%A7%E5%89%8D%E7%AB%AF/git/</url>
    <content><![CDATA[<p>作废 可以以计算机基础下的git文章进行拓展，这篇文章作废掉</p>
<h3 id="学习网址"><a href="#学习网址" class="headerlink" title="学习网址"></a>学习网址</h3><p>这可能是学习git操作最好的网址了 ——— <a href="https://learngitbranching.js.org/?locale=zh_CN">learngit</a></p>
<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>一个本地仓库可以对应多个远端仓库<br>git remote add origin xxx.git &#x2F;&#x2F; 将本地仓库与远端建立联系 origin是仓库别名 可以自定义<br>git remote add origin1 xxx.git &#x2F;&#x2F; 将本地仓库与另一个远端建立联系<br>如果都使用origin push将一起推送至两个仓库<br>如果增加<code>-u</code>指令 则使用 <code>git push</code> 默认推送到设置的仓库,不使用默认则是 <code>git push origin master</code></p>
<h3 id="git图示"><a href="#git图示" class="headerlink" title="git图示"></a>git图示</h3><p> <img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/git/image-20210426132629619.png" alt="image-20210426132629619"></p>
<h3 id="git命令简单介绍，后期会补全"><a href="#git命令简单介绍，后期会补全" class="headerlink" title="git命令简单介绍，后期会补全"></a>git命令简单介绍，后期会补全</h3><h4 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a><strong>git add</strong></h4><p>可将该文件添加到暂存区。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add [file1] [file2] ...</span><br></pre></td></tr></table></figure>

<p>添加指定目录到暂存区，包括子目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add [dir]</span><br></pre></td></tr></table></figure>

<p>添加当前目录下的所有文件到暂存区：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p><code>git add -u &lt;==&gt; git add –update</code><br><strong>提交所有被删除和修改的文件到数据暂存区</strong></p>
<p><code>git add .</code><br><strong>提交所有修改的和新建的数据暂存区</strong></p>
<p><code>git add -A &lt;==&gt;git add –all</code><br><strong>提交所有被删除、被替换、被修改和新增的文件到数据暂存区</strong></p>
<h5 id="撤销git-add"><a href="#撤销git-add" class="headerlink" title="撤销git add"></a>撤销git add</h5><p>撤销上次add</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout .  撤销add操作，不可恢复</span><br></pre></td></tr></table></figure>

<p>单独撤销某个文件 对应vscode中的取消暂存文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset a.txt</span><br></pre></td></tr></table></figure>

<p>上面的这个命令是一个简写，实际上<code>reset</code>命令的完整写法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --mixed HEAD a.txt</span><br></pre></td></tr></table></figure>

<p> 其中，<code>mixed</code>是一个模式（mode）参数，如果<code>reset</code>省略这个选项的话默认是<code>mixed</code>模式；<code>HEAD</code>指定了一个历史提交的 hash 值；<code>a.txt</code>指定了一个或者多个文件。</p>
<p><strong>该命令的自然语言描述是：不改变<code>work dir</code>中的任何数据，将<code>stage</code>区域中的<code>a.txt</code>文件还原成<code>HEAD</code>指向的<code>commit history</code>中的样子</strong>。就相当于把对<code>a.txt</code>的修改从<code>stage</code>区撤销，但依然保存在<code>work dir</code>中，变为<code>unstage</code>的状态。</p>
<blockquote>
<p>描述的不咋滴</p>
</blockquote>
<h4 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h4><p>将暂存区内容添加到仓库中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;一些描述&#x27;</span><br></pre></td></tr></table></figure>

<p>再简单提一些常见场景， 比如说<code>commit</code>完之后，突然发现一些错别字需要修改，又不想为改几个错别字而新开一个<code>commit</code>到<code>history</code>区，那么就可以使用下面这个命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>

<p>这样就是把错别字的修改和之前的那个<code>commit</code>中的修改合并，作为一个<code>commit</code>提交到<code>history</code>区。</p>
<h4 id="工作区命令"><a href="#工作区命令" class="headerlink" title="工作区命令"></a>工作区命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ git clone 从远端仓库拉取代码</span><br><span class="line">- git init 初始化</span><br><span class="line">- git remote 远端建立连接</span><br><span class="line">- git pull 拉取远端代码，并与本地合并</span><br><span class="line">git log 查看提交记录 按空格持续加载 Q退出 </span><br><span class="line">git log 可以显示所有提交过的版本信息，不包括已经被删除的 commit 记录和 reset 的操作</span><br><span class="line">git reflog 可以查看**本地所有**的所有操作记录（包括分支、包括已经被删除的 commit 记录和 reset 的操作）,适合找回</span><br><span class="line">git config </span><br><span class="line"> git config --global --list 查看全局的git配置</span><br><span class="line"> git config --global user.name xxxx 设置全局user name</span><br><span class="line"> git config --global user.email xx@xx 设置全局user.email</span><br><span class="line">  1、仓库级别 local 【优先级最高】</span><br><span class="line">  2、用户级别 global【优先级次之】</span><br><span class="line">  3、系统级别 system【优先级最低】</span><br><span class="line">git status 工作区 暂存区 远端是否需要拉取等信息</span><br><span class="line">git restore 指令使得在工作空间但是不在暂存区的文件撤销更改</span><br><span class="line">git restore --staged 的作用是将暂存区(add)的文件从暂存区撤出，但不会撤销修改</span><br><span class="line">git commit -m &quot;msg&quot; 暂存区提交到本地仓库</span><br></pre></td></tr></table></figure>

<h5 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h5><p> <strong>git push</strong> 命令用于从将本地的分支版本上传到远程并合并。</p>
<p>命令格式如下：远程分支如果不存在，则会创建一个分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure>

<p>如果本地分支名与远程分支名相同，则可以省略冒号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>

<p>如果当前分支与多个主机存在追踪关系，则可以使用 -u 参数指定一个默认主机，这样后面就可以不加任何参数使用git push</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push -u origin master </span><br></pre></td></tr></table></figure>

<p>当遇到这种情况就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要 -all 选项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push --all origin </span><br></pre></td></tr></table></figure>

<p><strong>实例演示</strong></p>
<p>以下命令将本地的 master 分支推送到 origin 主机的 master 分支。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<p>相等于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin master:master</span><br></pre></td></tr></table></figure>

<p>如果本地版本与远程版本有差异，但又要强制推送可以使用 –force 参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push --force origin master</span><br></pre></td></tr></table></figure>

<p>删除主机的分支可以使用 –delete 参数，以下命令表示删除 origin 主机的 master 分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin --delete master</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>略本地分支名，也可以删除指定的远程分支</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin :master</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="Git-fetch"><a href="#Git-fetch" class="headerlink" title="Git fetch"></a>Git fetch</h5><p>简单的来说 git pull &#x3D; git fetch + git merge</p>
<p>git fetch 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch &lt;远程主机名&gt; //这个命令将某个远程主机的更新全部取回本地</span><br></pre></td></tr></table></figure>

<p>如果只想取回特定分支的更新，可以指定分支名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch &lt;远程主机名&gt; &lt;分支名&gt; //注意之间有空格</span><br></pre></td></tr></table></figure>

<p>最常见的命令如取回<code>origin</code> 主机的<code>master</code> 分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch origin master</span><br></pre></td></tr></table></figure>

<p>取回更新后，会返回一个<code>FETCH_HEAD</code> ，指的是某个branch在服务器上的最新状态，我们可以在本地通过它查看刚取回的更新信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log -p FETCH_HEAD</span><br></pre></td></tr></table></figure>

<p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/git/fetch.png" alt="img"></p>
<p>可以看到返回的信息包括更新的文件名，更新的作者和时间，以及更新的代码（19行红色[删除]和绿色[新增]部分）。我们可以通过这些信息来判断是否产生冲突，以确定是否将更新merge到当前分支。</p>
<p><strong>代码合并示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 在本地新建一个temp分支，并将远程origin仓库的master分支代码下载到本地temp分支；</span><br><span class="line">git fetch origin master:temp</span><br><span class="line"></span><br><span class="line">## 比较本地代码与刚刚从远程下载下来的代码的区别；</span><br><span class="line">git diff temp</span><br><span class="line"></span><br><span class="line">## 合并temp分支到本地的master分支;</span><br><span class="line">git merge temp</span><br><span class="line"></span><br><span class="line">## 如果不想保留temp分支，删除;</span><br><span class="line">git branch -D temp</span><br></pre></td></tr></table></figure>

<h4 id="stage暂存区命令"><a href="#stage暂存区命令" class="headerlink" title="stage暂存区命令"></a>stage暂存区命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash 贮藏 详细看下边</span><br></pre></td></tr></table></figure>

<h5 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h5><p><code>stash</code>命令可用于临时保存和回复修改，<strong>可跨分支</strong>。</p>
<blockquote>
<p>*<strong>注：在未<code>add</code>之前才能执行<code>stash</code>！！！！*</strong></p>
</blockquote>
<ul>
<li><code>git stash [save message]</code><br>保存，<code>save</code>为可选项，<code>message</code>为本次保存的注释</li>
<li><code>git stash list</code><br>所有保存的记录列表</li>
<li><code>git stash pop stash@&#123;num&#125;</code><br>恢复，<code>num</code>是可选项，通过<code>git stash list</code>可查看具体值。<strong>只能恢复一次</strong></li>
<li><code>git stash apply stash@&#123;num&#125;</code><br>恢复，<code>num</code>是可选项，通过<code>git stash list</code>可查看具体值。<strong>可回复多次</strong></li>
<li><code>git stash drop stash@&#123;num&#125;</code><br>删除某个保存，<code>num</code>是可选项，通过<code>git stash list</code>可查看具体值</li>
<li><code>git stash clear</code><br>删除所有保存</li>
</ul>
<h4 id="master命令"><a href="#master命令" class="headerlink" title="master命令"></a>master命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard commitID 回退版本 相当于删除中间的版本</span><br></pre></td></tr></table></figure>

<h5 id="Git-diff命令的四种用法"><a href="#Git-diff命令的四种用法" class="headerlink" title="Git diff命令的四种用法"></a>Git diff命令的四种用法</h5><p><strong><code>git diff</code></strong> 比较「暂存区」与「工作区」之间的差异。</p>
<p><strong><code>git diff commitID</code></strong> 比较「给定提交 ID」与「工作区」的差异。</p>
<p><strong><code>git diff --cached commitID</code></strong> 比较「暂存区」与「给定提交 ID」的差异</p>
<p><strong><code>git diff commit1 commit2</code></strong> 比较指定的两次提交 「commit1」与 「commit2」的差异</p>
<p><strong>选项</strong> <code>--stat</code> 显示有多少行发生变化，简洁的展示差异</p>
<h5 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h5><p><code>git reset</code>  通过把分支记录回退几个提交记录来实现撤销改动</p>
<p> <code>git reset HEAD~1</code> 回退到上次提交（撤销commit），但是文件修改后的内容还是存在于工作区的</p>
<blockquote>
<p>远程仓库做出的修改并没有回退哦，要记住</p>
</blockquote>
<p> 此时通过git log和 git reflog对比就能看出两条命令的明显区别了</p>
<p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/git/image-20210427154024280.png" alt="image-20210427154024280"></p>
<p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/git/image-20210427154043396.png" alt="image-20210427154043396"></p>
<h5 id="Git-Revert"><a href="#Git-Revert" class="headerlink" title="Git Revert"></a>Git Revert</h5><p>虽然在你的本地分支中使用 <code>git reset</code> 很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的！<strong>revert 之后就可以把你的更改推送到远程仓库与别人分享啦</strong>。</p>
<p><code>git revert HEAD</code>相当于相当于把上次提交的内容还原覆盖到工作区中，提交记录会增加一个，而不是减少，详细见下一节的示意</p>
<h5 id="reset-和-revert对比"><a href="#reset-和-revert对比" class="headerlink" title="reset 和 revert对比"></a>reset 和 revert对比</h5><p>初始状态，切记HEAD~1和HEAD 不能混用，有意想不到的结果</p>
<p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/git/image-20210427154540480.png" alt="image-20210427154540480"></p>
<p><code>git reset HEAD~1</code></p>
<p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/git/image-20210427154611065.png" alt="image-20210427154611065"></p>
<p><code>git revert HEAD</code></p>
<p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/git/image-20210427154652039.png" alt="image-20210427154652039"></p>
<h4 id="分支命令"><a href="#分支命令" class="headerlink" title="分支命令"></a>分支命令</h4><h5 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h5><p>一般用于分支的操作，比如创建分支，查看分支等等，</p>
<p>　 <code>git branch</code> 不带参数：列出本地已经存在的分支，并且在当前分支的前面用”*”标记</p>
<p>　　<code>git branch -r</code>  查看远程版本库分支列表</p>
<p>　　<code>git branch -a</code> 查看所有分支列表，包括本地和远程</p>
<p>　　<code>git branch dev</code> 创建名为dev的分支，创建分支时需要是最新的环境，创建分支但依然停留在当前分支</p>
<p>　　<code>git branch -d dev</code> 删除dev分支，如果在分支中有一些未merge的提交，那么会删除分支失败</p>
<p>  <code>git branch -D dev</code>：强制删除dev分支</p>
<p>  <code>git branch -vv</code>  可以查看本地分支对应的远程分支</p>
<p>　　<code>git branch -m oldName newName</code>  给分支重命名</p>
<p>  <code>git branch -f main HEAD~3</code>  <strong>强制修改分支位置</strong> 向上移动3个位置</p>
<p>  <code>git branch -f main commitID</code>  <strong>强制修改分支位置</strong>到指定commit</p>
<h5 id="Git-checkout"><a href="#Git-checkout" class="headerlink" title="Git checkout"></a>Git checkout</h5><p> <code>git checkout master</code> 将分支切换到master</p>
<p>　<code>git checkout -b master</code> 如果分支存在则只切换分支，若不存在则创建并切换到master分支</p>
<blockquote>
<p>在这里只介绍分支相关的命令</p>
</blockquote>
<h5 id="Git-合并分支的两种方式"><a href="#Git-合并分支的两种方式" class="headerlink" title="Git 合并分支的两种方式"></a>Git 合并分支的两种方式</h5><p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/git/image-20210426180103988.png" alt="image-20210426180103988"></p>
<p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/git/image-20210426180149291.png" alt="image-20210426180149291"></p>
<blockquote>
<p>我们在切换分支，和新建分支的时候，有没有想过，这些操作操作背后的工作原理是怎样的呢？最大的功臣就是.git目录下的HEAD引用,下面有对HEAD的详细解释</p>
</blockquote>
<h5 id="Git-rebase"><a href="#Git-rebase" class="headerlink" title="Git rebase"></a>Git rebase</h5><p>第二种合并分支的方法是 <code>git rebase</code>。Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。</p>
<p>Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。</p>
<p>这个用图示比较清晰</p>
<p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/git/image-20210426201823042.png" alt="image-20210426201823042"><br><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/git/image-20210426201909176.png" alt="image-20210426201909176"></p>
<p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/git/image-20210426201938207.png" alt="image-20210426201938207"></p>
<h3 id="Git-flow"><a href="#Git-flow" class="headerlink" title="Git flow"></a>Git flow</h3><p>两种常见的模型</p>
<p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/git/image-20210426183300352.png" alt="image-20210426183300352"></p>
<p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/git/image-20210426183643468.png" alt="image-20210426183643468"></p>
<h3 id="git-HEAD"><a href="#git-HEAD" class="headerlink" title="git HEAD"></a>git HEAD</h3><p>可以把HEAD理解成一个指针，HEAD指针通常会指向一个分支，如下图所示</p>
<p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/git/image-20210427143641740.png" alt="image-20210427143641740"></p>
<p>HEAD–&gt;master–&gt;commitID，通常情况下，HEAD会一直跟随着当前分支，并指向分支，而分支则指向当前最新的commit</p>
<p>还有一种 <code>detached HEAD</code>的状态，使用<code>git checkout C3</code>即可以把HEAD指针指向C3</p>
<blockquote>
<p>还有一种相对引用的方式，<code>git checkout main^</code>*3 或者  <code>git checkout main^^^</code> 或者 <code>git checkout main~3</code>  或者使用 <code>git checkout HEAD^^^</code>,这几种方法都是向父节点方向移动</p>
</blockquote>
<p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/git/image-20210427144448741.png" alt="image-20210427144448741"></p>
<p>如果此时进行commit，git的返回信息会提示我们，You are in ‘detached HEAD’ state.（你现在处于’分离头’状态）。然后会从C3节点出现一个新的节点，HEAD会指向新的节点，可以简单的理解为匿名分支（图和上边不一样，仅做示意）</p>
<p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/git/image-20210427145825615.png" alt="image-20210427145825615"></p>
<p>我们现在有两个选择，如下：</p>
<ul>
<li><p>丢弃这个匿名分支</p>
<ul>
<li>直接检出到任何一个别的分支，就相当于放弃了这些提交</li>
</ul>
</li>
<li><p>保留这个匿名分支</p>
<ul>
<li>创建一个名为newtest的分支来保存这些提交<ul>
<li><code>git branch newtest c7</code>  这种方式HEAD并未指向newtest，而是指向了C7，仍是指针分离状态</li>
<li><code>git checkout -b newtest</code>   HEAD指向了newtest，newtest指向了C7</li>
</ul>
</li>
</ul>
</li>
<li><p>与现存分支，参考分支命令章节</p>
</li>
</ul>
<h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><p><code>git checkout</code>命令用于切换分支或恢复工作树文件，也可以指定HEAD指针的位置</p>
<p>除了分支命令中介绍的使用方法，还可以进行HEAD操作，详细见上一小节</p>
]]></content>
      <categories>
        <category>大前端</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>正则疑难点记录</title>
    <url>/%E6%AD%A3%E5%88%99/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p><a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md">转载自</a></p>
<h2 id="什么是正则表达式？"><a href="#什么是正则表达式？" class="headerlink" title="什么是正则表达式？"></a>什么是正则表达式？</h2><blockquote>
<p>正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。</p>
</blockquote>
<p>一个正则表达式是一种从左到右匹配主体字符串的模式。<br>“Regular expression”这个词比较拗口，我们常使用缩写的术语“regex”或“regexp”。<br>正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等。</p>
<p>想象你正在写一个应用，然后你想设定一个用户命名的规则，让用户名包含字符、数字、下划线和连字符，以及限制字符的个数，好让名字看起来没那么丑。<br>我们使用以下正则表达式来验证一个用户名：</p>
<p><img src="/_posts/%E6%AD%A3%E5%88%99/assets/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240713140610224.png" alt="image-20240713140610224"></p>
<p>以上的正则表达式可以接受 <code>john_doe</code>、<code>jo-hn_doe</code>、<code>john12_as</code>。<br>但不匹配<code>Jo</code>，因为它包含了大写的字母而且太短了。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#%E7%9B%AE%E5%BD%95">目录</a><ul>
<li><a href="#1-%E5%9F%BA%E6%9C%AC%E5%8C%B9%E9%85%8D">1. 基本匹配</a></li>
<li><a href="#2-%E5%85%83%E5%AD%97%E7%AC%A6">2. 元字符</a></li>
<li><a href="#21-%E7%82%B9%E8%BF%90%E7%AE%97%E7%AC%A6-">2.1 点运算符 <code>.</code></a></li>
<li><a href="#22-%E5%AD%97%E7%AC%A6%E9%9B%86">2.2 字符集</a><ul>
<li><a href="#221-%E5%90%A6%E5%AE%9A%E5%AD%97%E7%AC%A6%E9%9B%86">2.2.1 否定字符集</a></li>
</ul>
</li>
<li><a href="#23-%E9%87%8D%E5%A4%8D%E6%AC%A1%E6%95%B0">2.3 重复次数</a><ul>
<li><a href="#231--%E5%8F%B7">2.3.1 <code>*</code> 号</a></li>
<li><a href="#232--%E5%8F%B7">2.3.2 <code>+</code> 号</a></li>
<li><a href="#233--%E5%8F%B7">2.3.3 <code>?</code> 号</a></li>
</ul>
</li>
<li><a href="#24--%E5%8F%B7">2.4 <code>&#123;&#125;</code> 号</a></li>
<li><a href="#25--%E7%89%B9%E5%BE%81%E6%A0%87%E7%BE%A4">2.5 <code>(...)</code> 特征标群</a></li>
<li><a href="#26--%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6">2.6 <code>|</code> 或运算符</a></li>
<li><a href="#27-%E8%BD%AC%E7%A0%81%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6">2.7 转码特殊字符</a></li>
<li><a href="#28-%E9%94%9A%E7%82%B9">2.8 锚点</a><ul>
<li><a href="#281--%E5%8F%B7">2.8.1 <code>^</code> 号</a></li>
<li><a href="#282--%E5%8F%B7">2.8.2 <code>$</code> 号</a></li>
</ul>
</li>
<li><a href="#3-%E7%AE%80%E5%86%99%E5%AD%97%E7%AC%A6%E9%9B%86">3. 简写字符集</a></li>
<li><a href="#4-%E9%9B%B6%E5%AE%BD%E5%BA%A6%E6%96%AD%E8%A8%80%E5%89%8D%E5%90%8E%E9%A2%84%E6%9F%A5">4. 零宽度断言（前后预查）</a><ul>
<li><a href="#41--%E6%AD%A3%E5%85%88%E8%A1%8C%E6%96%AD%E8%A8%80">4.1 <code>?=...</code> 正先行断言</a></li>
<li><a href="#42--%E8%B4%9F%E5%85%88%E8%A1%8C%E6%96%AD%E8%A8%80">4.2 <code>?!...</code> 负先行断言</a></li>
<li><a href="#43---%E6%AD%A3%E5%90%8E%E5%8F%91%E6%96%AD%E8%A8%80">4.3 <code>?&lt;= ...</code> 正后发断言</a></li>
<li><a href="#44--%E8%B4%9F%E5%90%8E%E5%8F%91%E6%96%AD%E8%A8%80">4.4 <code>?&lt;!...</code> 负后发断言</a></li>
</ul>
</li>
<li><a href="#5-%E6%A0%87%E5%BF%97">5. 标志</a><ul>
<li><a href="#51-%E5%BF%BD%E7%95%A5%E5%A4%A7%E5%B0%8F%E5%86%99case-insensitive">5.1 忽略大小写（Case Insensitive）</a></li>
<li><a href="#52-%E5%85%A8%E5%B1%80%E6%90%9C%E7%B4%A2global-search">5.2 全局搜索（Global search）</a></li>
<li><a href="#53-%E5%A4%9A%E8%A1%8C%E4%BF%AE%E9%A5%B0%E7%AC%A6multiline">5.3 多行修饰符（Multiline）</a></li>
<li><a href="#6-%E8%B4%AA%E5%A9%AA%E5%8C%B9%E9%85%8D%E4%B8%8E%E6%83%B0%E6%80%A7%E5%8C%B9%E9%85%8Dgreedy-vs-lazy-matching">6. 贪婪匹配与惰性匹配（Greedy vs lazy matching）</a></li>
</ul>
</li>
<li><a href="#%E8%B4%A1%E7%8C%AE">贡献</a></li>
<li><a href="#%E8%AE%B8%E5%8F%AF%E8%AF%81">许可证</a></li>
</ul>
</li>
</ul>
<h2 id="1-基本匹配"><a href="#1-基本匹配" class="headerlink" title="1. 基本匹配"></a>1. 基本匹配</h2><p>正则表达式其实就是在执行搜索时的格式，它由一些字母和数字组合而成。<br>例如：一个正则表达式 <code>the</code>，它表示一个规则：由字母<code>t</code>开始，接着是<code>h</code>，再接着是<code>e</code>。</p>
<pre>
"the" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/dmRygT/1">在线练习</a></p>
<p>正则表达式<code>123</code>匹配字符串<code>123</code>。它逐个字符的与输入的正则表达式做比较。</p>
<p>正则表达式是大小写敏感的，所以<code>The</code>不会匹配<code>the</code>。</p>
<pre>
"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/1paXsy/1">在线练习</a></p>
<h2 id="2-元字符"><a href="#2-元字符" class="headerlink" title="2. 元字符"></a>2. 元字符</h2><p>正则表达式主要依赖于元字符。<br>元字符不代表他们本身的字面意思，他们都有特殊的含义。一些元字符写在方括号中的时候有一些特殊的意思。以下是一些元字符的介绍：</p>
<table>
<thead>
<tr>
<th align="center">元字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.</td>
<td>句号匹配任意单个字符除了换行符。</td>
</tr>
<tr>
<td align="center">[ ]</td>
<td>字符种类。匹配方括号内的任意字符。</td>
</tr>
<tr>
<td align="center">[^ ]</td>
<td>否定的字符种类。匹配除了方括号里的任意字符</td>
</tr>
<tr>
<td align="center">*</td>
<td>匹配&gt;&#x3D;0个重复的在*号之前的字符。</td>
</tr>
<tr>
<td align="center">+</td>
<td>匹配&gt;&#x3D;1个重复的+号前的字符。</td>
</tr>
<tr>
<td align="center">?</td>
<td>标记?之前的字符为可选.</td>
</tr>
<tr>
<td align="center">{n,m}</td>
<td>匹配num个大括号之前的字符或字符集 (n &lt;&#x3D; num &lt;&#x3D; m).</td>
</tr>
<tr>
<td align="center">(xyz)</td>
<td>字符集，匹配与 xyz 完全相等的字符串.</td>
</tr>
<tr>
<td align="center">&#124;</td>
<td>或运算符，匹配符号前或后的字符.</td>
</tr>
<tr>
<td align="center">&#92;</td>
<td>转义字符,用于匹配一些保留的字符 <code>[ ] ( ) &#123; &#125; . * + ? ^ $ \ &#124;</code></td>
</tr>
<tr>
<td align="center">^</td>
<td>从开始行开始匹配.</td>
</tr>
<tr>
<td align="center">$</td>
<td>从末端开始匹配.</td>
</tr>
</tbody></table>
<h2 id="2-1-点运算符"><a href="#2-1-点运算符" class="headerlink" title="2.1 点运算符 ."></a>2.1 点运算符 <code>.</code></h2><p><code>.</code>是元字符中最简单的例子。<br><code>.</code>匹配任意单个字符，但不匹配换行符。<br>例如，表达式<code>.ar</code>匹配一个任意字符后面跟着是<code>a</code>和<code>r</code>的字符串。</p>
<pre>
".ar" => The <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/xc9GkU/1">在线练习</a></p>
<h2 id="2-2-字符集"><a href="#2-2-字符集" class="headerlink" title="2.2 字符集"></a>2.2 字符集</h2><p>字符集也叫做字符类。<br>方括号用来指定一个字符集。<br>在方括号中使用连字符来指定字符集的范围。<br>在方括号中的字符集不关心顺序。<br>例如，表达式<code>[Tt]he</code> 匹配 <code>the</code> 和 <code>The</code>。</p>
<pre>
"[Tt]he" => <a href="#learn-regex"><strong>The</strong></a> car parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/2ITLQ4/1">在线练习</a></p>
<p>方括号的句号就表示句号。<br>表达式 <code>ar[.]</code> 匹配 <code>ar.</code>字符串</p>
<pre>
"ar[.]" => A garage is a good place to park a c<a href="#learn-regex"><strong>ar.</strong></a>
</pre>

<p><a href="https://regex101.com/r/wL3xtE/1">在线练习</a></p>
<h3 id="2-2-1-否定字符集"><a href="#2-2-1-否定字符集" class="headerlink" title="2.2.1 否定字符集"></a>2.2.1 否定字符集</h3><p>一般来说 <code>^</code> 表示一个字符串的开头，但它用在一个方括号的开头的时候，它表示这个字符集是否定的。<br>例如，表达式<code>[^c]ar</code> 匹配一个后面跟着<code>ar</code>的除了<code>c</code>的任意字符。</p>
<pre>
"[^c]ar" => The car <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/nNNlq3/1">在线练习</a></p>
<h2 id="2-3-重复次数"><a href="#2-3-重复次数" class="headerlink" title="2.3 重复次数"></a>2.3 重复次数</h2><p>后面跟着元字符 <code>+</code>，<code>*</code> or <code>?</code> 的，用来指定匹配子模式的次数。<br>这些元字符在不同的情况下有着不同的意思。</p>
<h3 id="2-3-1-号"><a href="#2-3-1-号" class="headerlink" title="2.3.1 * 号"></a>2.3.1 <code>*</code> 号</h3><p><code>*</code>号匹配 在<code>*</code>之前的字符出现<code>大于等于0</code>次。<br>例如，表达式 <code>a*</code> 匹配0或更多个以a开头的字符。表达式<code>[a-z]*</code> 匹配一个行中所有以小写字母开头的字符串。</p>
<pre>
"[a-z]*" => T<a href="#learn-regex"><strong>he</strong></a> <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>parked</strong></a> <a href="#learn-regex"><strong>in</strong></a> <a href="#learn-regex"><strong>the</strong></a> <a href="#learn-regex"><strong>garage</strong></a> #21.
</pre>

<p><a href="https://regex101.com/r/7m8me5/1">在线练习</a></p>
<p><code>*</code>字符和<code>.</code>字符搭配可以匹配所有的字符<code>.*</code>。<br><code>*</code>和表示匹配空格的符号<code>\s</code>连起来用，如表达式<code>\s*cat\s*</code>匹配0或更多个空格开头和0或更多个空格结尾的cat字符串。</p>
<pre>
"\s*cat\s*" => The fat<a href="#learn-regex"><strong> cat </strong></a>sat on the con<a href="#learn-regex"><strong>cat</strong></a>enation.
</pre>

<p><a href="https://regex101.com/r/gGrwuz/1">在线练习</a></p>
<h3 id="2-3-2-号"><a href="#2-3-2-号" class="headerlink" title="2.3.2 + 号"></a>2.3.2 <code>+</code> 号</h3><p><code>+</code>号匹配<code>+</code>号之前的字符出现 &gt;&#x3D;1 次。<br>例如表达式<code>c.+t</code> 匹配以首字母<code>c</code>开头以<code>t</code>结尾，中间跟着至少一个字符的字符串。</p>
<pre>
"c.+t" => The fat <a href="#learn-regex"><strong>cat sat on the mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/Dzf9Aa/1">在线练习</a></p>
<h3 id="2-3-3-号"><a href="#2-3-3-号" class="headerlink" title="2.3.3 ? 号"></a>2.3.3 <code>?</code> 号</h3><p>在正则表达式中元字符 <code>?</code> 标记在符号前面的字符为可选，即出现 0 或 1 次。<br>例如，表达式 <code>[T]?he</code> 匹配字符串 <code>he</code> 和 <code>The</code>。</p>
<pre>
"[T]he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>

<p><a href="https://regex101.com/r/cIg9zm/1">在线练习</a></p>
<pre>
"[T]?he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in t<a href="#learn-regex"><strong>he</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/kPpO2x/1">在线练习</a></p>
<h2 id="2-4-号"><a href="#2-4-号" class="headerlink" title="2.4 {} 号"></a>2.4 <code>&#123;&#125;</code> 号</h2><p>在正则表达式中 <code>&#123;&#125;</code> 是一个量词，常用来限定一个或一组字符可以重复出现的次数。<br>例如， 表达式 <code>[0-9]&#123;2,3&#125;</code> 匹配最少 2 位最多 3 位 0~9 的数字。</p>
<pre>
"[0-9]{2,3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>

<p><a href="https://regex101.com/r/juM86s/1">在线练习</a></p>
<p>我们可以省略第二个参数。<br>例如，<code>[0-9]&#123;2,&#125;</code> 匹配至少两位 0~9 的数字。</p>
<pre>
"[0-9]{2,}" => The number was 9.<a href="#learn-regex"><strong>9997</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>

<p><a href="https://regex101.com/r/Gdy4w5/1">在线练习</a></p>
<p>如果逗号也省略掉则表示重复固定的次数。<br>例如，<code>[0-9]&#123;3&#125;</code> 匹配3位数字</p>
<pre>
"[0-9]{3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to 10.0.
</pre>

<p><a href="https://regex101.com/r/Sivu30/1">在线练习</a></p>
<h2 id="2-5-特征标群"><a href="#2-5-特征标群" class="headerlink" title="2.5 (...) 特征标群"></a>2.5 <code>(...)</code> 特征标群</h2><p>特征标群是一组写在 <code>(...)</code> 中的子模式。<code>(...)</code> 中包含的内容将会被看成一个整体，和数学中小括号（ ）的作用相同。例如, 表达式 <code>(ab)*</code> 匹配连续出现 0 或更多个 <code>ab</code>。如果没有使用 <code>(...)</code> ，那么表达式 <code>ab*</code> 将匹配连续出现 0 或更多个 <code>b</code> 。再比如之前说的 <code>&#123;&#125;</code> 是用来表示前面一个字符出现指定次数。但如果在 <code>&#123;&#125;</code> 前加上特征标群 <code>(...)</code> 则表示整个标群内的字符重复 N 次。</p>
<p>我们还可以在 <code>()</code> 中用或字符 <code>|</code> 表示或。例如，<code>(c|g|p)ar</code> 匹配 <code>car</code> 或 <code>gar</code> 或 <code>par</code>.</p>
<pre>
"(c|g|p)ar" => The <a href="#learn-regex"><strong>car</strong></a> is <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/tUxrBG/1">在线练习</a></p>
<h2 id="2-6-或运算符"><a href="#2-6-或运算符" class="headerlink" title="2.6 | 或运算符"></a>2.6 <code>|</code> 或运算符</h2><p>或运算符就表示或，用作判断条件。</p>
<p>例如 <code>(T|t)he|car</code> 匹配 <code>(T|t)he</code> 或 <code>car</code>。</p>
<pre>
"(T|t)he|car" => <a href="#learn-regex"><strong>The</strong></a> <a href="#learn-regex"><strong>car</strong></a> is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/fBXyX0/1">在线练习</a></p>
<h2 id="2-7-转码特殊字符"><a href="#2-7-转码特殊字符" class="headerlink" title="2.7 转码特殊字符"></a>2.7 转码特殊字符</h2><p>反斜线 <code>\</code> 在表达式中用于转码紧跟其后的字符。用于指定 <code>&#123; &#125; [ ] / \ + * . $ ^ | ?</code> 这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线 <code>\</code>。</p>
<p>例如 <code>.</code> 是用来匹配除换行符外的所有字符的。如果想要匹配句子中的 <code>.</code> 则要写成 <code>\.</code> 以下这个例子 <code>\.?</code>是选择性匹配<code>.</code></p>
<pre>
"(f|c|m)at\.?" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> sat on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/DOc5Nu/1">在线练习</a></p>
<h2 id="2-8-锚点"><a href="#2-8-锚点" class="headerlink" title="2.8 锚点"></a>2.8 锚点</h2><p>在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。<code>^</code> 指定开头，<code>$</code> 指定结尾。</p>
<h3 id="2-8-1-号"><a href="#2-8-1-号" class="headerlink" title="2.8.1 ^ 号"></a>2.8.1 <code>^</code> 号</h3><p><code>^</code> 用来检查匹配的字符串是否在所匹配字符串的开头。</p>
<p>例如，在 <code>abc</code> 中使用表达式 <code>^a</code> 会得到结果 <code>a</code>。但如果使用 <code>^b</code> 将匹配不到任何结果。因为在字符串 <code>abc</code> 中并不是以 <code>b</code> 开头。</p>
<p>例如，<code>^(T|t)he</code> 匹配以 <code>The</code> 或 <code>the</code> 开头的字符串。</p>
<pre>
"(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/5ljjgB/1">在线练习</a></p>
<pre>
"^(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>

<p><a href="https://regex101.com/r/jXrKne/1">在线练习</a></p>
<h3 id="2-8-2-号"><a href="#2-8-2-号" class="headerlink" title="2.8.2 $ 号"></a>2.8.2 <code>$</code> 号</h3><p>同理于 <code>^</code> 号，<code>$</code> 号用来匹配字符是否是最后一个。</p>
<p>例如，<code>(at\.)$</code> 匹配以 <code>at.</code> 结尾的字符串。</p>
<pre>
"(at\.)" => The fat c<a href="#learn-regex"><strong>at.</strong></a> s<a href="#learn-regex"><strong>at.</strong></a> on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>

<p><a href="https://regex101.com/r/y4Au4D/1">在线练习</a></p>
<pre>
"(at\.)$" => The fat cat. sat. on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>

<p><a href="https://regex101.com/r/t0AkOd/1">在线练习</a></p>
<h2 id="3-简写字符集"><a href="#3-简写字符集" class="headerlink" title="3. 简写字符集"></a>3. 简写字符集</h2><p>正则表达式提供一些常用的字符集简写。如下:</p>
<table>
<thead>
<tr>
<th align="center">简写</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.</td>
<td>除换行符外的所有字符</td>
</tr>
<tr>
<td align="center">\w</td>
<td>匹配所有字母数字，等同于 <code>[a-zA-Z0-9_]</code></td>
</tr>
<tr>
<td align="center">\W</td>
<td>匹配所有非字母数字，即符号，等同于： <code>[^\w]</code></td>
</tr>
<tr>
<td align="center">\d</td>
<td>匹配数字： <code>[0-9]</code></td>
</tr>
<tr>
<td align="center">\D</td>
<td>匹配非数字： <code>[^\d]</code></td>
</tr>
<tr>
<td align="center">\s</td>
<td>匹配所有空格字符，等同于： <code>[\t\n\f\r\p&#123;Z&#125;]</code></td>
</tr>
<tr>
<td align="center">\S</td>
<td>匹配所有非空格字符： <code>[^\s]</code></td>
</tr>
<tr>
<td align="center">\f</td>
<td>匹配一个换页符</td>
</tr>
<tr>
<td align="center">\n</td>
<td>匹配一个换行符</td>
</tr>
<tr>
<td align="center">\r</td>
<td>匹配一个回车符</td>
</tr>
<tr>
<td align="center">\t</td>
<td>匹配一个制表符</td>
</tr>
<tr>
<td align="center">\v</td>
<td>匹配一个垂直制表符</td>
</tr>
<tr>
<td align="center">\p</td>
<td>匹配 CR&#x2F;LF（等同于 <code>\r\n</code>），用来匹配 DOS 行终止符</td>
</tr>
</tbody></table>
<h2 id="4-零宽度断言（前后预查）"><a href="#4-零宽度断言（前后预查）" class="headerlink" title="4. 零宽度断言（前后预查）"></a>4. 零宽度断言（前后预查）</h2><p>先行断言和后发断言都属于<strong>非捕获簇</strong>（不捕获文本 ，也不针对组合计进行计数）。<br>先行断言用于判断所匹配的格式是否在另一个确定的格式之前，匹配结果不包含该确定格式（仅作为约束）。</p>
<p>例如，我们想要获得所有跟在 <code>$</code> 符号后的数字，我们可以使用正后发断言 <code>(?&lt;=\$)[0-9\.]*</code>。<br>这个表达式匹配 <code>$</code> 开头，之后跟着 <code>0,1,2,3,4,5,6,7,8,9,.</code> 这些字符可以出现大于等于 0 次。</p>
<p>零宽度断言如下：</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">?&#x3D;</td>
<td>正先行断言-存在</td>
</tr>
<tr>
<td align="center">?!</td>
<td>负先行断言-排除</td>
</tr>
<tr>
<td align="center">?&lt;&#x3D;</td>
<td>正后发断言-存在</td>
</tr>
<tr>
<td align="center">?&lt;!</td>
<td>负后发断言-排除</td>
</tr>
</tbody></table>
<h3 id="4-1-正先行断言"><a href="#4-1-正先行断言" class="headerlink" title="4.1 ?=... 正先行断言"></a>4.1 <code>?=...</code> 正先行断言</h3><p><code>?=...</code> 正先行断言，表示第一部分表达式之后必须跟着 <code>?=...</code>定义的表达式。</p>
<p>返回结果只包含满足匹配条件的第一部分表达式。<br>定义一个正先行断言要使用 <code>()</code>。在括号内部使用一个问号和等号： <code>(?=...)</code>。</p>
<p>正先行断言的内容写在括号中的等号后面。<br>例如，表达式 <code>(T|t)he(?=\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>，在括号中我们又定义了正先行断言 <code>(?=\sfat)</code> ，即 <code>The</code> 和 <code>the</code> 后面紧跟着 <code>(空格)fat</code>。</p>
<pre>
"(T|t)he(?=\sfat)" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/IDDARt/1">在线练习</a></p>
<h3 id="4-2-负先行断言"><a href="#4-2-负先行断言" class="headerlink" title="4.2 ?!... 负先行断言"></a>4.2 <code>?!...</code> 负先行断言</h3><p>负先行断言 <code>?!</code> 用于筛选所有匹配结果，筛选条件为 其后不跟随着断言中定义的格式。<br><code>正先行断言</code>  定义和 <code>负先行断言</code> 一样，区别就是 <code>=</code> 替换成 <code>!</code> 也就是 <code>(?!...)</code>。</p>
<p>表达式 <code>(T|t)he(?!\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>，且其后不跟着 <code>(空格)fat</code>。</p>
<pre>
"(T|t)he(?!\sfat)" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/V32Npg/1">在线练习</a></p>
<h3 id="4-3"><a href="#4-3" class="headerlink" title="4.3 ?&lt;= ... 正后发断言"></a>4.3 <code>?&lt;= ...</code> 正后发断言</h3><p>正后发断言 记作<code>(?&lt;=...)</code> 用于筛选所有匹配结果，筛选条件为 其前跟随着断言中定义的格式。<br>例如，表达式 <code>(?&lt;=(T|t)he\s)(fat|mat)</code> 匹配 <code>fat</code> 和 <code>mat</code>，且其前跟着 <code>The</code> 或 <code>the</code>。</p>
<pre>
"(?<=(T|t)he\s)(fat|mat)" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the <a href="#learn-regex"><strong>mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/avH165/1">在线练习</a></p>
<h3 id="4-4"><a href="#4-4" class="headerlink" title="4.4 ?&lt;!... 负后发断言"></a>4.4 <code>?&lt;!...</code> 负后发断言</h3><p>负后发断言 记作 <code>(?&lt;!...)</code> 用于筛选所有匹配结果，筛选条件为 其前不跟随着断言中定义的格式。<br>例如，表达式 <code>(?&lt;!(T|t)he\s)(cat)</code> 匹配 <code>cat</code>，且其前不跟着 <code>The</code> 或 <code>the</code>。</p>
<pre>
"(?&lt;!(T|t)he\s)(cat)" => The cat sat on <a href="#learn-regex"><strong>cat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/8Efx5G/1">在线练习</a></p>
<h2 id="5-标志"><a href="#5-标志" class="headerlink" title="5. 标志"></a>5. 标志</h2><p>标志也叫模式修正符，因为它可以用来修改表达式的搜索结果。<br>这些标志可以任意的组合使用，它也是整个正则表达式的一部分。</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">i</td>
<td>忽略大小写。</td>
</tr>
<tr>
<td align="center">g</td>
<td>全局搜索。</td>
</tr>
<tr>
<td align="center">m</td>
<td>多行修饰符：锚点元字符 <code>^</code> <code>$</code> 工作范围在每行的起始。</td>
</tr>
</tbody></table>
<h3 id="5-1-忽略大小写（Case-Insensitive）"><a href="#5-1-忽略大小写（Case-Insensitive）" class="headerlink" title="5.1 忽略大小写（Case Insensitive）"></a>5.1 忽略大小写（Case Insensitive）</h3><p>修饰语 <code>i</code> 用于忽略大小写。<br>例如，表达式 <code>/The/gi</code> 表示在全局搜索 <code>The</code>，在后面的 <code>i</code> 将其条件修改为忽略大小写，则变成搜索 <code>the</code> 和 <code>The</code>，<code>g</code> 表示全局搜索。</p>
<pre>
"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/dpQyf9/1">在线练习</a></p>
<pre>
"/The/gi" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/ahfiuh/1">在线练习</a></p>
<h3 id="5-2-全局搜索（Global-search）"><a href="#5-2-全局搜索（Global-search）" class="headerlink" title="5.2 全局搜索（Global search）"></a>5.2 全局搜索（Global search）</h3><p>修饰符 <code>g</code> 常用于执行一个全局搜索匹配，即（不仅仅返回第一个匹配的，而是返回全部）。<br>例如，表达式 <code>/.(at)/g</code> 表示搜索 任意字符（除了换行）+ <code>at</code>，并返回全部结果。</p>
<pre>
"/.(at)/" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/jnk6gM/1">在线练习</a></p>
<pre>
"/.(at)/g" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> <a href="#learn-regex"><strong>sat</strong></a> on the <a href="#learn-regex"><strong>mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/dO1nef/1">在线练习</a></p>
<h3 id="5-3-多行修饰符（Multiline）"><a href="#5-3-多行修饰符（Multiline）" class="headerlink" title="5.3 多行修饰符（Multiline）"></a>5.3 多行修饰符（Multiline）</h3><p>多行修饰符 <code>m</code> 常用于执行一个多行匹配。</p>
<p>像之前介绍的 <code>(^,$)</code> 用于检查格式是否是在待检测字符串的开头或结尾。但我们如果想要它在每行的开头和结尾生效，我们需要用到多行修饰符 <code>m</code>。</p>
<p>例如，表达式 <code>/at(.)?$/gm</code> 表示小写字符 <code>a</code> 后跟小写字符 <code>t</code> ，末尾可选除换行符外任意字符。根据 <code>m</code> 修饰符，现在表达式匹配每行的结尾。</p>
<pre>
"/.at(.)?$/" => The fat
                cat sat
                on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/hoGMkP/1">在线练习</a></p>
<pre>
"/.at(.)?$/gm" => The <a href="#learn-regex"><strong>fat</strong></a>
                  cat <a href="#learn-regex"><strong>sat</strong></a>
                  on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/E88WE2/1">在线练习</a></p>
<h3 id="6-贪婪匹配与惰性匹配（Greedy-vs-lazy-matching）"><a href="#6-贪婪匹配与惰性匹配（Greedy-vs-lazy-matching）" class="headerlink" title="6. 贪婪匹配与惰性匹配（Greedy vs lazy matching）"></a>6. 贪婪匹配与惰性匹配（Greedy vs lazy matching）</h3><p>正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 <code>?</code> 将贪婪匹配模式转化为惰性匹配模式。</p>
<pre>
"/(.*at)/" => <a href="#learn-regex"><strong>The fat cat sat on the mat</strong></a>. </pre>

<p><a href="https://regex101.com/r/AyAdgJ/1">在线练习</a></p>
<pre>
"/(.*?at)/" => <a href="#learn-regex"><strong>The fat</strong></a> cat sat on the mat. </pre>

<p><a href="https://regex101.com/r/AyAdgJ/2">在线练习</a></p>
<h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><ul>
<li>报告问题</li>
<li>开放合并请求</li>
<li>传播此文档</li>
<li>直接和我联系 <a href="mailto:&#x7a;&#105;&#x69;&#115;&#x68;&#97;&#110;&#x65;&#x64;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;">&#x7a;&#105;&#x69;&#115;&#x68;&#97;&#110;&#x65;&#x64;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;</a> 或 <a href="https://twitter.com/ziishaned"><img src="/_posts/%E6%AD%A3%E5%88%99/assets/https:/img.shields.io/twitter/url/https/twitter.com/ziishaned.svg?style=social&label=Follow%20@ziishaned" alt="Twitter URL"></a></li>
</ul>
<h2 id="许可证"><a href="#许可证" class="headerlink" title="许可证"></a>许可证</h2><p>MIT &copy; <a href="https://twitter.com/ziishaned">Zeeshan Ahmad</a></p>
]]></content>
      <categories>
        <category>正则</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB mongoose 基础用法</title>
    <url>/%E5%A4%A7%E5%89%8D%E7%AB%AF/mongoose/</url>
    <content><![CDATA[<p><a href="http://www.mongoosejs.net/docs/guide.html">mongoose中文网</a></p>
<h2 id="mongoose-基础用法记录"><a href="#mongoose-基础用法记录" class="headerlink" title="mongoose 基础用法记录"></a>mongoose 基础用法记录</h2><h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><ul>
<li>首先在mongoDB里新建一个数据库，例如test1，借助Navicat工具</li>
</ul>
<p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/mongoose/image-20210428170647238.png" alt="image-20210428170647238"></p>
<ul>
<li>然后书写test.js</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var mongoose = require(&#x27;mongoose&#x27;);</span><br><span class="line">// 后面跟随的配置是安全配置，防止控制台输出警告</span><br><span class="line">mongoose.connect(&#x27;mongodb://39.106.100.189:10050/test1&#x27;, &#123;</span><br><span class="line">  useUnifiedTopology: true,</span><br><span class="line">  useNewUrlParser: true</span><br><span class="line">&#125;);</span><br><span class="line">// 如果有用户名 密码 可以使用</span><br><span class="line">// mongoose.connect(&#x27;mongodb://name:pwd@39.106.100.189:10050/test1&#x27;, &#123;</span><br><span class="line">  useUnifiedTopology: true,</span><br><span class="line">  useNewUrlParser: true</span><br><span class="line">&#125;);</span><br><span class="line">var db = mongoose.connection;</span><br><span class="line">db.on(&#x27;error&#x27;, function () &#123;</span><br><span class="line">  console.log(&#x27;error&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line">db.once(&#x27;open&#x27;, function() &#123;</span><br><span class="line">  console.log(&#x27;success&#x27;);</span><br><span class="line">  var kittySchema = mongoose.Schema(&#123;</span><br><span class="line">    name: String</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  kittySchema.methods.speak = function () &#123;</span><br><span class="line">    var greeting = this.name</span><br><span class="line">      ? &quot;Meow name is &quot; + this.name</span><br><span class="line">      : &quot;I don&#x27;t have a name&quot;;</span><br><span class="line">    console.log(greeting);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 简历表</span><br><span class="line">  var Kitten = mongoose.model(&#x27;Kitten&#x27;, kittySchema);</span><br><span class="line"></span><br><span class="line">  var fluffy = new Kitten(&#123; name: &#x27;fluffy&#x27; &#125;);</span><br><span class="line">  fluffy.speak(); // &quot;Meow name is fluffy&quot; </span><br><span class="line">  </span><br><span class="line">  fluffy.save(function (err, fluffy) &#123;</span><br><span class="line">    if (err) return console.error(err);</span><br><span class="line">    fluffy.speak();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">// 还有一种方式 更加简洁</span><br><span class="line">var User = mongoose.model(&#x27;User&#x27;, &#123; // 建立表</span><br><span class="line"> name: String,</span><br><span class="line"> age: Number</span><br><span class="line">&#125;);</span><br><span class="line">var fluffy = new User(&#123; name: &#x27;ming&#x27;, age: 15 &#125;); </span><br><span class="line"></span><br><span class="line">fluffy.save(function (err, fluffy) &#123; // 保存一条数据</span><br><span class="line"> if (err) return console.error(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>新增了一条fluffy数据，数据库显示如下</li>
</ul>
<p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/mongoose/image-20210428170922882.png" alt="image-20210428170922882"></p>
<h3 id="项目中按功能拆分"><a href="#项目中按功能拆分" class="headerlink" title="项目中按功能拆分"></a>项目中按功能拆分</h3><p>一般会把mongoose初始化，Schema，和操作表分离</p>
<p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/mongoose/image-20210428181713717.png" alt="image-20210428181713717"></p>
<h4 id="mongoose初始化"><a href="#mongoose初始化" class="headerlink" title="mongoose初始化"></a>mongoose初始化</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DBHelper.js</span><br><span class="line"></span><br><span class="line">import mongoose from &#x27;mongoose&#x27;;</span><br><span class="line">import config from &#x27;./index&#x27;;</span><br><span class="line"></span><br><span class="line">// 创建链接</span><br><span class="line">mongoose.connect(config.DB_URL, &#123;</span><br><span class="line">  useUnifiedTopology: true,</span><br><span class="line">  useNewUrlParser: true</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 连接成功</span><br><span class="line">mongoose.connection.on(&quot;connected&quot;, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;success&#x27; + config.DB_URL);</span><br><span class="line">&#125;)</span><br><span class="line">// 连接异常</span><br><span class="line">mongoose.connection.on(&quot;error&quot;, (error) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;error&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 断开连接</span><br><span class="line">mongoose.connection.on(&quot;disconnected&quot;, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;断开连接&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default mongoose</span><br></pre></td></tr></table></figure>

<h4 id="Schema文件"><a href="#Schema文件" class="headerlink" title="Schema文件"></a>Schema文件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">model/User.js // 对应数据库 users表</span><br><span class="line"></span><br><span class="line">import mongoose from &#x27;../config/DBHelpler&#x27;;</span><br><span class="line">const Schema = mongoose.Schema;</span><br><span class="line"></span><br><span class="line">const UserSchema = new Schema(&#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    type: String</span><br><span class="line">  &#125;,</span><br><span class="line">  age: &#123;</span><br><span class="line">    type: Number</span><br><span class="line">  &#125;,</span><br><span class="line">  email: &#123;</span><br><span class="line">    type: String</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const UserModel = mongoose.model(&#x27;User&#x27;, UserSchema)</span><br><span class="line"></span><br><span class="line">export default UserModel</span><br></pre></td></tr></table></figure>

<h4 id="controller文件"><a href="#controller文件" class="headerlink" title="controller文件"></a>controller文件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 模拟</span><br><span class="line">// 增删改查基础操作</span><br><span class="line">import User from &#x27;./User&#x27;;</span><br><span class="line"></span><br><span class="line">// 增</span><br><span class="line">const user = &#123;</span><br><span class="line">  name: &quot;xiaoming&quot;,</span><br><span class="line">  age: 30,</span><br><span class="line">  email: &quot;46546746&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const run = async () =&gt; &#123;</span><br><span class="line">  const data = new User(user)</span><br><span class="line">  const result = await data.save() // promise</span><br><span class="line">  console.log(result);</span><br><span class="line">&#125;</span><br><span class="line">run();</span><br><span class="line">// 查</span><br><span class="line">const search = async () =&gt; &#123;</span><br><span class="line">  const result = await User.find() // promise</span><br><span class="line">  console.log(result);</span><br><span class="line">&#125;</span><br><span class="line">search();</span><br><span class="line">// 改</span><br><span class="line">const update = async () =&gt; &#123;</span><br><span class="line">  // User.updateMany</span><br><span class="line">  const result = await User.updateOne(&#123;</span><br><span class="line">    // filter</span><br><span class="line">    name: &quot;xiaoming&quot;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    email: &quot;safasfas&quot;</span><br><span class="line">  &#125;)</span><br><span class="line">  console.log(result);</span><br><span class="line">&#125;</span><br><span class="line">update();</span><br><span class="line">// 删</span><br><span class="line">const delete_ = async () =&gt; &#123;</span><br><span class="line">  // User.deleteMany</span><br><span class="line">  const result = await User.deleteOne(&#123;</span><br><span class="line">    // filter</span><br><span class="line">    name: &quot;ming&quot;</span><br><span class="line">  &#125;)</span><br><span class="line">  console.log(result);</span><br><span class="line">&#125;</span><br><span class="line">delete_();</span><br></pre></td></tr></table></figure>

<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>添加 <code>Model</code> 的静态方法也十分简单，继续用 <code>animalSchema</code> 举例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// assign a function to the &quot;statics&quot; object of our animalSchema</span></span><br><span class="line">animalSchema.<span class="property">statics</span>.<span class="property">findByName</span> = <span class="keyword">function</span>(<span class="params">name, cb</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">find</span>(&#123; <span class="attr">name</span>: <span class="keyword">new</span> <span class="title class_">RegExp</span>(name, <span class="string">&#x27;i&#x27;</span>) &#125;, cb);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Animal</span> = mongoose.<span class="title function_">model</span>(<span class="string">&#x27;Animal&#x27;</span>, animalSchema);</span><br><span class="line"><span class="title class_">Animal</span>.<span class="title function_">findByName</span>(<span class="string">&#x27;fido&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, animals</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(animals);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>同样<strong>不要</strong>在静态方法中使用 ES6 箭头函数</p>
]]></content>
      <categories>
        <category>大前端</category>
      </categories>
      <tags>
        <tag>mongoose</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>正则疑难点记录</title>
    <url>/%E6%AD%A3%E5%88%99/%E7%96%91%E9%9A%BE%E7%82%B9%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="正则疑难点记录"><a href="#正则疑难点记录" class="headerlink" title="正则疑难点记录"></a>正则疑难点记录</h1><h2 id="贪婪、非贪婪与独占模式"><a href="#贪婪、非贪婪与独占模式" class="headerlink" title="贪婪、非贪婪与独占模式"></a>贪婪、非贪婪与独占模式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 贪婪匹配</span><br><span class="line">&quot;c.*t&quot; =&gt; The fat cat sat on the mat.</span><br><span class="line">//匹配： cat sat on the mat</span><br></pre></td></tr></table></figure>

<p><strong>在字符后加上一个问号（?）则可以开启懒惰模式，在该模式下，正则引擎尽可能少的重复匹配字符，匹配成功之后它会继续匹配剩余的字符串</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 非贪婪匹配  则可以开启懒惰模式，在该模式下，正则引擎尽可能少的重复匹配字符，匹配成功之后它会继续匹配剩余的字符串</span><br><span class="line">&quot;c.*?t&quot; =&gt; The fat cat sat on the mat.</span><br><span class="line">//匹配： cat</span><br></pre></td></tr></table></figure>

<p><strong>在表达式后加上一个加号（+），则会开启独占模式。同贪婪模式一样，独占模式一样会匹配最长。不过在独占模式下，正则表达式尽可能长地去匹配字符串，一旦匹配不成功就会结束匹配而不会回溯。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;c.*+t&quot; =&gt; The fat cat sat on the mat.</span><br><span class="line">//匹配： 空</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/study-everyday/p/7426862.html">淘宝大佬笔记-贪婪、懒惰与独占-回溯问题</a>  </p>
<h2 id="0次匹配-？"><a href="#0次匹配-？" class="headerlink" title="0次匹配 * ？"></a>0次匹配 * ？</h2><ul>
<li><em>匹配&gt;&#x3D;0个重复的在</em>号之前的字符。<ul>
<li><ul>
<li>匹配&gt;&#x3D;1个重复的+号前的字符。</li>
</ul>
</li>
</ul>
</li>
<li>? 标记?之前的字符为可选(代表0次或者1次).</li>
</ul>
<hr>
<p>看一下下列代码,匹配模式是<code>/[a-z]*/</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &quot;The fata catqq sat on the mat.&quot;;</span><br><span class="line">var reg = /[a-z]*/;</span><br><span class="line">console.log(str.match(reg));</span><br></pre></td></tr></table></figure>

<p>结果如下,替换为<code>/[a-z]?/</code>结果也是一样的<br><img src="/_posts/%E6%AD%A3%E5%88%99/assets/%E7%96%91%E9%9A%BE%E7%82%B9%E8%AE%B0%E5%BD%95/bg1.png" alt="疑难点记录"><br>匹配到了一个<code>&quot;&quot;</code></p>
<hr>
<p>现在添加一个全局搜索符 g</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &quot;The fata catqq sat on the mat.&quot;;</span><br><span class="line">var reg = /[a-z]*/g;</span><br><span class="line">console.log(str.match(reg));</span><br></pre></td></tr></table></figure>

<p>结果如下图：<br><img src="/_posts/%E6%AD%A3%E5%88%99/assets/%E7%96%91%E9%9A%BE%E7%82%B9%E8%AE%B0%E5%BD%95/bg2.png" alt="疑难点记录"><br>我非常疑惑为什么会匹配到 <code>&quot;&quot;</code> 下面是来自<a href="https://regex101.com/r/7m8me5/1">正则匹配</a>的示意图<br><img src="/_posts/%E6%AD%A3%E5%88%99/assets/%E7%96%91%E9%9A%BE%E7%82%B9%E8%AE%B0%E5%BD%95/bg3.png" alt="疑难点记录"><br>蓝色虚线表示<code>&quot;&quot;</code></p>
<hr>
<p>如果把正则换成<code>/[a-z]?/g</code>结果如下所示<br><img src="/_posts/%E6%AD%A3%E5%88%99/assets/%E7%96%91%E9%9A%BE%E7%82%B9%E8%AE%B0%E5%BD%95/bg4.png" alt="疑难点记录"><br>这是因为<code>?</code>开启了懒惰模式，正则引擎尽可能少的重复匹配字符，匹配成功之后它会继续匹配剩余的字符串  </p>
]]></content>
      <categories>
        <category>正则</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树</title>
    <url>/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%95%B0/</url>
    <content><![CDATA[<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p><img src="/_posts/%E7%AE%97%E6%B3%95/assets/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%95%B0/image-20210730105124238.png" alt="image-20210730105124238"></p>
<h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h3><p>​ 模拟操作示意网站<a href="https://visualgo.net/zh/bst">二叉搜索树</a></p>
<ul>
<li><p>查询</p>
</li>
<li><p>插入</p>
<p>首先需要搜索是否有重复节点，如果有 count++ ，如果没有，查询到的最后节点也就是插入需要操作的节点</p>
</li>
<li><p>删除</p>
<ul>
<li>删除 叶子节点(即最底层的节点，仅有一个关联节点)很简单，直接删除就可以，如果是关联节点(有子节点)，则会找出该节点右侧最小的节点替换它的位置（即比它大的最小值），<strong>需要注意指针的替换和删除</strong></li>
</ul>
<p><img src="/_posts/%E7%AE%97%E6%B3%95/assets/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%95%B0/image-20210730105732099.png" alt="image-20210730105732099"></p>
<p><img src="/_posts/%E7%AE%97%E6%B3%95/assets/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%95%B0/image-20210730105831806.png" alt="image-20210730105831806"></p>
</li>
</ul>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p><img src="/_posts/%E7%AE%97%E6%B3%95/assets/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%95%B0/image-20210730105043533.png" alt="image-20210730105043533"></p>
<p>时间复杂度log2 N 也就是 2的X次方 &#x3D; N  x是查询次数</p>
<p>插入 一个数 首先需要搜索是否有重复节点，如果有 count++ ，如果没有，查询到的最后节点也就是插入需要操作的节点</p>
<p>删除 叶子节点(即最底层的节点，仅有一个关联节点)很简单，直接删除就可以，如果是</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>简单记录学习极客时间-数据与结构之美-排序相关的知识记录</p>
<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>排序动画演示 可用手机app</p>
<h2 id="时间复杂度-On2"><a href="#时间复杂度-On2" class="headerlink" title="时间复杂度 On2"></a>时间复杂度 On2</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否 满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在 的位置，重复 n 次，就完成了 n 个数据的排序工作。</p>
<p>冒泡排序最不容易出错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [4,5,2,3,8,7,6,1,10]</span><br><span class="line">function bubble(arr) &#123;</span><br><span class="line">  const l = arr.length</span><br><span class="line">  for (let i = 0; i &lt; l - 1; i++) &#123;</span><br><span class="line">    // 没有交换发生 其实代表数组已经是有序的了</span><br><span class="line">    let flag = true;</span><br><span class="line">    for (let j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">      if (arr[i] &gt; arr[j]) &#123;</span><br><span class="line">        const temp = arr[i]</span><br><span class="line">        arr[i] = arr[j]</span><br><span class="line">        arr[j] = temp</span><br><span class="line">        // 有交换发生</span><br><span class="line">        flag = false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (flag) &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">bubble(arr)</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure>

<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>首先，我们将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有 一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排 序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程， 直到未排序区间中元素为空，算法结束。</p>
<p><strong>插入排序写起来比较费劲，要注意的地方比较多</strong></p>
<p>我自己的写的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function insert(arr) &#123;</span><br><span class="line">  const l = arr.length</span><br><span class="line">  for (let i = 0; i &lt; l - 1; i++) &#123;</span><br><span class="line">    let j = i + 1</span><br><span class="line">    while (arr[j-1] &gt; arr[j] &amp;&amp; j&gt;=0) &#123;</span><br><span class="line">      const temp = arr[j]</span><br><span class="line">      arr[j] = arr[j-1]</span><br><span class="line">      arr[j-1] = temp</span><br><span class="line">      j--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">insert(arr)</span><br></pre></td></tr></table></figure>

<p>教程写的，已经换成JavaScript，并加了注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function insert2(arr) &#123;</span><br><span class="line">  const l = arr.length;</span><br><span class="line">  for (let i = 1; i &lt; l; ++i) &#123;</span><br><span class="line">    // 缓存当前处理的元素，减少交换次数 </span><br><span class="line">    let value = arr[i];</span><br><span class="line">    // 对比前方排序区，查找插入的位置</span><br><span class="line">    let j = i - 1;</span><br><span class="line">    for ( ; j &gt;= 0; --j) &#123;</span><br><span class="line">      if (arr[j] &gt; value) &#123;</span><br><span class="line">        // 相当于把arr[j]向右移一位</span><br><span class="line">        // 第一次被覆盖掉的元素是当前处理元素，已在顶部缓存</span><br><span class="line">        // 第一次以后被覆盖的元素，实际上已经保存在右侧了</span><br><span class="line">        arr[j + 1] = arr[j]; // 数据移动</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // 当前元素已经满足条件，不需要交换</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 只在最后交换 j+1 </span><br><span class="line">    arr[j + 1] = value; // 插入数据</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function select(arr) &#123;</span><br><span class="line">  const l = arr.length</span><br><span class="line">  let min, minIndex</span><br><span class="line">  for (let i = 0; i &lt; l - 1; i++) &#123;</span><br><span class="line">   // 起始位置</span><br><span class="line">    min = arr[i]</span><br><span class="line">    minIndex = i</span><br><span class="line">    for (let j = i+1; j &lt; l; j++) &#123;</span><br><span class="line">      if (arr[j] &lt; min) &#123;</span><br><span class="line">        min = arr[j]</span><br><span class="line">        minIndex = j</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    const temp = arr[i]</span><br><span class="line">    arr[i] = min</span><br><span class="line">    arr[minIndex] = temp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// select(arr)</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure>

<h2 id="时间复杂度-O-nlogn"><a href="#时间复杂度-O-nlogn" class="headerlink" title="时间复杂度 O nlogn"></a>时间复杂度 O nlogn</h2><h3 id="归并排序-稳定"><a href="#归并排序-稳定" class="headerlink" title="归并排序(稳定)"></a>归并排序(稳定)</h3><p>自己的代码，未优化的版本，找了好久的错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 归并排序</span><br><span class="line">function merginInto(arr, l, r) &#123;</span><br><span class="line">  if (l === r) &#123;</span><br><span class="line">    return arr</span><br><span class="line">  &#125;</span><br><span class="line">  const m = (l + r) &gt;&gt; 1 // 相当于除以2 取整</span><br><span class="line">  const left = arr.slice(l, m + 1)</span><br><span class="line">  const right = arr.slice(m + 1, r + 1)</span><br><span class="line">  return sortOrderArr(</span><br><span class="line">    left.length &lt;= 1 ? left: merginInto(</span><br><span class="line">     // 忘了把边界改成新数组的了</span><br><span class="line">      left, 0, m</span><br><span class="line">    ),</span><br><span class="line">    right.length &lt;= 1 ? right : merginInto(</span><br><span class="line">      // 忘了把边界改成新数组的了</span><br><span class="line">      right, 0, r - (m + 1)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">// 将两个有序数组合并</span><br><span class="line">function sortOrderArr(arr1, arr2) &#123;</span><br><span class="line">  const res = []</span><br><span class="line">  let i1 = i2 = 0, l1 = arr1.length, l2 = arr2.length</span><br><span class="line">  while (i1&lt;l1 || i2&lt;l2) &#123;</span><br><span class="line">    if (i1 === l1) &#123;</span><br><span class="line">      res.push(arr2[i2++])</span><br><span class="line">    &#125; else if(i2===l2) &#123;</span><br><span class="line">      res.push(arr1[i1++])</span><br><span class="line">    &#125;else if (arr1[i1] &lt;= arr2[i2]) &#123;</span><br><span class="line">      res.push(arr1[i1++])</span><br><span class="line">    &#125;else(</span><br><span class="line">      res.push(arr2[i2++])</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较大众的写法，<strong>这个类似于二叉树的后续遍历</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function mergeInto(arr, l, r) &#123;</span><br><span class="line">  if (l &gt;= r) &#123;</span><br><span class="line">    return arr</span><br><span class="line">  &#125;</span><br><span class="line">  const m = (l + r) &gt;&gt; 1;</span><br><span class="line">  // 原地排序 不需要返回</span><br><span class="line">  mergeInto(arr, l, m)</span><br><span class="line">  mergeInto(arr, m + 1, r)</span><br><span class="line">  // 两个已经拍好序的数组</span><br><span class="line">  mergeArr(arr, l, m, r)</span><br><span class="line">  return arr</span><br><span class="line">&#125;</span><br><span class="line">function mergeArr(arr, l, m, r) &#123;</span><br><span class="line">  const res = []</span><br><span class="line">  let i1 = l, i2 = m + 1, l1 = m+1, l2 = r+1</span><br><span class="line">  while (i1&lt;l1 || i2&lt;l2) &#123;</span><br><span class="line">    if (i1 === l1) &#123;</span><br><span class="line">      res.push(arr[i2++])</span><br><span class="line">    &#125; else if(i2===l2) &#123;</span><br><span class="line">      res.push(arr[i1++])</span><br><span class="line">    &#125;else if (arr[i1] &lt;= arr[i2]) &#123;</span><br><span class="line">      res.push(arr[i1++])</span><br><span class="line">    &#125;else(</span><br><span class="line">      res.push(arr[i2++])</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  for (let i = l,j=0; i &lt; r+1; i++,j++) &#123;</span><br><span class="line">    arr[i] = res[j]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序-不稳定"><a href="#快速排序-不稳定" class="headerlink" title="快速排序(不稳定)"></a>快速排序(不稳定)</h3><p><strong>把比参考位置小的数移到左侧，大的移到右侧，如果不额外占用空间的话，比较难写</strong></p>
<p>空间复杂度 O n 比较容易写出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fastSort(arr, l, r) &#123;</span><br><span class="line">  if (l &gt;= r) &#123;</span><br><span class="line">    return arr</span><br><span class="line">  &#125;</span><br><span class="line">  const p = fastSortHandle(arr, l, r)</span><br><span class="line">  fastSort(arr, l, p - 1)</span><br><span class="line">  fastSort(arr, p + 1, r)</span><br><span class="line">  return arr</span><br><span class="line">&#125;</span><br><span class="line">// 快排辅助函数 分区 排序</span><br><span class="line">function fastSortHandle(arr, l, r) &#123;</span><br><span class="line"> // 占用了 On的空间</span><br><span class="line">  const res = []</span><br><span class="line">  //随机会好一点</span><br><span class="line">  const rdm = Math.floor(Math.random()*(r-l+1)+l)</span><br><span class="line">  const ref = arr[rdm]</span><br><span class="line">  let li = l, ri = r</span><br><span class="line">  for (let i = l; i &lt; r + 1; i++) &#123;</span><br><span class="line">    if (i === rdm) &#123;</span><br><span class="line">      continue</span><br><span class="line">    &#125;</span><br><span class="line">    if (arr[i] &lt;= ref) &#123;</span><br><span class="line">      res[li] = arr[i]</span><br><span class="line">      li++</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      res[ri] = arr[i]</span><br><span class="line">      ri--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  res[ri] = ref</span><br><span class="line">  for (let i = l; i &lt; r+1; i++) &#123;</span><br><span class="line">    arr[i] = res[i]</span><br><span class="line">  &#125;</span><br><span class="line">  return ri</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="O1空间复杂度左右归类的算法解释"><a href="#O1空间复杂度左右归类的算法解释" class="headerlink" title="O1空间复杂度左右归类的算法解释"></a>O1空间复杂度左右归类的算法解释</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fastSortHandle(arr, l, r) &#123;</span><br><span class="line">  // const rdm = Math.floor(Math.random()*(r-l+1)+l)</span><br><span class="line">  const rdm = 1</span><br><span class="line">  const ref = arr[rdm]</span><br><span class="line">  let j = l</span><br><span class="line">  for (let i = l; i &lt; r + 1; i++) &#123;</span><br><span class="line">    // 跳过</span><br><span class="line">    if (i === rdm) &#123;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    // 跳过</span><br><span class="line">    if (j === rdm) &#123;</span><br><span class="line">      j++</span><br><span class="line">    &#125;</span><br><span class="line">    if (arr[i] &lt;= ref) &#123;</span><br><span class="line">      [arr[i], arr[j]] = [arr[j], arr[i]]</span><br><span class="line">      j++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (rdm &lt; j) &#123;</span><br><span class="line">    j--</span><br><span class="line">  &#125;</span><br><span class="line">  [arr[rdm], arr[j]] = [arr[j], arr[rdm]]</span><br><span class="line">  return j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当选择一个随机数N，下标INDEX作为参照点的话，程序运行到关键点的情况应该如下图所示</p>
<p>左侧是小于等于N的数，右侧是大于N的数，但是N可能在左侧或者右侧</p>
<p><img src="/_posts/%E7%AE%97%E6%B3%95/assets/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20211112105742642.png" alt="image-20211112105742642"></p>
<p>最好的情况就是 把N的位置放进 j-1 和 j之间，但是这样<strong>时间复杂度较高，采取交换替代</strong></p>
<p>如果N在左侧就和<code>J-1</code>交换，N在右侧就和<code>J</code>置换，如果不需要随机选择位置的话，N取最右侧元素，就不需要判断了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (rdm &lt; j) &#123;</span><br><span class="line">    j--</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  [arr[rdm], arr[j]] = [arr[j], arr[rdm]]</span><br><span class="line">  return j</span><br></pre></td></tr></table></figure>

<h4 id="更好的随机数左右归类"><a href="#更好的随机数左右归类" class="headerlink" title="更好的随机数左右归类"></a>更好的随机数左右归类</h4><p><a href="https://leetcode-cn.com/problems/sort-an-array/solution/pai-xu-shu-zu-by-leetcode-solution/">力扣官方</a>采取先用随机数与最后一位交换位置在进行常规方法，方法容易理解，也不容易出错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int partition(vector&lt;int&gt;&amp; nums, int l, int r) &#123;</span><br><span class="line">      int pivot = nums[r];</span><br><span class="line">      int i = l - 1;</span><br><span class="line">      for (int j = l; j &lt;= r - 1; ++j) &#123;</span><br><span class="line">          if (nums[j] &lt;= pivot) &#123;</span><br><span class="line">              i = i + 1;</span><br><span class="line">              swap(nums[i], nums[j]);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      swap(nums[i + 1], nums[r]);</span><br><span class="line">      return i + 1;</span><br><span class="line">  &#125;</span><br><span class="line">  int randomized_partition(vector&lt;int&gt;&amp; nums, int l, int r) &#123;</span><br><span class="line">      int i = rand() % (r - l + 1) + l; // 随机选一个作为我们的主元</span><br><span class="line">      swap(nums[r], nums[i]);</span><br><span class="line">      return partition(nums, l, r);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>最后总结出JavaScript版本的快速排序</p>
<p><img src="/_posts/%E7%AE%97%E6%B3%95/assets/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20211112112025117.png" alt="image-20211112112025117"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fastSort(arr, l, r) &#123;</span><br><span class="line">  if (l &gt;= r) &#123;</span><br><span class="line">    return arr</span><br><span class="line">  &#125;</span><br><span class="line">  const p = fastSortHandle(arr, l, r)</span><br><span class="line">  // -1 +1 可别忘 会死循环的</span><br><span class="line">  fastSort(arr, l, p - 1)</span><br><span class="line">  fastSort(arr, p + 1, r)</span><br><span class="line">  return arr</span><br><span class="line">&#125;</span><br><span class="line">function fastSortHandle(arr, l, r) &#123;</span><br><span class="line">  const rdm = Math.floor(Math.random() * (r - l + 1) + l)</span><br><span class="line">  // 与最后元素交换</span><br><span class="line">  swap(arr, rdm, r)</span><br><span class="line"></span><br><span class="line">  const ref = arr[r]</span><br><span class="line">  let j = l</span><br><span class="line">  for (let i = l; i &lt; r; i++) &#123;</span><br><span class="line">    if (arr[i] &lt;= ref) &#123;</span><br><span class="line">      swap(arr, i, j)</span><br><span class="line">      j++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  swap(arr, r, j)</span><br><span class="line">  return j</span><br><span class="line">&#125;</span><br><span class="line">function swap(arr, p, q) &#123;</span><br><span class="line">  const temp = arr[p]</span><br><span class="line">  arr[p] = arr[q]</span><br><span class="line">  arr[q] = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序和快速排序的区别与联系"><a href="#归并排序和快速排序的区别与联系" class="headerlink" title="归并排序和快速排序的区别与联系"></a>归并排序和快速排序的区别与联系</h3><p><img src="/_posts/%E7%AE%97%E6%B3%95/assets/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20211112112920927.png" alt="image-20211112112920927"></p>
<p>快排和归并用的都是分治思想，递推公式和递归代码也非常相似，那它们的区别在哪里呢?</p>
<p><img src="/_posts/%E7%AE%97%E6%B3%95/assets/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20211112113107064.png" alt="image-20211112113107064">可以发现，归并排序的处理过程是由下到上的，先处理子问题，然后再合并。</p>
<p>而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。</p>
<p>归并排序虽然是稳定的、时 间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以 是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode</title>
    <url>/%E7%AE%97%E6%B3%95/LeetCode/</url>
    <content><![CDATA[<h2 id="卡牌分组"><a href="#卡牌分组" class="headerlink" title="卡牌分组"></a>卡牌分组</h2><p>给定一副牌，每张牌上都写着一个整数。</p>
<p>此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：</p>
<p>每组都有 X 张牌。组内所有的牌上都写着相同的整数。<br>仅当你可选的 X &gt;&#x3D; 2 时返回 true。</p>
<hr>
<p>示例 1：</p>
<p>输入：[1,2,3,4,4,3,2,1]<br>输出：true<br>解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]<br>示例 2：</p>
<hr>
<p>输入：[1,1,1,2,2,2,3,3]<br>输出：false<br>解释：没有满足要求的分组。<br>示例 3：  </p>
<hr>
<p>输入：[1]<br>输出：false<br>解释：没有满足要求的分组。<br>示例 4：  </p>
<hr>
<p>输入：[1,1]<br>输出：true<br>解释：可行的分组是 [1,1]<br>示例 5：  </p>
<hr>
<p>输入：[1,1,2,2,2,2]<br>输出：true<br>解释：可行的分组是 [1,1]，[2,2]，[2,2]  </p>
<hr>
<p><strong>涉及点</strong></p>
<ul>
<li>辗转相除法 求最大公约数</li>
<li>利用哈希表计算元素出现次数</li>
</ul>
<hr>
<p>自己的解答</p>
<ul>
<li>首先利用 <code>ES6</code> 新数据结构 <code>Map</code> ，计算元素出现的次数</li>
<li>使用<code>...</code>运算符将其转为数组，不要忘记利用 (Map.protype.values()返回的是一个新的Iterator对象)</li>
<li>然后遍历数组，取当前项与后一项做辗转相除法，求出最大公约数后赋值给后一项，直到运算完成</li>
<li>这里需要考虑[1,1]的这种情况，由于次数数组程度为 1 ，所以做了特殊处理</li>
<li>然后只要判断最后的最大公约数是否大于 2 即可</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var hasGroupsSizeX = function(deck) &#123;</span><br><span class="line">  if(deck.length&lt;2)&#123;</span><br><span class="line">    return false</span><br><span class="line">  &#125;</span><br><span class="line">  const countMap = new Map()</span><br><span class="line">  for (let i = 0; i &lt; deck.length; i++) &#123;</span><br><span class="line">    countMap.set(deck[i],countMap.has(deck[i]) ? countMap.get(deck[i]) + 1 : 1)</span><br><span class="line">  &#125;</span><br><span class="line">  const countArray = [...countMap.values()] </span><br><span class="line">  console.log(countArray);</span><br><span class="line">  let g;</span><br><span class="line">  if(countArray.length === 1 &amp;&amp; countArray[2] &gt;=2 )&#123;</span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line">  for (let i = 0; i &lt; countArray.length - 1; i++) &#123;</span><br><span class="line">    g = ojld(countArray[i], countArray[i+1])</span><br><span class="line">    countArray[i+1] = g</span><br><span class="line">  &#125;</span><br><span class="line">  return g &gt;= 2</span><br><span class="line">&#125;;</span><br><span class="line">function ojld(chushu, yushu) &#123;</span><br><span class="line">  if(chushu % yushu === 0)&#123;</span><br><span class="line">    return yushu</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    return ojld(yushu, chushu % yushu)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>网上的解答,在此仅展示部分代码，代码取第一位做了一次重复运算，所有不需要考虑特殊情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">最大公约数</span><br><span class="line">因为该数组是出现次数数组，最小值至少为1（至少出现1次），所以默认赋值为数组首位对公约数计算无干扰</span><br><span class="line">*/</span><br><span class="line">let g = timeAry[0];</span><br><span class="line"></span><br><span class="line">// 遍历出现次数，计算最大公约数</span><br><span class="line">timeAry.forEach(time =&gt; &#123;</span><br><span class="line">  // 因为需要比较所有牌出现次数的最大公约数，故需要一个中间值</span><br><span class="line">  g = gcd(g, time);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="605-种花问题"><a href="#605-种花问题" class="headerlink" title="605 种花问题"></a>605 种花问题</h2><p>假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。  </p>
<p>给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。  </p>
<hr>
<p>示例 1:<br>输入: flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 1<br>输出: True  </p>
<hr>
<p>示例 2:<br>输入: flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 2<br>输出: False  </p>
<hr>
<p>注意:</p>
<ul>
<li>数组内已种好的花不会违反种植规则。  </li>
<li>输入的数组长度范围为 [1, 20000]。</li>
<li>n 是非负整数，且不会超过输入数组的大小。</li>
</ul>
<hr>
<p>官方解答, 有几个缺点</p>
<ul>
<li>边界条件过于负责</li>
<li>遍历次数较多</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var canPlaceFlowers = function(flowerbed, n) &#123;</span><br><span class="line">  let count = 0</span><br><span class="line">  for (let i = 0,length = flowerbed.length; i &lt; length; i++) &#123;</span><br><span class="line">    const item = flowerbed[i];</span><br><span class="line">    if(item!=1)&#123;</span><br><span class="line">      if((i==0||flowerbed[i-1]==0)&amp;&amp;(i==flowerbed.length-1||flowerbed[i+1]==0))&#123;</span><br><span class="line">        flowerbed[i] = 1</span><br><span class="line">        count++</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return count&gt;=n</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>较好的解答, 通俗易懂</p>
<ul>
<li>两边不为1，隐含着最左和最右的边界条件</li>
<li>当符合种花条件时，将遍历序号 +1 取代赋值，减少了遍历次数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var canPlaceFlowers = function (flowerbed, n) &#123;</span><br><span class="line">  var num = 0</span><br><span class="line">  for (var i = 0, length = flowerbed.length; i &lt; length; i++) &#123;</span><br><span class="line">    if (flowerbed[i] === 0 &amp;&amp; flowerbed[i - 1] !== 1 &amp;&amp; flowerbed[i + 1] !== 1) &#123;</span><br><span class="line">      num++</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return n &lt;= num</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="格雷编码"><a href="#格雷编码" class="headerlink" title="格雷编码"></a>格雷编码</h2><p><a href="https://leetcode-cn.com/problems/gray-code/solution/gray-code-jing-xiang-fan-she-fa-by-jyd/">优秀解题思路-附带图解</a><br>主要就是找规律，据说数字电路课有讲解  </p>
<hr>
<p>我的解答</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84 柱状图中最大的矩形"></a>84 柱状图中最大的矩形</h2><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。<br><img src="/_posts/%E7%AE%97%E6%B3%95/assets/leetCode/bg1.png" alt="最大矩形">  </p>
<hr>
<p>我的解法，用最原始的方法进行解答，理论上可行，但是空间复杂度和时间复杂度太复杂了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var largestRectangleArea = function(heights) &#123;</span><br><span class="line">  let maxArea = 0</span><br><span class="line">  while (heights.length !== 0) &#123;</span><br><span class="line">    const lengths = [...heights];</span><br><span class="line">    while(lengths.length !== 0)&#123;</span><br><span class="line">      let area = Math.min(...lengths) * lengths.length</span><br><span class="line">      if(area&gt;maxArea)&#123;</span><br><span class="line">        maxArea = area</span><br><span class="line">      &#125;</span><br><span class="line">      lengths.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    heights.shift()</span><br><span class="line">  &#125;</span><br><span class="line">  return maxArea</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/xiang-xi-jie-shao-dan-diao-zhan-de-li-jie-he-shi-y/">单调栈应用优秀讲解</a>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const largestRectangleArea = (heights) =&gt; &#123;</span><br><span class="line">  let maxArea = 0</span><br><span class="line">  const stack = []</span><br><span class="line">  heights = [0, ...heights, 0]         </span><br><span class="line">  for (let i = 0; i &lt; heights.length; i++) &#123; </span><br><span class="line">    while (heights[i] &lt; heights[stack[stack.length - 1]]) &#123; // 当前bar比栈顶bar矮</span><br><span class="line">      const stackTopIndex = stack.pop() // 栈顶元素出栈，并保存栈顶bar的索引</span><br><span class="line">      maxArea = Math.max(               // 计算面积，并挑战最大面积</span><br><span class="line">        maxArea,                        // 计算出栈的bar形成的长方形面积</span><br><span class="line">        heights[stackTopIndex] * (i - stack[stack.length - 1] - 1)</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(i)                       // 当前bar比栈顶bar高了，入栈</span><br><span class="line">  &#125;</span><br><span class="line">  return maxArea</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试中遇到的算法题-两个有序数组合并为一个有序数组"><a href="#面试中遇到的算法题-两个有序数组合并为一个有序数组" class="headerlink" title="面试中遇到的算法题 两个有序数组合并为一个有序数组"></a>面试中遇到的算法题 两个有序数组合并为一个有序数组</h2><p>两个数组<br><code>let arr1  = [0, 3, 5, 8, 15, 19]</code><br><code>let arr2 =  [1, 2, 7, 13, 16, 17, 18]</code><br>结果输出为<br><code>[0, 1, 2, 3, 5, 7, 8, 13, 15, 16, 17, 18]</code><br>假设两个数组都为升序排列  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr1  = [-1, 0, 1, 5, 8, 15, 19, 22, 33]</span><br><span class="line">let arr2 =  [3, 4, 7, 13, 15, 16, 17, 18, 19, 20, 33, 34, 35]</span><br><span class="line">for (let i = 0; i &lt; arr1.length; i++) &#123;</span><br><span class="line">  for (let j = 0; j &lt; arr2.length; j++) &#123;</span><br><span class="line">    if(arr1[i]&lt;arr2[j])&#123;</span><br><span class="line">      arr2.splice(j, 0, arr1[i]);</span><br><span class="line">      break;</span><br><span class="line">    &#125;else if(j === arr2.length -1)&#123;</span><br><span class="line">      arr2.splice(j + 1, 0, arr1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">引申，如果不让使用for循环、sort  </span><br><span class="line">**下边这个方法问题不大，测试了很多数据，还拥有优化空间**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>let arr1  &#x3D; [-1, 0, 1, 5, 8, 15, 19, 22, 33]<br>let arr2 &#x3D;  [3, 4, 7, 13, 15, 16, 17, 18, 19, 20, 33, 34, 35]<br>function handle(arr1, arr2) {<br>  if(arr1.length &#x3D;&#x3D;&#x3D; 0){<br>    return<br>  }else{<br>    var v1 &#x3D; arr1.shift()<br>    addPosition(v1, arr2, 0)<br>    return handle(arr1, arr2)<br>  }<br>}<br>function addPosition(v1, arr2, index){<br>  if(index &gt;&#x3D; arr2.length){<br>    return<br>  }else{<br>    if(v1 &lt;&#x3D; arr2[index] &amp;&amp; (index &#x3D;&#x3D;&#x3D; 0 || v1 &gt; arr2[index - 1])){<br>      arr2.splice(index, 0, v1)<br>      return<br>    } else if(index &#x3D;&#x3D;&#x3D; arr2.length - 1) {<br>      if(v1 &gt; arr2[index]){<br>        arr2.splice(index + 1, 0, v1)<br>        return<br>      }<br>    }<br>    return addPosition(v1, arr2, index + 1)<br>  }<br>}<br>handle(arr1, arr2)<br>console.log(arr2);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">***</span><br><span class="line">其实升序排列 还隐藏着一些条件，上述代码优化如下</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>let arr1  &#x3D; [-1, 0, 1, 5, 8, 15, 19, 22, 33]<br>    let arr2 &#x3D;  [3, 4, 7, 13, 15, 16, 17, 18, 19, 20, 33, 34, 35]<br>    function handle(arr1, arr2) {<br>      if(arr1.length &#x3D;&#x3D;&#x3D; 0){<br>        return<br>      }else{<br>        var v1 &#x3D; arr1.shift()<br>        addPosition(v1, arr2, 0)<br>        return handle(arr1, arr2)<br>      }<br>    }<br>    function addPosition(v1, arr2, index){<br>      if(index &gt;&#x3D; arr2.length){<br>        return<br>      }else{<br>        &#x2F;&#x2F; 优化了下列代码<br>        if(v1 &lt;&#x3D; arr2[index]){<br>          arr2.splice(index, 0, v1)<br>          return<br>        } else if(index &#x3D;&#x3D;&#x3D; arr2.length - 1) {<br>          arr2.splice(index + 1, 0, v1)<br>          return<br>        }<br>        &#x2F;&#x2F; 优化结束<br>        return addPosition(v1, arr2, index + 1)<br>      }<br>    }<br>    handle(arr1, arr2)<br>    console.log(arr2);</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>递归链表翻转</title>
    <url>/%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92%E9%93%BE%E8%A1%A8%E7%BF%BB%E8%BD%AC/</url>
    <content><![CDATA[<h2 id="递归链表翻转"><a href="#递归链表翻转" class="headerlink" title="递归链表翻转"></a>递归链表翻转</h2><p>给定单链表的头节点 head ，请反转链表，并返回反转后的链表的头节点。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>基础递归公式如下</strong></p>
<h3 id="前置递归"><a href="#前置递归" class="headerlink" title="前置递归"></a>前置递归</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function reverse(head)&#123;</span><br><span class="line">      if(!head || head.next === null)&#123;</span><br><span class="line">          console.log(&quot;last--&quot;, head)</span><br><span class="line">          return head;</span><br><span class="line">      &#125;</span><br><span class="line">      const last = reverse(head.next)</span><br><span class="line">      console.log(&quot;head--&quot;, head)</span><br><span class="line">      head.next.next = head</span><br><span class="line">      head.next = null</span><br><span class="line">      </span><br><span class="line">      console.log(&quot;last--&quot;, last)</span><br><span class="line">      return last</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用[1,2,3,4,5]作为测试用例</strong>，输出结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">last--  [5]</span><br><span class="line">head--  [4,5]</span><br><span class="line">last--  [5,4]</span><br><span class="line">head--  [3,4]</span><br><span class="line">last--  [5,4,3]</span><br><span class="line">head--  [2,3]</span><br><span class="line">last--  [5,4,3,2]</span><br><span class="line">head--  [1,2]</span><br><span class="line">last--  [5,4,3,2,1]</span><br></pre></td></tr></table></figure>

<p>做一个灵魂画手，帮助记忆。</p>
<p><img src="/_posts/%E7%AE%97%E6%B3%95/assets/%E9%80%92%E5%BD%92%E9%93%BE%E8%A1%A8%E7%BF%BB%E8%BD%AC/%E5%9B%BE%E5%83%8F2.jpeg" alt="图像2"></p>
<p>由于是前置递归，代码由下而上进行运行，每一步都会将head节点与上一个节点进行翻转，并将head节点指向null</p>
<p>head节点信息由调用栈的函数持有</p>
<h3 id="后置递归"><a href="#后置递归" class="headerlink" title="后置递归"></a>后置递归</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 后置递归</span><br><span class="line">  function df(pre, cur) &#123;</span><br><span class="line">    if (cur === null) &#123;</span><br><span class="line">      return pre;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      var temp = cur.next;</span><br><span class="line">      cur.next = pre;</span><br><span class="line">      return df(cur, temp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return df(null, head);</span><br></pre></td></tr></table></figure>

<p>灵魂画手又来了</p>
<p><img src="/_posts/%E7%AE%97%E6%B3%95/assets/%E9%80%92%E5%BD%92%E9%93%BE%E8%A1%A8%E7%BF%BB%E8%BD%AC/%E5%9B%BE%E5%83%8F3.jpeg" alt="图像3"></p>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 迭代</span><br><span class="line">var reverseList = function (head) &#123;</span><br><span class="line">  var pre = null, cur = head, next;</span><br><span class="line">  while (cur) &#123;</span><br><span class="line">    next = cur.next;</span><br><span class="line">    cur.next = pre;</span><br><span class="line">    pre = cur;</span><br><span class="line">    cur = next;</span><br><span class="line">  &#125;</span><br><span class="line">  return pre;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="翻转链表前N个节点"><a href="#翻转链表前N个节点" class="headerlink" title="翻转链表前N个节点"></a>翻转链表前N个节点</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入 [1,2,3,4,5] 3</span><br><span class="line">输出 [3,2,1,4,5]</span><br></pre></td></tr></table></figure>

<h3 id="前置递归-1"><a href="#前置递归-1" class="headerlink" title="前置递归"></a>前置递归</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function ListNode(val, next) &#123;</span><br><span class="line">  this.val = (val===undefined ? 0 : val)</span><br><span class="line">  this.next = (next===undefined ? null : next)</span><br><span class="line">&#125;</span><br><span class="line">const list = new ListNode(1)</span><br><span class="line">list.next = new ListNode(2)</span><br><span class="line">list.next.next = new ListNode(3)</span><br><span class="line">list.next.next.next = new ListNode(4)</span><br><span class="line">list.next.next.next.next = new ListNode(5)</span><br><span class="line">list.next.next.next.next.next = null</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let middleHead = null</span><br><span class="line">function reverseN(head, n) &#123;</span><br><span class="line">  if (n === 1) &#123;</span><br><span class="line">    middleHead = head.next </span><br><span class="line">    return head</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  const last = reverseN(head.next, n - 1)</span><br><span class="line">  head.next.next = head</span><br><span class="line">  head.next = middleHead</span><br><span class="line">  return last</span><br><span class="line">&#125;</span><br><span class="line">console.log(reverseN(list, 3))</span><br></pre></td></tr></table></figure>

<p>灵魂画图，有点难以理解啊</p>
<p><img src="/_posts/%E7%AE%97%E6%B3%95/assets/%E9%80%92%E5%BD%92%E9%93%BE%E8%A1%A8%E7%BF%BB%E8%BD%AC/%E5%9B%BE%E5%83%8F4.jpeg" alt="图像4"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
        <tag>递归</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器原理</title>
    <url>/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="chrome架构"><a href="#chrome架构" class="headerlink" title="chrome架构"></a>chrome架构</h2><p>打开一个chrome网页，如图所示会出现很多线程</p>
<p><img src="/_posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/image-20210712221958756.png" alt="image-20210712221958756"></p>
<p>首先需要讲解一下 进程和线程</p>
<h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><ul>
<li><strong>一个进程就是一个程序的运行实例</strong></li>
<li><strong>线程是不能单独存在的，它是由进程来启动和管理的</strong></li>
<li><strong>线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率</strong></li>
</ul>
<p><img src="/_posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/image-20210712222146731.png" alt="image-20210712222146731"></p>
<p>总结来说，进程和线程之间的关系有以下 4 个特点。</p>
<ul>
<li><strong>1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。</strong></li>
<li><strong>2. 线程之间共享进程中的数据。</strong></li>
<li><strong>3. 当一个进程关闭之后，操作系统会回收进程所占用的内存(包括泄漏的内存)。</strong></li>
<li><strong>4. 进程之间的内容相互隔离。(通信依靠IPC进程间通信)</strong></li>
</ul>
<h3 id="浏览器架构发展史"><a href="#浏览器架构发展史" class="headerlink" title="浏览器架构发展史"></a>浏览器架构发展史</h3><h4 id="单进程浏览器"><a href="#单进程浏览器" class="headerlink" title="单进程浏览器"></a>单进程浏览器</h4><p><strong>单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里</strong></p>
<p><img src="/_posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/image-20210712222743496.png" alt="image-20210712222743496"></p>
<p>缺点很明显</p>
<ul>
<li><p>不稳定</p>
<p>一个插件的意外崩溃会引起整个浏览器的崩溃，除了插件之外，<strong>渲染引擎模块（复杂代码）</strong>也是不稳定的</p>
</li>
<li><p>不流畅</p>
<p>所有页面的渲染模块、JavaScript 执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行</p>
</li>
<li><p>不安全</p>
<p>插件可以使用c++编写，可以轻易访问操作系统</p>
</li>
</ul>
<h4 id="多进程浏览器"><a href="#多进程浏览器" class="headerlink" title="多进程浏览器"></a>多进程浏览器</h4><p>多进程浏览器<strong>解决了</strong>单进程浏览器的几个问题</p>
<ul>
<li>不稳定：由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面</li>
<li>不流畅：每个tab页均有一个渲染进程，JavaScript 也是运行在渲染进程中的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染页面</li>
<li>不安全：安全沙箱，Chrome 把插件进程和渲染进程锁在沙箱里面</li>
</ul>
<p>多进程浏览器也会有一些问题</p>
<ul>
<li><p><strong>更高的资源占用：</strong>因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环</p>
<p>境），这就意味着浏览器会消耗更多的内存资源。</p>
</li>
<li><p><strong>更复杂的体系架构：</strong>浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已</p>
<p>经很难适应新的需求了。</p>
</li>
</ul>
<p>多进程浏览器包括（浏览器架构持续优化中，仅供参考）:<br><img src="/_posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/image-20210712223130924.png" alt="image-20210712223130924"></p>
<ul>
<li><p><strong>浏览器进程</strong>。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</p>
</li>
<li><p><em><strong>渲染进程</strong></em>。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中。默认情况下，<strong>Chrome 会为每个 Tab 标签创建一个渲染进程</strong>。出于安全考虑，渲染进程都是运行在沙箱模式下。</p>
<ul>
<li>主线程（<strong>也就是我们常说的js单线程</strong>）<ul>
<li>渲染事件（如解析 DOM、计算布局、绘制）</li>
<li>用户交互事件（如鼠标点击、滚动页面、放大缩小等）</li>
<li>JavaScript 脚本执行事件</li>
<li>网络请求完成、文件读写完成事件</li>
<li>垃圾回收</li>
<li>等等</li>
</ul>
</li>
<li>合成线程(动画优化)</li>
<li>光栅化线程池</li>
<li>IO 线程</li>
</ul>
</li>
<li><p><strong>GPU 进程</strong></p>
</li>
<li><p><strong>网络进程</strong></p>
</li>
<li><p><strong>插件进程</strong></p>
</li>
</ul>
<h2 id="从输入URL到页面展示，这中间发生了什么"><a href="#从输入URL到页面展示，这中间发生了什么" class="headerlink" title="从输入URL到页面展示，这中间发生了什么"></a>从输入URL到页面展示，这中间发生了什么</h2><p><img src="/_posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/image-20210714180345180.png" alt="image-20210714180345180"></p>
<p>从图中可以看出，<strong>整个过程需要各个进程之间的配合</strong>，首先介绍一下各进程的主要职责</p>
<ul>
<li><p>浏览器进程主要负责用户交互、子进程管理和文件储存等功能。</p>
</li>
<li><p>网络进程是面向渲染进程和浏览器进程等提供网络下载功能。</p>
</li>
<li><p>渲染进程的主要职责是把从网络下载的 HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。</p>
</li>
</ul>
<h3 id="渲染流程之前的流程"><a href="#渲染流程之前的流程" class="headerlink" title="渲染流程之前的流程"></a>渲染流程之前的流程</h3><p> 这个过程可以大致描述为如下。</p>
<ul>
<li><p>首先，浏览器进程接收到用户输入的 URL 请求，浏览器进程便将该 URL 转发给网络进程。然后，在网络进程中发起真正的 URL 请求。</p>
</li>
<li><p>接着网络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程。</p>
</li>
<li><p>浏览器进程接收到网络进程的响应头数据之后，发送“提交导航 (CommitNavigation)”消息到渲染进程；</p>
</li>
<li><p>渲染进程接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立数据管道；</p>
</li>
<li><p>最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程：“已经准备好接受和解析页面数据了”。</p>
</li>
<li><p>浏览器进程接收到渲染进程“提交文档”的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态。</p>
</li>
</ul>
<h3 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h3><p>美团文章的图</p>
<p><img src="/_posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/1671b9d4d735398e~tplv-t2oaga2asx-watermark-20220303151906096.gif" alt="img"></p>
<p> 按照渲染的时间顺序，流水线可分为如下几个子阶段：</p>
<h4 id="构建-DOM-树"><a href="#构建-DOM-树" class="headerlink" title="构建 DOM 树"></a>构建 DOM 树</h4><p><img src="/_posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/image-20210715143236150.png" alt="image-20210715143236150"></p>
<p> 构建 DOM 树的<strong>输入内容</strong>是一个非常简单的 HTML 文件，然后经由HTML 解析器解析，最终输出树状结构的 DOM</p>
<h4 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h4><p> 样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成：</p>
<ol>
<li><p>把CSS转换为浏览器能够理解的结构</p>
<blockquote>
<p>和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以<strong>当渲染引擎接</strong></p>
<p><strong>收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——</strong></p>
<p><strong>styleSheets</strong>。</p>
</blockquote>
</li>
<li><p>转换样式表中的属性值，使其标准化</p>
<p><img src="/_posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/image-20210715143850698.png" alt="image-20210715143850698"></p>
<blockquote>
<p><strong>需要将所有值转换为渲染引擎容易理解的、标准化的计算值</strong></p>
</blockquote>
</li>
<li><p>计算出 DOM 树中每个节点的具体样式</p>
</li>
</ol>
<h4 id="布局阶段"><a href="#布局阶段" class="headerlink" title="布局阶段"></a>布局阶段</h4><p> 我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。<strong>那么接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局</strong>。</p>
<p>​    Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。</p>
<h5 id="创建布局树"><a href="#创建布局树" class="headerlink" title="创建布局树"></a>创建布局树</h5><p> 在显示之前，我们还要额外地构建一棵只包含可见元素布局树。</p>
<p><img src="/_posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/image-20210715165934972.png" alt="image-20210715165934972"></p>
<h5 id="布局计算"><a href="#布局计算" class="headerlink" title="布局计算"></a>布局计算</h5><p> <strong>在执行布局操作的时候，会把布局运算的结果重新写回布局树中</strong>，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方</p>
<blockquote>
<p>所以在调试台中 经常看到layout之后 在再次update layer tree</p>
<p><img src="/_posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/image-20211223095237296.png" alt="image-20211223095237296"></p>
</blockquote>
<h4 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h4><p> 渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的<strong>图层树（LayerTree）</strong></p>
<p><img src="/_posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/image-20210715170447195.png" alt="image-20210715170447195"></p>
<p> 那么需要满足什么条件，渲染引擎才会为特定的节点创建新的层呢？</p>
<ul>
<li><p>拥有<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context">层叠上下文</a>属性的元素会被提升为单独的一层</p>
</li>
<li><p>需要剪裁（clip）的地方也会被创建为图层</p>
<blockquote>
<p>层叠上下文在css中也是一个很重要的概念，在blog中也有一些相关文章</p>
</blockquote>
</li>
</ul>
<h4 id="图层绘制"><a href="#图层绘制" class="headerlink" title="图层绘制"></a>图层绘制</h4><h5 id="分析出绘制列表"><a href="#分析出绘制列表" class="headerlink" title="分析出绘制列表"></a>分析出绘制列表</h5><p> 在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制。渲染引擎会把一个图层的绘制拆分成很多小的<strong>绘制指令</strong>，然后再把这些指令按照顺序组成一个待绘制列表，如下图所示：</p>
<p><img src="/_posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/image-20210715172527999.png" alt="image-20210715172527TCP协议的特点999"></p>
<p> 绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的<strong>合成线程</strong>来完成的。当图层的绘制列表准备好之后，主线程会把该绘制列表<strong>提交（commit）</strong>给合成线程</p>
<h5 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h5><p> 通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做<strong>视口</strong>（viewport）。通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。</p>
<p> 基于这个原因，<strong>合成线程会将图层划分为图块（tile）</strong>，这些图块的大小通常是 <strong>256x256</strong> 或者 <strong>512x512</strong></p>
<h5 id="光栅化raster"><a href="#光栅化raster" class="headerlink" title="光栅化raster"></a>光栅化raster</h5><p> 合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓<strong>栅格化，是指将图块转换为位图</strong>。</p>
<p> 而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的</p>
<p><img src="/_posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/image-20210715173725392.png" alt="image-20210715173725392"></p>
<h5 id="合成和显示"><a href="#合成和显示" class="headerlink" title="合成和显示"></a>合成和显示</h5><p> 一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</p>
<p> 浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p>
<h4 id="渲染流水线大总结"><a href="#渲染流水线大总结" class="headerlink" title="渲染流水线大总结"></a>渲染流水线大总结</h4><p><img src="/_posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/image-20210715173820255.png" alt="image-20210715173820255"></p>
<p>结合上图，一个完整的渲染流程大致可总结为如下：</p>
<ul>
<li>渲染进程将 HTML 内容转换为能够读懂的<strong>DOM 树</strong>结构。</li>
<li>渲染引擎将 CSS 样式表转化为浏览器可以理解的<strong>styleSheets</strong>，计算出 DOM 节点的样式。</li>
<li>创建<strong>布局树</strong>，并计算元素的布局信息。</li>
<li>计算结果<strong>重新写入布局树</strong>（我觉得这一步挺重要）</li>
<li>对布局树进行分层，并生成<strong>分层树</strong>。</li>
<li>为每个图层生成<strong>绘制列表</strong>，并将其提交到合成线程。</li>
<li>合成线程将图层分成<strong>图块</strong>，并在<strong>光栅化线程池</strong>中将图块转换成位图。</li>
<li>合成线程发送绘制图块命令<strong>DrawQuad</strong>给浏览器进程。</li>
<li>浏览器进程根据 DrawQuad 消息<strong>生成页面</strong>，并<strong>显示</strong>到显示器上。</li>
</ul>
<h3 id="css和js对dom解析渲染的影响"><a href="#css和js对dom解析渲染的影响" class="headerlink" title="css和js对dom解析渲染的影响"></a>css和js对dom解析渲染的影响</h3><p>直接说结论</p>
<ul>
<li><p>css不会阻塞DOM的解析(<strong>document中已存在，只是没有渲染在屏幕上</strong>)，但会阻塞其渲染</p>
<blockquote>
<p>样式树 和 dom树 共同决定渲染树，两者可以并行解析，但是dom树必须等样式树解析后才可以合成</p>
</blockquote>
</li>
<li><p>css会阻塞后面JS的的执行</p>
<blockquote>
<p>因为js有修改cssom的能力</p>
</blockquote>
</li>
<li><p>JS会阻塞DOM解析和渲染</p>
<blockquote>
<p>js有修改dom的能力</p>
</blockquote>
</li>
</ul>
<h3 id="减少白屏时间"><a href="#减少白屏时间" class="headerlink" title="减少白屏时间"></a>减少白屏时间</h3><p> 如果白屏时间过久，就会影响到用户体验。</p>
<p> 为了缩短白屏时间，我们来挨个分析这个阶段的主要任务，包括了<strong>解析 HTML、下载 CSS、下载 JavaScript、生成 CSSOM、执行 JavaScript、生成布局树、绘制页面</strong>一系列操作。</p>
<p> 通常情况下的瓶颈主要体现在<strong>下载 CSS 文件、下载 JavaScript 文件和执行 JavaScript</strong>。</p>
<p> 所以要想缩短白屏时长，可以有以下策略：</p>
<ul>
<li>通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。</li>
<li>但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。</li>
<li>还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 async 或者 defer。</li>
<li>对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。</li>
<li>骨架屏和loading css</li>
</ul>
<h3 id="回流、重绘、合成"><a href="#回流、重绘、合成" class="headerlink" title="回流、重绘、合成"></a>回流、重绘、合成</h3><p>需要补充</p>
<p><a href="https://juejin.cn/post/6844904083212468238#heading-12">回流重绘</a></p>
<h2 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h2><p>浏览器安全可以分为三大块——<strong>Web 页面安全、浏览器网络安全</strong>和<strong>浏览器系统安全</strong></p>
<h3 id="web页面安全"><a href="#web页面安全" class="headerlink" title="web页面安全"></a>web页面安全</h3><p>在没有安全保障的 Web 世界中，我们是没有隐私的，因此需要安全策略来保障我们的隐私和数据的安全。</p>
<h4 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h4><p>在页面中最基础、最核心的安全策略：**<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">同源策略</a>（Same-origin policy），<strong>如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源，两个不同的源之间若想要</strong>相互访问资源或者操作 DOM**，那么会有一套基础的安全策略的制约，我们把这称为同源策略。</p>
<p>下表给出了与 URL <code>http://store.company.com/dir/page.html</code> 的源进行对比的示例:</p>
<p><img src="/_posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/image-20210805172753684.png" alt="image-20210805172753684"></p>
<p>具体来讲，同源策略主要表现在 DOM、Web 数据和网络这三个层面：</p>
<ul>
<li><p><strong>DOM 层面</strong>。同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。</p>
</li>
<li><p><strong>数据层面</strong>。同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据</p>
</li>
<li><p><strong>网络层面</strong>。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点</p>
</li>
</ul>
<h4 id="安全和便利性的权衡"><a href="#安全和便利性的权衡" class="headerlink" title="安全和便利性的权衡"></a><strong>安全和便利性的权衡</strong></h4><p> 安全性和便利性是相互对立的，让不同的源之间绝对隔离，无疑是最安全的措施，但这也会使得 Web 项目难以开发和使用，因此浏览器就要在这之间做出权衡，出让一些安全性来满足灵活性：</p>
<ul>
<li><strong>页面中可以嵌入第三方资源</strong></li>
<li><strong>跨域资源共享和跨文档消息机制</strong><ul>
<li><strong>跨域资源共享（CORS）</strong></li>
<li><strong>跨文档消息机制</strong> <strong>postMessage</strong></li>
</ul>
</li>
</ul>
<h4 id="xss-csrf"><a href="#xss-csrf" class="headerlink" title="xss csrf"></a>xss csrf</h4><p>在前端安全中有详细介绍</p>
<p><a href="/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8">前端安全</a></p>
]]></content>
      <categories>
        <category>浏览器原理</category>
      </categories>
      <tags>
        <tag>chrome架构</tag>
        <tag>从输入URL到页面展示，这中间发生了什么</tag>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>解题思路或方法</title>
    <url>/%E7%AE%97%E6%B3%95/%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="统计数组或字符串重复数字数量的时候使用哈希表"><a href="#统计数组或字符串重复数字数量的时候使用哈希表" class="headerlink" title="统计数组或字符串重复数字数量的时候使用哈希表"></a>统计数组或字符串重复数字数量的时候使用哈希表</h2><ul>
<li>这种方法性能好，而且容易理解，且不易出错</li>
<li>不能用来统计<strong>连续出现</strong>的次数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 相同牌出现次数Map</span><br><span class="line">let timeMap = new Map();</span><br><span class="line"></span><br><span class="line">// 遍历牌</span><br><span class="line">deck.forEach(num =&gt; &#123;</span><br><span class="line">    // 统计每张牌出现的次数</span><br><span class="line">    timeMap.set(num, timeMap.has(num) ? timeMap.get(num) + 1 : 1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Map.prototype.values()返回的是一个新的Iterator对象，所以可以使用扩展运算符(...)来构造成数组</span><br><span class="line">let timeAry = [...timeMap.values()];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>相关题目 卡片分组 leetcode 914</p>
</blockquote>
<ul>
<li>计算<strong>连续出现</strong>次数的方法（自己写的，很垃圾，看见好的会更新）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;1122233334444&quot;</span><br><span class="line">var arr = s.split(&quot;&quot;);</span><br><span class="line">var arrSame = [];</span><br><span class="line">var length = 1</span><br><span class="line">for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">  if(arr[i]!==arr[i+1]||(!arr[i+1]))&#123;</span><br><span class="line">    arrSame.push(length)</span><br><span class="line">    length = 1</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    length++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>相关题目 计数二进制子串 leetcode 696</p>
</blockquote>
<h2 id="辗转相除法-欧几里得算法"><a href="#辗转相除法-欧几里得算法" class="headerlink" title="辗转相除法 欧几里得算法"></a>辗转相除法 欧几里得算法</h2><p>1997 &#x2F; 615 &#x3D; 3 (余 152)<br>615 &#x2F; 152 &#x3D; 4(余7)<br>152 &#x2F; 7 &#x3D; 21(余5)<br>7 &#x2F; 5 &#x3D; 1 (余2)<br>5 &#x2F; 2 &#x3D; 2 (余1)<br>2 &#x2F; 1 &#x3D; 2 (余0)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function ojld(chushu, yushu) &#123;</span><br><span class="line">  if(chushu % yushu === 0)&#123;</span><br><span class="line">    return yushu</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    return ojld(yushu, chushu % yushu)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单调栈的讲解与应用"><a href="#单调栈的讲解与应用" class="headerlink" title="单调栈的讲解与应用"></a>单调栈的讲解与应用</h2>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>git 简记</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/git/</url>
    <content><![CDATA[<p>git 简记，主要参考掘金小册和以前的视频笔记，构建一个简单的记忆结构</p>
<h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><ul>
<li>提交所有被删除和修改的文件到数据暂存区</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add -u 或 git add –update</span><br></pre></td></tr></table></figure>

<ul>
<li>提交所有修改的和新建的到数据暂存区</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<ul>
<li>提交所有被删除、被替换、被修改和新增的文件到数据暂存区</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add -A 或 git add –all</span><br></pre></td></tr></table></figure>

<h3 id="撤销-add"><a href="#撤销-add" class="headerlink" title="撤销 add"></a>撤销 add</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 恢复暂存区的所有文件到工作区 =&gt; vscode git工具中的 取消暂存所有更改</span><br><span class="line"></span><br><span class="line">$ git reset HEAD 如果后面什么都不跟的话 就是上一次add 里面的全部撤销了 相当于git restore -staged .</span><br><span class="line"></span><br><span class="line">$ git reset HEAD XXX/XXX/XXX.php 就是对某个php文件进行撤销了</span><br></pre></td></tr></table></figure>

<h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><p>将暂存区内容添加到仓库中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;一些描述&#x27;</span><br></pre></td></tr></table></figure>

<p>再简单提一些常见场景， 比如说<code>commit</code>完之后，突然发现一些错别字需要修改，又不想为改几个错别字而新开一个<code>commit</code>到<code>history</code>区，那么就可以使用下面这个命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>

<p>这样就是把错别字的修改和之前的那个<code>commit</code>中的修改合并 并覆盖上次的commit。</p>
<h3 id="撤销-修改-commit"><a href="#撤销-修改-commit" class="headerlink" title="撤销 修改 commit"></a>撤销 修改 commit</h3><h4 id="丢弃上次的提交"><a href="#丢弃上次的提交" class="headerlink" title="丢弃上次的提交"></a>丢弃上次的提交</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset HEAD^</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：在 Git 中，有两个「偏移符号」： <code>^</code> 和 <code>~</code>。</p>
<p><code>^</code> 的用法：在 <code>commit</code> 的后面加一个或多个 <code>^</code> 号，可以把 <code>commit</code> 往回偏移，偏移的数量是 <code>^</code> 的数量。例如：<code>master^</code> 表示 <code>master</code> 指向的 <code>commit</code> 之前的那个 <code>commit</code>； <code>HEAD^^</code> 表示 <code>HEAD</code> 所指向的 <code>commit</code> 往前数两个 <code>commit</code>。</p>
<p><code>~</code> 的用法：在 <code>commit</code> 的后面加上 <code>~</code> 号和一个数，可以把 <code>commit</code> 往回偏移，偏移的数量是 <code>~</code> 号后面的数。例如：<code>HEAD~5</code> 表示 <code>HEAD</code> 指向的 <code>commit</code>往前数 5 个 <code>commit</code>。</p>
</blockquote>
<h4 id="如果已经推送到远端"><a href="#如果已经推送到远端" class="headerlink" title="如果已经推送到远端"></a>如果已经推送到远端</h4><ul>
<li><p>1 确定无风险可以执行，git push -f 可以强制推送，无视冲突，远端的那次commit也会消失</p>
</li>
<li><p>2 安全操作，你希望撤销哪个 <code>commit</code>，就把它填在后面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git revert HEAD^</span><br></pre></td></tr></table></figure>

<p>上面这行代码就会增加一条新的 <code>commit</code>，它的内容和倒数第二个 <code>commit</code> 是相反的，从而和<strong>倒数第二个</strong> <code>commit</code> 相互抵消，达到撤销的效果。</p>
<p>在 <code>revert</code> 完成之后，把新的 <code>commit</code> 再 <code>push</code> 上去，这个 <code>commit</code> 的内容就被撤销了。它和前面所介绍的撤销方式相比，最主要的区别是，这次改动只是被「反转」了，并没有在历史中消失掉，你的历史中会存在两条 <code>commit</code> ：一个原始 <code>commit</code> ，一个对它的反转 <code>commit</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git revert HEAD                撤销最新一次 commit</span><br><span class="line">git revert HEAD^               撤销前一次 commit</span><br><span class="line">git revert commitid            撤销指定commitid的commit </span><br></pre></td></tr></table></figure>
</li>
<li><p>撤销commit，同时将代码恢复到对应ID的版本(中间的commit都没了)</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard commitId</span><br></pre></td></tr></table></figure>

<p><strong>reset后接参数</strong></p>
<ol>
<li>–hard：重置位置的同时，清空工作目录和暂存区的所有内容；</li>
<li>–soft：重置位置的同时，保留工作目录和暂存区的内容，并把重置 HEAD 的位置所导致的新的文件差异放进暂存区。</li>
<li>–mixed（默认）：重置位置的同时，保留工作目录的内容，把暂存区和重置 HEAD 的位置所导致的新的文件差异都放入工作目录</li>
</ol>
<h4 id="修改前几次的commit-不新增commit"><a href="#修改前几次的commit-不新增commit" class="headerlink" title="修改前几次的commit 不新增commit"></a>修改前几次的commit 不新增commit</h4><p>详见#rebase章节</p>
<h3 id="restore-撤销"><a href="#restore-撤销" class="headerlink" title="restore 撤销"></a>restore 撤销</h3><p><code>git restore --staged &lt;file&gt;...</code>  撤销add，将暂存区的文件从暂存区撤出，但不会更改文件的内容</p>
<p><code>git restore &lt;file&gt;...</code> 撤销工作区改动，已经在暂存区的改动不会撤销 相当于 <code>git checkout -- filepathname</code></p>
<h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><p>实质上，<code>push</code> 做的事是：<strong>把当前 <code>branch</code> 的位置（即它指向哪个 <code>commit</code>）上传到远端仓库，并把它的路径上的 <code>commit</code>s 一并上传</strong>。</p>
<p>也就是每次仅上传当前的分支上的commit</p>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><h4 id="创建一个分支"><a href="#创建一个分支" class="headerlink" title="创建一个分支"></a>创建一个分支</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch feature1</span><br></pre></td></tr></table></figure>

<h4 id="切换到分支"><a href="#切换到分支" class="headerlink" title="切换到分支"></a>切换到分支</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout feature1</span><br></pre></td></tr></table></figure>

<h4 id="切换分支-如果不存在就创建一个分支"><a href="#切换分支-如果不存在就创建一个分支" class="headerlink" title="切换分支 如果不存在就创建一个分支"></a>切换分支 如果不存在就创建一个分支</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b feature1</span><br></pre></td></tr></table></figure>

<h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -d feature1 </span><br></pre></td></tr></table></figure>

<blockquote>
<p>没有合并到master，删除会失败，强行删除 -d 换成 -D</p>
</blockquote>
<h4 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch 列出本地已经存在的分支,并且当前分支会用*标记</span><br><span class="line">git branch -r 查看远程版本库的分支列表</span><br></pre></td></tr></table></figure>

<h4 id="推送远端不存在的分支"><a href="#推送远端不存在的分支" class="headerlink" title="推送远端不存在的分支"></a>推送远端不存在的分支</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout feature1</span><br><span class="line">去推送本地分支到远程分支 的同时，为他俩建立联系(默认联系)</span><br><span class="line">以后push这个分支 默认就推送到现在建立联系的远端分支上</span><br><span class="line">git push --set-upstream origin feature1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 Git 中（2.0 及它之后的版本），默认情况下，你用不加参数的 <code>git push</code> 只能上传那些之前从远端 <code>clone</code> 下来或者 <code>pull</code> 下来的分支，而如果需要 <code>push</code> 你本地的自己创建的分支，则需要手动指定目标仓库和目标分支（并且目标分支的名称必须和本地分支完全相同），就像上面这样</p>
</blockquote>
<h4 id="删除远端仓库的分支"><a href="#删除远端仓库的分支" class="headerlink" title="删除远端仓库的分支"></a>删除远端仓库的分支</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin -d feature1 # 用 -d 参数把远程仓库的 branch 也删了</span><br></pre></td></tr></table></figure>

<h4 id="找回被删除的分支"><a href="#找回被删除的分支" class="headerlink" title="找回被删除的分支"></a>找回被删除的分支</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reflog 查看删除分支前的commit </span><br></pre></td></tr></table></figure>

<p><img src="/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/assets/git/15fe3de05468c613~tplv-t2oaga2asx-watermark.gif" alt="img"></p>
<p>从图中可以看出，<code>HEAD</code> 的最后一次移动行为是「从 <code>branch1</code> 移动到 <code>master</code>」。而在这之后，<code>branch1</code> 就被删除了。所以它之前的那个 <code>commit</code> 就是 <code>branch1</code> 被删除之前的位置了，也就是第二行的 <code>c08de9a</code>。</p>
<p>所以现在就可以切换回 <code>c08de9a</code>，然后重新创建 <code>branch1</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout c08de9a</span><br><span class="line">git checkout -b branch1</span><br></pre></td></tr></table></figure>

<p>这样，你刚删除的 <code>branch1</code> 就找回来了。</p>
<h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h4><p>两种方式，一种利用merge，一种利用rebase</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge branch</span><br></pre></td></tr></table></figure>

<p><img src="/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/assets/git/15fdea7b6646a1f3~tplv-t2oaga2asx-watermark.gif" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 git checkout branch1</span><br><span class="line">2 git rebase master</span><br><span class="line">在 rebase 之后，记得切回 master 再 merge 一下，把 master 移到最新的 commit</span><br><span class="line">3 git checkout master</span><br><span class="line">4 git merge(rebase) branch1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/assets/git/1600abd620a8e28c~tplv-t2oaga2asx-watermark.gif" alt="img"></p>
<p><img src="/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/assets/git/160149e054fe485c~tplv-t2oaga2asx-watermark.gif" alt="img"></p>
<h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p><code>merge</code> 的意思是「合并」，它做的事也是合并：指定一个 <code>commit</code>，把它合并到当前的 <code>commit</code> 来。具体来讲，<code>merge</code> 做的事是：</p>
<p><strong>从目标 <code>commit</code> 和当前 <code>commit</code> （即 <code>HEAD</code> 所指向的 <code>commit</code>）分叉的位置起，把目标 <code>commit</code> 的路径上的所有 <code>commit</code> 的内容一并应用到当前 <code>commit</code>，然后自动生成一个新的 <code>commit</code>。</strong></p>
<p>merge有时产生冲突:</p>
<ul>
<li>git pull时，远端仓库包含本地没有的 <code>commit</code>，而且本地仓库也包含远端没有的 <code>commit</code> 时</li>
<li><code>git pull = git fetch + git merge origin/HEAD</code></li>
<li>git merge 合并的时候，文件有冲突</li>
</ul>
<p>处于冲突解决状态时</p>
<p> 解决冲突，解决完冲突后进行commit时，会自动填入commit信息”这是一个merge信息”</p>
<p> 放弃解决  <code>git merge --abort</code>输入这行代码，你的 Git 仓库就会回到 <code>merge</code> 前的状态</p>
<h3 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h3><p><code>git checkout</code>命令用于切换分支或恢复工作树文件，也可以指定HEAD指针的位置。</p>
<p><code>checkout</code> 本质上的功能其实是：签出（ checkout ）指定的 <code>commit</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">此命令用来放弃掉所有还没有加入到缓存区（就是 git add 命令）的修改</span><br><span class="line"></span><br><span class="line"># 放弃单个文件修改,注意不要忘记中间的&quot;--&quot;,不写就成了检出分支了!</span><br><span class="line">git checkout -- filepathname</span><br><span class="line"></span><br><span class="line"># 放弃所有的文件修改</span><br><span class="line">git checkout . </span><br><span class="line"></span><br><span class="line"># 切换到分支</span><br><span class="line"></span><br><span class="line">git checkout feature1</span><br><span class="line"></span><br><span class="line"># 切换分支 如果不存在就创建一个分支</span><br><span class="line"></span><br><span class="line">git checkout -b feature1</span><br><span class="line"></span><br><span class="line"># 签出commit</span><br></pre></td></tr></table></figure>

<p>首先介绍一下<code>HEAD</code>，可以把HEAD理解成一个指针，HEAD指针通常会指向一个分支，如下图所示</p>
<p><img src="/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/assets/git/image-20210427143641740.png" alt="e&#39;m"></p>
<p>HEAD–&gt;master–&gt;commitID，通常情况下，HEAD会一直跟随着当前分支，并指向分支，而分支则指向当前最新的commit</p>
<p>还有一种 <code>detached HEAD</code>的状态，使用<code>git checkout C3</code>即可以把HEAD指针指向C3</p>
<blockquote>
<p>经过我的测试，在工作区和暂存区有改动的情况下，无法进行git checkout commitID or branch</p>
<p><img src="/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/assets/git/image-20220106112249119.png" alt="image-20220106112249119"></p>
</blockquote>
<blockquote>
<p>还有一种相对引用的方式，<code>git checkout main^</code>*3 或者  <code>git checkout main^^^</code> 或者 <code>git checkout main~3</code>  或者使用 <code>git checkout HEAD^^^</code>,这几种方法都是向父节点方向移动</p>
</blockquote>
<p><img src="/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/assets/git/image-20210427144448741.png" alt="image-20210427144448741"></p>
<p>如果此时进行commit，git的返回信息会提示我们，You are in ‘detached HEAD’ state.（你现在处于’分离头’状态）。然后会从C3节点出现一个新的节点，HEAD会指向新的节点，可以简单的理解为匿名分支（图和上边不一样，仅做示意）</p>
<p><img src="/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/assets/git/image-20210427145825615.png" alt="image-20210427145825615"></p>
<p>我们现在有两个选择，如下：</p>
<ul>
<li><p>丢弃这个匿名分支</p>
<ul>
<li>直接检出到任何一个别的分支，就相当于放弃了这些提交</li>
</ul>
</li>
<li><p>保留这个匿名分支</p>
<ul>
<li>创建一个名为newtest的分支来保存这些提交<ul>
<li><code>git branch newtest c7</code>  这种方式HEAD并未指向newtest，而是指向了C7，仍是指针分离状态</li>
<li><code>git checkout -b newtest</code>   HEAD指向了newtest，newtest指向了C7</li>
</ul>
</li>
</ul>
</li>
<li><p>与现存分支合并，参考分支命令章节</p>
</li>
</ul>
<h3 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h3><ul>
<li><p><code>git stash save &quot;save message&quot;</code> : 执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。</p>
<ul>
<li>增加参数可以存储没有追踪的文件  <code>git stash save -u</code>   &#x3D;&#x3D;&#x3D;  <code>git stash save --include-untracked</code></li>
</ul>
</li>
<li><p><code>git stash list</code> ：查看stash了哪些存储</p>
</li>
<li><p><code>git stash show</code> ：显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@{$num}，比如第二个 git stash show stash@{1}</p>
</li>
<li><p><code>git stash show -p</code> : 显示第一个存储的改动，如果想显示其他存存储，命令：git stash show stash@{$num} -p ，比如第二个：git stash show stash@{1} -p</p>
</li>
<li><p><code>git stash apply</code>:应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@{0}，如果要使用其他个，git s tash apply stash@{$num} ， 比如第二个：git stash apply stash@{1}</p>
</li>
<li><p><code>git stash pop</code> ：命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@{0}，如果要应用并删除其他stash，命令：git stash pop stash@{$num} ，比如应用并删除第二个：git stash pop stash@{1}</p>
</li>
<li><p><code>git stash drop stash@&#123;$num&#125;</code>：丢弃stash@{$num}存储，从列表中删除这个存储192.168.1.110</p>
</li>
<li><p><code>git stash clear</code>：删除所有缓存的stash</p>
</li>
</ul>
<h3 id="查看改动"><a href="#查看改动" class="headerlink" title="查看改动"></a>查看改动</h3><p>查看改动内容的方法，大致有这么几类：</p>
<ol>
<li><p>查看历史中的多个commit：log</p>
<ol>
<li>查看详细改动： <code>git log -p</code></li>
<li>查看大致改动：<code>git log --stat</code></li>
</ol>
</li>
<li><p>查看具体某个commit：show</p>
<ol>
<li>要看最新 <code>commit</code> ，直接输入 <code>git show</code> ；要看指定 <code>commit</code> ，输入 <code>git show commit的引用或SHA-1</code></li>
<li>如果还要指定文件，在 <code>git show</code> 的最后加上文件名</li>
</ol>
</li>
<li><p>查看未提交的内容：diff</p>
<ol>
<li><p>查看暂存区和上一条 <code>commit</code> 的区别：<code>git diff --staged</code>（或 <code>--cached</code>）也就是暂存区 tobe commit的内容</p>
</li>
<li><p>查看工作目录和暂存区的区别：<code>git diff</code> 不加选项参数</p>
</li>
<li><p>查看工作目录和上一条 <code>commit</code> 的区别：<code>git diff HEAD(commitID)</code> <strong>vscode默认展示的</strong>,也就是工作目录和暂存区所有的改动相较于最新commit的区别</p>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>git reflog  查看<strong>本地所有</strong>的所有操作记录（包括分支、包括已经被删除的 commit 记录和 reset 的操作）,适合找回</p>
</blockquote>
<h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><p>git rebase 可以理解为嫁接、编辑（包括删除）commit链条，可以完成很多功能，包括但不限于合并分支、编辑任意数量commit节点、删除任意数量的commit节点、插入任意数量的节点</p>
<h4 id="git-rebase-commitID-branch"><a href="#git-rebase-commitID-branch" class="headerlink" title="git rebase commitID || branch"></a>git rebase commitID || branch</h4><blockquote>
<p>没有commit分叉点的话，除了快速移动外应该没有作用</p>
</blockquote>
<p>见合并分支一节，如果是commitID的话，效果如下图所示</p>
<p><img src="/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/assets/git/15fe24400508e3c8~tplv-t2oaga2asx-watermark.gif" alt="img"></p>
<p>如果在这里执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase 第3个commit</span><br></pre></td></tr></table></figure>

<p>那么 Git 会自动选取 <code>3</code> 和 <code>5</code> 的历史交叉点 <code>2</code> 作为 <code>rebase</code> 的起点，依次将 <code>4</code> 和 <code>5</code> 重新提交到 <code>3</code> 的路径上去。</p>
<h4 id="git-rebase-i"><a href="#git-rebase-i" class="headerlink" title="git rebase -i"></a>git rebase -i</h4><p><code>git rebase -i HEAD^^</code></p>
<p>可以编辑（ 倒数第三个commit, HEAD ] 之间的commit ，按下 i 进行编辑模式，操作命令写的很清楚，一般会用到edit和drop</p>
<p>如果使用了edit，会是HEAD进入游离状态，并指向edit对应的commit</p>
<p>这个时候可以进行各种操作，比如修改工作区并新增一个commit或者直接使用 <code>git commit -amend</code> 来修改这条commit message</p>
<p>操作完成后 使用 <code>git rebase --continue</code> 结束回归正常</p>
<p>也可以放弃 <code>rebase</code> <code>git rebase --abort</code></p>
<blockquote>
<p>建议熟练后在进行骚操作</p>
</blockquote>
<p><img src="/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/assets/git/image-20220106215219131.png" alt="image-20220106215219131"></p>
<h4 id="Git-rebase-–onto"><a href="#Git-rebase-–onto" class="headerlink" title="Git rebase –onto"></a>Git rebase –onto</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase --onto 目标commit 起点commit(不包括起点) 终点commit</span><br></pre></td></tr></table></figure>

<p><code>--onto</code> 参数后面有三个附加参数：目标 <code>commit</code>、起点 <code>commit</code>（注意：rebase 的时候会把起点排除在外）、终点 <code>commit</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase --onto 第3个commit 第4个commit branch1</span><br></pre></td></tr></table></figure>

<p><img src="/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/assets/git/15fe24400d7d73d0~tplv-t2oaga2asx-watermark.gif" alt="img"></p>
<p>同样的，你也可以用 <code>rebase --onto</code> 来撤销提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase --onto HEAD^^ HEAD^ branch1</span><br></pre></td></tr></table></figure>

<p>上面这行代码的意思是：以倒数第二个 <code>commit</code> 为起点（起点不包含在 <code>rebase</code> 序列里哟），<code>branch1</code> 为终点，<code>rebase</code> 到倒数第三个 <code>commit</code> 上。</p>
<p>也就是这样：</p>
<p><img src="/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/assets/git/15fe243fce5804fd~tplv-t2oaga2asx-watermark.gif" alt="img"></p>
<h3 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h3><p>实质上，<code>reset</code> 这个指令虽然可以用来撤销 <code>commit</code> ，但它的实质行为并不是撤销，而是移动 <code>HEAD</code> ，并且「捎带」上 <code>HEAD</code> 所指向的 <code>branch</code>（如果有的话）。</p>
<p>reset后接参数</p>
<ol>
<li>–hard：重置位置的同时，清空工作目录和暂存区的所有内容；</li>
<li>–soft：重置位置的同时，保留工作目录和暂存区的内容，并把重置 HEAD 的位置所导致的新的文件差异放进暂存区。</li>
<li>–mixed（默认）：重置位置的同时，保留工作目录的内容，把暂存区和重置 HEAD 的位置所导致的新的文件差异都放入工作目录</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard C3</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Git 的历史只能往回看，不能向未来看，所以把 <code>HEAD</code> 和 <code>branch</code> 往回移动，就能起到撤回 <code>commit</code> 的效果。</p>
<p>在relog里可以回溯哦，前提在git没回收commit节点之前</p>
</blockquote>
<p><img src="/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/assets/git/15fe19c8a3235853~tplv-t2oaga2asx-watermark.gif" alt="img"></p>
<p>所以同理，<code>reset --hard</code> 不仅可以撤销提交，还可以用来把 <code>HEAD</code> 和 <code>branch</code> 移动到其他的任何地方。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard branch2</span><br></pre></td></tr></table></figure>

<p><img src="/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/assets/git/15fe333cb605b0de~tplv-t2oaga2asx-watermark.gif" alt="img"></p>
<h3 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h3><h4 id="git打tag"><a href="#git打tag" class="headerlink" title="git打tag"></a>git打tag</h4><p>通常在发布软件的时候打一个tag，tag会记录版本的commit号，方便后期回溯。</p>
<h4 id="列出已有的tag"><a href="#列出已有的tag" class="headerlink" title="列出已有的tag"></a>列出已有的tag</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure>

<p>加上<code>-l</code>命令可以使用通配符来过滤<code>tag</code></p>
<p><img src="/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/assets/git/webp" alt="img"></p>
<h4 id="新建tag"><a href="#新建tag" class="headerlink" title="新建tag"></a>新建tag</h4><p>使用<code>git tag</code>命令跟上tag名字，直接创建一个tag。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag v1.0</span><br></pre></td></tr></table></figure>

<p>上面创建一个名为<code>v1.0</code>的tag。使用<code>git tag</code>命令可以看到新增加的tag。</p>
<p>还可以加上<code>-a</code>参数来创建一个带备注的tag，备注信息由<code>-m</code>指定。如果你未传入<code>-m</code>则创建过程系统会自动为你打开编辑器让你填写备注信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag -a tagName -m &quot;my tag&quot;</span><br></pre></td></tr></table></figure>

<h4 id="查看tag详细信息"><a href="#查看tag详细信息" class="headerlink" title="查看tag详细信息"></a>查看tag详细信息</h4><p><code>git show</code>命令可以查看tag的详细信息，包括commit号等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git show tagName</span><br></pre></td></tr></table></figure>

<p><img src="/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/assets/git/image-20220107114423786.png" alt="image-20220107114423786"></p>
<p>tag最重要的是有git commit号，后期我们可以根据这个commit号来回溯代码。</p>
<h4 id="给指定的某个commit号加tag"><a href="#给指定的某个commit号加tag" class="headerlink" title="给指定的某个commit号加tag"></a>给指定的某个commit号加tag</h4><p>打tag不必要在head之上，也可在之前的版本上打，这需要你知道某个提交对象的校验和（通过git log获取，取校验和的前几位数字即可）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag -a v1.2 9fceb02 -m &quot;my tag&quot;</span><br></pre></td></tr></table></figure>

<h4 id="将tag同步到远程服务器"><a href="#将tag同步到远程服务器" class="headerlink" title="将tag同步到远程服务器"></a>将tag同步到远程服务器</h4><p>同提交代码后，使用<code>git push</code>来推送到远程服务器一样，<code>tag</code>也需要进行推送才能到远端服务器。</p>
<h5 id="推送单个分支"><a href="#推送单个分支" class="headerlink" title="推送单个分支"></a>推送单个分支</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin v1.0</span><br></pre></td></tr></table></figure>

<h5 id="推送本地所有tag"><a href="#推送本地所有tag" class="headerlink" title="推送本地所有tag"></a>推送本地所有tag</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure>

<h4 id="切换到某个tag"><a href="#切换到某个tag" class="headerlink" title="切换到某个tag"></a>切换到某个tag</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout tagName</span><br></pre></td></tr></table></figure>

<p>跟分支一样，可以直接切换到某个tag去。这个时候不位于任何分支，处于游离状态，可以考虑基于这个tag创建一个分支。</p>
<h4 id="删除某个tag"><a href="#删除某个tag" class="headerlink" title="删除某个tag"></a>删除某个tag</h4><ul>
<li>本地删除</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag -d v0.1.2 </span><br></pre></td></tr></table></figure>

<ul>
<li>远端删除<br>git push origin :refs&#x2F;tags&#x2F;<tagName></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin :refs/tags/v0.1.2</span><br></pre></td></tr></table></figure>

<h3 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h3><p><a href="http://www.ruanyifeng.com/blog/2020/04/git-cherry-pick.html">详见阮一峰</a></p>
<p><code>git cherry-pick</code>命令的作用，就是将指定的提交（commit）应用于其他分支。</p>
<p>会将指定的提交<code>commitHash</code>，应用于当前分支。这会在当前分支产生一个新的提交，<strong>当然它们的哈希值会不一样</strong>。</p>
<p>举例来说，代码仓库有<code>master</code>和<code>feature</code>两个分支。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a - b - c - d   Master</span><br><span class="line">     \</span><br><span class="line">       e - f - g Feature</span><br></pre></td></tr></table></figure>

<p>现在将提交<code>f</code>应用到<code>master</code>分支。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到 master 分支</span></span><br><span class="line">$ git checkout master</span><br><span class="line"></span><br><span class="line"><span class="comment"># Cherry pick 操作</span></span><br><span class="line">$ git cherry-pick f</span><br></pre></td></tr></table></figure>

<p>上面的操作完成以后，代码库就变成了下面的样子。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a - b - c - d - f   Master</span><br><span class="line">     \</span><br><span class="line">       e - f - g Feature</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，<code>master</code>分支的末尾增加了一个提交<code>f</code>。</p>
<p><code>git cherry-pick</code>命令的参数，不一定是提交的哈希值，分支名也是可以的，表示转移该分支的最新提交。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cherry-pick feature</span><br></pre></td></tr></table></figure>

<p>上面代码表示将<code>feature</code>分支的<strong>最近一次提交</strong>，转移到当前分支。</p>
<p>Cherry pick 支持一次转移多个提交。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git cherry-pick &lt;HashA&gt; &lt;HashB&gt;</span><br></pre></td></tr></table></figure>

<p>上面的命令将 A 和 B 两个提交应用到当前分支。这会在当前分支生成两个对应的新提交。</p>
<p>如果想要转移一系列的连续提交，可以使用下面的简便语法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git cherry-pick A..B </span><br></pre></td></tr></table></figure>

<p>上面的命令可以转移从 A 到 B 的所有提交。它们必须按照正确的顺序放置：提交 A 必须早于提交 B，否则命令将失败，但不会报错。</p>
<p> 一定要注意<strong>不包括节点 A</strong></p>
<h3 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h3><h4 id="查看配置-git-config-l"><a href="#查看配置-git-config-l" class="headerlink" title="查看配置 - git config -l"></a>查看配置 - git config -l</h4><p>使用git config -l 可以查看现在的git环境详细配置</p>
<p>查看不同级别的配置文件：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看系统config</span></span><br><span class="line">git config --system --<span class="keyword">list</span></span><br><span class="line">　　</span><br><span class="line"><span class="comment">#查看当前用户（global）配置</span></span><br><span class="line">git config --<span class="keyword">global</span>  --<span class="keyword">list</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#查看当前仓库配置信息</span></span><br><span class="line">git config --local  --<span class="keyword">list</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="设置用户名与邮箱（用户标识，必要）"><a href="#设置用户名与邮箱（用户标识，必要）" class="headerlink" title="设置用户名与邮箱（用户标识，必要）"></a>设置用户名与邮箱（用户标识，必要）</h4><p>当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">git config --<span class="keyword">global</span> user.name <span class="string">&quot;mazhihong&quot;</span>  <span class="meta">#名称</span></span><br><span class="line">git config --<span class="keyword">global</span> user.email <span class="string">&quot;xxxx@qq.com&quot;</span>   <span class="meta">#邮箱</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="添加配置项"><a href="#添加配置项" class="headerlink" title="添加配置项"></a>添加配置项</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">git config [--local|--<span class="keyword">global</span>|--system]  section.key <span class="keyword">value</span></span><br><span class="line">[--local|--<span class="keyword">global</span>|--system]  <span class="meta">#可选的，对应本地，全局，系统不同级别的设置</span></span><br><span class="line">section.key <span class="meta">#区域下的键</span></span><br><span class="line"><span class="keyword">value</span> <span class="meta">#对应的值</span></span><br></pre></td></tr></table></figure>

<p>–local 项目级<br> –global 当前用户级<br> –system 系统级</p>
<h4 id="删除配置项"><a href="#删除配置项" class="headerlink" title="删除配置项"></a>删除配置项</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config [--<span class="built_in">local</span>|--global|--system] --<span class="built_in">unset</span> section.key</span><br></pre></td></tr></table></figure>

<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><h4 id="checkout-和-reset-的不同"><a href="#checkout-和-reset-的不同" class="headerlink" title="checkout 和 reset 的不同"></a>checkout 和 reset 的不同</h4><p><code>checkout</code> 和 <code>reset</code> 都可以切换 <code>HEAD</code> 的位置，它们除了有许多细节的差异外，最大的区别在于：<code>reset</code> 在移动 <code>HEAD</code> 时会带着它所指向的 <code>branch</code> 一起移动，而 <code>checkout</code> 不会。当你用 <code>checkout</code> 指向其他地方的时候，<code>HEAD</code> 和 它所指向的 <code>branch</code> 就自动脱离了。</p>
<p>事实上，<code>checkout</code> 有一个专门用来只让 <code>HEAD</code> 和 <code>branch</code> 脱离而不移动 <code>HEAD</code> 的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout --detach</span><br></pre></td></tr></table></figure>

<p>执行这行代码，Git 就会把 <code>HEAD</code> 和 <code>branch</code> 脱离，直接指向当前 <code>commit</code>：</p>
<p><img src="/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/assets/git/1600acce7b90b009~tplv-t2oaga2asx-watermark.gif" alt="git checkout --detach"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>字节和unicode</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="位-bit-字节-Byte"><a href="#位-bit-字节-Byte" class="headerlink" title="位(bit) &amp; 字节(Byte)"></a>位(bit) &amp; 字节(Byte)</h2><p><a href="https://juejin.cn/post/7002088412903637022#heading-2">详细</a></p>
<h3 id="bit"><a href="#bit" class="headerlink" title="bit"></a>bit</h3><p>1位二进制数，也就是1bit，有2种可能，可以表示数0,1 <strong>也就是开关状态 是计算机的存储基础</strong></p>
<p>2位二进制数，2bit，有4种可能(2x2)，可以表示数0,1,2,3</p>
<p>3位二进制数,3bit，有8种可能(2x2x2)，可以表示数0,1,2,3,4,5,6,7</p>
<h3 id="Byte"><a href="#Byte" class="headerlink" title="Byte"></a>Byte</h3><p>大B，表示字节</p>
<p>1Byte &#x3D; 8 bit, 2^8是256，1个字节能表示的数就是0-255,共256种可能性。</p>
<h2 id="Unicode编码"><a href="#Unicode编码" class="headerlink" title="Unicode编码"></a>Unicode编码</h2><p><a href="https://juejin.cn/post/6844903590155272199#heading-3">摘抄</a></p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>​ Unicode（统一码、万国码、单一码）是计算机科学领域里的一项业界标准,包括字符集、编码方案等。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。</p>
<h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>UTF-8（<strong>8-bit Unicode Transformation Format</strong>）是一种针对Unicode的可变长度字符编码，又称万国码。UTF-8 <strong>用1到6个字节编码Unicode字符</strong>。用在网页上可以统一页面显示中文简体繁体及其它语言（如英文，日文，韩文）。</p>
<blockquote>
<p>UTF-8是一种非常通用的<strong>可变长</strong>字符编码方式</p>
<p>像UTF-8里面，ASCII所表示的字符集就是用1 Byte来表示，而大部分汉字则是用3 Byte来表示。</p>
</blockquote>
<h3 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><blockquote>
<p>UTF-16 Unicode字符编码五层次模型的第三层：字符编码表（Character Encoding Form，也称为 “storage format”）的一种实现方式。即把Unicode字符集的抽象码位映射为16位长的二进制整数（即码元， 长度为2 Byte）的序列，用于数据存储或传递。Unicode字符的码位，需要1个或者2个16位长的码元来表示，因此这是一个变长表示。</p>
</blockquote>
<p>引用维基百科中对于UTF-16编码的解释我们可以知道，UTF-16最少也会用2 Byte来表示一个字符，因此没有办法兼容ASCII编码（ASCII编码使用1 Byte来进行存储）。</p>
<h3 id="JS中的string"><a href="#JS中的string" class="headerlink" title="JS中的string"></a>JS中的string</h3><p>在JavaScript中，所有的string类型（或者被称为DOMString）都是使用UTF-16编码的。</p>
<p>因此，当我们需要转换成二进制与后端进行通信时，需要注意相关的编码方式。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>bit</tag>
        <tag>位</tag>
        <tag>字节</tag>
        <tag>Byte</tag>
        <tag>utf-8</tag>
        <tag>utf-16</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="五大设计原则"><a href="#五大设计原则" class="headerlink" title="五大设计原则"></a>五大设计原则</h1><p>js常用前两种原则，语言特性和后三种原则关联不大。</p>
<ul>
<li>单一职责原则<ul>
<li>一个程序只做好一件事</li>
<li>如果功能复杂就拆分开，每个部分保持独立</li>
</ul>
</li>
<li>开放封闭原则<ul>
<li>对扩展开放，对修改封闭</li>
<li>增加需求时，扩展新代码，而非修改已有代码</li>
<li>这是软件设计的终极目标</li>
</ul>
</li>
<li>李氏置换原则</li>
<li>接口独立原则</li>
<li>依赖导致原则</li>
</ul>
<h1 id="设计模式的基本-面向对象"><a href="#设计模式的基本-面向对象" class="headerlink" title="设计模式的基本-面向对象"></a>设计模式的基本-面向对象</h1><p>为何使用面向对象</p>
<ul>
<li>程序执行：顺序、判断、循环 —- 结构化</li>
<li>面对对象 —- 数据结构化</li>
<li>对于计算机，结构化的才是最简单的</li>
<li>变成应该 简单&amp;抽象</li>
</ul>
<h1 id="js常用设计模式简介及举例"><a href="#js常用设计模式简介及举例" class="headerlink" title="js常用设计模式简介及举例"></a>js常用设计模式简介及举例</h1><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="实际例子"><a href="#实际例子" class="headerlink" title="实际例子"></a>实际例子</h3><h4 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class jQuery &#123;</span><br><span class="line">  construct(selector)&#123;</span><br><span class="line">    .....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">window.$ = function(selector)&#123;</span><br><span class="line">  return new jQuery(selector)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="React-createElement"><a href="#React-createElement" class="headerlink" title="React.createElement"></a>React.createElement</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Vnode(tag, attrs, children) &#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br><span class="line">React.createElement = function(tag, attrs, children) &#123;</span><br><span class="line">  return new Vnode(tag, attrs, children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>js利用闭包和立即执行函数实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class SingleObj&#123;</span><br><span class="line">  login() &#123;</span><br><span class="line">    console.log(&#x27;111&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">SingleObj.getInstance = (function () &#123;</span><br><span class="line">  let instance = null;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    if (!instance) &#123;</span><br><span class="line">      instance = new SingleObj();</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">const test1 = SingleObj.getInstance();</span><br><span class="line">const test2 = SingleObj.getInstance();</span><br><span class="line"></span><br><span class="line">console.log(test1 === test2); // true</span><br><span class="line"></span><br><span class="line">// 无法防止错误用法，例如：</span><br><span class="line">const test3 = new SingleObj();</span><br></pre></td></tr></table></figure>

<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>旧接口格式和使用者不兼容</li>
<li>中间加一个适配转换接口</li>
</ul>
<h3 id="实际例子-1"><a href="#实际例子-1" class="headerlink" title="实际例子"></a>实际例子</h3><h4 id="封装旧接口"><a href="#封装旧接口" class="headerlink" title="封装旧接口"></a>封装旧接口</h4><p>解决新旧代码不兼容的问题，尽量避免全局替换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 自己封装的ajax，使用方式如下</span><br><span class="line">ajax(&#123;</span><br><span class="line">  url:&#x27;/getData&#x27;,</span><br><span class="line">  type:&#x27;post&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    id: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).done(function()&#123;&#125;)</span><br><span class="line">// 但是由于历史原因，代码全是 $.ajax(&#123;...&#125;)</span><br><span class="line"></span><br><span class="line">// 解决方案，做一层适配器</span><br><span class="line">var $ = &#123;</span><br><span class="line">  ajax: function(option) &#123;</span><br><span class="line">    return ajax(option);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="vue-computed"><a href="#vue-computed" class="headerlink" title="vue computed"></a>vue computed</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">  &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">----------------------------------</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &#x27;#example&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#x27;Hello&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // 计算属性的 getter</span><br><span class="line">    reversedMessage: function () &#123;</span><br><span class="line">      // `this` 指向 vm 实例</span><br><span class="line">      return this.message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>为对象添加新功能</li>
<li>不改变其原有的结构和功能</li>
</ul>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="es7装饰器提案"><a href="#es7装饰器提案" class="headerlink" title="es7装饰器提案"></a>es7装饰器提案</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@testable</span><br><span class="line">class MyTestableClass &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function testable(target) &#123;</span><br><span class="line">  target.isTestable = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyTestableClass.isTestable // true</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>@testable</code>就是一个装饰器。它修改了<code>MyTestableClass</code>这个类的行为，为它加上了静态属性<code>isTestable</code>。<code>testable</code>函数的参数<code>target</code>是<code>MyTestableClass</code>类本身。</p>
<p>基本上，装饰器的行为就是下面这样。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@decorator</span><br><span class="line">class A &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line">class A &#123;&#125;</span><br><span class="line">A = decorator(A) || A;</span><br></pre></td></tr></table></figure>

<p>也就是说，装饰器是一个对类进行处理的函数。装饰器函数的第一个参数，就是所要装饰的目标类。</p>
<p>装饰器实现 <code>mixin</code> 功能演示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function mixins(...list) &#123;</span><br><span class="line">  return function (target) &#123;</span><br><span class="line">    Object.assign(target.prototype, ...list)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const Foo = &#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    console.log(&#x27;foo&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@mixins(Foo)</span><br><span class="line">class MyClass &#123;&#125;</span><br><span class="line"></span><br><span class="line">const obj = new MyClass();</span><br><span class="line">obj.foo() // &#x27;foo&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="core-decorators"><a href="#core-decorators" class="headerlink" title="core-decorators"></a>core-decorators</h4><p>第三方类库，提供了一些常用装饰器<br><a href="https://www.npmjs.com/package/core-decorators">npm地址</a><br>只读</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; readonly &#125; from &#x27;core-decorators&#x27;;</span><br><span class="line"> </span><br><span class="line">class Meal &#123;</span><br><span class="line">  @readonly</span><br><span class="line">  entree = &#x27;steak&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var dinner = new Meal();</span><br><span class="line">dinner.entree = &#x27;salmon&#x27;;</span><br><span class="line">// Cannot assign to read only property &#x27;entree&#x27; of [object Object]</span><br></pre></td></tr></table></figure>

<p>即将废弃</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; deprecate &#125; from &#x27;core-decorators&#x27;;</span><br><span class="line"> </span><br><span class="line">class Person &#123;</span><br><span class="line">  @deprecate</span><br><span class="line">  facepalm() &#123;&#125;</span><br><span class="line"> </span><br><span class="line">  @deprecate(&#x27;We stopped facepalming&#x27;)</span><br><span class="line">  facepalmHard() &#123;&#125;</span><br><span class="line"> </span><br><span class="line">  @deprecate(&#x27;We stopped facepalming&#x27;, &#123; url: &#x27;http://knowyourmeme.com/memes/facepalm&#x27; &#125;)</span><br><span class="line">  facepalmHarder() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">let person = new Person();</span><br><span class="line"> </span><br><span class="line">person.facepalm();</span><br><span class="line">// DEPRECATION Person#facepalm: This function will be removed in future versions.</span><br><span class="line"> </span><br><span class="line">person.facepalmHard();</span><br><span class="line">// DEPRECATION Person#facepalmHard: We stopped facepalming</span><br><span class="line"> </span><br><span class="line">person.facepalmHarder();</span><br><span class="line">// DEPRECATION Person#facepalmHarder: We stopped facepalming</span><br><span class="line">//</span><br><span class="line">//     See http://knowyourmeme.com/memes/facepalm for more details.</span><br><span class="line">//</span><br></pre></td></tr></table></figure>

<h3 id="常用使用场景"><a href="#常用使用场景" class="headerlink" title="常用使用场景"></a>常用使用场景</h3><h4 id="类的装饰"><a href="#类的装饰" class="headerlink" title="类的装饰"></a>类的装饰</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Circle&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  draw()&#123;</span><br><span class="line">    console.log(&#x27;画一个圆形&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 装饰器</span><br><span class="line">class Decorator() &#123;</span><br><span class="line">  constructor(circle) &#123;</span><br><span class="line">    this.circle = circle</span><br><span class="line">  &#125;</span><br><span class="line">  draw() &#123;</span><br><span class="line">    this.circle.draw()</span><br><span class="line">    this.setRedBorder(this.circle)</span><br><span class="line">  &#125;</span><br><span class="line">  setRedBorder(circle)&#123;</span><br><span class="line">    console.log(&#x27;设置红色边框&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法的装饰"><a href="#方法的装饰" class="headerlink" title="方法的装饰"></a>方法的装饰</h4><p>例子1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function readonly(target, name, descriptor) &#123;</span><br><span class="line">  // 属性描述符</span><br><span class="line">  descriptor.writable = false;</span><br><span class="line">  return descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.first = &#x27;A&#x27;</span><br><span class="line">    this.last = &#x27;B&#x27;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @readonly</span><br><span class="line">  name() &#123;</span><br><span class="line">    return `$&#123;this.first&#125; $&#123;this.last&#125;`</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.name = () =&gt; &#123; // 报错</span><br><span class="line">  console.log(1111)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子2 函数改造，重点在于 call 和 this 的用法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function log(target, name, descriptor)&#123;</span><br><span class="line">  const oldFnc = descriptor.value;</span><br><span class="line">  descriptor.value = function()&#123;</span><br><span class="line">    console.log(target, name, descriptor);</span><br><span class="line">    // return 是为了确保不丢失函数返回值</span><br><span class="line">    return oldFnc.call(this, arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Math &#123;</span><br><span class="line">  @log</span><br><span class="line">  add(a, b) &#123;</span><br><span class="line">    return a + b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理类和目标类分离，隔离开目标类和使用者<br>常用场景</p>
<ul>
<li>网页事件代理</li>
<li>jQuery $.proxy</li>
<li>es6 proxy</li>
<li>set get<br>代码示意</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 本体</span><br><span class="line">class RealImg&#123;</span><br><span class="line">  constructor(fileName) &#123;</span><br><span class="line">    this.fileName = fileName;</span><br><span class="line">    this.loadFromDisk() // 初始化从硬盘加载文件</span><br><span class="line">  &#125;</span><br><span class="line">  diaplay() &#123;</span><br><span class="line">    console.log(&#x27;...diaplay&#x27; + this.fileName);</span><br><span class="line">  &#125;</span><br><span class="line">  loadFromDisk() &#123;</span><br><span class="line">    console.log(&#x27;...loading&#x27; + this.fileName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 代理</span><br><span class="line">class ProxyImg&#123;</span><br><span class="line">  constructor(fileName) &#123;</span><br><span class="line">    this.realImg = new RealImg(fileName);</span><br><span class="line">  &#125;</span><br><span class="line">  display() &#123;</span><br><span class="line">    this.realImg.diaplay();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 演示</span><br><span class="line">const img1 = new ProxyImg(&#x27;1.png&#x27;);</span><br><span class="line">img1.display();</span><br></pre></td></tr></table></figure>

<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>使用场景</p>
<ul>
<li>为子系统中的一组接口提供了一个高层接口</li>
<li>使用者使用这个高层接口</li>
</ul>
<p><img src="/_posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/assets/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F-7521436.png" alt="外观模式"></p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>前端最常用、最重要的模式<br>代码示意</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Subject &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.state = 0;</span><br><span class="line">    this.observers = [];</span><br><span class="line">  &#125;</span><br><span class="line">  getState() &#123;</span><br><span class="line">    return this.state;</span><br><span class="line">  &#125;</span><br><span class="line">  setState(state) &#123;</span><br><span class="line">    this.state = state;</span><br><span class="line">    this.notifyAllObservers();</span><br><span class="line">  &#125;</span><br><span class="line">  notifyAllObservers() &#123;</span><br><span class="line">    this.observers.forEach(observer =&gt; &#123;</span><br><span class="line">      observer.update();</span><br><span class="line">      console.log(`$&#123;observer.name&#125; -- updata --- $&#123;this.getState()&#125;`);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  attach(observer) &#123;</span><br><span class="line">    this.observers.push(observer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 观察者</span><br><span class="line">class Observer &#123;</span><br><span class="line">  constructor(name, subject) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.subject = subject;</span><br><span class="line">    this.subject.attach(this);</span><br><span class="line">  &#125;</span><br><span class="line">  update() &#123;</span><br><span class="line">    console.log(&#x27;更新&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const subject = new Subject();</span><br><span class="line">const ob1 = new Observer(&#x27;ob1&#x27;, subject);</span><br><span class="line">const ob2 = new Observer(&#x27;ob2&#x27;, subject);</span><br><span class="line">const ob3 = new Observer(&#x27;ob3&#x27;, subject);</span><br><span class="line">subject.setState(1);</span><br><span class="line">subject.setState(2);</span><br><span class="line">subject.setState(3);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>应用场景</p>
<ul>
<li>网页事件绑定</li>
<li>promise</li>
<li>jQuery callback</li>
<li>nodejs 自定义事件</li>
</ul>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>使用场景</p>
<ul>
<li>顺序访问一个集合</li>
<li>使用者无需知道集合的内部结构<br>代码演示</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Interator&#123;</span><br><span class="line">  index = 0</span><br><span class="line">  constructor(container) &#123;</span><br><span class="line">    this.list = container.list</span><br><span class="line">  &#125;</span><br><span class="line">  next() &#123;</span><br><span class="line">    if (this.hasNext()) &#123;</span><br><span class="line">      // 先返回，后加加</span><br><span class="line">      return this.list[this.index++]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  hasNext() &#123;</span><br><span class="line">    if (this.index &gt;= this.list.length) &#123;</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Container&#123;</span><br><span class="line">  constructor(list) &#123;</span><br><span class="line">    this.list = list;</span><br><span class="line">  &#125;</span><br><span class="line">  getInterator() &#123;</span><br><span class="line">    return new Interator(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例</p>
<ul>
<li>iterator &amp; for of</li>
</ul>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>使用场景</p>
<ul>
<li>一个对象有状态变化</li>
<li>每个状态变化都会触发一个逻辑</li>
<li>不能中使用if-else来控制</li>
</ul>
<p>实际应用</p>
<ul>
<li>状态机 例如html标签解析</li>
<li>promise 状态</li>
</ul>
<h2 id="其他模式"><a href="#其他模式" class="headerlink" title="其他模式"></a>其他模式</h2><p>不常用，暂时略过</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>鉴权的几种方式介绍对比</title>
    <url>/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%89%B4%E6%9D%83/</url>
    <content><![CDATA[<p>转载于<a href="https://zhuanlan.zhihu.com/p/271768645">知乎</a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>说起鉴权大家应该都很熟悉，不过作为前端开发来讲，鉴权的流程大头都在后端小哥那边，本文的目的就是为了让大家了解一下常见的鉴权的方式和原理。</p>
<p>认知：HTTP 是一个无状态协议，所以客户端每次发出请求时，下一次请求无法得知上一次请求所包含的状态数据。</p>
<h2 id="一、HTTP-Auth-Authentication"><a href="#一、HTTP-Auth-Authentication" class="headerlink" title="一、HTTP Auth Authentication"></a>一、HTTP Auth Authentication</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>HTTP 提供一个用于权限控制和认证的通用框架。最常用的HTTP认证方案是HTTP Basic Authentication</p>
<p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/%E9%89%B4%E6%9D%83/v2-71336270489a1f46abaacd308d8d9fde_720w.jpg" alt="img"></p>
<h3 id="鉴权流程"><a href="#鉴权流程" class="headerlink" title="鉴权流程"></a>鉴权流程</h3><p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/%E9%89%B4%E6%9D%83/v2-b957b0802ac5bd9cab96e3a4594147b5_720w.jpg" alt="img"></p>
<h3 id="加解密过程"><a href="#加解密过程" class="headerlink" title="加解密过程"></a>加解密过程</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Authorization 加密过程</span></span><br><span class="line"><span class="keyword">let</span> email = <span class="string">&quot;postmail@test.com&quot;</span></span><br><span class="line"><span class="keyword">let</span> password = <span class="string">&quot;12345678&quot;</span></span><br><span class="line"><span class="keyword">let</span> auth = <span class="string">`<span class="subst">$&#123;email&#125;</span>:<span class="subst">$&#123;password&#125;</span>`</span></span><br><span class="line"><span class="keyword">const</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(auth, <span class="string">&#x27;ascii&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">info</span>(buf.<span class="title function_">toString</span>(<span class="string">&#x27;base64&#x27;</span>)); <span class="comment">// cG9zdG1haWxAdGVzdC5jb206MTIzNDU2Nzg=</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Authorization 解密过程</span></span><br><span class="line"><span class="keyword">const</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(authorization.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)[<span class="number">1</span>] || <span class="string">&#x27;&#x27;</span>),  <span class="string">&#x27;base64&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> user = buf.<span class="title function_">toString</span>(<span class="string">&#x27;ascii&#x27;</span>).<span class="title function_">split</span>(<span class="string">&#x27;:&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="其他-HTTP-认证"><a href="#其他-HTTP-认证" class="headerlink" title="其他 HTTP 认证"></a>其他 HTTP 认证</h3><p>通用 HTTP 身份验证框架有多个验证方案使用。不同的验证方案会在安全强度上有所不同。</p>
<p>IANA 维护了<a href="https://link.zhihu.com/?target=http://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml">一系列的验证方案</a>，除此之外还有其他类型的验证方案由虚拟主机服务提供，例如 Amazon AWS ，常见的验证方案包括：</p>
<ul>
<li>Basic (查看 <a href="https://link.zhihu.com/?target=https://tools.ietf.org/html/rfc7617">RFC 7617</a>, Base64 编码凭证. 详情请参阅下文.),</li>
<li>Bearer (查看 <a href="https://link.zhihu.com/?target=https://tools.ietf.org/html/rfc6750">RFC 6750</a>, bearer 令牌通过OAuth 2.0保护资源),</li>
<li>Digest (查看 <a href="https://link.zhihu.com/?target=https://tools.ietf.org/html/rfc6750">RFC 7616</a>, 只有 md5 散列 在Firefox中支持, 查看 <a href="https://link.zhihu.com/?target=https://bugzilla.mozilla.org/show_bug.cgi?id=472823">bug 472823</a> 用于SHA加密支持),</li>
<li>HOBA (查看 <a href="https://link.zhihu.com/?target=https://tools.ietf.org/html/rfc7486">RFC 7486</a> (草案), HTTP Origin-Bound 认证, 基于数字签名),</li>
<li>Mutual (查看 <a href="https://link.zhihu.com/?target=https://tools.ietf.org/html/draft-ietf-httpauth-mutual-11">draft-ietf-httpauth-mutual</a>),</li>
<li>AWS4-HMAC-SHA256 (查看 <a href="https://link.zhihu.com/?target=http://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-auth-using-authorization-header.html">AWS docs</a>)</li>
</ul>
<h2 id="二、Cookie-Session"><a href="#二、Cookie-Session" class="headerlink" title="二、Cookie + Session"></a>二、Cookie + Session</h2><h3 id="注册流程"><a href="#注册流程" class="headerlink" title="注册流程"></a>注册流程</h3><p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/%E9%89%B4%E6%9D%83/v2-63251d6ab5fb9daa53fd70eb7c75c873_720w.jpg" alt="img"></p>
<p><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/apolloren/p/11985083.html">思考：为什么要在密码里加点“盐”？</a></p>
<h3 id="鉴权流程-1"><a href="#鉴权流程-1" class="headerlink" title="鉴权流程"></a>鉴权流程</h3><p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/%E9%89%B4%E6%9D%83/v2-8dda0c46d5fdd8e08ad79ffa7f7e8174_720w.jpg" alt="img"></p>
<h3 id="Session-存储"><a href="#Session-存储" class="headerlink" title="Session 存储"></a>Session 存储</h3><p>最常用的 Session 存储方式是 KV 存储，如Redis，在分布式、API 支持、性能方面都是比较好的，除此之外还有 mysql、file 存储。</p>
<p>如果服务是分布式的，使用 file 存储，多个服务间存在同步 session 的问题；高并发情况下错误读写锁的控制。</p>
<h3 id="Session-Refresh"><a href="#Session-Refresh" class="headerlink" title="Session Refresh"></a>Session Refresh</h3><p>我们上面提到的流程中，缺少 Session 的刷新的环节，我们不能在用户登录之后经过一个 expires 时间就把用户踢出去，如果在 Session 有效期间用户一直在操作，这时候 expires 时间就应该刷新。</p>
<p>以 Koa 为例，刷新 Session 的机制也比较简单： 开发一个 middleware（默认情况下所有请求都会经过该 middleware），如果校验 Session 有效，就更新 Session 的 expires: 当前时间+过期时间。</p>
<p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/%E9%89%B4%E6%9D%83/v2-4d4fa3b83c1e6275d1fa3a7f1731d8da_720w.jpg" alt="img"></p>
<p><strong>优化：</strong></p>
<ol>
<li>频繁更新 session 会影响性能，可以在 session 快过期的时候再更新过期时间。</li>
<li>如果某个用户一直在操作，同一个 sessionID 可能会长期有效，如果相关 cookie 泄露，可能导致比较大的风险，可以在生成 sessionID 的同时生成一个 refreshID，在 sessionID 过期之后使用 refreshID 请求服务端生成新的 sessionID（这个方案需要前端判断 sessionID 失效，并携带 refreshID 发请求)。</li>
</ol>
<h3 id="单设备登录"><a href="#单设备登录" class="headerlink" title="单设备登录"></a>单设备登录</h3><p>有些情况下，只允许一个帐号在一个端下登录，如果换了一个端，需要把之前登录的端踢下线（默认情况下，同一个帐号可以在不同的端下同时登录的）。</p>
<p>这时候可以借助一个服务保存用户唯一标识和 sessionId 值的对应关系，如果同一个用户，但 sessionId 不一样，则不允许登录或者把之前的踢下线(删除旧 session )。</p>
<h2 id="三、JWT"><a href="#三、JWT" class="headerlink" title="三、JWT"></a>三、JWT</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>JSON Web Token (JWT)是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。</p>
<h3 id="JWT-组成"><a href="#JWT-组成" class="headerlink" title="JWT 组成"></a>JWT 组成</h3><p>JWT 由三部分组成，分别是 header(头部)，payload(载荷)，signature(签证) 这三部分以小数点连接起来。</p>
<p>例如使用名为 jwt-token 的cookie来存储 JWT 例如：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">jwt-token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoibHVzaGlqaWUiLCJpYXQiOjE1MzI1OTUyNTUsImV4cCI6MTUzMjU5NTI3MH0.WZ9_poToN9llFFUfkswcpTljRDjF4JfZcmqYS0JcKO8;</span><br></pre></td></tr></table></figure>

<p>使用<code>.</code>分割值可以得到三部分组成元素，按照顺序分别为：</p>
<ul>
<li><p><code>header</code>：</p>
<ul>
<li><ul>
<li>值：eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</li>
</ul>
</li>
<li>Base64 解码: <code>&#123;&quot;alg&quot;: &quot;HS256&quot;, &quot;type&quot;: &quot;JWT&quot;&#125;</code></li>
</ul>
</li>
<li><p><code>payload</code>：</p>
<ul>
<li><ul>
<li>值：eyJuYW1lIjoibHVzaGlqaWUiLCJpYXQiOjE1MzI1OTUyNTUsImV4cCI6MTUzMjU5NTI3MH0</li>
</ul>
</li>
<li>Base64 解码：</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;       </span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;lushijie&quot;</span>,        </span><br><span class="line">    <span class="string">&quot;iat&quot;</span>: <span class="number">1532595255</span>, <span class="comment">// 发布时间       </span></span><br><span class="line">    <span class="string">&quot;exp&quot;</span>: <span class="number">1532595270</span> <span class="comment">// 过期时间     </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>signature</code>：</p>
<ul>
<li><ul>
<li>值：WZ9_poToN9llFFUfkswcpTljRDjF4JfZcmqYS0JcKO8</li>
</ul>
</li>
<li>解码：</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> headerEncode = <span class="title function_">base64Encode</span>(header);     </span><br><span class="line"><span class="keyword">const</span> payloadEncode = <span class="title function_">base64Encode</span>(payload);     </span><br><span class="line"><span class="keyword">let</span> signature = <span class="title class_">HMACSHA256</span>(headerEncode + <span class="string">&#x27;.&#x27;</span> + payloadEncode, <span class="string">&#x27;密钥&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>防CSRF（主要是伪造请求，带上cookie）</li>
<li>适合移动应用 app</li>
</ul>
<h3 id="鉴权流程-2"><a href="#鉴权流程-2" class="headerlink" title="鉴权流程"></a>鉴权流程</h3><p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/%E9%89%B4%E6%9D%83/v2-470f68419e3a414cbbfb7cc4162c2e12_720w.jpg" alt="img"></p>
<h3 id="Token-校验"><a href="#Token-校验" class="headerlink" title="Token 校验"></a>Token 校验</h3><p>对于验证一个 JWT 是否有效也是比较简单的，服务端根据前面介绍的计算方法计算出 signature，和要校验的JWT中的 signature 部分进行对比就可以了，如果 signature 部分相等则是一个有效的 JWT。</p>
<h3 id="Token-Refresh"><a href="#Token-Refresh" class="headerlink" title="Token Refresh"></a>Token Refresh</h3><p>为了减少 JWT Token 泄露风险，一般有效期会设置的比较短。 这样就会存在 JWT Token 过期的情况，我们不可能让用户频繁去登录获取新的 JWT Token。</p>
<p><strong>解决方案：</strong></p>
<p>可以同时生成 JWT Token 与 Refresh Token，其中 Refresh Roken 的有效时间长于 JWT Token，这样当 JWT Token 过期之后，使用 Refresh Token 获取新的 JWT Token 与 Refresh Token，<strong>其中 Refresh Token 只能使用一次</strong>。</p>
<h2 id="四、OAuth"><a href="#四、OAuth" class="headerlink" title="四、OAuth"></a>四、OAuth</h2><p><a href="https://www.ruanyifeng.com/blog/2019/04/oauth_design.html">阮一峰通俗介绍OAuth</a></p>
<p><a href="https://link.zhihu.com/?target=http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html">OAuth 2.0 的四种方式 - 阮一峰的网络日志www.ruanyifeng.com<img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/https:/pic2.zhimg.com/v2-b80f9dfb7ec08c42b4563246d8d137d5_180x120.jpg" alt="图标"></a></p>
<p>下面是转载，防止链接失效</p>
<h3 id="RFC-6749"><a href="#RFC-6749" class="headerlink" title="RFC 6749"></a>RFC 6749</h3><p>OAuth 2.0 的标准是 <a href="https://tools.ietf.org/html/rfc6749">RFC 6749</a> 文件。该文件先解释了 OAuth 是什么。</p>
<p>OAuth 引入了一个授权层，用来分离两种不同的角色：客户端和资源所有者。……资源所有者同意以后，资源服务器可以向客户端颁发令牌。客户端通过令牌，去请求数据。</p>
<p>这段话的意思就是，<strong>OAuth 的核心就是向第三方应用颁发令牌。</strong>然后，RFC 6749 接着写道：</p>
<p>（由于互联网有多种场景，）本标准定义了获得令牌的四种授权方式（authorization grant ）。</p>
<p>也就是说，<strong>OAuth 2.0 规定了四种获得令牌的流程。你可以选择最适合自己的那一种，向第三方应用颁发令牌。</strong>下面就是这四种授权方式。</p>
<ul>
<li>授权码（authorization-code）</li>
<li>隐藏式（implicit）</li>
<li>密码式（password）：</li>
<li>客户端凭证（client credentials）</li>
</ul>
<p>注意，不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。</p>
<h3 id="第一种授权方式：授权码"><a href="#第一种授权方式：授权码" class="headerlink" title="第一种授权方式：授权码"></a>第一种授权方式：授权码</h3><p><strong>授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。</strong></p>
<p>这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。</p>
<p>第一步，A 网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用。下面就是 A 网站跳转 B 网站的一个示意链接。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//b.com/oauth/authorize?</span></span><br><span class="line">response_type=code&amp;</span><br><span class="line">client_id=<span class="variable constant_">CLIENT_ID</span>&amp;</span><br><span class="line">redirect_uri=<span class="variable constant_">CALLBACK_URL</span>&amp;</span><br><span class="line">scope=read</span><br></pre></td></tr></table></figure>


<p>上面 URL 中，<code>response_type</code>参数表示要求返回授权码（<code>code</code>），<code>client_id</code>参数让 B 知道是谁在请求，<code>redirect_uri</code>参数是 B 接受或拒绝请求后的跳转网址，<code>scope</code>参数表示要求的授权范围（这里是只读）。</p>
<p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/%E9%89%B4%E6%9D%83/bg2019040902.jpg" alt="img"></p>
<p>第二步，用户跳转后，B 网站会要求用户登录，然后询问是否同意给予 A 网站授权。用户表示同意，这时 B 网站就会跳回<code>redirect_uri</code>参数指定的网址。跳转时，会传回一个授权码，就像下面这样。&#96;&#96;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//a.com/callback?code=AUTHORIZATION_CODE</span></span><br></pre></td></tr></table></figure>

<p>上面 URL 中，<code>code</code>参数就是授权码。</p>
<p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/%E9%89%B4%E6%9D%83/bg2019040907.jpg" alt="img"></p>
<p>第三步，A 网站拿到授权码以后，就可以在后端，向 B 网站请求令牌。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//b.com/oauth/token?</span></span><br><span class="line"> client_id=<span class="variable constant_">CLIENT_ID</span>&amp;</span><br><span class="line"> client_secret=<span class="variable constant_">CLIENT_SECRET</span>&amp;</span><br><span class="line"> grant_type=authorization_code&amp;</span><br><span class="line"> code=<span class="variable constant_">AUTHORIZATION_CODE</span>&amp;</span><br><span class="line"> redirect_uri=<span class="variable constant_">CALLBACK_URL</span></span><br></pre></td></tr></table></figure>

<p>上面 URL 中，<code>client_id</code>参数和<code>client_secret</code>参数用来让 B 确认 A 的身份（<code>client_secret</code>参数是保密的，因此只能在后端发请求），<code>grant_type</code>参数的值是<code>AUTHORIZATION_CODE</code>，表示采用的授权方式是授权码，<code>code</code>参数是上一步拿到的授权码，<code>redirect_uri</code>参数是令牌颁发后的回调网址。</p>
<p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/%E9%89%B4%E6%9D%83/bg2019040904.jpg" alt="img"></p>
<p>第四步，B 网站收到请求以后，就会颁发令牌。具体做法是向<code>redirect_uri</code>指定的网址，发送一段 JSON 数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">  <span class="string">&quot;access_token&quot;</span>:<span class="string">&quot;ACCESS_TOKEN&quot;</span>,</span><br><span class="line">  <span class="string">&quot;token_type&quot;</span>:<span class="string">&quot;bearer&quot;</span>,</span><br><span class="line">  <span class="string">&quot;expires_in&quot;</span>:<span class="number">2592000</span>,</span><br><span class="line">  <span class="string">&quot;refresh_token&quot;</span>:<span class="string">&quot;REFRESH_TOKEN&quot;</span>,</span><br><span class="line">  <span class="string">&quot;scope&quot;</span>:<span class="string">&quot;read&quot;</span>,</span><br><span class="line">  <span class="string">&quot;uid&quot;</span>:<span class="number">100101</span>,</span><br><span class="line">  <span class="string">&quot;info&quot;</span>:&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面 JSON 数据中，<code>access_token</code>字段就是令牌，A 网站在后端拿到了。</p>
<p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/%E9%89%B4%E6%9D%83/bg2019040905.jpg" alt="img"></p>
<h3 id="第二种方式：隐藏式"><a href="#第二种方式：隐藏式" class="headerlink" title="第二种方式：隐藏式"></a>第二种方式：隐藏式</h3><p>有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。<strong>RFC 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）”隐藏式”（implicit）。</strong></p>
<p>第一步，A 网站提供一个链接，要求用户跳转到 B 网站，授权用户数据给 A 网站使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//b.com/oauth/authorize?</span></span><br><span class="line">  response_type=token&amp;</span><br><span class="line">  client_id=<span class="variable constant_">CLIENT_ID</span>&amp;</span><br><span class="line">  redirect_uri=<span class="variable constant_">CALLBACK_URL</span>&amp;</span><br><span class="line">  scope=read</span><br></pre></td></tr></table></figure>

<p>上面 URL 中，<code>response_type</code>参数为<code>token</code>，表示要求直接返回令牌。</p>
<p>第二步，用户跳转到 B 网站，登录后同意给予 A 网站授权。这时，B 网站就会跳回<code>redirect_uri</code>参数指定的跳转网址，并且把令牌作为 URL 参数，传给 A 网站。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//a.com/callback#token=ACCESS_TOKEN</span></span><br></pre></td></tr></table></figure>

<p>上面 URL 中，<code>token</code>参数就是令牌，A 网站因此直接在前端拿到令牌。</p>
<p>注意，令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在”中间人攻击”的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。</p>
<p><img src="/_posts/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/assets/%E9%89%B4%E6%9D%83/bg2019040906.jpg" alt="img"></p>
<p>这种方式把令牌直接传给前端，是很不安全的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。</p>
<h3 id="第三种方式：密码式"><a href="#第三种方式：密码式" class="headerlink" title="第三种方式：密码式"></a>第三种方式：密码式</h3><p><strong>如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为”密码式”（password）。</strong></p>
<p>第一步，A 网站要求用户提供 B 网站的用户名和密码。拿到以后，A 就直接向 B 请求令牌。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//oauth.b.com/token?</span></span><br><span class="line">  grant_type=password&amp;</span><br><span class="line">  username=<span class="variable constant_">USERNAME</span>&amp;</span><br><span class="line">  password=<span class="variable constant_">PASSWORD</span>&amp;</span><br><span class="line">  client_id=<span class="variable constant_">CLIENT_ID</span></span><br></pre></td></tr></table></figure>

<p>上面 URL 中，<code>grant_type</code>参数是授权方式，这里的<code>password</code>表示”密码式”，<code>username</code>和<code>password</code>是 B 的用户名和密码。</p>
<p>第二步，B 网站验证身份通过后，直接给出令牌。注意，这时不需要跳转，而是把令牌放在 JSON 数据里面，作为 HTTP 回应，A 因此拿到令牌。</p>
<p>这种方式需要用户给出自己的用户名&#x2F;密码，显然风险很大，因此只适用于其他授权方式都无法采用的情况，而且必须是用户高度信任的应用。</p>
<h3 id="第四种方式：凭证式"><a href="#第四种方式：凭证式" class="headerlink" title="第四种方式：凭证式"></a>第四种方式：凭证式</h3><p><strong>最后一种方式是凭证式（client credentials），适用于没有前端的命令行应用，即在命令行下请求令牌。</strong></p>
<p>第一步，A 应用在命令行向 B 发出请求。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//oauth.b.com/token?</span></span><br><span class="line">  grant_type=client_credentials&amp;</span><br><span class="line">  client_id=<span class="variable constant_">CLIENT_ID</span>&amp;</span><br><span class="line">  client_secret=<span class="variable constant_">CLIENT_SECRET</span></span><br></pre></td></tr></table></figure>

<p>上面 URL 中，<code>grant_type</code>参数等于<code>client_credentials</code>表示采用凭证式，<code>client_id</code>和<code>client_secret</code>用来让 B 确认 A 的身份。</p>
<p>第二步，B 网站验证通过以后，直接返回令牌。</p>
<p>这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。</p>
<h3 id="令牌的使用"><a href="#令牌的使用" class="headerlink" title="令牌的使用"></a>令牌的使用</h3><p>A 网站拿到令牌以后，就可以向 B 网站的 API 请求数据了。</p>
<p>此时，每个发到 API 的请求，都必须带有令牌。具体做法是在请求的头信息，加上一个<code>Authorization</code>字段，令牌就放在这个字段里面。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -H <span class="string">&quot;Authorization: Bearer ACCESS_TOKEN&quot;</span> \</span><br><span class="line"><span class="string">&quot;https://api.b.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面命令中，<code>ACCESS_TOKEN</code>就是拿到的令牌。</p>
<h3 id="更新令牌"><a href="#更新令牌" class="headerlink" title="更新令牌"></a>更新令牌</h3><p>令牌的有效期到了，如果让用户重新走一遍上面的流程，再申请一个新的令牌，很可能体验不好，而且也没有必要。OAuth 2.0 允许用户自动更新令牌。</p>
<p>具体方法是，B 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）。令牌到期前，用户使用 refresh token 发一个请求，去更新令牌。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//b.com/oauth/token?</span></span><br><span class="line">  grant_type=refresh_token&amp;</span><br><span class="line">  client_id=<span class="variable constant_">CLIENT_ID</span>&amp;</span><br><span class="line">  client_secret=<span class="variable constant_">CLIENT_SECRET</span>&amp;</span><br><span class="line">  refresh_token=<span class="variable constant_">REFRESH_TOKEN</span></span><br></pre></td></tr></table></figure>

<p>上面 URL 中，<code>grant_type</code>参数为<code>refresh_token</code>表示要求更新令牌，<code>client_id</code>参数和<code>client_secret</code>参数用于确认身份，<code>refresh_token</code>参数就是用于更新令牌的令牌。</p>
<p>B 网站验证通过以后，就会颁发新的令牌。</p>
<p>写到这里，颁发令牌的四种方式就介绍完了。<a href="https://www.ruanyifeng.com/blog/2019/04/github-oauth.html">下一篇文章</a>会编写一个真实的 Demo，演示如何通过 OAuth 2.0 向 GitHub 的 API 申请令牌，然后再用令牌获取数据。</p>
<p><a href="https://link.zhihu.com/?target=https://blog.csdn.net/maxchenBug/article/details/88791514">https://link.zhihu.com/?target=https%3A//blog.csdn.net/maxchenBug/article/details/88791514</a>)</p>
<h2 id="五、总结对比"><a href="#五、总结对比" class="headerlink" title="五、总结对比"></a>五、总结对比</h2><p>没有最好，只有最合适！！！</p>
<h4 id="HTTP-Auth-Authentication"><a href="#HTTP-Auth-Authentication" class="headerlink" title="HTTP Auth Authentication"></a>HTTP Auth Authentication</h4><ul>
<li><p>梳理总结：</p>
<ul>
<li>通用 HTTP 身份验证框架有多个验证方案使用。不同的验证方案会在安全强度上有所不同。HTTP Auth Authentication 是最常用的 HTTP认证方案，为了减少泄露风险一般要求 HTTPS 协议。</li>
</ul>
</li>
<li><p>适用场景</p>
<ul>
<li>一般多被用在内部安全性要求不高的的系统上，如路由器网页管理接口</li>
</ul>
</li>
<li><p>问题：</p>
<ul>
<li>请求上携带验证信息，容易被嗅探到</li>
<li>无法注销</li>
</ul>
</li>
<li></li>
</ul>
<h4 id="Cookie-Session"><a href="#Cookie-Session" class="headerlink" title="Cookie + Session"></a>Cookie + Session</h4><ul>
<li><p>梳理总结：</p>
<ul>
<li>服务端存储 session ，客户端存储 cookie，其中 cookie 保存的为 sessionID</li>
<li>可以灵活 revoke(撤销) 权限，更新信息后可以方便的同步 session 中相应内容</li>
<li>分布式 session 一般使用 redis(或其他KV) 存储</li>
</ul>
</li>
<li><p>使用场景：</p>
<ul>
<li>适合传统系统独立鉴权</li>
</ul>
</li>
</ul>
<h4 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h4><ul>
<li><p>梳理总结：</p>
<ul>
<li>服务器不再需要存储 session，服务器认证鉴权业务可以方便扩展</li>
<li>JWT 并不依赖 cookie（防范CSRF），也可以使用 header 传递</li>
<li>为减少盗用(中间人)，要使用 HTTPS 协议传输</li>
</ul>
</li>
<li><p>适用场景：</p>
<ul>
<li>适合做简单的 RESTful API 认证</li>
<li>适合一次性验证，例如注册激活链接</li>
</ul>
</li>
<li><p>问题：</p>
<ul>
<li>使用过程中无法废弃某个 token，有效期内 token 一直有效</li>
<li>payload 信息更新时，已下发的 token 无法同步</li>
</ul>
</li>
</ul>
<h4 id="OAuth"><a href="#OAuth" class="headerlink" title="OAuth"></a>OAuth</h4><ul>
<li><p>梳理总结：</p>
<ul>
<li>OAuth是一个开放标准，允许用户授权第三方应用访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方移动应用或分享他们数据的所有内容。</li>
<li>GitHub OAuth 文档 <a href="https://link.zhihu.com/?target=https://docs.github.com/en/free-pro-team@latest/developers/apps/identifying-and-authorizing-users-for-github-apps">Identifying and authorizing users for GitHub Apps</a></li>
</ul>
</li>
<li><p>适用场景：OAuth 分为下面四种模式</p>
<ul>
<li>简化模式，不安全，适用于纯静态页面应用</li>
<li>授权码模式，功能最完整、流程最严密的授权模式，通常使用在公网的开放平台中</li>
<li>密码模式，一般在内部系统中使用，调用者是以用户为单位。</li>
<li>客户端模式，一般在内部系统之间的 API 调用。两个平台之间调用，以平台为单位。</li>
</ul>
</li>
</ul>
<p>转载于<a href="https://zhuanlan.zhihu.com/p/271768645">知乎</a></p>
<p><strong>延伸阅读</strong></p>
<p><a href="https://link.zhihu.com/?target=https://blog.csdn.net/Faker_Wang/article/details/80877654">单点登录注销_Faker_Wang的博客-CSDN博客blog.csdn.net</a></p>
<p>[《手机扫码登录内网怎么实现的？》blog.csdn.net](</p>
]]></content>
      <categories>
        <category>大前端</category>
      </categories>
      <tags>
        <tag>鉴权</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器缓存原理</title>
    <url>/%E7%BD%91%E7%BB%9C/cache/</url>
    <content><![CDATA[<p>转载</p>
<h1 id="一、浏览器缓存基本认识"><a href="#一、浏览器缓存基本认识" class="headerlink" title="一、浏览器缓存基本认识"></a>一、浏览器缓存基本认识</h1><p><strong>分为强缓存和协商缓存</strong></p>
<ol>
<li>浏览器在加载资源时，先根据这个资源的一些<code>http header</code>判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个<code>css</code>文件，如果浏览器在加载它所在的网页时，这个<code>css</code>文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个<code>css</code>，连请求都不会发送到网页所在服务器</li>
<li>当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些<code>http header</code>验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源</li>
<li><strong>强缓存与协商缓存的共同点是</strong>：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：<strong>强缓存不发请求到服务器</strong>，<strong>协商缓存会发请求到服务器</strong></li>
<li>当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据</li>
</ol>
<h1 id="二、强缓存的原理"><a href="#二、强缓存的原理" class="headerlink" title="二、强缓存的原理"></a>二、强缓存的原理</h1><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h2><blockquote>
<p>当浏览器对某个资源的请求命中了强缓存时，返回的<code>http</code>状态为<code>200</code>，在<code>chrome</code>的开发者工具的<code>network</code>里面<code>size</code>会显示为<code>from cache</code>，比如京东的首页里就有很多静态资源配置了强缓存，用<code>chrome</code>打开几次，再用<code>f12</code>查看<code>network</code>，可以看到有不少请求就是从缓存中加载的</p>
</blockquote>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/1.png" alt="img"></p>
<ul>
<li>强缓存是利用<code>Expires</code>或者<code>Cache-Control</code>这两个<code>http response header</code>实现的，它们都用来表示资源在客户端缓存的有效期。</li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Expires`是`http1.0`提出的一个表示资源过期时间的`header`，它描述的是一个绝对时间，由服务器返回，用`GMT`格式的字符串表示，如：`Expires:Thu, 31 Dec 2037 23:55:55 GMT</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="2-2-Expires缓存原理"><a href="#2-2-Expires缓存原理" class="headerlink" title="2.2 Expires缓存原理"></a>2.2 Expires缓存原理</h2><ol>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在<code>respone</code>的<code>header</code>加上<code>Expires</code>，如</li>
</ol>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/2.png" alt="img"></p>
<ol>
<li>浏览器在接收到这个资源后，会把这个资源连同所有<code>response header</code>一起缓存下来（所以缓存命中的请求返回的<code>header</code>并不是来自服务器，而是来自之前缓存的<code>header</code>）</li>
<li>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的<code>Expires</code>跟当前的请求时间比较，如果请求时间在<code>Expires</code>指定的时间之前，就能命中缓存，否则就不行</li>
<li>如果缓存没有命中，浏览器直接从服务器加载资源时，<code>Expires Header</code>在重新加载的时候会被更新</li>
</ol>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Expires`是较老的强缓存管理`header`，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。所以在`http1.1`的时候，提出了一个新的`header`，就是`Cache-Control`，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：`Cache-Control:max-age=315360000</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="2-3-Cache-Control缓存原理"><a href="#2-3-Cache-Control缓存原理" class="headerlink" title="2.3 Cache-Control缓存原理"></a>2.3 Cache-Control缓存原理</h2><ol>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在<code>respone</code>的<code>header</code>加上<code>Cache-Control</code>，如：</li>
</ol>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/3.png" alt="img"></p>
<ol>
<li>浏览器在接收到这个资源后，会把这个资源连同所有<code>response header</code>一起缓存下来</li>
<li>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和<code>Cache-Control</code>设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行</li>
<li>如果缓存没有命中，浏览器直接从服务器加载资源时，<code>Cache-Control Header</code>在重新加载的时候会被更新</li>
</ol>
<ul>
<li><code>Cache-Control</code>描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较<code>Expires</code>，<code>Cache-Control</code>的缓存管理更有效，安全一些。</li>
<li>这两个<code>header</code>可以只启用一个，也可以同时启用，当<code>response header</code>中，<code>Expires</code>和<code>Cache-Control</code>同时存在时，<code>Cache-Control</code>优先级高于<code>Expires</code>：</li>
</ul>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/4.png" alt="img"></p>
<h2 id="2-4-cache-control-补充"><a href="#2-4-cache-control-补充" class="headerlink" title="2.4 cache-control 补充"></a>2.4 cache-control 补充</h2><p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/cache/1642834020024-2f112f4b-df67-4094-856c-04d71c79360d.png" alt="img"></p>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/cache/1642835507632-481e335e-b8ee-44e0-ae15-a738503d3776.png" alt="img"></p>
<h1 id="三、强缓存的管理"><a href="#三、强缓存的管理" class="headerlink" title="三、强缓存的管理"></a>三、强缓存的管理</h1><blockquote>
<p>前面介绍的是强缓存的原理，在实际应用中我们会碰到需要强缓存的场景和不需要强缓存的场景，通常有2种方式来设置是否启用强缓存</p>
</blockquote>
<ol>
<li>通过代码的方式，在<code>web</code>服务器返回的响应中添加<code>Expires</code>和<code>Cache-Control Header</code></li>
<li>通过配置<code>web</code>服务器的方式，让<code>web</code>服务器在响应资源的时候统一添加<code>Expires</code>和<code>Cache-Control Header</code></li>
</ol>
<blockquote>
<p>比如在javaweb里面，我们可以使用类似下面的代码设置强缓存</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.util.Date date = new java.util.Date();    </span><br><span class="line">response.setDateHeader(&quot;Expires&quot;,date.getTime()+20000); //Expires:过时期限值 </span><br><span class="line">response.setHeader(&quot;Cache-Control&quot;, &quot;public&quot;); //Cache-Control来控制页面的缓存与否,public:浏览器和缓存服务器都可以缓存页面信息；</span><br><span class="line">response.setHeader(&quot;Pragma&quot;, &quot;Pragma&quot;); //Pragma:设置页面是否缓存，为Pragma则缓存，no-cache则不缓存</span><br></pre></td></tr></table></figure>

<blockquote>
<p>还可以通过类似下面的<code>java</code>代码设置不启用强缓存</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">response.setHeader( &quot;Pragma&quot;, &quot;no-cache&quot; );   </span><br><span class="line">response.setDateHeader(&quot;Expires&quot;, 0);   </span><br><span class="line">response.addHeader( &quot;Cache-Control&quot;, &quot;no-cache&quot; );//浏览器和缓存服务器都不应该缓存页面信息</span><br></pre></td></tr></table></figure>

<ul>
<li><code>nginx</code>和<code>apache</code>作为专业的<code>web</code>服务器，都有专门的配置文件，可以配置<code>expires</code>和<code>cache-control</code>，这方面的知识，如果你对运维感兴趣的话，可以在百度上搜索<code>nginx</code> 设置 <code>expires cache-control</code>或 <code>apache 设置 expires cache-control</code> 都能找到不少相关的文章。</li>
<li>由于在开发的时候不会专门去配置强缓存，而浏览器又默认会缓存图片，<code>css</code>和<code>js</code>等静态资源，所以开发环境下经常会因为强缓存导致资源没有及时更新而看不到最新的效果，解决这个问题的方法有很多，常用的有以下几种</li>
</ul>
<p><strong>处理缓存带来的问题</strong></p>
<ol>
<li>直接<code>ctrl+f5</code>，这个办法能解决页面直接引用的资源更新的问题</li>
<li>使用浏览器的隐私模式开发</li>
<li>如果用的是<code>chrome</code>，可以<code>f12</code>在<code>network</code>那里把缓存给禁掉（这是个非常有效的方法）</li>
</ol>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/5.png" alt="img"></p>
<ol>
<li>在开发阶段，给资源加上一个动态的参数，如<code>css/index.css?v=0.0001</code>，由于每次资源的修改都要更新引用的位置，同时修改参数的值，所以操作起来不是很方便，除非你是在动态页面比如jsp里开发就可以用服务器变量来解决（<code>v=$&#123;sysRnd&#125;</code>），或者你能用一些前端的构建工具来处理这个参数修改的问题</li>
<li>如果资源引用的页面，被嵌入到了一个<code>iframe</code>里面，可以在<code>iframe</code>的区域右键单击重新加载该页面，以<code>chrome</code>为例</li>
</ol>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/6.png" alt="img"></p>
<ol>
<li>如果缓存问题出现在<code>ajax</code>请求中，最有效的解决办法就是<code>ajax</code>的请求地址追加随机数</li>
<li>还有一种情况就是动态设置<code>iframe</code>的<code>src</code>时，有可能也会因为缓存问题，导致看不到最新的效果，这时候在要设置的<code>src</code>后面添加随机数也能解决问题</li>
<li>如果你用的是<code>grunt</code>和<code>gulp</code>、<code>webpack</code>这种前端工具开发，通过它们的插件比如<code>grunt-contrib-connect</code>来启动一个静态服务器，则完全不用担心开发阶段的资源更新问题，因为在这个静态服务器下的所有资源返回的<code>respone header</code>中，<code>cache-control</code>始终被设置为不缓存</li>
</ol>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/7.png" alt="img"></p>
<h1 id="四、强缓存的应用"><a href="#四、强缓存的应用" class="headerlink" title="四、强缓存的应用"></a>四、强缓存的应用</h1><blockquote>
<p>强缓存是前端性能优化最有力的工具，没有之一，对于有大量静态资源的网页，一定要利用强缓存，提高响应速度。通常的做法是，为这些静态资源全部配置一个超时时间超长的<code>Expires</code>或<code>Cache-Control</code>，这样用户在访问网页时，只会在第一次加载时从服务器请求静态资源，其它时候只要缓存没有失效并且用户没有强制刷新的条件下都会从自己的缓存中加载，比如前面提到过的京东首页缓存的资源，它的缓存过期时间都设置到了<code>2026</code>年</p>
</blockquote>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/8.png" alt="img"></p>
<blockquote>
<p>然而这种缓存配置方式会带来一个新的问题，就是发布时资源更新的问题，比如某一张图片，在用户访问第一个版本的时候已经缓存到了用户的电脑上，当网站发布新版本，替换了这个图片时，已经访问过第一个版本的用户由于缓存的设置，导致在默认的情况下不会请求服务器最新的图片资源，除非他清掉或禁用缓存或者强制刷新，否则就看不到最新的图片效果</p>
</blockquote>
<p>这个问题已经有成熟的解决方案，具体内容可阅读知乎这篇文章详细了解：<a href="https://www.zhihu.com/question/20790576">https://www.zhihu.com/question/20790576</a></p>
<p>文章提到的东西都属于理论上的解决方案，不过现在已经有很多前端工具能够实际地解决这个问题，由于每个工具涉及到的内容细节都有很多，本文没有办法一一深入介绍。有兴趣的可以去了解下<code>grunt</code> <code>gulp</code> <code>webpack</code> <code>fis</code> 还有edp这几个工具，基于这几个工具都能解决这个问题，尤其是<code>fis</code>和<code>edp</code>是百度推出的前端开发平台，有现成的文档可以参考：</p>
<p><a href="http://fis.baidu.com/fis3/api/index.html">http://fis.baidu.com/fis3/api/index.html</a></p>
<p><a href="http://ecomfe.github.io/edp/doc/initialization/install/">http://ecomfe.github.io/edp/doc/initialization/install/</a></p>
<blockquote>
<p>强缓存还有一点需要注意的是，通常都是针对静态资源使用，动态资源需要慎用，除了服务端页面可以看作动态资源外，那些引用静态资源的<code>html</code>也可以看作是动态资源，如果这种<code>html</code>也被缓存，当这些<code>html</code>更新之后，可能就没有机制能够通知浏览器这些html有更新，尤其是前后端分离的应用里，页面都是纯<code>html</code>页面，每个访问地址可能都是直接访问<code>html</code>页面，这些页面通常不加强缓存，以保证浏览器访问这些页面时始终请求服务器最新的资源</p>
</blockquote>
<h1 id="五、协商缓存的原理"><a href="#五、协商缓存的原理" class="headerlink" title="五、协商缓存的原理"></a>五、协商缓存的原理</h1><h2 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h2><blockquote>
<p>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的<code>http</code>状态为<code>304</code>并且会显示一个<code>Not Modified</code>的字符串，比如你打开京东的首页，按<code>f12</code>打开开发者工具，再按<code>f5</code>刷新页面，查看<code>network</code>，可以看到有不少请求就是命中了协商缓存的</p>
</blockquote>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/9.png" alt="img"></p>
<blockquote>
<p>查看单个请求的<code>Response Header</code>，也能看到<code>304</code>的状态码和<code>Not Modified</code>的字符串，只要看到这个就可说明这个资源是命中了协商缓存，然后从客户端缓存中加载的，而不是服务器最新的资源</p>
</blockquote>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/10.png" alt="img"></p>
<h2 id="5-2-Last-Modified-response-，If-Modified-Since-request-控制协商缓存"><a href="#5-2-Last-Modified-response-，If-Modified-Since-request-控制协商缓存" class="headerlink" title="5.2 Last-Modified(response)，If-Modified-Since(request)控制协商缓存"></a>5.2 Last-Modified(response)，If-Modified-Since(request)控制协商缓存</h2><ol>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在<code>respone</code>的<code>header</code>加上<code>Last-Modified</code>的<code>header</code>，这个<code>header</code>表示这个资源在服务器上的最后修改时间</li>
</ol>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/11.png" alt="img"></p>
<ol>
<li>浏览器再次跟服务器请求这个资源时，在<code>request</code>的<code>header</code>上加上<code>If-Modified-Since</code>的<code>header</code>，这个<code>header</code>的值就是上一次请求时返回的<code>Last-Modified</code>的值</li>
</ol>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/12.png" alt="img"></p>
<ol>
<li>服务器再次收到资源请求时，根据浏览器传过来<code>If-Modified-Since</code>和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回<code>304 Not Modified</code>，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回<code>304 Not Modified</code>的响应时，<code>response header</code>中不会再添加<code>Last-Modified</code>的<code>header</code>，因为既然资源没有变化，那么<code>Last-Modified</code>也就不会改变，这是服务器返回<code>304</code>时的<code>response header</code></li>
</ol>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/13.png" alt="img"></p>
<ol>
<li>浏览器收到<code>304</code>的响应后，就会从缓存中加载资源</li>
<li>如果协商缓存没有命中，浏览器直接从服务器加载资源时，<code>Last-Modified</code> <code>Header</code>在重新加载的时候会被更新，下次请求时，<code>If-Modified-Since</code>会启用上次返回的<code>Last-Modified</code>值</li>
</ol>
<blockquote>
<p>【<code>Last-Modified</code>，<code>If-Modified-Since</code>】都是根据服务器时间返回的<code>header</code>，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个<code>header</code>配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对<code>header</code>来管理协商缓存，这对<code>header</code>就是【<code>ETag</code>、<code>If-None-Match</code>】。它们的缓存管理的方式是</p>
</blockquote>
<h2 id="5-3-ETag-response-、If-None-Match-request-控制协商缓存"><a href="#5-3-ETag-response-、If-None-Match-request-控制协商缓存" class="headerlink" title="5.3 ETag(response)、If-None-Match(request)控制协商缓存"></a>5.3 ETag(response)、If-None-Match(request)控制协商缓存</h2><ol>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在<code>respone</code>的<code>header</code>加上<code>ETag</code>的<code>header</code>，这个<code>header</code>是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充<code>Last-Modified</code>的问题</li>
</ol>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/14.png" alt="img"></p>
<ol>
<li>浏览器再次跟服务器请求这个资源时，在<code>request</code>的<code>header</code>上加上<code>If-None-Match</code>的<code>header</code>，这个<code>header</code>的值就是上一次请求时返回的<code>ETag</code>的值</li>
</ol>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/15.png" alt="img"></p>
<ol>
<li>服务器再次收到资源请求时，根据浏览器传过来<code>If-None-Match</code>和然后再根据资源生成一个新的<code>ETag</code>，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回<code>304 Not Modified</code>，但是不会返回资源内容；如果有变化，就正常返回资源内容。与<code>Last-Modified</code>不一样的是，当服务器返回<code>304 Not Modified</code>的响应时，由于<code>ETag</code>重新生成过，<code>response header</code>中还会把这个<code>ETag</code>返回，即使这个<code>ETag</code>跟之前的没有变化</li>
</ol>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/16.png" alt="img"></p>
<ol>
<li>浏览器收到<code>304</code>的响应后，就会从缓存中加载资源。</li>
</ol>
<h1 id="六、协商缓存的管理"><a href="#六、协商缓存的管理" class="headerlink" title="六、协商缓存的管理"></a>六、协商缓存的管理</h1><blockquote>
<p>协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。大部分<code>web</code>服务器都默认开启协商缓存，而且是同时启用【<code>Last-Modified</code>，<code>If-Modified-Since</code>】和【<code>ETag</code>、<code>If-None-Match</code>】，比如<code>apache</code>:</p>
</blockquote>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/17.png" alt="img"></p>
<blockquote>
<p>如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。</p>
</blockquote>
<ul>
<li>【<code>Last-Modified</code>，<code>If-Modified-Since</code>】和【<code>ETag</code>、<code>If-None-Match</code>】一般都是同时启用，这是为了处理<code>Last-Modified</code>不可靠的情况。</li>
</ul>
<p><strong>有一种场景需要注意</strong></p>
<ul>
<li>分布式系统里多台机器间文件的<code>Last-Modified</code>必须保持一致，以免负载均衡到不同机器导致比对失败；</li>
<li><strong>分布式系统尽量关闭掉<code>ETag</code></strong>(<strong>每台机器生成的<code>ETag</code>都会不一样</strong>）；</li>
<li>京东页面的资源请求，返回的<code>repsones header</code>就只有<code>Last-Modified</code>，没有<code>ETag</code>：</li>
</ul>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/https:/poetries1.gitee.io/img-repo/2019/10/18.png" alt="img"></p>
<blockquote>
<p>协商缓存需要配合强缓存使用，你看前面这个截图中，除了<code>Last-Modified</code>这个<code>header</code>，还有强缓存的相关<code>header</code>，因为如果不启用强缓存的话，协商缓存根本没有意义</p>
</blockquote>
<h1 id="七、相关浏览器行为对缓存的影响"><a href="#七、相关浏览器行为对缓存的影响" class="headerlink" title="七、相关浏览器行为对缓存的影响"></a>七、相关浏览器行为对缓存的影响</h1><blockquote>
<p>如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。这是默认的处理方式，这个方式可能被浏览器的行为改变：</p>
</blockquote>
<ul>
<li>当<code>ctrl+f5</code>强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</li>
<li>当<code>f5</code>刷新网页时，跳过强缓存，但是会检查协商缓存</li>
</ul>
<h1 id="总结图片"><a href="#总结图片" class="headerlink" title="总结图片"></a>总结图片</h1><p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/cache/7b22f75c35414de9828c28f142a36a8d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.png" alt="强缓存"></p>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/cache/acab5cc0f39c46d9845677ddf7310746~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.png" alt="协商缓存"></p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title>三次握手、四次挥手</title>
    <url>/%E7%BD%91%E7%BB%9C/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    <content><![CDATA[<p><a href="https://juejin.cn/post/6844903958624878606">转载</a></p>
<p>三次握手和四次挥手是各个公司常见的考点，也具有一定的水平区分度，也被一些面试官作为热身题。很多小伙伴说这个问题刚开始回答的挺好，但是后面越回答越冒冷汗，最后就歇菜了。</p>
<p>见过比较典型的面试场景是这样的:</p>
<blockquote>
<p>面试官：请介绍下三次握手</p>
</blockquote>
<blockquote>
<p>求职者：第一次握手就是客户端给服务器端发送一个报文，第二次就是服务器收到报文之后，会应答一个报文给客户端，第三次握手就是客户端收到报文后再给服务器发送一个报文，三次握手就成功了。</p>
</blockquote>
<blockquote>
<p>面试官：然后呢？</p>
</blockquote>
<blockquote>
<p>求职者：这就是三次握手的过程，很简单的。</p>
</blockquote>
<blockquote>
<p>面试官：。。。。。。</p>
</blockquote>
<blockquote>
<p>（番外篇：一首凉凉送给你）</p>
</blockquote>
<p>记住猿人谷一句话：<strong>面试时越简单的问题，一般就是隐藏着比较大的坑，一般都是需要将问题扩展的</strong>。上面求职者的回答不对吗？当然对，但距离面试官的期望可能还有点距离。</p>
<p>希望大家能带着如下问题进行阅读，收获会更大。</p>
<ol>
<li>请画出三次握手和四次挥手的示意图</li>
<li>为什么连接的时候是三次握手？</li>
<li>什么是半连接队列？</li>
<li>ISN(Initial Sequence Number)是固定的吗？</li>
<li>三次握手过程中可以携带数据吗？</li>
<li>如果第三次握手丢失了，客户端服务端会如何处理？</li>
<li>SYN攻击是什么？</li>
<li>挥手为什么需要四次？</li>
<li>四次挥手释放连接时，等待2MSL的意义?</li>
</ol>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/16da9fd289836792~tplv-t2oaga2asx-watermark-20211207100719210.gif" alt="三次握手和四次挥手.png"></p>
<h3 id="tcp标志位含义"><a href="#tcp标志位含义" class="headerlink" title="tcp标志位含义"></a>tcp标志位含义</h3><p>搞懂位码含义，方便理解。位码即tcp标志位，有6种标示：</p>
<ul>
<li>SYN(synchronous建立联机)</li>
<li>ACK(acknowledgement 确认)</li>
<li>PSH(push传送)</li>
<li>FIN(finish结束)</li>
<li>RST(reset重置)</li>
<li>URG(urgent紧急)</li>
<li>seq Sequence number(顺序号码)</li>
<li>ack Acknowledge number(确认号码)</li>
</ul>
<h2 id="1-三次握手"><a href="#1-三次握手" class="headerlink" title="1. 三次握手"></a>1. 三次握手</h2><p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换<code>TCP窗口大小</code>信息。</p>
<p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。 进行三次握手：</p>
<ul>
<li><p>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 <code>SYN_SEND</code> 状态。</p>
<p>首部的同步位SYN&#x3D;1，初始序号seq&#x3D;x，SYN&#x3D;1的报文段不能携带数据，但要消耗掉一个序号。</p>
</li>
<li><p>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 <code>SYN_RCVD</code> 的状态。</p>
<p>在确认报文段中SYN&#x3D;1，ACK&#x3D;1，确认号ack&#x3D;x+1，初始序号seq&#x3D;y。</p>
</li>
<li><p>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 <code>ESTABLISHED</code> 状态。服务器收到 ACK 报文之后，也处于 <code>ESTABLISHED</code> 状态，此时，双方已建立起了连接。</p>
<p>确认报文段ACK&#x3D;1，确认号ack&#x3D;y+1，序号seq&#x3D;x+1（初始为seq&#x3D;x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p>
</li>
</ul>
<p>发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。</p>
<p>在socket编程中，客户端执行connect()时，将触发三次握手。</p>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/16da9fd28a45bd19~tplv-t2oaga2asx-watermark-20211207100718733.gif" alt="三次握手.png"></p>
<p>![图像 2](assets&#x2F;三次握手四次挥手&#x2F;图像 2.jpeg)</p>
<h3 id="1-1-为什么需要三次握手，两次不行吗？"><a href="#1-1-为什么需要三次握手，两次不行吗？" class="headerlink" title="1.1 为什么需要三次握手，两次不行吗？"></a>1.1 为什么需要三次握手，两次不行吗？</h3><p>弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。</p>
<ul>
<li>第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</li>
<li>第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</li>
<li>第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</li>
</ul>
<p>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</p>
<p>试想如果是用两次握手，则会出现下面这种情况：</p>
<blockquote>
<p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在<strong>某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端</strong>，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p>
</blockquote>
<h3 id="1-2-什么是半连接队列？"><a href="#1-2-什么是半连接队列？" class="headerlink" title="1.2 什么是半连接队列？"></a>1.2 什么是半连接队列？</h3><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个<strong>队列</strong>里，我们把这种队列称之为<strong>半连接队列</strong>。</p>
<p>当然还有一个<strong>全连接队列</strong>，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p>
<p>这里在补充一点关于<strong>SYN-ACK 重传次数</strong>的问题： 服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。 注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s……</p>
<h3 id="1-3-ISN-Initial-Sequence-Number-是固定的吗？"><a href="#1-3-ISN-Initial-Sequence-Number-是固定的吗？" class="headerlink" title="1.3 ISN(Initial Sequence Number)是固定的吗？"></a>1.3 ISN(Initial Sequence Number)是固定的吗？</h3><p>当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，每4ms加1 。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。</p>
<p><strong>三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</strong></p>
<h3 id="1-4-三次握手过程中可以携带数据吗？"><a href="#1-4-三次握手过程中可以携带数据吗？" class="headerlink" title="1.4 三次握手过程中可以携带数据吗？"></a>1.4 三次握手过程中可以携带数据吗？</h3><p>其实第三次握手的时候，是可以携带数据的。但是，<strong>第一次、第二次握手不可以携带数据</strong></p>
<p>为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。</p>
<p>也就是说，<strong>第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。</strong></p>
<h3 id="1-5-SYN攻击是什么？"><a href="#1-5-SYN攻击是什么？" class="headerlink" title="1.5 SYN攻击是什么？"></a>1.5 SYN攻击是什么？</h3><p><strong>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的</strong>，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS&#x2F;DDoS 攻击。</p>
<p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux&#x2F;Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -n -p TCP | grep SYN_RECV</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>常见的防御 SYN 攻击的方法有如下几种：</p>
<ul>
<li>缩短超时（SYN Timeout）时间</li>
<li>增加最大半连接数</li>
<li>过滤网关防护</li>
<li>SYN cookies技术</li>
</ul>
<h2 id="2-四次挥手"><a href="#2-四次挥手" class="headerlink" title="2. 四次挥手"></a>2. 四次挥手</h2><p>建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的<strong>半关闭</strong>（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p>
<p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。</p>
<p>刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p>
<ul>
<li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 <code>FIN_WAIT1</code> 状态。 即发出<strong>连接释放报文段</strong>（FIN&#x3D;1，序号seq&#x3D;u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</li>
<li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <code>CLOSE_WAIT</code> 状态。 即服务端收到连接释放报文段后即发出<strong>确认报文段</strong>（ACK&#x3D;1，确认号ack&#x3D;u+1，序号seq&#x3D;v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</li>
<li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code> 的状态。 即服务端没有要向客户端发出的数据，服务端发出<strong>连接释放报文段</strong>（FIN&#x3D;1，ACK&#x3D;1，序号seq&#x3D;w，确认号ack&#x3D;u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</li>
<li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 <code>TIME_WAIT</code> 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 <code>CLOSED</code> 状态。 即客户端收到服务端的连接释放报文段后，对此发出<strong>确认报文段</strong>（ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</li>
</ul>
<p>收到一个FIN只意味着在这一方向上没有数据流动。<strong>客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。</strong></p>
<p>在socket编程中，任何一方执行close()操作即可产生挥手操作。</p>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/16da9fd28b49f652~tplv-t2oaga2asx-watermark-20211207100718775.gif" alt="image.png"></p>
<p>![图像 3](assets&#x2F;三次握手四次挥手&#x2F;图像 3-8931236.jpeg)</p>
<h3 id="2-1-挥手为什么需要四次？"><a href="#2-1-挥手为什么需要四次？" class="headerlink" title="2.1 挥手为什么需要四次？"></a>2.1 挥手为什么需要四次？</h3><p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中<strong>ACK报文是用来应答的，SYN报文是用来同步的</strong>。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，”你发的FIN报文我收到了”。<strong>只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送</strong>。故需要四次挥手。</p>
<h3 id="2-2-2MSL等待状态"><a href="#2-2-2MSL等待状态" class="headerlink" title="2.2 2MSL等待状态"></a>2.2 2MSL等待状态</h3><p>TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。</p>
<p>对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。</p>
<p>这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。</p>
<h3 id="2-3-四次挥手释放连接时，等待2MSL的意义"><a href="#2-3-四次挥手释放连接时，等待2MSL的意义" class="headerlink" title="2.3 四次挥手释放连接时，等待2MSL的意义?"></a>2.3 四次挥手释放连接时，等待2MSL的意义?</h3><blockquote>
<p><strong>MSL</strong>是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p>
</blockquote>
<p><strong>为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器</strong>。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。</p>
<h4 id="两个理由"><a href="#两个理由" class="headerlink" title="两个理由"></a>两个理由</h4><ol>
<li>保证客户端发送的最后一个ACK报文段能够到达服务端。 这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。</li>
<li>防止“已失效的连接请求报文段”出现在本连接中。 客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</li>
</ol>
<h3 id="2-4-为什么TIME-WAIT状态需要经过2MSL才能返回到CLOSE状态？"><a href="#2-4-为什么TIME-WAIT状态需要经过2MSL才能返回到CLOSE状态？" class="headerlink" title="2.4 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？"></a>2.4 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？</h3><p>理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以<strong>TIME_WAIT状态就是用来重发可能丢失的ACK报文</strong>。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>《TCP&#x2F;IP详解 卷1:协议》有一张TCP状态变迁图，很具有代表性，有助于大家理解三次握手和四次挥手的状态变化。如下图所示，粗的实线箭头表示正常的客户端状态变迁，粗的虚线箭头表示正常的服务器状态变迁。</p>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/16da9fd28b1900f9~tplv-t2oaga2asx-watermark-20211207100719030.gif" alt="TCP状态变迁图.jpg"></p>
<p><strong>以后面试官再问你三次握手和四次挥手，直接把这一篇文章丢给他就可以了，他想问的都在这里。</strong></p>
<h3 id="https交换证书"><a href="#https交换证书" class="headerlink" title="https交换证书"></a>https交换证书</h3><p><a href="/%E7%BD%91%E7%BB%9C/https%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B">https握手</a></p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议</title>
    <url>/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h3 id="常见网页协议"><a href="#常见网页协议" class="headerlink" title="常见网页协议"></a>常见网页协议</h3><ul>
<li><strong>TCP&#x2F;IP</strong>  是互联网相关的各类协议族的总称</li>
<li><strong>IP</strong>（Internet Protocol）网际协议（<strong>网络层协议</strong>）IP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC 地址（Media Access Control Address）</li>
<li><strong>HTTP</strong> 超文本传输协议是一个用于传输超媒体文档（例如 HTML）的<strong>应用层协议</strong>。它是为 Web 浏览器与 Web 服务器之间的通信而设计的，但也可以用于其他目的</li>
<li><strong>TCP</strong>（Transmission Control Protocol，<strong>传输控制协议</strong>）是一种面向连接的、可靠的、基于字节流的<strong>传输层通信协议</strong></li>
<li><strong>UDP</strong>（User Data Protocol，<strong>用户数据报协议</strong>）一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上</li>
</ul>
<h3 id="TCP-IP-的分层管理"><a href="#TCP-IP-的分层管理" class="headerlink" title="TCP&#x2F;IP 的分层管理"></a><strong>TCP&#x2F;IP</strong> 的分层管理</h3><p><strong>利用 TCP&#x2F;IP 协议族进行网络通信时，会通过分层顺序与对方进行通信</strong></p>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/image-20210714152647756.png" alt="image-20210714152647756"></p>
<p>这些层基本上被分为4层：</p>
<ul>
<li><p>应用层</p>
<ul>
<li>1、超文本传输协议（<strong>HTTP</strong>):万维网的基本协议</li>
<li>2、文件传输（<strong>FTP</strong>文件传输协议）；</li>
<li>3、远程登录（<strong>Telnet</strong>），提供远程访问其它主机功能, 它允许用户登录internet主机，并在这台主机上执行命令</li>
<li>4、网络管理（<strong>SNMP</strong>简单网络管理协议），该协议提供了监控网络设备的方法， 以及配置管理,统计信息收集,性能管理及安全管理等</li>
<li>5、域名系统（<strong>DNS</strong>），该系统用于在internet中将域名及其公共广播的网络节点转换成IP地址</li>
</ul>
</li>
<li><p>传输层</p>
<ul>
<li>1、<strong>TCP</strong></li>
<li>2、<strong>UDP</strong></li>
</ul>
</li>
<li><p>网络层</p>
<ul>
<li>1、Internet协议（IP）</li>
<li>2、Internet控制信息协议（ICMP）</li>
<li>3、地址解析协议（ARP）ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。</li>
<li>4、反向地址解析协议（RARP）</li>
</ul>
</li>
<li><p>链路层</p>
<p>用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。</p>
<blockquote>
<p>OSI 七层模型</p>
</blockquote>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/6b87668471004dffbe71ee14b7bd8c8d~tplv-k3u1fbpfcp-watermark.gif" alt="img"></p>
<blockquote>
<p>附图 tcp段，IP分段 HTTP权威指南80页</p>
</blockquote>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E5%85%AD%E7%AB%A0IP%E5%88%86%E7%BB%84.jpeg" alt="HTTP权威指南第六章IP分组"></p>
</li>
</ul>
<h3 id="TCP-IP-通信传输流"><a href="#TCP-IP-通信传输流" class="headerlink" title="TCP&#x2F;IP 通信传输流"></a><strong>TCP&#x2F;IP</strong> 通信传输流</h3><p> 利用 TCP&#x2F;IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。 发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。</p>
<p> 这种把数据信息包装起来的做法称为<strong>封装</strong>（encapsulate），如下图所示</p>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/image-20210714153451934.png" alt="image-20210714153451934"></p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/170723f106ff0306~tplv-t2oaga2asx-watermark.gif" alt="img"></p>
<p> 头部至少20个字节</p>
<p>待整理</p>
<h4 id="TCP协议的特点"><a href="#TCP协议的特点" class="headerlink" title="TCP协议的特点"></a>TCP协议的特点</h4><h5 id="面向连接"><a href="#面向连接" class="headerlink" title="面向连接"></a>面向连接</h5><p>  面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</p>
<h5 id="仅支持单播传输"><a href="#仅支持单播传输" class="headerlink" title="仅支持单播传输"></a>仅支持单播传输</h5><p>  每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p>
<h5 id="面向字节流"><a href="#面向字节流" class="headerlink" title="面向字节流"></a>面向字节流</h5><p>  TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</p>
<h5 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h5><p>  对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的<strong>按序接收</strong>。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p>
<h5 id="提供拥塞控制"><a href="#提供拥塞控制" class="headerlink" title="提供拥塞控制"></a>提供拥塞控制</h5><p>  当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞</p>
<h5 id="TCP提供全双工通信"><a href="#TCP提供全双工通信" class="headerlink" title="TCP提供全双工通信"></a>TCP提供全双工通信</h5><p>  TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）</p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>  UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p>
<p>它有以下几个特点：</p>
<h4 id="1-面向无连接"><a href="#1-面向无连接" class="headerlink" title="1. 面向无连接"></a>1. 面向无连接</h4><p>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，<strong>不会对数据报文进行任何拆分和拼接操作</strong>。</p>
<p>具体来说就是：</p>
<ul>
<li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li>
<li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li>
</ul>
<h4 id="2-有单播，多播，广播的功能"><a href="#2-有单播，多播，广播的功能" class="headerlink" title="2. 有单播，多播，广播的功能"></a>2. 有单播，多播，广播的功能</h4><p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p>
<h4 id="3-UDP是面向报文的"><a href="#3-UDP是面向报文的" class="headerlink" title="3. UDP是面向报文的"></a>3. UDP是面向报文的</h4><p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p>
<h4 id="4-不可靠性"><a href="#4-不可靠性" class="headerlink" title="4. 不可靠性"></a>4. 不可靠性</h4><p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</p>
<p>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p>
<p>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/b20e3fe2fd2a486498a8683ff92fb69d~tplv-k3u1fbpfcp-watermark-20211220150615293.gif" alt="img"></p>
<p>从上面的动态图可以得知，UDP只会把想发的数据报文一股脑的丢给对方，并不在意数据有无安全完整到达。</p>
<h4 id="5-头部开销小，传输数据报文时是很高效的"><a href="#5-头部开销小，传输数据报文时是很高效的" class="headerlink" title="5. 头部开销小，传输数据报文时是很高效的"></a>5. 头部开销小，传输数据报文时是很高效的</h4><p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/49fcab711e4f43beb72f1b2d297bbf0f~tplv-k3u1fbpfcp-watermark-20211220150611420.gif" alt="img"></p>
<p>UDP 头部包含了以下几个数据：</p>
<ul>
<li>两个十六位的端口号，分别为源端口（可选字段）和目标端口 （4字节？）</li>
<li>整个数据报文的长度</li>
<li>整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误</li>
</ul>
<p><strong>因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的</strong></p>
<h3 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h3><table>
<thead>
<tr>
<th></th>
<th>UDP</th>
<th>TCP</th>
</tr>
</thead>
<tbody><tr>
<td>是否连接</td>
<td>无连接</td>
<td>面向连接</td>
</tr>
<tr>
<td>是否可靠</td>
<td>不可靠传输，不使用流量控制和拥塞控制</td>
<td>可靠传输，使用流量控制和拥塞控制</td>
</tr>
<tr>
<td>连接对象个数</td>
<td>支持一对一，一对多，多对一和多对多交互通信</td>
<td>只能是一对一通信</td>
</tr>
<tr>
<td>传输方式</td>
<td>面向报文</td>
<td>面向字节流</td>
</tr>
<tr>
<td>首部开销</td>
<td>首部开销小，仅8字节</td>
<td>首部最小20字节，最大60字节</td>
</tr>
<tr>
<td>适用场景</td>
<td>适用于实时应用（IP电话、视频会议、直播等）</td>
<td>适用于要求可靠传输的应用，例如文件传输</td>
</tr>
</tbody></table>
<h3 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h3><p>拥塞处理和流量控制不同，后者是作用于接收方，保证接收方来得及接受数据。而前者是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。</p>
<p>拥塞处理包括了四个算法，分别为：慢开始，拥塞避免，快速重传，快速恢复。</p>
<h4 id="慢开始算法"><a href="#慢开始算法" class="headerlink" title="慢开始算法"></a>慢开始算法</h4><p>慢开始算法，顾名思义，就是在传输开始时将发送窗口慢慢指数级扩大，从而避免一开始就传输大量数据导致网络拥塞。</p>
<p>慢开始算法步骤具体如下</p>
<ol>
<li>连接初始设置拥塞窗口（Congestion Window） 为 1 MSS（一个分段的最大数据量）</li>
<li>每过一个 RTT 就将窗口大小乘二</li>
<li>指数级增长肯定不能没有限制的，所以有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法。</li>
</ol>
<h4 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h4><p>拥塞避免算法相比简单点，每过一个 RTT 窗口大小只加一，这样能够避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值。</p>
<p>在传输过程中可能定时器超时的情况，这时候 TCP 会认为网络拥塞了，会马上进行以下步骤：</p>
<ul>
<li>将阈值设为当前拥塞窗口的一半</li>
<li>将拥塞窗口设为 1 MSS</li>
<li>启动拥塞避免算法</li>
</ul>
<h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>快速重传一般和快恢复一起出现。一旦接收端收到的报文出现失序的情况，接收端只会回复最后一个顺序正确的报文序号（没有 Sack 的情况下）。如果收到三个重复的 ACK，无需等待定时器超时再重发而是启动快速重传。具体算法分为两种：</p>
<p><strong>TCP Taho 实现如下</strong></p>
<ul>
<li>将阈值设为当前拥塞窗口的一半</li>
<li>将拥塞窗口设为 1 MSS</li>
<li>重新开始慢开始算法</li>
</ul>
<p><strong>TCP Reno 实现如下</strong></p>
<ul>
<li>拥塞窗口减半</li>
<li>将阈值设为当前拥塞窗口</li>
<li>进入快恢复阶段（重发对端需要的包，一旦收到一个新的 ACK 答复就退出该阶段）</li>
<li>使用拥塞避免算法</li>
</ul>
<h4 id="TCP-New-Ren-改进后的快恢复"><a href="#TCP-New-Ren-改进后的快恢复" class="headerlink" title="TCP New Ren 改进后的快恢复"></a>TCP New Ren 改进后的快恢复</h4><p><strong>TCP New Reno</strong> 算法改进了之前 <strong>TCP Reno</strong> 算法的缺陷。在之前，快恢复中只要收到一个新的 ACK 包，就会退出快恢复。</p>
<p>在 <strong>TCP New Reno</strong> 中，TCP 发送方先记下三个重复 ACK 的分段的最大序号。</p>
<p>假如我有一个分段数据是 1 ~ 10 这十个序号的报文，其中丢失了序号为 3 和 7 的报文，那么该分段的最大序号就是 10。发送端只会收到 ACK 序号为 3 的应答。这时候重发序号为 3 的报文，接收方顺利接收并会发送 ACK 序号为 7 的应答。这时候 TCP 知道对端是有多个包未收到，会继续发送序号为 7 的报文，接收方顺利接收并会发送 ACK 序号为 11 的应答，这时发送端认为这个分段接收端已经顺利接收，接下来会退出快恢复阶段。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>网络协议</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP的发展史</title>
    <url>/%E7%BD%91%E7%BB%9C/http%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2/</url>
    <content><![CDATA[<h3 id="http-0-9"><a href="#http-0-9" class="headerlink" title="http 0.9"></a>http 0.9</h3><p> HTTP&#x2F;0.9 是于 1991 年提出的，主要用于学术交流，需求很简单——用来在网络之间传递 HTML 超文本的内容，所以被称为<strong>超文本传输协议</strong></p>
<p> 总的来说，当时的需求很简单，就是用来传输体积很小的 HTML 文件，所以 HTTP&#x2F;0.9 的实现有以下三个特点。</p>
<ul>
<li><p>第一个是只有一个请求行，并没有<strong>HTTP 请求头和请求体</strong>，因为只需要一个请求行就可以完整表达客户端的需求了。</p>
</li>
<li><p>第二个是服务器也没有返回头信息，这是因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了。</p>
</li>
<li><p>第三个是返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输是最合适的。</p>
</li>
</ul>
<h3 id="http-1-0"><a href="#http-1-0" class="headerlink" title="http 1.0"></a>http 1.0</h3><p>万维网的高速发展带来了很多新的需求，而 HTTP&#x2F;0.9 已经不能适用新兴网络的发展，所以这时就需要一个新的协议来支撑新兴网络，这就是 HTTP&#x2F;1.0 诞生的原因。</p>
<ul>
<li>引入了请求头和响应头<ul>
<li>多类型数据</li>
<li>压缩方式</li>
<li>用户代理 user-agent</li>
</ul>
</li>
<li>引入了状态码</li>
<li>引入了cache机制</li>
</ul>
<h3 id="http-1-1"><a href="#http-1-1" class="headerlink" title="http 1.1"></a>http 1.1</h3><p>不过随着技术的继续发展，需求也在不断迭代更新，很快 HTTP&#x2F;1.0 也不能满足需求了，所以 HTTP&#x2F;1.1 又在 HTTP&#x2F;1.0 的基础之上做了大量的更新</p>
<ul>
<li><p><strong>改进持久连接</strong>（默认开启），<strong>它的特点是在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持</strong>。</p>
<blockquote>
<p>每个域名最多同时维护 6 个 TCP 持久连接</p>
</blockquote>
</li>
<li><p><strong>不成熟的 HTTP 管线化</strong>，如果 TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求，这就是著名的<strong>队头阻塞</strong>的问题</p>
<ul>
<li><p>HTTP&#x2F;1.1 中试图通过管线化的技术来解决<strong>队头阻塞</strong>的问题。HTTP&#x2F;1.1 中的管线化是指将多个 HTTP 请求整批提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。</p>
<blockquote>
<p>FireFox、Chrome 都做过管线化的试验，但是由于各种原因，它们最终都放弃了管线化技术。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>提供虚拟主机的支持</strong></p>
</li>
<li><p><strong>对动态生成的内容提供了完美支持</strong>，HTTP&#x2F;1.1 通过引入<strong>Chunk transfer 机制</strong>来解决这个问题，最后使用一个零长度的块作为发送数据完成的标志</p>
</li>
<li><p><strong>客户端 Cookie、安全机制</strong></p>
</li>
</ul>
<h3 id="http-2-0"><a href="#http-2-0" class="headerlink" title="http 2.0"></a>http 2.0</h3><h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a><strong>多路复用</strong></h4><p> 前面我们分析了 HTTP&#x2F;1.1 所存在的一些主要问题：慢启动和 TCP 连接之间相互竞争带宽是由于 TCP 本身的机制导致的，而队头阻塞是由于 HTTP&#x2F;1.1 的机制导致的。</p>
<p> HTTP&#x2F;2 的思路就是<strong>一个域名只使用一个 TCP 长连接来传输数据</strong>，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题</p>
<p> 另一个问题就是队头阻塞的问题，等待请求完成后才能去请求下一个资源，这种方式无疑是最慢的，所以 <strong>HTTP&#x2F;2 需要实现资源的并行请求</strong>，解决了<strong>应用层面的队头阻塞</strong>，也就是任何时候都可以将请求发送给服务器，而并不需要等待其他请求的完成，然后服务器也可以随时返回处理好的请求资源给浏览器</p>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/http%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2/image-20210803172922718.png" alt="image-20210803172922718"></p>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/http%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2/image-20210803173309562.png" alt="image-20210803173309562"></p>
<h4 id="http2分帧"><a href="#http2分帧" class="headerlink" title="http2分帧"></a>http2分帧</h4><p>帧是数据传输的最小单位，以二进制传输代替原本的明文传输，原本的报文消息被划分为更小的数据帧</p>
<h5 id="帧结构"><a href="#帧结构" class="headerlink" title="帧结构"></a>帧结构</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> +-----------------------------------------------+</span><br><span class="line"> |                 Length (24)                   |</span><br><span class="line"> +---------------+---------------+---------------+</span><br><span class="line"> |   Type (8)    |   Flags (8)   |</span><br><span class="line"> +-+-------------+---------------+-------------------------------+</span><br><span class="line"> |R|                 Stream Identifier (31)                      |</span><br><span class="line"> +=+=============================================================+</span><br><span class="line"> |                   Frame Payload (0...)                      ...</span><br><span class="line"> +---------------------------------------------------------------+</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>名称</th>
<th>长度</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Length</td>
<td>3 字节</td>
<td>表示帧负载的长度，取值范围为 （2 的 14 次方）至 （2 的 24 次方 - 1）。（2 的 14 次方） 16384 字节是默认的最大帧大小，如果需要更大的帧，必须在 SETTINGS 帧中设置</td>
</tr>
<tr>
<td>Type</td>
<td>1 字节</td>
<td>当前帧类型（见下表）</td>
</tr>
<tr>
<td>Flags</td>
<td>1 字节</td>
<td>具体帧类型的标识</td>
</tr>
<tr>
<td>R</td>
<td>1 位</td>
<td>保留位，不要设置，否则可能会带来严重的后果</td>
</tr>
<tr>
<td>Stream Identifier</td>
<td>31 位</td>
<td>每个流的唯一 ID</td>
</tr>
<tr>
<td>Frame Payload</td>
<td>长度可变</td>
<td>真实的帧内容，长度是在 Length 字段中设置的</td>
</tr>
</tbody></table>
<p>由于  HTTP&#x2F;2 是分帧的，请求和响应都可以多路复用，有助于解决类似类似队头阻塞的问题。</p>
<h5 id="帧类型"><a href="#帧类型" class="headerlink" title="帧类型"></a>帧类型</h5><table>
<thead>
<tr>
<th>名称</th>
<th>ID</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DATA</td>
<td>0x0</td>
<td>传输流的核心内容</td>
</tr>
<tr>
<td>HEADERS</td>
<td>0x1</td>
<td>包含 HTTP 首部，和可选的优先级参数</td>
</tr>
<tr>
<td>PRIORITY</td>
<td>0x2</td>
<td>指示或更改流的优先级和依赖</td>
</tr>
<tr>
<td>RST_STREAM</td>
<td>0x3</td>
<td>允许一端停止流（通常由于错误导致的）</td>
</tr>
<tr>
<td>SETTINGS</td>
<td>0x4</td>
<td>协商连接级参数</td>
</tr>
<tr>
<td>PUSH_PROMISE</td>
<td>0x5</td>
<td>提示客户端，服务器要推送些东西</td>
</tr>
<tr>
<td>PING</td>
<td>0x6</td>
<td>测试连接可用性和往返时延（RTT）</td>
</tr>
<tr>
<td>GOAWAY</td>
<td>0x7</td>
<td>告诉另一端，当前的端已结束</td>
</tr>
<tr>
<td>WINDOW_UPDATE</td>
<td>0x8</td>
<td>协商一端将要接收多少字节（用于流量控制）</td>
</tr>
<tr>
<td>CONTINUATION</td>
<td>0x9</td>
<td>用以扩展 HEADERS 模块</td>
</tr>
</tbody></table>
<h4 id="HTTP-2-其他特性"><a href="#HTTP-2-其他特性" class="headerlink" title="HTTP&#x2F;2 其他特性"></a><strong>HTTP&#x2F;2</strong> <strong>其他特性</strong></h4><ul>
<li>可以设置请求优先级</li>
<li>服务器推送</li>
<li>头部压缩</li>
</ul>
<h3 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h3><h4 id="应用层面"><a href="#应用层面" class="headerlink" title="应用层面"></a>应用层面</h4><p>在 <strong>HTTP&#x2F;1.1</strong> 中使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。</p>
<p>http 2通过对请求和响应进行编号的方式，实现资源并行请求解决了这个问题</p>
<h4 id="TCP层面"><a href="#TCP层面" class="headerlink" title="TCP层面"></a>TCP层面</h4><h5 id="http-1-1-1"><a href="#http-1-1-1" class="headerlink" title="http 1.1"></a>http 1.1</h5><p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/http%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2/image-20210805145222668.png" alt="image-20210805145222668"></p>
<p>通过上图你会发现，从一端发送给另外一端的数据会被拆分为一个个按照顺序排列的数据包，这些数据包通过网络传输到了接收端，接收端再按照顺序将这些数据包组合成原始数据，这样就完成了数据传输。</p>
<p>不过，如果在数据传输的过程中，有一个数据因为网络故障或者其他原因而丢包了，那么整个 TCP 的连接就会处于暂停状态，需要等待丢失的数据包被重新传输过来。你可以把 TCP连接看成是一个按照顺序传输数据的管道，管道中的任意一个数据丢失了，那之后的数据都需要等待该数据的重新传输。为了直观理解，你可以参考下图：</p>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/http%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2/image-20210805145256682.png" alt="image-20210805145256682"></p>
<p>我们就把<strong>在 TCP 传输过程中，由于单个数据包的丢失而造成的阻塞称为 TCP 上的队头阻塞</strong>。</p>
<h5 id="http-2-0-1"><a href="#http-2-0-1" class="headerlink" title="http 2.0"></a>http 2.0</h5><p>那队头阻塞是怎么影响 HTTP&#x2F;2 传输的呢？首先我们来看正常情况下 HTTP&#x2F;2 是怎么传输多路请求的，为了直观理解，你可以参考下图：</p>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/assets/http%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2/image-20230216173807167.png" alt="image-20230216173807167"></p>
<p><strong>通过该图，我们知道在 HTTP&#x2F;2 中，多个请求是跑在一个 TCP 管道中的，如果其中任意一路数据流中出现了丢包的情况，那么就会阻塞该 TCP 连接中的所有请求。这不同于HTTP&#x2F;1.1，使用 HTTP&#x2F;1.1 时，浏览器为每个域名开启了 6 个 TCP 连接，如果其中的 1个 TCP 连接发生了队头阻塞，那么其他的 5 个连接依然可以继续传输数据。</strong></p>
<p>所以随着丢包率的增加，HTTP&#x2F;2 的传输效率也会越来越差。有测试数据表明，当系统达到了 2% 的丢包率时，HTTP&#x2F;1.1 的传输效率反而比 HTTP&#x2F;2 表现得更好。</p>
<p>HTTP&#x2F;2 是通过分帧并且给每个帧打上流的 ID 去避免依次响应的问题，对方接收到帧之后根据 ID 拼接出流，这样就可以做到乱序响应从而避免请求时的队首阻塞问题。但是 TCP 层面的队首阻塞是 HTTP&#x2F;2 无法解决的（HTTP 只是应用层协议，TCP 是传输层协议），<strong>TCP 的阻塞问题是因为传输阶段可能会丢包，一旦丢包就会等待重新发包，阻塞后续传输，这个问题虽然有滑动窗口（Sliding Window）这个方案，但是只能增强抗干扰，并没有彻底解决。</strong></p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
        <tag>http0.9</tag>
        <tag>http1.0</tag>
        <tag>http1.1</tag>
        <tag>http2</tag>
        <tag>http3</tag>
      </tags>
  </entry>
  <entry>
    <title>类的多种继承方式</title>
    <url>/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E5%A4%9A%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>转载自<a href="https://github.com/mqyqingfeng/Blog">github</a> 参考JS高程</p>
<p>本文讲解JavaScript各种继承方式和优缺点。</p>
<p>但是注意：</p>
<p>这篇文章更像是笔记，哎，再让我感叹一句：《JavaScript高级程序设计》写得真是太好了！</p>
<h2 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1.原型链继承"></a>1.原型链继承</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Parent () &#123;</span><br><span class="line">    this.name = &#x27;kevin&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child () &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = new Parent();</span><br><span class="line"></span><br><span class="line">var child1 = new Child();</span><br><span class="line"></span><br><span class="line">console.log(child1.getName()) // kevin</span><br></pre></td></tr></table></figure>

<p>问题：</p>
<p>1.引用类型的属性被所有实例共享，举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Parent () &#123;</span><br><span class="line">    this.names = [&#x27;kevin&#x27;, &#x27;daisy&#x27;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child () &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = new Parent();</span><br><span class="line"></span><br><span class="line">var child1 = new Child();</span><br><span class="line"></span><br><span class="line">child1.names.push(&#x27;yayu&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(child1.names); // [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span><br><span class="line"></span><br><span class="line">var child2 = new Child();</span><br><span class="line"></span><br><span class="line">console.log(child2.names); // [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span><br></pre></td></tr></table></figure>

<p>2.在创建 Child 的实例时，不能向Parent传参</p>
<h2 id="2-借用构造函数-经典继承"><a href="#2-借用构造函数-经典继承" class="headerlink" title="2.借用构造函数(经典继承)"></a>2.借用构造函数(经典继承)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Parent () &#123;</span><br><span class="line">    this.names = [&#x27;kevin&#x27;, &#x27;daisy&#x27;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child () &#123;</span><br><span class="line">    Parent.call(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var child1 = new Child();</span><br><span class="line"></span><br><span class="line">child1.names.push(&#x27;yayu&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(child1.names); // [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span><br><span class="line"></span><br><span class="line">var child2 = new Child();</span><br><span class="line"></span><br><span class="line">console.log(child2.names); // [&quot;kevin&quot;, &quot;daisy&quot;]</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<p>1.避免了引用类型的属性被所有实例共享</p>
<p>2.可以在 Child 中向 Parent 传参</p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Parent (name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child (name) &#123;</span><br><span class="line">    Parent.call(this, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var child1 = new Child(&#x27;kevin&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(child1.name); // kevin</span><br><span class="line"></span><br><span class="line">var child2 = new Child(&#x27;daisy&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(child2.name); // daisy</span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<p>方法都在构造函数中定义，每次创建实例都会创建一遍方法。</p>
<h2 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3.组合继承"></a>3.组合继承</h2><p>原型链继承和经典继承双剑合璧。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Parent (name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child (name, age) &#123;</span><br><span class="line"></span><br><span class="line">    Parent.call(this, name);</span><br><span class="line">    </span><br><span class="line">    this.age = age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = new Parent();</span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line"></span><br><span class="line">var child1 = new Child(&#x27;kevin&#x27;, &#x27;18&#x27;);</span><br><span class="line"></span><br><span class="line">child1.colors.push(&#x27;black&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(child1.name); // kevin</span><br><span class="line">console.log(child1.age); // 18</span><br><span class="line">console.log(child1.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</span><br><span class="line"></span><br><span class="line">var child2 = new Child(&#x27;daisy&#x27;, &#x27;20&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(child2.name); // daisy</span><br><span class="line">console.log(child2.age); // 20</span><br><span class="line">console.log(child2.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</span><br></pre></td></tr></table></figure>

<p>优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。</p>
<h2 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4.原型式继承"></a>4.原型式继承</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function createObj(o) &#123;</span><br><span class="line">    function F()&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    return new F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。</p>
<p>缺点：</p>
<p>包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &#x27;kevin&#x27;,</span><br><span class="line">    friends: [&#x27;daisy&#x27;, &#x27;kelly&#x27;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 = createObj(person);</span><br><span class="line">var person2 = createObj(person);</span><br><span class="line"></span><br><span class="line">person1.name = &#x27;person1&#x27;;</span><br><span class="line">console.log(person2.name); // kevin</span><br><span class="line"></span><br><span class="line">person1.firends.push(&#x27;taylor&#x27;);</span><br><span class="line">console.log(person2.friends); // [&quot;daisy&quot;, &quot;kelly&quot;, &quot;taylor&quot;]</span><br></pre></td></tr></table></figure>

<p>注意：修改<code>person1.name</code>的值，<code>person2.name</code>的值并未发生改变，并不是因为<code>person1</code>和<code>person2</code>有独立的 name 值，而是因为<code>person1.name = &#39;person1&#39;</code>，给<code>person1</code>添加了 name 值，并非修改了原型上的 name 值。</p>
<h2 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5. 寄生式继承"></a>5. 寄生式继承</h2><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function createObj (o) &#123;</span><br><span class="line">    var clone = Object.create(o);</span><br><span class="line">    clone.sayName = function () &#123;</span><br><span class="line">        console.log(&#x27;hi&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    return clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。</p>
<h2 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6. 寄生组合式继承"></a>6. 寄生组合式继承</h2><p>为了方便大家阅读，在这里重复一下组合继承的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Parent (name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child (name, age) &#123;</span><br><span class="line">    Parent.call(this, name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = new Parent();</span><br><span class="line"></span><br><span class="line">var child1 = new Child(&#x27;kevin&#x27;, &#x27;18&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(child1)</span><br></pre></td></tr></table></figure>

<p>组合继承最大的缺点是会调用两次父构造函数。</p>
<p>一次是设置子类型实例的原型的时候：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Child.prototype = new Parent();</span><br></pre></td></tr></table></figure>

<p>一次在创建子类型实例的时候：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var child1 = new Child(&#x27;kevin&#x27;, &#x27;18&#x27;);</span><br></pre></td></tr></table></figure>

<p>回想下 new 的模拟实现，其实在这句中，我们会执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Parent.call(this, name);</span><br></pre></td></tr></table></figure>

<p>在这里，我们又会调用了一次 Parent 构造函数。</p>
<p>所以，在这个例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为<code>colors</code>，属性值为<code>[&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;]</code>。</p>
<p>那么我们该如何精益求精，避免这一次重复调用呢？</p>
<p>如果我们不使用 Child.prototype &#x3D; new Parent() ，而是间接的让 Child.prototype 访问到 Parent.prototype 呢？</p>
<p>看看如何实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function inheritPrototype(subType, superType) &#123;</span><br><span class="line">    let prototype = object(superType.prototype); // 创建对象</span><br><span class="line">    prototype.constructor = subType; // 增强对象 </span><br><span class="line">    subType.prototype = prototype; // 赋值对象</span><br><span class="line">  &#125;</span><br><span class="line">  function object(o) &#123; </span><br><span class="line">    function F() &#123;&#125; </span><br><span class="line">    F.prototype = o; </span><br><span class="line">    return new F(); </span><br><span class="line">  &#125;</span><br><span class="line">  function SuperType(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">  &#125;</span><br><span class="line">  SuperType.prototype.sayName = function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  function SubType(name, age) &#123;</span><br><span class="line">    SuperType.call(this, name);</span><br><span class="line">    this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  inheritPrototype(SubType, SuperType);</span><br><span class="line">  SubType.prototype.sayAge = function () &#123;</span><br><span class="line">    console.log(this.age);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>引用《JavaScript高级程序设计》中对寄生组合式继承的夸赞就是：</p>
<p>这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>
]]></content>
      <categories>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>class</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title>类的继承</title>
    <url>/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h2 id="ES5的继承"><a href="#ES5的继承" class="headerlink" title="ES5的继承"></a>ES5的继承</h2><p>首先我们创建一个简单的父类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">  this.name = name</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.say = function()&#123;</span><br><span class="line">  return &#x27;hi&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承父类<br><strong>首先有一点需要说明，constructor属于不可枚举的属性</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">constructor:</span><br><span class="line">  configurable: true</span><br><span class="line">  enumerable: false  // 不可枚举</span><br><span class="line">  value: ƒ Student(name, age)</span><br><span class="line">  writable: true</span><br></pre></td></tr></table></figure>

<ul>
<li>组合继承 最常用的继承</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Student(name, age)&#123;</span><br><span class="line">  //拓展一个实例属性 </span><br><span class="line">  Person.call(this, name); //其实很简单直接，就是调用一遍父类的this.x = x</span><br><span class="line">  this.age = age</span><br><span class="line">&#125;</span><br><span class="line">//将子类的原型对象指向Person的实例</span><br><span class="line">Student.prototype = new Person(); </span><br><span class="line">//将子类的原型对象的构造函数正确指回</span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line">//新增一个实例方法</span><br><span class="line">Student.prototype.sayAge = function()&#123;</span><br><span class="line">  return this.age</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>寄生组合继承  完美的继承</li>
</ul>
<p>JavaScript高程里的写法，<strong>需要借助两个辅助函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function inheritPrototype(subType, superType) &#123;</span><br><span class="line">    let prototype = object(superType.prototype); // 创建对象</span><br><span class="line">    prototype.constructor = subType; // 增强对象 </span><br><span class="line">    subType.prototype = prototype; // 赋值对象</span><br><span class="line">  &#125;</span><br><span class="line">  function object(o) &#123; </span><br><span class="line">    function F() &#123;&#125; </span><br><span class="line">    F.prototype = o; </span><br><span class="line">    return new F(); </span><br><span class="line">  &#125;</span><br><span class="line">  function SuperType(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">  &#125;</span><br><span class="line">  SuperType.prototype.sayName = function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  function SubType(name, age) &#123;</span><br><span class="line">    SuperType.call(this, name);</span><br><span class="line">    this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  inheritPrototype(SubType, SuperType);</span><br><span class="line">  SubType.prototype.sayAge = function () &#123;</span><br><span class="line">    console.log(this.age);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>下边是网上的变种（倒是能用）</p>
<p>第一种方式，感觉不太好</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Student(name, age)&#123;</span><br><span class="line">  Person.call(this, name);</span><br><span class="line">  this.age = age</span><br><span class="line">&#125;</span><br><span class="line">// Object.assign 无法复制继承属性及不可枚举的数据 以及get set函数</span><br><span class="line">Student.prototype = Object.assign(Object.create(Person.prototype), Student.prototype)</span><br><span class="line">// 所以需要重新赋值constructor,但是用这种方法constructor属性就变为可枚举属性了</span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line">Student.prototype.sayAge = function()&#123;</span><br><span class="line">  return this.age</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const student = new Student(&#x27;lucy&#x27;,30)</span><br><span class="line">console.log(student);</span><br></pre></td></tr></table></figure>

<p>第二种方式,可以解决枚举属性的问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Student.prototype = Object.create(Person.prototype, &#123;</span><br><span class="line">  constructor: &#123;</span><br><span class="line">    value: Student,</span><br><span class="line">    enumerable: false,</span><br><span class="line">    writable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125; </span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>

<p>第三种方式是我自己想的，结合<code>Object.getOwnPropertyDescriptors()</code><br>该函数的参数是<strong>Student.prototype</strong>，第一次写的时候忘了写<code>.prototype</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Student.prototype = Object.create(</span><br><span class="line">  Person.prototype, </span><br><span class="line">  Object.getOwnPropertyDescriptors(Student.prototype)</span><br><span class="line">) </span><br></pre></td></tr></table></figure>

<p>下图是控制台输出，左边是组合继承，右边是寄生组合继承<br><img src="/_posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/assets/%E7%BB%A7%E6%89%BF/bg2.png" alt="控制台输出">  </p>
<hr>
<blockquote>
<p>我们为什么要把子类的prototype<strong>指向父类的实例而不是父类的prototype</strong>呢<br>如果我们把子类的原型对象直接指向父类的原型对象，扩展子类会影响到父类  </p>
</blockquote>
<p>将子类的原型对象直接指向父类的原型对象，给子类添加额外的原型方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Student(name, age)&#123;</span><br><span class="line">  Person.call(this, name); </span><br><span class="line">  this.age = age</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = Person.prototype; </span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line">Student.prototype.sayAge = function()&#123;</span><br><span class="line">  return this.age</span><br><span class="line">&#125;;</span><br><span class="line">console.log(Person.prototype);</span><br><span class="line">console.log(Student.prototype);</span><br></pre></td></tr></table></figure>

<p><img src="/_posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/assets/%E7%BB%A7%E6%89%BF/bg1.png" alt="控制台结果"><br>我们可以看到父类的prototype已经被子类改变了，这明显不符合我们的目的</p>
<h2 id="ES5继承的帮助记忆"><a href="#ES5继承的帮助记忆" class="headerlink" title="ES5继承的帮助记忆"></a>ES5继承的帮助记忆</h2><p>子类的prototype必须是某个对象(这个对象的__proto__必须指向父类的prototype)  </p>
<p>满足这个条件的某个对象：</p>
<ul>
<li>父类的实例  组合继承</li>
<li>Object.create(父类.prototype) 寄生组合继承</li>
</ul>
<p>满足条件后子类的实例可以通过两个__proto__查找，访问到父类原型对象，即  </p>
<p><img src="/_posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/assets/%E7%BB%A7%E6%89%BF/bg4.png" alt="控制台输出"></p>
<h2 id="ES6的继承"><a href="#ES6的继承" class="headerlink" title="ES6的继承"></a>ES6的继承</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  constructor(name)&#123;</span><br><span class="line">    this.name = name //实例属性</span><br><span class="line">  &#125;</span><br><span class="line">  say()&#123; //原型方法</span><br><span class="line">    return &#x27;hi&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">  constructor(name, age)&#123;</span><br><span class="line">    super(name) </span><br><span class="line">    this.age = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const student = new Student(&#x27;lucy&#x27;,30)</span><br><span class="line">console.log(student);</span><br></pre></td></tr></table></figure>

<p>控制台输出与ES5寄生组合继承一致  </p>
<p><img src="/_posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/assets/%E7%BB%A7%E6%89%BF/bg3.png" alt="控制台结果">  </p>
]]></content>
      <categories>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>class</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title>工作中遇到的-小-问题记录</title>
    <url>/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/peacetime/</url>
    <content><![CDATA[<h2 id="1-有效解决setTimeout跨级传参数"><a href="#1-有效解决setTimeout跨级传参数" class="headerlink" title="1 有效解决setTimeout跨级传参数"></a>1 有效解决setTimeout跨级传参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">功能：修改 window.setTimeout，使之可以传递参数和对象参数 </span><br><span class="line">使用方法： setTimeout(回调函数,时间,参数1,...,参数n)</span><br></pre></td></tr></table></figure>

<h2 id="2-单击和双击的冲突问题"><a href="#2-单击和双击的冲突问题" class="headerlink" title="2 单击和双击的冲突问题"></a>2 单击和双击的冲突问题</h2><p>在一个对象同时绑定单击和双击事件时，当双击该对象时，事件发生顺序为 单击-单击-双击。<br>解决该问题可以通过定时器解决</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var TimeFn = null;</span><br><span class="line">$(&#x27;#box&#x27;).click(function () &#123;</span><br><span class="line">    clearTimeout(TimeFn);</span><br><span class="line">    TimeFn = setTimeout(function()&#123;</span><br><span class="line">        console.log(&#x27;click&#x27;)</span><br><span class="line">    &#125;,100);</span><br><span class="line">&#125;);</span><br><span class="line">$(&#x27;#box&#x27;).dblclick(function () &#123;</span><br><span class="line">    clearTimeout(TimeFn);</span><br><span class="line">    console.log(&#x27;dbclick&#x27;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当定时器延迟启动的时间小于300毫秒，第一个单击事件无法被抹消，发生事件为 单击-双击<br>（第二个单击事件和双击事件触发的时间隔间几乎为0，延迟时间对它没有影响）<br>当定时器延迟启动的事件大于300毫秒，第一个单击事件可以被抹消，发生事件为 双击</p>
<h2 id="3-jQuery-事件传参"><a href="#3-jQuery-事件传参" class="headerlink" title="3 jQuery 事件传参"></a>3 jQuery 事件传参</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;js/jquery-2.1.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    function Ceshi()&#123;</span><br><span class="line">      this.a=1;</span><br><span class="line">      this.b=2;</span><br><span class="line">      this.c=3;</span><br><span class="line">      this.d=4;    </span><br><span class="line">    &#125;</span><br><span class="line">    Ceshi.prototype.aa=function()&#123;</span><br><span class="line">      var _this=this;</span><br><span class="line">//    $(&#x27;input&#x27;).on(&#x27;click&#x27;,&#123;e:_this&#125;,this.bb) 用此方法可以拿到</span><br><span class="line">      $(&#x27;input&#x27;).on(&#x27;click&#x27;,this.bb).bind(this)</span><br><span class="line">    &#125;</span><br><span class="line">    Ceshi.prototype.bb=function(evt)&#123;               </span><br><span class="line">      console.log(this.b)// undefined</span><br><span class="line">//    console.log(_this.b) // _this is not defined</span><br><span class="line">//    console.log(evt.data.e.b)   //用此方法可以拿到</span><br><span class="line">//    console.log(evt.clientX)</span><br><span class="line">    &#125;</span><br><span class="line">    var demo=new Ceshi()</span><br><span class="line">    demo.aa()</span><br><span class="line">&lt;/script&gt;  </span><br></pre></td></tr></table></figure>

<h2 id="4-ajax-同步异步"><a href="#4-ajax-同步异步" class="headerlink" title="4 ajax 同步异步"></a>4 ajax 同步异步</h2><p>ajax异步请求，不会按上下顺序执行，注意数组操作，以防错位，可以使用同步</p>
<h2 id="5-利用元素记录信息"><a href="#5-利用元素记录信息" class="headerlink" title="5 利用元素记录信息"></a>5 利用元素记录信息</h2><p>利用JSON.stringfiy 可以将复杂json数据存入元素中，利用JSON.parse可以拿出</p>
<h2 id="6-窗口大小改变事件"><a href="#6-窗口大小改变事件" class="headerlink" title="6 窗口大小改变事件"></a>6 窗口大小改变事件</h2><p>window.onresize以最后一个函数为准， $(window).resize(function(){})，可以同时存在多个</p>
<h2 id="7-判断一个对象是否存在的方法"><a href="#7-判断一个对象是否存在的方法" class="headerlink" title="7 判断一个对象是否存在的方法"></a>7 判断一个对象是否存在的方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (typeof myObj == &quot;undefined&quot;) &#123;</span><br><span class="line">　var myObj = &#123; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这是目前使用最广泛的判断javascript对象是否存在的方法。</p>
</blockquote>
<h2 id="8-深拷贝函数，可以复制对象中的函数及数组（很全面）"><a href="#8-深拷贝函数，可以复制对象中的函数及数组（很全面）" class="headerlink" title="8 深拷贝函数，可以复制对象中的函数及数组（很全面）"></a>8 深拷贝函数，可以复制对象中的函数及数组（很全面）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function deepCopy(p, c) &#123;</span><br><span class="line">  var c = c || &#123;&#125;;</span><br><span class="line">  for (var i in p) &#123;</span><br><span class="line">    if(! p.hasOwnProperty(i))&#123;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof p[i] === &#x27;object&#x27;) &#123;</span><br><span class="line">      c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;;</span><br><span class="line">      deepCopy(p[i], c[i]);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      c[i] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent = &#123;name: &#x27;foo&#x27;, birthPlaces: [&#x27;北京&#x27;,&#x27;上海&#x27;,&#x27;香港&#x27;]&#125;</span><br><span class="line">var Child = deepCopy(Parent);</span><br></pre></td></tr></table></figure>

<h2 id="9-‘undefined’-和-undefined-使用区别"><a href="#9-‘undefined’-和-undefined-使用区别" class="headerlink" title="9  ‘undefined’ 和 undefined 使用区别"></a>9  ‘undefined’ 和 undefined 使用区别</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">     a:1, </span><br><span class="line">&#125;</span><br><span class="line">console.log(obj.b == &#x27;undefined&#x27;) //  false</span><br><span class="line">console.log(obj.b == undefined) //  true 判断元素属性是否存在的常用方法</span><br><span class="line">console.log(typeof obj.b ==&#x27;undefined&#x27;)  //true</span><br><span class="line">console.log(typeof ob)        //  &#x27;undefined&#x27;</span><br><span class="line">console.log(typeof ob == &#x27;undefined&#x27;) // true  此为最常用的判断元素是否存在的方法</span><br><span class="line">console.log(typeof ob == undefined) //  false</span><br></pre></td></tr></table></figure>

<h2 id="10-padding-bottom"><a href="#10-padding-bottom" class="headerlink" title="10 padding-bottom"></a>10 padding-bottom</h2><p>占位防止图片加载过程中的抖动 % 定义基于父元素宽度的百分比下内边距</p>
<h2 id="11-siblings-兄弟元素-且包括它本身"><a href="#11-siblings-兄弟元素-且包括它本身" class="headerlink" title="11 siblings() 兄弟元素 且包括它本身"></a>11 siblings() 兄弟元素 且包括它本身</h2><h2 id="12-撑开父元素宽度超过父元素外层宽度的方法"><a href="#12-撑开父元素宽度超过父元素外层宽度的方法" class="headerlink" title="12 撑开父元素宽度超过父元素外层宽度的方法"></a>12 撑开父元素宽度超过父元素外层宽度的方法</h2><p>父元素 white-space: nowrap;  内部元素 display: inline-block;</p>
<h2 id="13-pointer-events"><a href="#13-pointer-events" class="headerlink" title="13 pointer-events"></a>13 pointer-events</h2><p>更像是JavaScript，它能够：</p>
<ul>
<li>阻止用户的点击动作产生任何效果</li>
<li>阻止缺省鼠标指针的显示</li>
<li>阻止CSS里的 hover 和 active 状态的变化触发事件</li>
<li>阻止JavaScript点击动作触发的事件<br>pointer-events: none 顾名思义，就是鼠标事件拜拜的意思。元素应用了该 CSS 属性，链接啊，点击啊什么的都变成了 “浮云牌酱油”。pointer-events: none 的作用是让元素实体 “虚化”。例如一个应用 pointer-events: none 的按钮元素，则我们在页面上看到的这个按钮，只是一个虚幻的影子而已，您可以理解为海市蜃楼，幽灵的躯体。当我们用手触碰它的时候可以轻易地没有任何感觉地从中穿过去。</li>
</ul>
<h2 id="14-switch需要注意的地方，没有break的情况"><a href="#14-switch需要注意的地方，没有break的情况" class="headerlink" title="14 switch需要注意的地方，没有break的情况"></a>14 switch需要注意的地方，没有break的情况</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function handle(num)&#123;</span><br><span class="line">  switch (num)&#123;</span><br><span class="line">    case 1:</span><br><span class="line">      console.log(1)</span><br><span class="line">    case 2:</span><br><span class="line">      console.log(2)</span><br><span class="line">    case 3:</span><br><span class="line">      console.log(3)</span><br><span class="line">    case 4:</span><br><span class="line">      console.log(4)</span><br><span class="line">    case 5:</span><br><span class="line">      console.log(5)</span><br><span class="line">    case 6:</span><br><span class="line">      console.log(6)</span><br><span class="line">    default:</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">handle(3)   // 3 4 5 6 </span><br></pre></td></tr></table></figure>

<p>没有break的情况下，从<strong>满足条件开始</strong>一直会向下执行，无视case，直至break停止</p>
<h2 id="15-设置position-absolute元素的宽高百分比时，并不是依据父元素的，而是依据定位参考的元素"><a href="#15-设置position-absolute元素的宽高百分比时，并不是依据父元素的，而是依据定位参考的元素" class="headerlink" title="15 设置position absolute元素的宽高百分比时，并不是依据父元素的，而是依据定位参考的元素"></a>15 设置position absolute元素的宽高百分比时，并不是依据父元素的，而是依据定位参考的元素</h2><h2 id="16-js中如何判断属性是对象实例中的属性还是原型中的属性"><a href="#16-js中如何判断属性是对象实例中的属性还是原型中的属性" class="headerlink" title="16 js中如何判断属性是对象实例中的属性还是原型中的属性"></a>16 js中如何判断属性是对象实例中的属性还是原型中的属性</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function hasPrototypeProperty(obj, name) &#123;</span><br><span class="line">  return !obj.hasOwnProperty(name) &amp;&amp; (name in obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当属性存在对象实例上的时候，函数返回false，表示该属性不是存在原型上，当属性存在原型上的时候，函数返回true。</p>
<h2 id="17-vue中-dispath-支持promise-和-commit"><a href="#17-vue中-dispath-支持promise-和-commit" class="headerlink" title="17 vue中 dispath(支持promise) 和 commit"></a>17 vue中 dispath(支持promise) 和 commit</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$store.dispatch(&#x27;LoginByUsername&#x27;, this.loginForm).then(() =&gt; &#123;</span><br><span class="line">  this.$router.push(&#123; path: &#x27;/&#x27; &#125;); //登录成功之后重定向到首页</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">  this.$message.error(err); //登录失败提示错误</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LoginByUsername(&#123; commit &#125;, userInfo) &#123;</span><br><span class="line">  const username = userInfo.username.trim()</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    loginByUsername(username, userInfo.password).then(response =&gt; &#123;</span><br><span class="line">      const data = response.data</span><br><span class="line">      Cookies.set(&#x27;Token&#x27;, response.data.token) //登录成功后将token存储在cookie之中</span><br><span class="line">      commit(&#x27;SET_TOKEN&#x27;, data.token)</span><br><span class="line">      resolve()</span><br><span class="line">    &#125;).catch(error =&gt; &#123;</span><br><span class="line">      reject(error)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18-变量提升也有优先级-函数声明-arguments-变量声明"><a href="#18-变量提升也有优先级-函数声明-arguments-变量声明" class="headerlink" title="18 变量提升也有优先级, 函数声明 &gt; arguments &gt; 变量声明"></a>18 变量提升也有优先级, 函数声明 &gt; arguments &gt; 变量声明</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(c);</span><br><span class="line">function c(a) &#123;</span><br><span class="line">  console.log(a);</span><br><span class="line">  var a = 3;</span><br><span class="line">&#125;</span><br><span class="line">//function c()&#123;...&#125;</span><br><span class="line">//案例2 </span><br><span class="line">console.log(c);</span><br><span class="line">var c = function (a) &#123;</span><br><span class="line">  console.log(a);</span><br><span class="line">  var a = 3;</span><br><span class="line">&#125;</span><br><span class="line">//undefined</span><br></pre></td></tr></table></figure>

<p>重复声明会被忽略</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">foo(); // 1</span><br><span class="line">var foo;</span><br><span class="line">function foo() &#123; console.log( 1 ); &#125;</span><br><span class="line">foo = function() &#123; console.log( 2 ); &#125;;</span><br></pre></td></tr></table></figure>

<p>注意，var foo 尽管出现在 function foo()… 的声明之前，<strong>但它是重复的声明（因此被忽略了）</strong>，因为函数声明会被提升到普通变量之前。</p>
<blockquote>
<p>看一下你所不知道的JavaScript上 40页</p>
</blockquote>
<h2 id="19-npx讲解"><a href="#19-npx讲解" class="headerlink" title="19 npx讲解"></a>19 npx讲解</h2><p>npx 会帮你执行依赖包里的二进制文件<br>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i webpack -D      //非全局安装</span><br><span class="line">//如果要执行 webpack 的命令</span><br><span class="line">./node_modules/.bin/webpack -v</span><br></pre></td></tr></table></figure>

<p>有了 npx 之后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i webpack -D    //非全局安装</span><br><span class="line">npx webpack -v </span><br></pre></td></tr></table></figure>

<p>npx 会自动查找当前依赖包中的可执行文件，如果找不到，就会去 PATH 里找。如果依然找不到，就会帮你安装。</p>
<blockquote>
<p>使用package.json中的script命令，也会优先使用依赖包里的二进制文件</p>
</blockquote>
<h2 id="20-引用图片-两种方式都可以"><a href="#20-引用图片-两种方式都可以" class="headerlink" title="20 引用图片,两种方式都可以"></a>20 引用图片,两种方式都可以</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const url = require(&#x27;./bg.jpg&#x27;)</span><br><span class="line">import url from &#x27;./bg.jpg&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="21-ES6类和TS类的区别记忆"><a href="#21-ES6类和TS类的区别记忆" class="headerlink" title="21 ES6类和TS类的区别记忆"></a>21 ES6类和TS类的区别记忆</h2><h3 id="ES6类的写法"><a href="#ES6类的写法" class="headerlink" title="ES6类的写法"></a>ES6类的写法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  name = &#x27;aaa&#x27; //可以用此方式定义实例属性初始值</span><br><span class="line">  constructor(name)&#123;</span><br><span class="line">    this.name = name //实例属性</span><br><span class="line">  &#125;</span><br><span class="line">  say()&#123; //原型方法</span><br><span class="line">    return this.name</span><br><span class="line">  &#125;</span><br><span class="line">  //不需要符号间隔</span><br><span class="line">  eat()&#123;</span><br><span class="line">    return &#x27;food&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  //静态方法，不会被实例继承，只能通过Person.destroyed()调用，可以被子类继承</span><br><span class="line">  static destroyed() &#123; </span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  //类的内部所有定义的方法，与ES5不同，都是不可枚举的（non-enumerable）</span><br><span class="line">&#125;</span><br><span class="line">//仅可以用下述方式添加原型属性</span><br><span class="line">Person.prototype.prop = &#x27;prop&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="TS类的写法"><a href="#TS类的写法" class="headerlink" title="TS类的写法"></a>TS类的写法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 传统写法</span><br><span class="line">class Person &#123;</span><br><span class="line">  public name: string; //实例属性</span><br><span class="line">  constructor(name: string) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  say()&#123; //原型方法</span><br><span class="line">    return this.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 简化写法</span><br><span class="line">class Person &#123; </span><br><span class="line">  constructor(public name: string) &#123; //实例属性</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  say()&#123; //原型方法</span><br><span class="line">    return this.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TS类 有不同的访问类型</p>
<ul>
<li>private, protected, public 访问类型<ul>
<li>public 完全开放使用</li>
<li>private 仅允许在类内被使用</li>
<li>protected 仅允许在类内及继承的子类中使用</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  public name: string; //不写constructor 实例属性name压根不存在</span><br><span class="line">  constructor(name: string) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  protected sayHi() &#123;</span><br><span class="line">    this.name;</span><br><span class="line">    console.log(&#x27;hi&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">  private sayABC() &#123;</span><br><span class="line">    this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ES6类的继承"><a href="#ES6类的继承" class="headerlink" title="ES6类的继承"></a>ES6类的继承</h3><p>详细书写在分类继承下</p>
<h2 id="22-TS转义代码中发现的-的骚操作"><a href="#22-TS转义代码中发现的-的骚操作" class="headerlink" title="22 TS转义代码中发现的,的骚操作"></a>22 TS转义代码中发现的<code>,</code>的骚操作</h2><p>原代码较为复杂，用下方简化代码示意</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function handle(a, b)&#123;</span><br><span class="line">  console.log(a+b);</span><br><span class="line">&#125;</span><br><span class="line">var d = 4</span><br><span class="line">var c = ((handle(1, 2)), d)</span><br><span class="line">console.log(c);</span><br><span class="line">//3</span><br><span class="line">//4</span><br></pre></td></tr></table></figure>

<blockquote>
<p>程序会先执行逗号之前的语句，然后把逗号之后的语句赋值<br>必须要加外层的括号</p>
</blockquote>
<h2 id="error类无法直观的打印，可以借用下列方法"><a href="#error类无法直观的打印，可以借用下列方法" class="headerlink" title="error类无法直观的打印，可以借用下列方法"></a>error类无法直观的打印，可以借用下列方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (const key of Object.keys(error)) &#123;</span><br><span class="line">  console.log(error[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vue中事件绑定的this指向"><a href="#vue中事件绑定的this指向" class="headerlink" title="vue中事件绑定的this指向"></a>vue中事件绑定的this指向</h2><p>下面是从vue单文件中methods方法中截取的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">addPointMove() &#123;</span><br><span class="line">  this.$refs[&quot;preview-img&quot;].addEventListener(&quot;mousedown&quot;, this.mouseDownHandle);</span><br><span class="line">  document.addEventListener(&quot;mouseup&quot;, this.mouseUpHandle);</span><br><span class="line">  this.$refs[&quot;preview-img&quot;].onclick = function () &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">  &#125;;</span><br><span class="line">  this.$refs[&quot;preview-img&quot;].addEventListener(&quot;click&quot;, this.ceshi1);</span><br><span class="line">  this.$refs[&quot;preview-img&quot;].addEventListener(&quot;click&quot;, this.ceshi2);</span><br><span class="line">  this.$refs[&quot;preview-img&quot;].addEventListener(&quot;click&quot;, this.ceshi3);</span><br><span class="line">&#125;,</span><br><span class="line">ceshi1() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;,</span><br><span class="line">ceshi2: function () &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;,</span><br><span class="line">ceshi3: () =&gt; &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>当点击click后，控制台输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 this.$refs[&quot;preview-img&quot;]</span><br><span class="line">2 vue实例</span><br><span class="line">3 vue实例</span><br><span class="line">4 undefined</span><br></pre></td></tr></table></figure>

<h2 id="async的错误捕捉"><a href="#async的错误捕捉" class="headerlink" title="async的错误捕捉"></a>async的错误捕捉</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function main() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const val1 = await 1;</span><br><span class="line">    const val2 = await 2;</span><br><span class="line">    await Promise.reject(new Error(&quot;222&quot;))</span><br><span class="line">    const val3 = await 3;</span><br><span class="line">    console.log(&#x27;Final: &#x27;, val3);</span><br><span class="line">  &#125;</span><br><span class="line">  catch (err) &#123;</span><br><span class="line">    console.error(err);</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(111);</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<p>运行至reject，try模块内的代码就停止了，然后运行catch代码块，之后正常运行<br>Error: 222<br>111  </p>
<h2 id="require-一个图片资源出现的问题"><a href="#require-一个图片资源出现的问题" class="headerlink" title="require 一个图片资源出现的问题"></a>require 一个图片资源出现的问题</h2><p>我在项目中书写一个头部组件的时候，需要动态引入背景图片</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">backgroundImage: &quot;url(&quot; + require(&quot;../assets/rwkb.png&quot;) + &quot;)&quot;</span><br></pre></td></tr></table></figure>

<p>写法是对的，但是死活出不来，我真是百思不得其解、、、后来发现打印出来的资源<br><img src="/_posts/%E9%97%AE%E9%A2%98%E7%A7%AF%E7%B4%AF/assets/peacetime/require1.png" alt="资源"></p>
<hr>
<p>然后我抱着试一试的态度多写了一个<code>.default</code>竟然成功了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">backgroundImage: &quot;url(&quot; + require(&quot;../../assets/img/rwkb.png&quot;).default + &quot;)&quot;</span><br></pre></td></tr></table></figure>

<p>后来我在另一个项目里打印</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(require(&quot;@/assets/img/401.png&quot;));</span><br></pre></td></tr></table></figure>

<p>控制台输出 <code>/img/401.abca6a5b.png</code></p>
<h2 id="element-ui-form表单动态验证"><a href="#element-ui-form表单动态验证" class="headerlink" title="element ui form表单动态验证"></a>element ui form表单动态验证</h2><p><img src="/_posts/%E9%97%AE%E9%A2%98%E7%A7%AF%E7%B4%AF/assets/peacetime/form1.jpg" alt="资源"><br><img src="/_posts/%E9%97%AE%E9%A2%98%E7%A7%AF%E7%B4%AF/assets/peacetime/form2.jpg" alt="资源"><br>切换某一个选项后，会动态改变表单及需要校验的表单<br>项目中采用v-if v-else方法改变表单，但是form rules验证会失效，解决方法：<strong>给元素添加唯一KEY</strong>  </p>
<blockquote>
<p>产生bug的原因在于diff算法的复用</p>
</blockquote>
<h2 id="vue-响应式的注意点"><a href="#vue-响应式的注意点" class="headerlink" title="vue 响应式的注意点"></a>vue 响应式的注意点</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      obj1: &#123;</span><br><span class="line">        a: 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>没有任何方法能在初始化后添加根级别的响应式</p>
<ul>
<li>结合上方代码即无法添加obj1以外的响应式</li>
</ul>
</li>
<li><p>向存在的嵌套对象添加新的响应式 property，比如obj1，有下面两种方式</p>
<ol>
<li><p>Vue.set(object, propertyName, value)</p>
</li>
<li><p>this.someObject &#x3D; Object.assign({}, this.someObject, { a: 1, b: 2 })</p>
<blockquote>
<p>注意 Object.assign 第一个参数是  { }</p>
</blockquote>
</li>
</ol>
</li>
<li><h3 id="Vue-delete-target-propertyName-index"><a href="#Vue-delete-target-propertyName-index" class="headerlink" title="Vue.delete( target, propertyName&#x2F;index )"></a><a href="https://cn.vuejs.org/v2/api/#Vue-delete">Vue.delete( target, propertyName&#x2F;index )</a></h3><ul>
<li>不能删除根对象 例如obj1 可以删除obj1.xx</li>
</ul>
</li>
</ul>
<h2 id="element的table组件在flex布局下宽度自适应解决办法"><a href="#element的table组件在flex布局下宽度自适应解决办法" class="headerlink" title="element的table组件在flex布局下宽度自适应解决办法"></a>element的table组件在flex布局下宽度自适应解决办法</h2><p>给宽度一个99% 可以很简单的搞定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;tp-el-table-ex</span><br><span class="line">  class=&quot;table&quot;</span><br><span class="line">  ref=&quot;clickTable&quot;</span><br><span class="line">  border</span><br><span class="line">  highlight-current-row</span><br><span class="line">  :loading=&quot;tableLoading&quot;</span><br><span class="line">  :data=&quot;tableData&quot;</span><br><span class="line">  style=&quot;width: 99%;&quot;</span><br></pre></td></tr></table></figure>

<h2 id="input事件和change事件的区别"><a href="#input事件和change事件的区别" class="headerlink" title="input事件和change事件的区别"></a>input事件和change事件的区别</h2><ul>
<li><p>input事件：</p>
<blockquote>
<p>input事件在输入框输入的时候回实时响应并触发</p>
</blockquote>
</li>
<li><p>change事件：</p>
<blockquote>
<p>change事件在input失去焦点才会考虑触发，它的缺点是无法实时响应。与blur事件有着相似的功能，但与blur事件不同的是，change事件在输入框的值未改变时并不会触发，当输入框的值和上一次的值不同，并且输入框失去焦点，就会触发change事件。</p>
</blockquote>
</li>
</ul>
<h2 id="GC-垃圾回收机制"><a href="#GC-垃圾回收机制" class="headerlink" title="GC 垃圾回收机制"></a>GC 垃圾回收机制</h2><ul>
<li>引用计数 无法解决循环引用 基本上被淘汰了</li>
<li>标记清除 mark and sweep 也存在一定的局限（对象如果有一个属性经常使用，其余属性就无法被回收）</li>
</ul>
<h2 id="void-0"><a href="#void-0" class="headerlink" title="void 0"></a>void 0</h2><ul>
<li>viod 任何东西都会返回 <code>undefined</code>，之所以使用0，是因为void 0 是表达式中最短的  </li>
<li>undefined可以被重写，所以用 void 0 比较保险</li>
<li>不少 JavaScript 压缩工具在压缩过程中，正是将 undefined 用 void 0 代替掉了</li>
</ul>
<h2 id="URLSearchParams-Object-fromEntries"><a href="#URLSearchParams-Object-fromEntries" class="headerlink" title="URLSearchParams Object.fromEntries"></a>URLSearchParams Object.fromEntries</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.fromEntries(new URLSearchParams(‘foo=bar&amp;baz=qux’))</span><br><span class="line">// &#123; foo: “bar”, baz: “qux” &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="node-contains-otherNode"><a href="#node-contains-otherNode" class="headerlink" title="node.contains(otherNode)"></a>node.contains(otherNode)</h2><p>node 是否包含otherNode节点, otherNode 是否是node的后代节点<br>如果 otherNode 是 node 的后代节点或是 node 节点本身.则返回true , 否则返回 false.</p>
<h2 id="getComputedStyle-和-style的区别"><a href="#getComputedStyle-和-style的区别" class="headerlink" title="getComputedStyle 和 style的区别"></a>getComputedStyle 和 style的区别</h2><p>用法<br>let style &#x3D; window.getComputedStyle(element, [pseudoElt]);</p>
<ul>
<li><p>element 用于获取计算样式的Element。</p>
</li>
<li><p>pseudoElt 可选<br>指定一个要匹配的伪元素的字符串，例如’::after’，必须对普通元素省略（或null）。</p>
</li>
<li><p>只读与可写<br>getComputedStyle方法是只读的，只能获取样式，不能设置；而element.style能读能写，能屈能伸。</p>
</li>
<li><p>获取的对象范围<br>getComputedStyle方法获取的是最终应用在元素上的所有CSS属性对象（即使没有CSS代码，也会把默认的祖宗八代都显示出来）；而element.style只能获取元素style属性中的CSS样式。因此对于一个光秃秃的元素<p>，getComputedStyle方法返回对象中length属性值（如果有）就是190+(据我测试FF:192, IE9:195, Chrome:253, 不同环境结果可能有差异), 而element.style就是0。</p>
</li>
<li><p>作用<br>getComputedStyle方法有一个很重要的，类似css()方法没有的功能——获取伪类元素样式</p>
</li>
<li><p>兼容性<br>getComputedStyle方法IE6~8是不支持的</p>
</li>
</ul>
<h2 id="Math-floor-的另类写法"><a href="#Math-floor-的另类写法" class="headerlink" title="Math.floor 的另类写法"></a>Math.floor 的另类写法</h2><p>Math.floor((touch.y2 - touch.y1) &#x2F; ANCHOR_HEIGHT) &#x3D;&#x3D;&#x3D; Math.floor((touch.y2 - touch.y1) | 0</p>
<h2 id="取一段区间值的小技巧"><a href="#取一段区间值的小技巧" class="headerlink" title="取一段区间值的小技巧"></a>取一段区间值的小技巧</h2><p>如果需要参数范围控制在[min,max]之间，传统方法可能需要三个控制流，借助math函数可以这么写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arg = Math.max(min, Math.min(arg, max))</span><br></pre></td></tr></table></figure>

<p>即可以arg控制在[min, max] 范围内</p>
<h2 id="filter-和-backdrop-filter"><a href="#filter-和-backdrop-filter" class="headerlink" title="filter 和 backdrop-filter"></a>filter 和 backdrop-filter</h2><ul>
<li>backdrop-filter CSS 属性可以让你为一个元素后面区域添加图形效果（如模糊或颜色偏移）。 因为它适用于元素背后的所有元素，为了看到效果，必须使元素或其背景至少部分透明。</li>
<li>filter CSS属性将模糊或颜色偏移等图形效果应用于元素。滤镜通常用于调整图像，背景和边框的渲染。<br><a href="https://www.jb51.net/css/745019.html">详情</a></li>
</ul>
<h2 id="需要小范围闭环取值"><a href="#需要小范围闭环取值" class="headerlink" title="需要小范围闭环取值"></a>需要小范围闭环取值</h2><p>可以借助取余函数，例如type只有三种值 0 1 2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let type = 0 </span><br><span class="line">function changeType()&#123;</span><br><span class="line">  type = (type + 1) % 3</span><br><span class="line">&#125;</span><br><span class="line">for(var i = 0;i&lt;=100;i++)&#123;</span><br><span class="line">  changeType()</span><br><span class="line">  console.log(type) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果 0、1、2、0、1、2、0、1、2………….<br>适合闭环取值</p>
<h2 id="console-log-打印彩色"><a href="#console-log-打印彩色" class="headerlink" title="console.log 打印彩色"></a>console.log 打印彩色</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var message = &quot;Hello word&quot;;</span><br><span class="line">var color = &quot;red&quot;;</span><br><span class="line">   </span><br><span class="line">console.log(&quot;%c &quot; + message ,  &quot;color:&quot; + color);</span><br><span class="line">console.log(&quot;%c &quot; + message ,  &quot;color:&quot; + &quot;blue&quot;);</span><br><span class="line">console.log(&quot;%c &quot; + message ,  &quot;color:&quot; + &quot;yellow&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="element-动态rules"><a href="#element-动态rules" class="headerlink" title="element 动态rules"></a>element 动态rules</h2><p>form默认会在rules改变后，重新校验，有字段可以设置。需要注意数据变化和rules变化的先后顺序问题，会带来一些不可预见的bug，form有去除校验结果的办法</p>
<h2 id="arguments-和对应参数的绑定"><a href="#arguments-和对应参数的绑定" class="headerlink" title="arguments 和对应参数的绑定"></a>arguments 和对应参数的绑定</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo(name, age, sex, hobbit) &#123;</span><br><span class="line"></span><br><span class="line">    console.log(name, arguments[0]); // name name</span><br><span class="line"></span><br><span class="line">    // 改变形参</span><br><span class="line">    name = &#x27;new name&#x27;;</span><br><span class="line"></span><br><span class="line">    console.log(name, arguments[0]); // new name new name</span><br><span class="line"></span><br><span class="line">    // 改变arguments</span><br><span class="line">    arguments[1] = &#x27;new age&#x27;;</span><br><span class="line"></span><br><span class="line">    console.log(age, arguments[1]); // new age new age</span><br><span class="line"></span><br><span class="line">    // 测试未传入的是否会绑定</span><br><span class="line">    console.log(sex); // undefined</span><br><span class="line"></span><br><span class="line">    sex = &#x27;new sex&#x27;;</span><br><span class="line"></span><br><span class="line">    console.log(sex, arguments[2]); // new sex undefined</span><br><span class="line"></span><br><span class="line">    arguments[3] = &#x27;new hobbit&#x27;;</span><br><span class="line"></span><br><span class="line">    console.log(hobbit, arguments[3]); // undefined new hobbit</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(&#x27;name&#x27;, &#x27;age&#x27;)</span><br></pre></td></tr></table></figure>

<p>传入的参数，实参和 arguments 的值会共享，当没有传入时，实参与 arguments 值不会共享</p>
<p>除此之外，以上是在非严格模式下，如果是在严格模式下，实参和 arguments 是不会共享的。</p>
<h2 id="JSON-stringify-有第二个参数-replacer"><a href="#JSON-stringify-有第二个参数-replacer" class="headerlink" title="JSON.stringify 有第二个参数 replacer"></a>JSON.stringify 有第二个参数 replacer</h2><p>它可以是数组或者函数，用来指定对象序列化过程中哪些属性应该被处理，哪些应该被排除。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function replacer(key, value) &#123;</span><br><span class="line">  if (typeof value === &quot;string&quot;) &#123;</span><br><span class="line">    return undefined;</span><br><span class="line">  &#125;</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo = &#123;foundation: &quot;Mozilla&quot;, model: &quot;box&quot;, week: 45, transport: &quot;car&quot;, month: 7&#125;;</span><br><span class="line">var jsonString = JSON.stringify(foo, replacer);</span><br><span class="line"></span><br><span class="line">console.log(jsonString)</span><br><span class="line">// &#123;&quot;week&quot;:45,&quot;month&quot;:7&#125;</span><br><span class="line">var foo = &#123;foundation: &quot;Mozilla&quot;, model: &quot;box&quot;, week: 45, transport: &quot;car&quot;, month: 7&#125;;</span><br><span class="line">console.log(JSON.stringify(foo, [&#x27;week&#x27;, &#x27;month&#x27;]));</span><br><span class="line">// &#123;&quot;week&quot;:45,&quot;month&quot;:7&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个被序列化的对象拥有 toJSON 方法，那么该 toJSON 方法就会覆盖该对象默认的序列化行为：不是那个对象被序列化，而是调用 toJSON 方法后的返回值会被序列化，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  foo: &#x27;foo&#x27;,</span><br><span class="line">  toJSON: function () &#123;</span><br><span class="line">    return &#x27;bar&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">JSON.stringify(obj);      // &#x27;&quot;bar&quot;&#x27;</span><br><span class="line">JSON.stringify(&#123;x: obj&#125;); // &#x27;&#123;&quot;x&quot;:&quot;bar&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="inject-provide-响应式"><a href="#inject-provide-响应式" class="headerlink" title="inject provide 响应式"></a>inject provide 响应式</h2><p>provide使用函数可以实现响应式，看起来不像是能响应的样子。。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父</span></span><br><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">ceshiObj1</span>: &#123;</span><br><span class="line">      <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">provide</span> () &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">getInfo</span>: <span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="property">ceshiObj1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="title function_">testInject</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ceshiObj1</span>.<span class="property">a</span>++</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子</span></span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getInfo</span>().<span class="property">a</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="defer和async"><a href="#defer和async" class="headerlink" title="defer和async"></a>defer和async</h2><p>js的执行都会阻塞html parsing</p>
<p><img src="/_posts/%E9%97%AE%E9%A2%98%E7%A7%AF%E7%B4%AF/assets/peacetime/bVWhRl.png" alt="wfL82.png"></p>
<h2 id="bind函数的参数"><a href="#bind函数的参数" class="headerlink" title="bind函数的参数"></a>bind函数的参数</h2><p>直接看代码吧</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function resolve(res) &#123;</span><br><span class="line">  console.log(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bindHandle(...rest) &#123;</span><br><span class="line">  console.log(rest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const after = bindHandle.bind(null, resolve, &quot;promise&quot;)</span><br><span class="line"></span><br><span class="line">after(&quot;res&quot;,&quot;res2&quot;)</span><br><span class="line"></span><br><span class="line">[ [Function: resolve], &#x27;promise&#x27;, &#x27;res&#x27;, &#x27;res2&#x27; ]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>问题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>常用手写函数</title>
    <url>/%E9%9D%A2%E8%AF%95/selfFuc/</url>
    <content><![CDATA[<h2 id="call函数"><a href="#call函数" class="headerlink" title="call函数"></a>call函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Function.prototype.selfCall = function(context) &#123;</span><br><span class="line">  const ctx = context || window;</span><br><span class="line">  // 去除第一个参数</span><br><span class="line">  const arg = [...arguments].slice(1);</span><br><span class="line">  // const arg = Array.slice.call(arguments, 1);</span><br><span class="line">  // 将函数赋值给ctx.fnc </span><br><span class="line">  ctx.fnc = this;</span><br><span class="line">  // 执行函数</span><br><span class="line">  const res = ctx.fnc(...arg);</span><br><span class="line">  Reflect.deleteProperty(ctx, &quot;fnc&quot;)</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法借用了很多ES6的方法，让我们看一下比较原始的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Function.prototype.call2 = function (context) &#123;</span><br><span class="line">    var context = context || window;</span><br><span class="line">    context.fn = this;</span><br><span class="line"></span><br><span class="line">    var args = [];</span><br><span class="line">    for(var i = 1, len = arguments.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(&#x27;arguments[&#x27; + i + &#x27;]&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var result = eval(&#x27;context.fn(&#x27; + args +&#x27;)&#x27;);</span><br><span class="line"></span><br><span class="line">    delete context.fn</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="apply函数"><a href="#apply函数" class="headerlink" title="apply函数"></a>apply函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Function.prototype.selfApply = function (context) &#123;</span><br><span class="line">  const ctx = context || window;</span><br><span class="line">  ctx.fnc = this;</span><br><span class="line">  const arg = [...arguments].slice(1)[0];</span><br><span class="line">  // const arg = Array.slice.call(arguments, 1)[0];</span><br><span class="line">  const res = ctx.fnc(...arg)</span><br><span class="line">  Reflect.deleteProperty(ctx, &quot;fnc&quot;)</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不借用ES6</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Function.prototype.apply = function (context, arr) &#123;</span><br><span class="line">    var context = Object(context) || window;</span><br><span class="line">    context.fn = this;</span><br><span class="line"></span><br><span class="line">    var result;</span><br><span class="line">    if (!arr) &#123;</span><br><span class="line">        result = context.fn();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        var args = [];</span><br><span class="line">        for (var i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">            args.push(&#x27;arr[&#x27; + i + &#x27;]&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        result = eval(&#x27;context.fn(&#x27; + args + &#x27;)&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete context.fn</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于 Object(context) 原文是这么说的：</p>
<p>非严格模式下，指定为 null 或 undefined 时会自动指向全局对象，郑航写的是严格模式下的，我写的是非严格模式下的，实际上现在的模拟代码有一点没有覆盖，就是当值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。</p>
</blockquote>
<h2 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h2><ul>
<li>首先书写了一个简单的bind函数，并不包括 new 操作</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Function.prototype.myBind = function (ctx) &#123;</span><br><span class="line">  const args = [...arguments].slice(1)</span><br><span class="line">  const self = this</span><br><span class="line">  return function () &#123;</span><br><span class="line">    return self.apply(ctx, [...args, ...arguments])   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数效果的模拟实现 &#x2F;&#x2F; TODO</p>
<h2 id="new-操作符"><a href="#new-操作符" class="headerlink" title="new 操作符"></a>new 操作符</h2><p>首先分析一下 new 操作符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Student(name, age) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.age = age</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.say = function () &#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">var jojo = new Student(&quot;jsd&quot;, 23);</span><br></pre></td></tr></table></figure>

<p>从结果分析</p>
<ul>
<li>返回了一个对象，其实例属性是通过构造函数(Student)生成的</li>
<li>对象的<code>__proto__</code>指向Student.prototype</li>
<li>创建一个空对象obj（{}）</li>
<li>将obj的<code>[[prototype]]</code>属性指向构造函数constrc的原型（即<code>obj.[[prototype]]</code> &#x3D; constrc.prototype）。</li>
<li>将构造函数constrc内部的this绑定到新建的对象obj，执行constrc（也就是跟调用普通函数一样，只是此时函数的this为新创建的对象obj而已，就好像执行obj.constrc()一样）；</li>
<li>若构造函数没有返回非原始值（即不是引用类型的值），则返回该新建的对象obj（默认会添加return this）。否则，返回引用类型的值。</li>
</ul>
<p>官方解释</p>
<ul>
<li>创建一个空的简单JavaScript对象（即{}）；</li>
<li>链接该对象（设置该对象的constructor）到另一个对象 ；</li>
<li>将步骤1新创建的对象作为this的上下文 ；</li>
<li>如果该函数没有返回对象，则返回this。<br>实现方式如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function createClass(_Class, ...rest) &#123;</span><br><span class="line">  const obj = &#123;&#125;</span><br><span class="line">  const res = _Class.apply(obj, rest)</span><br><span class="line">  obj.__proto__ = _Class.prototype</span><br><span class="line">  return typeof res === &quot;object&quot; ? res : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用Object.create稍微简化一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function newFactorSimple(ctor) &#123;</span><br><span class="line">  const arg = [...arguments].slice(1);</span><br><span class="line">  // 生成一个__proto__指向ctor.prototype的对象</span><br><span class="line">  var obj = Object.create(ctor.prototype);</span><br><span class="line">  ctor.call(obj, ...arg);</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实构造函数内含有return语句时，结果会出现差异</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 例子4</span><br><span class="line">function Student(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    // Null（空） null</span><br><span class="line">    // Undefined（未定义） undefined</span><br><span class="line">    // Number（数字） 1</span><br><span class="line">    // String（字符串）&#x27;1&#x27;</span><br><span class="line">    // Boolean（布尔） true</span><br><span class="line">    // Symbol（符号）（第六版新增） symbol</span><br><span class="line">    </span><br><span class="line">    // Object（对象） &#123;&#125;</span><br><span class="line">        // Function（函数） function()&#123;&#125;</span><br><span class="line">        // Array（数组） []</span><br><span class="line">        // Date（日期） new Date()</span><br><span class="line">        // RegExp（正则表达式）/a/</span><br><span class="line">        // Error （错误） new Error() </span><br><span class="line">    // return /a/;</span><br><span class="line">&#125;</span><br><span class="line">var student = new Student(&#x27;若川&#x27;);</span><br><span class="line">console.log(student); &#123;name: &#x27;若川&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p>前面六种基本类型都会正常返回{name: ‘若川’}，后面的Object(包含Functoin, Array, Date, RegExg, Error)都会直接返回这些值<br><strong>下面是考虑到各种情况后的new实现</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 模拟实现 new 操作符</span><br><span class="line"> * @param  &#123;Function&#125; ctor [构造函数]</span><br><span class="line"> * @return &#123;Object|Function|Regex|Date|Error&#125;      [返回结果]</span><br><span class="line"> */</span><br><span class="line">function newOperator(ctor)&#123;</span><br><span class="line">    if(typeof ctor !== &#x27;function&#x27;)&#123;</span><br><span class="line">      throw &#x27;newOperator function the first param must be a function&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    // ES6 new.target 是指向构造函数</span><br><span class="line">    newOperator.target = ctor;</span><br><span class="line">    var newObj = Object.create(ctor.prototype);</span><br><span class="line">    // ES5 arguments转成数组 当然也可以用ES6 [...arguments], Aarry.from(arguments);</span><br><span class="line">    // 除去ctor构造函数的其余参数</span><br><span class="line">    var argsArr = [].slice.call(arguments, 1);</span><br><span class="line">    // 3.生成的新对象会绑定到函数调用的`this`。</span><br><span class="line">    // 获取到ctor函数返回结果</span><br><span class="line">    var ctorReturnResult = ctor.apply(newObj, argsArr);</span><br><span class="line">    // 小结4 中这些类型中合并起来只有Object和Function两种类型 typeof null 也是&#x27;object&#x27;所以要不等于null，排除null</span><br><span class="line">    var isObject = typeof ctorReturnResult === &#x27;object&#x27; &amp;&amp; ctorReturnResult !== null;</span><br><span class="line">    var isFunction = typeof ctorReturnResult === &#x27;function&#x27;;</span><br><span class="line">    if(isObject || isFunction)&#123;</span><br><span class="line">      return ctorReturnResult;</span><br><span class="line">    &#125;</span><br><span class="line">    // 5.如果函数没有返回对象类型`Object`(包含`Functoin`, `Array`, `Date`, `RegExg`, `Error`)，那么`new`表达式中的函数调用会自动返回这个新的对象。</span><br><span class="line">    return newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="create函数"><a href="#create函数" class="headerlink" title="create函数"></a>create函数</h2><p>很多框架源码作者使用它来初始化一个新的对象，难道是最佳实践？<br>原因有二  </p>
<ul>
<li>通过Object.create(null)创建出来的对象，没有任何属性，显示No properties。我们可以将其当成一个干净的 map 来使用，自主定义 toString,hasOwnProperty等方法，并且不必担心将原型链上的同名方法被覆盖。</li>
<li>{…}创建的对象，使用for in遍历对象的时候，会遍历原型链上的属性，带来性能上的损耗。使用Object.create(null)则不必再对其进行遍历了。<br><img src="/_posts/%E9%9D%A2%E8%AF%95/assets/selfFuc/write1.png" alt="两种方式的比较"></li>
</ul>
<p>手写Object.create</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function ObjCreate(proto, properties) &#123;</span><br><span class="line">  // 判断类型，第一个参数传入的必须是 object, function</span><br><span class="line">  if (typeof proto !== &quot;object&quot; &amp;&amp; typeof proto !== &quot;function&quot;) &#123;</span><br><span class="line">    throw new TypeError(&quot;Object prototype may only be an Object: &quot; + proto);</span><br><span class="line">  &#125; </span><br><span class="line">  // 简单的实现的过程，忽略了properties</span><br><span class="line">  var func = function() &#123;&#125;;</span><br><span class="line">  func.prototype = proto; // 将fn的原型指向传入的proto</span><br><span class="line">  return new func();  // 返回创建的新对象，这里思考下，new func() 又做了什么事情呢？且往下看！</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>new func()的作用是创建一个新的对象，其中func是一个构造函数，在这个过程中，主要包含了如下步骤：  </p>
<ul>
<li>创建空对象obj;</li>
<li>将obj的原型设置为构造函数的原型，obj.<strong>proto</strong>&#x3D; func.prototype;</li>
<li>以obj为上下文执行构造函数，func.call(obj);</li>
<li>返回obj对象。</li>
</ul>
<h2 id="手写promise"><a href="#手写promise" class="headerlink" title="手写promise"></a>手写promise</h2><p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<ul>
<li>对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</li>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li>
</ul>
<blockquote>
<p>摘自阮一峰ES6深入理解</p>
</blockquote>
<h3 id="引入三个问题"><a href="#引入三个问题" class="headerlink" title="引入三个问题"></a>引入三个问题</h3><p>这三个问题可以帮助理解</p>
<p>1、Promise 中为什么要引入微任务？</p>
<p>由于promise采用.then延时绑定回调机制，而new Promise时又需要直接执行promise中的方法，即发生了先执行方法后添加回调的过程，此时需等待then方法绑定两个回调后才能继续执行方法回调，便可将回调添加到当前js调用栈中执行结束后的任务队列中，由于宏任务较多容易堵塞，则采用了微任务</p>
<p>2、Promise 中是如何实现回调函数返回值穿透的？</p>
<p>首先Promise的执行结果保存在promise的data变量中，然后是.then方法返回值为使用resolved或rejected回调方法新建的一个promise对象，即例如成功则返回new Promise（resolved），将前一个promise的data值赋给新建的promise</p>
<p>3、Promise 出错后，是怎么通过“冒泡”传递给最后那个捕获</p>
<p>promise内部有resolved_和rejected_变量保存成功和失败的回调，进入.then（resolved，rejected）时会判断rejected参数是否为函数，若是函数，错误时使用rejected处理错误；若不是，则错误时直接throw错误，一直传递到最后的捕获，若最后没有被捕获，则会报错。可通过监听unhandledrejection事件捕获未处理的promise错误</p>
<h3 id="简单的promise"><a href="#简单的promise" class="headerlink" title="简单的promise"></a>简单的promise</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function MyPromise(executor) &#123;</span><br><span class="line">  var _this = this;</span><br><span class="line">  this._status = &quot;pending&quot;;</span><br><span class="line">  this._successCallBack = null;</span><br><span class="line">  this._errorCallBack = null;</span><br><span class="line">  var resolve = function (res) &#123;</span><br><span class="line">    if (_this._status === &quot;pending&quot;) &#123;</span><br><span class="line">      _this._status = &quot;fulfilled&quot;;</span><br><span class="line">      // 运行then函数传递过来的成功函数</span><br><span class="line">      // 并将结果作为参数回传</span><br><span class="line">      _this._successCallBack(res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  var reject = function (res) &#123;</span><br><span class="line">    if (_this._status === &quot;pending&quot;) &#123;</span><br><span class="line">      _this._status = &quot;rejected&quot;;</span><br><span class="line">      // 运行then函数传递过来的错误函数</span><br><span class="line">      // 并将结果作为参数回传</span><br><span class="line">      _this._errorCallBack(res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 把内部函数resolve, reject作为参数，把传进来的函数执行一遍</span><br><span class="line">  setTimeout(() =&gt; &#123; // 使用setTimeout 是让resolve晚于then方法赋值</span><br><span class="line">    executor(resolve, reject)</span><br><span class="line">  &#125;, 0)</span><br><span class="line">&#125;</span><br><span class="line">MyPromise.prototype.then = function (sucess, error) &#123;</span><br><span class="line">  this._successCallBack = sucess;</span><br><span class="line">  this._errorCallBack = error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="进阶的promise"><a href="#进阶的promise" class="headerlink" title="进阶的promise"></a>进阶的promise</h3><p>实现then的链式调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyPromise &#123;</span><br><span class="line">  PromiseResult = null; // 终值</span><br><span class="line">  PromiseState = &quot;pending&quot;; // 状态</span><br><span class="line">  toDoFulFilled = null;</span><br><span class="line">  toDoRejected = null;</span><br><span class="line">  // 构造方法</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    const resolve = (value) =&gt; &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&quot;resolve&quot;);</span><br><span class="line">        if (this.PromiseState !== &quot;pending&quot;) return;</span><br><span class="line">        this.PromiseState = &quot;fulfilled&quot;;</span><br><span class="line">        this.PromiseResult = value;</span><br><span class="line"></span><br><span class="line">        if (this.toDoFulFilled) &#123;</span><br><span class="line">          this.toDoFulFilled(this.PromiseResult);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, 0);</span><br><span class="line">    &#125;;</span><br><span class="line">    const reject = (reason) =&gt; &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        if (this.PromiseState !== &quot;pending&quot;) return;</span><br><span class="line">        this.PromiseState = &quot;rejected&quot;;</span><br><span class="line">        this.PromiseResult = reason;</span><br><span class="line"></span><br><span class="line">        if (this.toDoRejected) &#123;</span><br><span class="line">          this.toDoRejected(this.PromiseResult);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, 0);</span><br><span class="line">    &#125;;</span><br><span class="line">    // 执行传进来的函数</span><br><span class="line">    try &#123;</span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    return new MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">      const resolvePromise = (cb) =&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          // 这个prevRes 就是本次then的返回值</span><br><span class="line">          // cb 就是 onFulfilled  onRejected</span><br><span class="line">          const prevRes = cb(this.PromiseResult);</span><br><span class="line">          // TODO</span><br><span class="line">          if (prevRes instanceof MyPromise) &#123;</span><br><span class="line">            prevRes.then(resolve, reject);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            resolve(prevRes);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; catch (err) &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">          throw new Error(err);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      this.toDoFulFilled = resolvePromise.bind(this, onFulfilled);</span><br><span class="line">      this.toDoRejected = resolvePromise.bind(this, onRejected);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* const test1 = new MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(&quot;成功&quot;);</span><br><span class="line">&#125;).then(</span><br><span class="line">  (res) =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">  &#125;,</span><br><span class="line">  (error) =&gt; &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">); */</span><br><span class="line"></span><br><span class="line">const test2 = new MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&quot;定时器&quot;);</span><br><span class="line">  &#125;, 2000);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(</span><br><span class="line">    (res) =&gt; &#123;</span><br><span class="line">      console.log(res);</span><br><span class="line">      return res + &quot;链式调用&quot;;</span><br><span class="line">    &#125;,</span><br><span class="line">    (error) =&gt; &#123;</span><br><span class="line">      console.log(error);</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .then(</span><br><span class="line">    (res) =&gt; &#123;</span><br><span class="line">      console.log(res);</span><br><span class="line">    &#125;,</span><br><span class="line">    (error) =&gt; &#123;</span><br><span class="line">      console.log(error);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>

<h3 id="限制promise并发"><a href="#限制promise并发" class="headerlink" title="限制promise并发"></a>限制promise并发</h3><p>主要的点</p>
<ul>
<li>在then方法里启动下一次任务</li>
<li>while为了塞满队列</li>
<li>task是一个待启动的promise</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MaxDuty&#123;</span><br><span class="line">  used = 0</span><br><span class="line">  tasks = []</span><br><span class="line">  constructor(max) &#123;</span><br><span class="line">    this.max = max</span><br><span class="line">  &#125;</span><br><span class="line">  addTask(task) &#123;</span><br><span class="line">    this.tasks.push(task)</span><br><span class="line">  &#125;</span><br><span class="line">  walk() &#123;</span><br><span class="line">    if (this.tasks.length &amp;&amp; this.used &lt; this.max) &#123;</span><br><span class="line">      this.used++</span><br><span class="line">      const task = this.tasks.shift()</span><br><span class="line">      task().then(res =&gt; &#123;</span><br><span class="line">        console.log(res);</span><br><span class="line">        this.used--</span><br><span class="line">        this.walk()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  start() &#123;</span><br><span class="line">    // 需要塞满</span><br><span class="line">    while (this.used &lt; this.max) &#123;</span><br><span class="line">      this.walk()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 返回一个待启动的promise</span><br><span class="line">function createTask(time, order) &#123;</span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    return new Promise(resolve =&gt; &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        resolve(order)</span><br><span class="line">      &#125;, time);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const maxDuty = new MaxDuty(2)</span><br><span class="line"></span><br><span class="line">maxDuty.addTask(createTask(1000, 1))</span><br><span class="line">maxDuty.addTask(createTask(500, 2))</span><br><span class="line">maxDuty.addTask(createTask(300, 3))</span><br><span class="line">maxDuty.addTask(createTask(400, 4))</span><br><span class="line"></span><br><span class="line">maxDuty.start()</span><br></pre></td></tr></table></figure>

<h2 id="珂里化"><a href="#珂里化" class="headerlink" title="珂里化"></a>珂里化</h2><p>第一版 比较简单，也好理解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var curry = function (fn) &#123;</span><br><span class="line">  // 取到fn之后的参数</span><br><span class="line">  var args = [].slice.call(arguments, 1);</span><br><span class="line">  // 返回一个待使用的新函数</span><br><span class="line">  return function () &#123;</span><br><span class="line">    // 将新函数的参数 和 之前生成珂里化函数的参数合并</span><br><span class="line">    var newArgs = args.concat([].slice.call(arguments));</span><br><span class="line">    // 不改变this，使用所有参数进行调用</span><br><span class="line">    return fn.apply(this, newArgs);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var addCurry = curry(add, 1, 2);</span><br><span class="line">addCurry() // 3</span><br><span class="line">//或者</span><br><span class="line">var addCurry = curry(add, 1);</span><br><span class="line">addCurry(2) // 3</span><br><span class="line">//或者</span><br><span class="line">var addCurry = curry(add);</span><br><span class="line">addCurry(1, 2) // 3</span><br></pre></td></tr></table></figure>

<h3 id="固定参数"><a href="#固定参数" class="headerlink" title="固定参数"></a>固定参数</h3><p>第二版 稍微复杂一些，先看实现的效果会比较好理解一点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var fn = curry(function (a, b, c) &#123;</span><br><span class="line">  console.log([a, b, c]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fn(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fn(&quot;a&quot;, &quot;b&quot;)(&quot;c&quot;); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fn(&quot;a&quot;)(&quot;b&quot;)(&quot;c&quot;); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fn(&quot;a&quot;)(&quot;b&quot;, &quot;c&quot;); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>首先需要明确1点</strong></p>
<ul>
<li>参数的个数是确定的，这也是递归调用的截止条件</li>
</ul>
<p>来看实现过程</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="comment">// 形参的个数 </span></span><br><span class="line">  <span class="keyword">const</span> length = fn.<span class="property">length</span></span><br><span class="line">  <span class="keyword">let</span> args = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> argChild = [...args,...<span class="variable language_">arguments</span>]</span><br><span class="line">    <span class="keyword">if</span> (argChild.<span class="property">length</span> === length) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, argChild)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(argChild);</span></span><br><span class="line">      <span class="keyword">return</span> curry.<span class="title function_">call</span>(<span class="variable language_">this</span>, fn, ...argChild)</span><br><span class="line">      <span class="comment">// return curry.apply(this, fn, argChild)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn1 = <span class="title function_">curry</span>(<span class="keyword">function</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>([a, b, c]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn1</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>) <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="title function_">fn1</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)(<span class="string">&quot;c&quot;</span>) <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="title function_">fn1</span>(<span class="string">&quot;a&quot;</span>)(<span class="string">&quot;b&quot;</span>)(<span class="string">&quot;c&quot;</span>) <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="title function_">fn1</span>(<span class="string">&quot;a&quot;</span>)(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>) <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="title function_">curry</span>(<span class="keyword">function</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>([a, b, c]);</span><br><span class="line">&#125;, <span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn2</span>(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>) <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="title function_">fn2</span>(<span class="string">&quot;b&quot;</span>)(<span class="string">&quot;c&quot;</span>) <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="不固定参数"><a href="#不固定参数" class="headerlink" title="不固定参数"></a>不固定参数</h3><p>这种方法太刻意了，建议闲下来的时候看看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// fn(a,b,c) = fn(a)(b)(c)</span><br><span class="line">function curry(fn) &#123;</span><br><span class="line">    return function core(...args) &#123;</span><br><span class="line">        let params = []</span><br><span class="line">        params = params.concat(args)</span><br><span class="line">        let inner = function(...args2) &#123;</span><br><span class="line">            params = params.concat(args2)</span><br><span class="line">            return core.apply(this, params)</span><br><span class="line">        &#125;</span><br><span class="line">        inner.toString = ()=&gt;&#123;</span><br><span class="line">            return fn.apply(null, params)</span><br><span class="line">        &#125;</span><br><span class="line">        return inner</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function add(...args) &#123;</span><br><span class="line">    return args.reduce((prev,curr)=&gt;prev + curr, 0)</span><br><span class="line">&#125;</span><br><span class="line">let curriedAdd = curry(add)</span><br><span class="line">alert(curriedAdd(1,2,3))</span><br><span class="line"></span><br><span class="line">alert(curriedAdd(1, 2)(1, 2, 3))</span><br><span class="line">curriedAdd(1)(2)(3)(4)(5)</span><br></pre></td></tr></table></figure>

<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p><a href="https://github.com/mqyqingfeng/Blog/issues/22">参考</a></p>
<p>有一些需要注意的点，可以帮助理解函数，重点看代码中注释的地方</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    html, body &#123;</span><br><span class="line">      height: 100%;</span><br><span class="line">      width: 100%;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    var count = 1</span><br><span class="line">    function handle(event) &#123;</span><br><span class="line">      console.log(this);</span><br><span class="line">    &#125;</span><br><span class="line">    document.onmousemove = debounce(handle, 400)</span><br><span class="line"></span><br><span class="line">    function debounce(fn, wait) &#123;</span><br><span class="line">      var timer = null</span><br><span class="line">      return function () &#123;</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">        timer = setTimeout(</span><br><span class="line">         // 这么写 实际上没有效果</span><br><span class="line">          fn.apply(this, arguments),</span><br><span class="line">          // 下面的写法均有效果</span><br><span class="line">          fn.bind(this, arguments),</span><br><span class="line">     fn,</span><br><span class="line">          wait</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，setTimeout第一个参数需要是一个函数，而<code>fn.apply(this, arguments)</code>不能算一个函数</p>
<p>下面写一个比较标准的debounce，可以正确响应参数和this</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> function debounce(fn, wait) &#123;</span><br><span class="line">      var timer = null</span><br><span class="line">      return function () &#123;</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">        timer = setTimeout(</span><br><span class="line">          fn.bind(this, ...arguments),</span><br><span class="line">          wait</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> // 不使用es6</span><br><span class="line">function debounce(func, wait) &#123;</span><br><span class="line">    var timeout;</span><br><span class="line"></span><br><span class="line">    return function () &#123;</span><br><span class="line">        var context = this;</span><br><span class="line">        var args = arguments;</span><br><span class="line"></span><br><span class="line">        clearTimeout(timeout)</span><br><span class="line">        timeout = setTimeout(function()&#123;</span><br><span class="line">            func.apply(context, args)</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="立刻执行"><a href="#立刻执行" class="headerlink" title="立刻执行"></a>立刻执行</h3><p>这个时候，代码已经很是完善了，但是为了让这个函数更加完善，我们接下来思考一个新的需求。</p>
<p>这个需求就是：</p>
<p>我不希望非要等到事件停止触发后才执行，我希望<strong>立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行</strong>。</p>
<p>其实这个实现也算简单，主要是理解需求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function immedia(fn, wait) &#123;</span><br><span class="line">      var flag = true</span><br><span class="line">      var timer = null</span><br><span class="line">      return function () &#123;</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">        // 保证不在触发后wait时间后，可以再次被触发</span><br><span class="line">        timer = setTimeout(</span><br><span class="line">          function () &#123;</span><br><span class="line">            flag = true</span><br><span class="line">          &#125;,</span><br><span class="line">          wait</span><br><span class="line">        )</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">         // 触发后 开启保护</span><br><span class="line">          flag = false</span><br><span class="line">          fn.apply(this, arguments)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>写在一个函数里，也很简单</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function debounce(fn, wait, immediate) &#123;</span><br><span class="line">     var timer = null</span><br><span class="line">     if(immediate)&#123;</span><br><span class="line">       var flag = true</span><br><span class="line">       return function () &#123;</span><br><span class="line">         clearTimeout(timer)</span><br><span class="line">         timer = setTimeout(</span><br><span class="line">           function () &#123;</span><br><span class="line">             flag = true</span><br><span class="line">           &#125;,</span><br><span class="line">           wait</span><br><span class="line">         )</span><br><span class="line">         if(flag)&#123;</span><br><span class="line">           flag = false</span><br><span class="line">           fn.apply(this, arguments)</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">       return function () &#123;</span><br><span class="line">         clearTimeout(timer)</span><br><span class="line">         timer = setTimeout(</span><br><span class="line">           fn.bind(this, ...arguments),</span><br><span class="line">           wait</span><br><span class="line">         )</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>节流的原理很简单：</p>
<p>如果你持续触发事件，每隔一段时间，只执行一次事件。</p>
<p>关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器。</p>
<h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function throttle(fn, wait) &#123;</span><br><span class="line">  const previous = 0;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    const now = new Date().getTime()</span><br><span class="line">    if (now - previous &gt; wait) &#123;</span><br><span class="line">      previous = now</span><br><span class="line">    &#125;</span><br><span class="line">    fn.apply(this, arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function throttle(fn, wait) &#123;</span><br><span class="line">     let flag = true</span><br><span class="line">     return function () &#123;</span><br><span class="line">       if (flag) &#123;</span><br><span class="line">         flag = false</span><br><span class="line">         fn.apply(this, arguments)</span><br><span class="line">         setTimeouto=(function () &#123;</span><br><span class="line">           flag = true</span><br><span class="line">         &#125;,wait)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="deepclone"><a href="#deepclone" class="headerlink" title="deepclone"></a>deepclone</h2><p>先看一个足够用的版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function deepClone(obj) &#123;</span><br><span class="line">  if (obj === &#x27;null&#x27;) return null</span><br><span class="line">  if (typeof obj !== &#x27;object&#x27;) return obj</span><br><span class="line">  if (obj instanceof RegExp) return new RegExp(obj)</span><br><span class="line">  if (obj instanceof Date) return new Date(obj)</span><br><span class="line">  let result = new obj.constructor</span><br><span class="line">  for (let key in obj) &#123;</span><br><span class="line">    if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">     result[key] = deepClone(obj[key]) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 上面的for循环可以改成</span><br><span class="line">  // Reflect.ownKeys(key =&gt; result[key] = deepClone(obj[key])</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先实现一个简单clone，包括对象 数组和基本类型的clone</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function deepClone(target) &#123;</span><br><span class="line">  if (typeof target !== &quot;object&quot;) &#123;</span><br><span class="line">    return target</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    const copy = Array.isArray(target) ? [] : &#123;&#125;</span><br><span class="line">    for (const key in target) &#123;</span><br><span class="line">      copy[key] = deepClone(target[key])</span><br><span class="line">    &#125;</span><br><span class="line">    return copy</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果出现循环引用，就会栈溢出，如何解决这个问题呢，需要借助map数据结构</p>
<p>解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题。</p>
<p>这个存储空间，需要可以存储<code>key-value</code>形式的数据，且<code>key</code>可以是一个引用类型，我们可以选择<code>Map</code>这种数据结构：</p>
<ul>
<li>检查<code>map</code>中有无克隆过的对象</li>
<li>有 - 直接返回</li>
<li>没有 - 将当前对象作为<code>key</code>，克隆对象作为<code>value</code>进行存储</li>
<li>继续克隆</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function deepClone(target) &#123;</span><br><span class="line">  const map = new Map();</span><br><span class="line">  return (function _clone(target) &#123;</span><br><span class="line">    if (typeof target !== &quot;object&quot;) &#123;</span><br><span class="line">      return target</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (map.has(target)) &#123;</span><br><span class="line">        return target</span><br><span class="line">      &#125;</span><br><span class="line">      map.set(target, null)</span><br><span class="line">      const copy = Array.isArray(target) ? [] : &#123;&#125;</span><br><span class="line">      for (const key in target) &#123;</span><br><span class="line">        copy[key] = _clone(target[key])</span><br><span class="line">      &#125;</span><br><span class="line">      return copy</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(target)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const target = &#123;</span><br><span class="line">  field1: 1,</span><br><span class="line">  field2: undefined,</span><br><span class="line">  field3: &#123;</span><br><span class="line">      child: &#x27;child&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  field4: [2, 4, 8]</span><br><span class="line">&#125;;</span><br><span class="line">target.target = target</span><br><span class="line">console.log(deepClone(target));</span><br></pre></td></tr></table></figure>

<p>控制台结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  field1: 1,</span><br><span class="line">  field2: undefined,</span><br><span class="line">  field3: &#123; child: &#x27;child&#x27; &#125;,</span><br><span class="line">  field4: [ 2, 4, 8 ],</span><br><span class="line">  target: &lt;ref *1&gt; &#123;</span><br><span class="line">    field1: 1,</span><br><span class="line">    field2: undefined,</span><br><span class="line">    field3: &#123; child: &#x27;child&#x27; &#125;,</span><br><span class="line">    field4: [ 2, 4, 8 ],</span><br><span class="line">    target: [Circular *1]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>circular</code>表示循环引用的意思，把Map换成weakMap，Map有强引用，不利用垃圾收集</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>手写函数</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS加密过程简介</title>
    <url>/%E7%BD%91%E7%BB%9C/https%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p><a href="https://juejin.cn/post/6844903795776815117">简洁易懂</a></p>
<p><a href="https://juejin.cn/post/6844904127420432391">详细介绍</a></p>
<p> https加密过程详细介绍，其中用到堆成加密和非对称加密和CA数字证书</p>
<ul>
<li><p>用户在浏览器发起HTTPS请求（如 <a href="https://juejin.cn/user/747323638163768">juejin.cn</a>），默认使用服务端的443端口进行连接；</p>
</li>
<li><p>HTTPS需要使用一套<strong>CA数字证书</strong>，证书内会附带一个<strong>公钥Pub</strong>，而与之对应的<strong>私钥Private</strong>保留在服务端不公开；</p>
</li>
<li><p>服务端收到请求，返回配置好的包含<strong>公钥Pub</strong>的证书给客户端；</p>
</li>
<li><p>客户端收到<strong>证书</strong>，校验合法性，主要包括是否在有效期内、证书的域名与请求的域名是否匹配，上一级证书是否有效（递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，则显示HTTPS警告信息，如果通过则继续；</p>
</li>
<li><p>客户端生成一个用于对称加密的<strong>随机Key</strong>，并用证书内的<strong>公钥Pub</strong>进行加密，发送给服务端；</p>
</li>
<li><p>服务端收到<strong>随机Key</strong>的密文，使用与<strong>公钥Pub</strong>配对的<strong>私钥Private</strong>进行解密，得到客户端真正想发送的<strong>随机Key</strong>；</p>
</li>
<li><p>服务端使用客户端发送过来的<strong>随机Key</strong>对要传输的HTTP数据进行对称加密，将密文返回客户端；</p>
</li>
<li><p>客户端使用<strong>随机Key</strong>对称解密密文，得到HTTP数据明文；</p>
</li>
<li><p>后续HTTPS请求使用之前交换好的<strong>随机Key</strong>进行对称加解密。</p>
</li>
</ul>
<p>如何保证数字证书的可靠性？</p>
<ol>
<li>CA机构拥有自己的一对公钥和私钥</li>
<li>CA机构在颁发证书时对证书明文信息进行哈希<ol>
<li>包含有证书持有者、证书有效期、公钥等信息</li>
</ol>
</li>
<li>将哈希值用私钥进行<strong>加签</strong>，得到数字签名</li>
<li>明文数据和数字签名组成证书，传递给客户端。</li>
<li>客户端得到证书，分解成明文部分Text和数字签名Sig1</li>
<li>用CA机构的公钥进行<strong>解签</strong>，得到Sig2（也就是CA机构对证书明文进行hash后的值）（由于CA机构是一种公信身份，因此在系统或浏览器中会内置CA机构的证书和公钥信息）</li>
<li>用证书里声明的哈希算法对明文Text部分进行哈希得到T</li>
<li>当自己计算得到的哈希值T与<strong>解签</strong>后的Sig2<strong>相等</strong>，表示证书可信，<strong>没有被篡改</strong></li>
</ol>
<blockquote>
<p>作者：接水怪<br>链接：<a href="https://juejin.cn/post/6844904127420432391">https://juejin.cn/post/6844904127420432391</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title>MacroTask（宏任务）和MicroTask（微任务）</title>
    <url>/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/Macro&amp;MicroTask/</url>
    <content><![CDATA[<blockquote>
<p>这个直接看浏览器原理 V8 第18节 有更详细的讲解<br><a href="/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%8F%8A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">时间循环及消息队列</a></p>
</blockquote>
<p>micro-task和macro-task就是两种不同的任务队列</p>
<ul>
<li>macro-task:<ul>
<li>script(script标签里面的整体代码)</li>
<li>setTimeout</li>
<li>setInterval</li>
<li>setImmediate</li>
<li>MessageChannel（vue nextTick 以前应该是<a href="https://cn.vuejs.org/v2/guide/reactivity.html">备选方案</a>）</li>
<li>I&#x2F;O</li>
<li>UI rendering</li>
<li>requestAnimationFrame</li>
</ul>
</li>
<li>micro-task:<ul>
<li>process.nextTick</li>
<li>Promise</li>
<li>Object.observe(已废弃)</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver">MutationObserver</a> (接口提供了监视对DOM树所做更改的能力)</li>
</ul>
</li>
</ul>
<p>JS开发人员应该对这些方法都不会太陌生——都是些常见的异步操作。但这些方法在执行时有什么区别呢？通俗来说，macrotasks和microtasks最大的区别在它们会被放置在不同的任务调度队列中。我在网上找了一张图，如下所示：</p>
<ul>
<li><strong>每个宏任务都会对应一个微任务列表</strong></li>
<li><strong>微任务列表存储在环境变量中</strong></li>
<li>结论来自于v8原理 18节</li>
</ul>
<p><img src="/_posts/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/assets/Macro&MicroTask/MacroTask1.jpg" alt="示意图"><br>每一次事件循环中，主进程都会先执行一个macroTask任务，这个任务就来自于所谓的MacroTask Queue队列；当该macroTask结束前，Event loop会立马<strong>调用microTask队列的任务，直到消费完所有的microtask，再继续下一个事件循环</strong>。</p>
<blockquote>
<p>管中窥豹，microTask调用优先级较高于macroTask.<br>先看一个demo</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&#x27;main start&#x27;);</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;setTimeout&#x27;);</span><br><span class="line">  process.nextTick(() =&gt; console.log(&#x27;process.nextTick 3&#x27;));</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">process.nextTick(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;process.nextTick 1&#x27;);</span><br><span class="line">  process.nextTick(() =&gt; console.log(&#x27;process.nextTick 2&#x27;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&#x27;main end&#x27;);</span><br></pre></td></tr></table></figure>

<p>看看它们的执行顺序是怎么样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1   main start</span><br><span class="line">2   main end</span><br><span class="line">3   process.nextTick 1</span><br><span class="line">4   process.nextTick 2</span><br><span class="line">5   setTimeout</span><br><span class="line">6   process.nextTick 3</span><br></pre></td></tr></table></figure>

<p>大致流程如下所示：</p>
<ol>
<li><p>先运行主程序（事实上主程序本身就是一个macroTask），主程序把setTimeout和process.nextTick分别放入MacroTask Queue和MicroTask Queue</p>
</li>
<li><p>主程序结束，这时候我们看到了第一二条的打印结果main start、main end</p>
</li>
<li><p>如上面所提到的，每一个macroTask结束后会开始消费microTask。这时的MicroTask Queue里有一个process.nextTick，然后发现它本身也调用了一个process.nextTick，所以继续把这个内层的任务加入MicroTask Queue。</p>
</li>
<li><p>线程消费掉所有MicroTask Queue里的任务（这时只有两个任务），我们得到了第三四条结果process.nextTick 1和process.nextTick 2</p>
</li>
<li><p>当MicroTask Queue清空后，Event Loop进入下一个循环：执行MacroTask Queue的setTimeout任务，然后得到了第五条输出setTimeout，之后它还会把又一个process.nextTick放入MicroTask Queue</p>
</li>
<li><p>继续如4所示过程，Event Loop在Current MacroTask执行完成后消费MicroTask Queue，这时候我们有了最后一条输出process.nextTick 3</p>
</li>
</ol>
<p><strong>下面也是一道经常考的面试题,可以更好的理解async await</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function async1() &#123;</span><br><span class="line">  console.log(&#x27;async1 start&#x27;); // 2</span><br><span class="line">  await async2(); // 微任务 1</span><br><span class="line">  console.log(&#x27;async1 end&#x27;); // 微任务 1 6</span><br><span class="line">&#125;</span><br><span class="line">async function async2() &#123;</span><br><span class="line">  console.log(&#x27;async2&#x27;); // 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&#x27;script start&#x27;);  // 1</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(&#x27;setTimeout&#x27;); // 宏任务 1 8</span><br><span class="line">&#125;, 0)</span><br><span class="line"></span><br><span class="line">async1(); </span><br><span class="line"></span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">  console.log(&#x27;promise1&#x27;); // 4</span><br><span class="line">  resolve(); // 微任务 2</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">  console.log(&#x27;promise2&#x27;); // 微任务 2 7</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&#x27;script end&#x27;); // 5</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>零散知识</category>
      </categories>
      <tags>
        <tag>eventLoop</tag>
      </tags>
  </entry>
  <entry>
    <title>需要掌握的概念</title>
    <url>/%E9%9D%A2%E8%AF%95/%E5%B8%B8%E7%94%A8%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p> 启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程</p>
<ul>
<li><strong>一个进程就是一个程序的运行实例</strong></li>
<li><strong>线程是不能单独存在的，它是由进程来启动和管理的</strong></li>
<li><strong>线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率</strong></li>
</ul>
<p><img src="/_posts/%E9%9D%A2%E8%AF%95/assets/%E5%B8%B8%E7%94%A8%E6%A6%82%E5%BF%B5/image-20210712222146731.png" alt="image-20210712222146731"></p>
<p>总结来说，进程和线程之间的关系有以下 4 个特点。</p>
<ul>
<li><strong>1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。</strong></li>
<li><strong>2. 线程之间共享进程中的数据。</strong></li>
<li><strong>3. 当一个进程关闭之后，操作系统会回收进程所占用的内存(包括泄漏的内存)。</strong></li>
<li><strong>4. 进程之间的内容相互隔离。(通信依靠IPC进程间通信)</strong></li>
</ul>
<h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><h3 id="常见网页协议"><a href="#常见网页协议" class="headerlink" title="常见网页协议"></a>常见网页协议</h3><ul>
<li><strong>TCP&#x2F;IP</strong>  是互联网相关的各类协议族的总称</li>
<li><strong>IP</strong>（Internet Protocol）网际协议（<strong>网络层协议</strong>）IP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方 那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC 地址（Media Access Control Address）</li>
<li><strong>HTTP</strong> 超文本传输协议是一个用于传输超媒体文档（例如 HTML）的<strong>应用层协议</strong>。它是为 Web 浏览器与 Web 服务器之间的通信而设计的，但也可以用于其他目的</li>
<li><strong>TCP</strong>（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的<strong>传输层通信协议</strong></li>
<li><strong>UDP</strong>（User Data Protocol，用户数据报协议）一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上</li>
</ul>
<h3 id="TCP-IP-的分层管理"><a href="#TCP-IP-的分层管理" class="headerlink" title="TCP&#x2F;IP 的分层管理"></a><strong>TCP&#x2F;IP</strong> 的分层管理</h3><p><strong>利用 TCP&#x2F;IP 协议族进行网络通信时，会通过分层顺序与对方进行通信</strong></p>
<p><img src="/_posts/%E9%9D%A2%E8%AF%95/assets/%E5%B8%B8%E7%94%A8%E6%A6%82%E5%BF%B5/image-20210714152647756.png" alt="image-20210714152647756"></p>
<p>这些层基本上被分为4层：</p>
<ul>
<li><p>应用层</p>
<ul>
<li>1、超文本传输协议（<strong>HTTP</strong>):万维网的基本协议</li>
<li>2、文件传输（FTP文件传输协议）；</li>
<li>3、远程登录（Telnet），提供远程访问其它主机功能, 它允许用户登录internet主机，并在这台主机上执行命令</li>
<li>4、网络管理（SNMP简单网络管理协议），该协议提供了监控网络设备的方法， 以及配置管理,统计信息收集,性能管理及安全管理等</li>
<li>5、域名系统（<strong>DNS</strong>），该系统用于在internet中将域名及其公共广播的网络节点转换成IP地址</li>
</ul>
</li>
<li><p>传输层</p>
<ul>
<li>1、<strong>TCP</strong></li>
<li>2、<strong>UDP</strong></li>
</ul>
</li>
<li><p>网络层</p>
<ul>
<li>1、Internet协议（IP）</li>
<li>2、Internet控制信息协议（ICMP）</li>
<li>3、地址解析协议（ARP）ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。</li>
<li>4、反向地址解析协议（RARP）</li>
</ul>
</li>
<li><p>链路层</p>
<p>用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。</p>
</li>
</ul>
<h2 id="Cookies-的属性"><a href="#Cookies-的属性" class="headerlink" title="Cookies 的属性"></a>Cookies 的属性</h2><p>在下面这张图里我们可以看到 Cookies 相关的一些属性：</p>
<p><img src="/_posts/%E9%9D%A2%E8%AF%95/assets/%E5%B8%B8%E7%94%A8%E6%A6%82%E5%BF%B5/170eb95c6ae10887~tplv-t2oaga2asx-watermark.gif" alt="img"></p>
<p>这里主要说一些大家可能没有注意的点：</p>
<h3 id="Name-Value"><a href="#Name-Value" class="headerlink" title="Name&#x2F;Value"></a>Name&#x2F;Value</h3><p>用 JavaScript 操作 Cookie 的时候注意对 Value 进行编码处理。</p>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>Expires 用于设置 Cookie 的过期时间。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>当 Expires 属性缺省时，表示是会话性 Cookie，像上图 Expires 的值为 Session，表示的就是会话性 Cookie。当为会话性 Cookie 的时候，值保存在客户端内存中，并在用户关闭浏览器时失效。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期 Cookie 也会被保留下来，就好像浏览器从来没有关闭一样。</p>
<p>与会话性 Cookie 相对的是持久性 Cookie，持久性 Cookies 会保存在用户的硬盘中，直至过期或者清除 Cookie。这里值得注意的是，设定的日期和时间<strong>只与客户端相关，而不是服务端</strong>。</p>
<h3 id="Max-Age"><a href="#Max-Age" class="headerlink" title="Max-Age"></a>Max-Age</h3><p>Max-Age 用于设置在 Cookie 失效之前需要经过的秒数。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Max-Age=604800;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>Max-Age 可以为正数、负数、甚至是 0。</p>
<p>如果 max-Age 属性为正数时，浏览器会将其持久化，即写到对应的 Cookie 文件中。</p>
<p>当 max-Age 属性为负数，则表示该 Cookie 只是一个会话性 Cookie。</p>
<p>当 max-Age 为 0 时，则会立即删除这个 Cookie。</p>
<p>假如 Expires 和 Max-Age 都存在，Max-Age 优先级更高。</p>
<h3 id="Domain"><a href="#Domain" class="headerlink" title="Domain"></a>Domain</h3><p>Domain 指定了 Cookie 可以送达的主机名。假如没有指定，那么默认值为当前文档访问地址中的主机部分（但是不包含子域名）。</p>
<p>像淘宝首页设置的 Domain 就是 .taobao.com，这样无论是 a.taobao.com 还是 b.taobao.com 都可以使用 Cookie。</p>
<p>在这里注意的是，不能跨域设置 Cookie，比如阿里域名下的页面把 Domain 设置成百度是无效的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Set</span>-<span class="title class_">Cookie</span>: qwerty=219ffwef9w0f; <span class="title class_">Domain</span>=baidu.<span class="property">com</span>; <span class="title class_">Path</span>=/; <span class="title class_">Expires</span>=<span class="title class_">Wed</span>, <span class="number">30</span> <span class="title class_">Aug</span> <span class="number">2020</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="variable constant_">GMT</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h3><p>Path 指定了一个 URL 路径，这个路径必须出现在要请求的资源的路径中才可以发送 Cookie 首部。比如设置 <code>Path=/docs</code>，<code>/docs/Web/</code> 下的资源会带 Cookie 首部，<code>/test</code> 则不会携带 Cookie 首部。</p>
<p><strong>Domain 和 Path 标识共同定义了 Cookie 的作用域：即 Cookie 应该发送给哪些 URL</strong>。</p>
<blockquote>
<p>1.domain表示的是cookie所在的域，默认为请求的地址，如网址为<a href="http://www.jb51.net/test/test.aspx%EF%BC%8C%E9%82%A3%E4%B9%88domain%E9%BB%98%E8%AE%A4%E4%B8%BAwww.jb51.net%E3%80%82%E8%80%8C%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE%EF%BC%8C%E5%A6%82%E5%9F%9FA%E4%B8%BAt1.test.com%EF%BC%8C%E5%9F%9FB%E4%B8%BAt2.test.com%EF%BC%8C%E9%82%A3%E4%B9%88%E5%9C%A8%E5%9F%9FA%E7%94%9F%E4%BA%A7%E4%B8%80%E4%B8%AA%E4%BB%A4%E5%9F%9FA%E5%92%8C%E5%9F%9FB%E9%83%BD%E8%83%BD%E8%AE%BF%E9%97%AE%E7%9A%84cookie%E5%B0%B1%E8%A6%81%E5%B0%86%E8%AF%A5cookie%E7%9A%84domain%E8%AE%BE%E7%BD%AE%E4%B8%BA.test.com%EF%BC%9B%E5%A6%82%E6%9E%9C%E8%A6%81%E5%9C%A8%E5%9F%9FA%E7%94%9F%E4%BA%A7%E4%B8%80%E4%B8%AA%E4%BB%A4%E5%9F%9FA%E4%B8%8D%E8%83%BD%E8%AE%BF%E9%97%AE%E8%80%8C%E5%9F%9FB%E8%83%BD%E8%AE%BF%E9%97%AE%E7%9A%84cookie%E5%B0%B1%E8%A6%81%E5%B0%86%E8%AF%A5cookie%E7%9A%84domain%E8%AE%BE%E7%BD%AE%E4%B8%BAt2.test.com%E3%80%82">www.jb51.net/test/test.aspx，那么domain默认为www.jb51.net。而跨域访问，如域A为t1.test.com，域B为t2.test.com，那么在域A生产一个令域A和域B都能访问的cookie就要将该cookie的domain设置为.test.com；如果要在域A生产一个令域A不能访问而域B能访问的cookie就要将该cookie的domain设置为t2.test.com。</a></p>
<p>2.path表示cookie所在的目录，asp.net默认为&#x2F;，就是根目录。在同一个服务器上有目录如下：&#x2F;test&#x2F;,&#x2F;test&#x2F;cd&#x2F;,&#x2F;test&#x2F;dd&#x2F;，现设一个cookie1的path为&#x2F;test&#x2F;，cookie2的path为&#x2F;test&#x2F;cd&#x2F;，那么test下的所有页面都可以访问到cookie1，而&#x2F;test&#x2F;和&#x2F;test&#x2F;dd&#x2F;的子页面不能访问cookie2。这是因为cookie能让其path路径下的页面访问。</p>
</blockquote>
<h3 id="Secure属性"><a href="#Secure属性" class="headerlink" title="Secure属性"></a>Secure属性</h3><p>标记为 Secure 的 Cookie 只应通过被HTTPS协议加密过的请求发送给服务端。使用 HTTPS 安全协议，可以保护 Cookie 在浏览器和 Web 服务器间的传输过程中不被窃取和篡改。</p>
<h3 id="HTTPOnly"><a href="#HTTPOnly" class="headerlink" title="HTTPOnly"></a>HTTPOnly</h3><p>设置 HTTPOnly 属性可以防止客户端脚本通过 document.cookie 等方式访问 Cookie，有助于避免 XSS 攻击。</p>
<h3 id="SameSite"><a href="#SameSite" class="headerlink" title="SameSite"></a>SameSite</h3><p>Cookie 的<code>SameSite</code>属性用来限制第三方 Cookie，从而减少安全风险。</p>
<p>它可以设置三个值。</p>
<ul>
<li>Strict</li>
<li>Lax</li>
<li>None</li>
</ul>
<h4 id="Strict"><a href="#Strict" class="headerlink" title="Strict"></a>Strict</h4><p><code>Strict</code>最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Set-Cookie: CookieName=CookieValue; SameSite=Strict;</span><br></pre></td></tr></table></figure>

<p>这个规则过于严格，可能造成非常不好的用户体验。比如，当前网页有一个 GitHub 链接，用户点击跳转就不会带有 GitHub 的 Cookie，跳转过去总是未登陆状态。</p>
<h4 id="Lax"><a href="#Lax" class="headerlink" title="Lax"></a>Lax</h4><p><code>Lax</code>规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-Cookie: CookieName=CookieValue; SameSite=Lax;</span><br></pre></td></tr></table></figure>

<p>导航到目标网址的 GET 请求，只包括三种情况：链接，预加载请求，GET 表单。详见下表。</p>
<table>
<thead>
<tr>
<th align="left">请求类型</th>
<th align="center">示例</th>
<th align="right">正常情况</th>
<th align="left">Lax</th>
</tr>
</thead>
<tbody><tr>
<td align="left">链接</td>
<td align="center"><code>&lt;a href=&quot;...&quot;&gt;&lt;/a&gt;</code></td>
<td align="right">发送 Cookie</td>
<td align="left">发送 Cookie</td>
</tr>
<tr>
<td align="left">预加载</td>
<td align="center"><code>&lt;link rel=&quot;prerender&quot; href=&quot;...&quot;/&gt;</code></td>
<td align="right">发送 Cookie</td>
<td align="left">发送 Cookie</td>
</tr>
<tr>
<td align="left">GET 表单</td>
<td align="center"><code>&lt;form method=&quot;GET&quot; action=&quot;...&quot;&gt;</code></td>
<td align="right">发送 Cookie</td>
<td align="left">发送 Cookie</td>
</tr>
<tr>
<td align="left">POST 表单</td>
<td align="center"><code>&lt;form method=&quot;POST&quot; action=&quot;...&quot;&gt;</code></td>
<td align="right">发送 Cookie</td>
<td align="left">不发送</td>
</tr>
<tr>
<td align="left">iframe</td>
<td align="center"><code>&lt;iframe src=&quot;...&quot;&gt;&lt;/iframe&gt;</code></td>
<td align="right">发送 Cookie</td>
<td align="left">不发送</td>
</tr>
<tr>
<td align="left">AJAX</td>
<td align="center"><code>$.get(&quot;...&quot;)</code></td>
<td align="right">发送 Cookie</td>
<td align="left">不发送</td>
</tr>
<tr>
<td align="left">Image</td>
<td align="center"><code>&lt;img src=&quot;...&quot;&gt;</code></td>
<td align="right">发送 Cookie</td>
<td align="left">不发送</td>
</tr>
</tbody></table>
<p>设置了<code>Strict</code>或<code>Lax</code>以后，基本就杜绝了 CSRF 攻击。当然，前提是用户浏览器支持 SameSite 属性。</p>
<h4 id="None"><a href="#None" class="headerlink" title="None"></a>None</h4><p>Chrome 计划将<code>Lax</code>变为默认设置。这时，网站可以选择显式关闭<code>SameSite</code>属性，将其设为<code>None</code>。不过，前提是必须同时设置<code>Secure</code>属性（Cookie 只能通过 HTTPS 协议发送），否则无效。</p>
<p>下面的设置无效。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Set-Cookie: widget_session=abc123; SameSite=None</span><br></pre></td></tr></table></figure>

<p>下面的设置有效。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Set-Cookie: widget_session=abc123; SameSite=None; Secure</span><br></pre></td></tr></table></figure>

<blockquote>
<p>cookie作者：冴羽</p>
<p>链接：<a href="https://juejin.cn/post/6844904095711494151">https://juejin.cn/post/6844904095711494151</a></p>
<p>samesite作者：阮一峰</p>
<p>链接：<a href="https://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html">https://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html</a></p>
</blockquote>
<h2 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h2><ul>
<li>文档根元素（<code>&lt;html&gt;</code>）；</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position"><code>position</code></a> 值为 <code>absolute</code>（绝对定位）或 <code>relative</code>（相对定位）且 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index"><code>z-index</code></a> 值不为 <code>auto</code> 的元素；</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position"><code>position</code></a> 值为 <code>fixed</code>（固定定位）或 <code>sticky</code>（粘滞定位）的元素（沾滞定位适配所有移动设备上的浏览器，但老的桌面浏览器不支持）；</li>
<li>flex (<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox"><code>flexbox</code> (en-US)</a>) 容器的子元素，且 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index"><code>z-index</code></a> 值不为 <code>auto</code>；</li>
<li>grid (<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid"><code>grid</code></a>) 容器的子元素，且 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index"><code>z-index</code></a> 值不为 <code>auto</code>；</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/opacity"><code>opacity</code></a> 属性值小于 <code>1</code> 的元素（参见 <a href="https://www.w3.org/TR/css3-color/#transparency">the specification for opacity</a>）；</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/mix-blend-mode"><code>mix-blend-mode</code></a> 属性值不为 <code>normal</code> 的元素；</li>
<li>以下任意属性值不为none的元素：<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform"><code>transform</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter"><code>filter</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/perspective"><code>perspective</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clip-path"><code>clip-path</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/mask"><code>mask</code></a> &#x2F; <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/mask-image"><code>mask-image</code></a> &#x2F; <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/mask-border"><code>mask-border</code></a></li>
</ul>
</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/isolation"><code>isolation</code></a> 属性值为 <code>isolate</code> 的元素；</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/-webkit-overflow-scrolling"><code>-webkit-overflow-scrolling</code></a> 属性值为 <code>touch</code> 的元素；</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/will-change"><code>will-change</code></a> 值设定了任一属性而该属性在 non-initial 值时会创建层叠上下文的元素（参考<a href="https://dev.opera.com/articles/css-will-change-property/">这篇文章</a>）；</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/contain"><code>contain</code></a> 属性值为 <code>layout</code>、<code>paint</code> 或包含它们其中之一的合成值（比如 <code>contain: strict</code>、<code>contain: content</code>）的元素。</li>
</ul>
<p><img src="/_posts/%E9%9D%A2%E8%AF%95/assets/%E5%B8%B8%E7%94%A8%E6%A6%82%E5%BF%B5/image-20211213143326679.png" alt="image-20211213143326679"></p>
<h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p><strong>块格式化上下文（Block Formatting Context，BFC）</strong> 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p>
<p>下列方式会创建<strong>块格式化上下文</strong>：</p>
<ul>
<li>根元素（<code>&lt;html&gt;）</code></li>
<li>浮动元素（元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a> 不是 <code>none</code>）</li>
<li>绝对定位元素（元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position"><code>position</code></a> 为 <code>absolute</code> 或 <code>fixed</code>）</li>
<li>行内块元素（元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 为 <code>inline-block</code>）</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow"><code>overflow</code></a> 计算值(Computed)不为 <code>visible</code> 的块元素</li>
<li>弹性元素（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 为 <code>flex</code> 或 <code>inline-flex</code>元素的直接子元素）</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/contain"><code>contain</code></a> 值为 <code>layout</code>、<code>content</code>或 paint 的元素</li>
<li><strong>前边的是比较常见的</strong></li>
<li>表格单元格（元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 为 <code>table-cell</code>，HTML表格单元格默认为该值）</li>
<li>表格标题（元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 为 <code>table-caption</code>，HTML表格标题默认为该值）</li>
<li>匿名表格单元格元素（元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 为 <code>table、``table-row</code>、 <code>table-row-group、``table-header-group、``table-footer-group</code>（分别是HTML table、row、tbody、thead、tfoot 的默认属性）或 <code>inline-table</code>）</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 值为 <code>flow-root</code> 的元素</li>
<li>网格元素（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 为 <code>grid</code> 或 <code>inline-grid</code> 元素的直接子元素）</li>
<li>多列容器（元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-count"><code>column-count</code></a> 或 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/column-width"><code>column-width</code> (en-US)</a> 不为 <code>auto，包括 ``column-count</code> 为 <code>1</code>）</li>
<li><code>column-span</code> 为 <code>all</code> 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（<a href="https://github.com/w3c/csswg-drafts/commit/a8634b96900279916bd6c505fda88dda71d8ec51">标准变更</a>，<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=709362">Chrome bug</a>）。</li>
</ul>
<p>块格式化上下文包含创建它的元素内部的所有内容.</p>
<p>块格式化上下文对浮动定位（参见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a>）与清除浮动（参见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear"><code>clear</code></a>）都很重要。浮动定位和清除浮动时只会应用于同一个BFC内的元素。浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。外边距折叠（<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing">Margin collapsing</a>）也只会发生在属于同一BFC的块级元素之间。</p>
<p>规则:</p>
<ul>
<li>属于同一个 BFC 的两个相邻 Box 垂直排列</li>
<li>属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠</li>
<li>BFC 中子元素的 margin box 的左边， 与包含块 (BFC) border box的左边相接触 (子元素 absolute 除外)</li>
<li>BFC 的区域不会与 float 的元素区域重叠 自适应两栏布局</li>
<li><img src="/_posts/%E9%9D%A2%E8%AF%95/assets/%E5%B8%B8%E7%94%A8%E6%A6%82%E5%BF%B5/v2-5ebd48f09fac875f0bd25823c76ba7fa_720w.png" alt="img"></li>
<li>计算 BFC 的高度时，浮动子元素也参与计算</li>
<li>文字层不会被浮动层覆盖，环绕于周围</li>
</ul>
<p>应用:</p>
<ul>
<li>阻止<code>margin</code>重叠</li>
<li>可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个<code>div</code>都位于同一个 BFC 区域之中)</li>
<li>自适应两栏布局</li>
<li>可以阻止元素被浮动元素覆盖</li>
</ul>
<p>可以参考<a href="https://zhuanlan.zhihu.com/p/25321647">知乎</a></p>
<h2 id="同源的定义"><a href="#同源的定义" class="headerlink" title="同源的定义"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy#%E5%90%8C%E6%BA%90%E7%9A%84%E5%AE%9A%E4%B9%89"><strong>同源</strong>的<strong>定义</strong></a></h2><p>如果两个 URL 的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol">protocol</a>、<a href="https://developer.mozilla.org/en-US/docs/Glossary/Port">port (en-US)</a> (如果有指定的话)和 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Host">host</a> 都相同的话，则这两个 URL 是<em>同源</em>。这个方案也被称为“协议&#x2F;主机&#x2F;端口元组”，或者直接是 “元组”。（“元组” 是指一组项目构成的整体，双重&#x2F;三重&#x2F;四重&#x2F;五重&#x2F;等的通用形式）。</p>
<p>下表给出了与 URL <code>http://store.company.com/dir/page.html</code> 的源进行对比的示例:</p>
<table>
<thead>
<tr>
<th align="left">URL</th>
<th align="left">结果</th>
<th align="right">原因</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>http://store.company.com/dir2/other.html</code></td>
<td align="left">同源</td>
<td align="right">只有路径不同</td>
</tr>
<tr>
<td align="left"><code>http://store.company.com/dir/inner/another.html</code></td>
<td align="left">同源</td>
<td align="right">只有路径不同</td>
</tr>
<tr>
<td align="left"><code>https://store.company.com/secure.html</code></td>
<td align="left">失败</td>
<td align="right">协议不同</td>
</tr>
<tr>
<td align="left"><code>http://store.company.com:81/dir/etc.html</code></td>
<td align="left">失败</td>
<td align="right">端口不同 ( <code>http://</code> 默认端口是80)</td>
</tr>
<tr>
<td align="left"><code>http://news.company.com/dir/other.html</code></td>
<td align="left">失败</td>
<td align="right">主机不同</td>
</tr>
</tbody></table>
<blockquote>
<p>Cookie中的「同站」判断就比较宽松：只要两个 URL 的 eTLD+1 相同即可，不需要考虑协议和端口。其中，eTLD 表示有效顶级域名，注册于 Mozilla 维护的公共后缀列表（Public Suffix List）中，例如，.com、.co.uk、.github.io 等。eTLD+1 则表示，有效顶级域名+二级域名，例如 taobao.com 等。</p>
</blockquote>
<h2 id="withCredentials"><a href="#withCredentials" class="headerlink" title="withCredentials"></a>withCredentials</h2><p><code>withCredentials</code>是<code>XMLHttpRequest</code>的一个属性，表示跨域请求是否提供凭据信息(cookie、HTTP认证及客户端SSL证明等)</p>
<p>实际中用途就是跨域请求是要不要携带cookie</p>
<p>在<code>samesite</code>默认为<code>lax</code>的<code>chrome</code>80+，只设置<code>withCredentials</code>已经没用了</p>
<h2 id="位-bit-字节-Byte"><a href="#位-bit-字节-Byte" class="headerlink" title="位(bit) &amp; 字节(Byte)"></a>位(bit) &amp; 字节(Byte)</h2><p><a href="https://juejin.cn/post/7002088412903637022#heading-2">详细</a></p>
<h3 id="bit"><a href="#bit" class="headerlink" title="bit"></a>bit</h3><p>1位二进制数，也就是1bit，有2种可能，可以表示数0,1 <strong>也就是开关状态 是计算机的存储基础</strong></p>
<p>2位二进制数，2bit，有4种可能(2x2)，可以表示数0,1,2,3</p>
<p>3位二进制数,3bit，有8种可能(2x2x2)，可以表示数0,1,2,3,4,5,6,7</p>
<h3 id="Byte"><a href="#Byte" class="headerlink" title="Byte"></a>Byte</h3><p>大B，表示字节</p>
<p>1Byte &#x3D; 8 bit, 2^8是256，1个字节能表示的数就是0-255,共256种可能性。</p>
<h2 id="Unicode编码"><a href="#Unicode编码" class="headerlink" title="Unicode编码"></a>Unicode编码</h2><p><a href="https://juejin.cn/post/6844903590155272199#heading-3">摘抄</a></p>
<p> Unicode（统一码、万国码、单一码）是计算机科学领域里的一项业界标准,包括字符集、编码方案等。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。</p>
<h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>UTF-8（<strong>8-bit Unicode Transformation Format</strong>）是一种针对Unicode的可变长度字符编码，又称万国码。UTF-8 <strong>用1到6个字节编码Unicode字符</strong>。用在网页上可以统一页面显示中文简体繁体及其它语言（如英文，日文，韩文）。</p>
<blockquote>
<p>UTF-8是一种非常通用的<strong>可变长</strong>字符编码方式</p>
<p>像UTF-8里面，<a href="http://ascii.wjccx.com/">ASCII</a>所表示的字符集就是用1 Byte来表示，而大部分汉字则是用3 Byte来表示。</p>
</blockquote>
<h3 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h3><blockquote>
<p>UTF-16 Unicode字符编码五层次模型的第三层：字符编码表（Character Encoding Form，也称为 “storage format”）的一种实现方式。即把Unicode字符集的抽象码位映射为16位长的二进制整数（即码元， 长度为2 Byte）的序列，用于数据存储或传递。Unicode字符的码位，需要1个或者2个16位长的码元(2字节或者4字节)来表示，因此这是一个变长表示。</p>
</blockquote>
<p>引用维基百科中对于UTF-16编码的解释我们可以知道，UTF-16最少也会用2 Byte来表示一个字符，因此没有办法兼容ASCII编码（ASCII编码使用1 Byte来进行存储）。</p>
<h3 id="JS中的string"><a href="#JS中的string" class="headerlink" title="JS中的string"></a>JS中的string</h3><p>在JavaScript中，所有的string类型（或者被称为DOMString）都是使用UTF-16编码的。</p>
<p>因此，当我们需要转换成二进制与后端进行通信时，需要注意相关的编码方式。</p>
<h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><p>在chrome的devtools里有很多性能指标，下面简单介绍一下这些指标</p>
<p>首先是可以在chrome的performance中标识的指标</p>
<ul>
<li><p>DCL (DOMContentLoaded Event)</p>
<ul>
<li>当初始的 <strong>HTML</strong> 文档被完全加载和解析完成之后，**<code>DOMContentLoaded</code>** 事件被触发，而无需等待样式表、图像和子框架的完全加载。(MDN的概念)</li>
<li>更加清晰的结论是，DOMContentLoaded 事件在 html文档加载完毕，并且 html 所引用的内联 js、以及外链 js 的<strong>同步</strong>代码都执行完毕后触发。</li>
</ul>
</li>
<li><p>L (Onload Event)</p>
<ul>
<li><strong>load</strong> 应该仅用于检测一个完全加载的页面 当一个资源及其依赖资源已完成加载时，将触发load事件</li>
<li>更加清晰的结论是，当页面 DOM 结构中的 js、css、图片，以及 js 异步加载的 js、css 、图片都加载完成之后，才会触发 load 事件。</li>
</ul>
<blockquote>
<p>页面中引用的 js 代码如果有异步加载的 js、css、图片，是会影响 load 事件触发的。<br>video、audio、flash 不会影响 load 事件触发。</p>
</blockquote>
</li>
<li><p>FP (First Paint)</p>
<ul>
<li><code>首次绘制</code>: 标记浏览器渲染任何在视觉上不同于导航前屏幕内容之内容的时间点，<strong>简而言之就是浏览器第一次发生变化的时间</strong></li>
</ul>
</li>
<li><p>FCP (First Contentful Paint)</p>
<ul>
<li><code>首次内容绘制</code> 标记浏览器渲染来自 DOM 第一位内容的时间点，该内容可能是文本、图像、SVG 甚至 元素.</li>
</ul>
</li>
<li><p>LCP (Largest Contentful Paint)</p>
<ul>
<li><code>最大内容渲染</code>: 代表在viewport中最大的页面元素加载的时间. LCP的数据会通过PerformanceEntry对象记录, 每次出现更大的内容渲染, 则会产生一个新的PerformanceEntry对象.(2019年11月新增)</li>
</ul>
</li>
</ul>
<p>然后是在性能分析 lighthouse中出现的六个指标,前两个在performance中也存在</p>
<ul>
<li>FCP (First Contentful Paint)</li>
<li>LCP (Largest Contentful Paint)</li>
<li>SI (Speed Index)<ul>
<li>指标用于显示页面可见部分的显示速度, 单位是时间</li>
</ul>
</li>
<li>TTI (Time to Interactive)<ul>
<li><code>可交互时间</code>: 指标用于标记应用已进行视觉渲染并能可靠响应用户输入的时间点.</li>
</ul>
</li>
<li>TBT (Total Blocking Time)<ul>
<li><code>页面阻塞总时长</code>: TBT汇总所有加载过程中阻塞用户操作的时长，在FCP和TTI之间任何long task中阻塞部分都会被汇总（超过50ms的长任务）</li>
</ul>
</li>
<li>CLS (Cumulative Layout Shift)<ul>
<li><code>累积布局偏移</code>: 总结起来就是一个元素初始时和其hidden之间的任何时间如果元素偏移了, 则会被计算进去，说简单点就是用户不期望的元素位置偏移。</li>
<li>根据 Google 的介绍，CLS 问题产生的原因一般包括：<ul>
<li>图片没有宽高</li>
<li>无尺寸的广告、嵌入式和iframes</li>
<li>动态注入的内容</li>
<li>导致FOIT&#x2F;FOUT的Web字体</li>
<li>在更新DOM之前等待网络响应的操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="对象获取属性的方法"><a href="#对象获取属性的方法" class="headerlink" title="对象获取属性的方法"></a>对象获取属性的方法</h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">不可枚举属性</th>
<th align="center">继承属性</th>
<th align="center">symbol属性</th>
<th align="center">自身属性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">in</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">for…in</td>
<td align="center">❌</td>
<td align="center">✅</td>
<td align="center">❌</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">JSON.stringfy()</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">Object.assign()</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">… 扩展运算符</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">Object.keys()、Object.values()、Object.entries()</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">Object.getOwnPropertyNames()</td>
<td align="center">✅</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">Object.getOwnPropertySymbols(obj)</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">✅</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">Reflect.ownKeys(obj)</td>
<td align="center">✅</td>
<td align="center">❌</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">Object.getOwnPropertyDescriptor(s)</td>
<td align="center">✅</td>
<td align="center">❌</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
</tbody></table>
<h2 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h2><p> <strong>避免二次调用父的prototype</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> // 父</span><br><span class="line"> function SuperType(name) &#123;</span><br><span class="line">   this.name = name;</span><br><span class="line">   this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line"> &#125;</span><br><span class="line"> SuperType.prototype.sayName = function () &#123;</span><br><span class="line">   console.log(this.name);</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">// 借助辅助原型函数链接到父prototype</span><br><span class="line">function object(o) &#123; </span><br><span class="line">   function F() &#123;&#125; </span><br><span class="line">   F.prototype = o; </span><br><span class="line">   return new F(); </span><br><span class="line"> &#125;</span><br><span class="line"> // 保证正确的construct，将只prototype链接到辅助原型函数上的实例上</span><br><span class="line"> function inheritPrototype(subType, superType) &#123;</span><br><span class="line">   let prototype = object(superType.prototype); // 创建对象</span><br><span class="line">   prototype.constructor = subType; // 增强对象 </span><br><span class="line">   subType.prototype = prototype; // 赋值对象</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">// 继承</span><br><span class="line"> function SubType(name, age) &#123;</span><br><span class="line">  // 一</span><br><span class="line">   SuperType.call(this, name);</span><br><span class="line">   this.age = age;</span><br><span class="line"> &#125;</span><br><span class="line"> // 二</span><br><span class="line"> inheritPrototype(SubType, SuperType);</span><br><span class="line"> </span><br><span class="line"> SubType.prototype.sayAge = function () &#123;</span><br><span class="line">   console.log(this.age);</span><br><span class="line"> &#125;;</span><br><span class="line"> var child = new SubType(&quot;头疼&quot;, 30)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>常用概念</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise A+规范</title>
    <url>/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/promise/</url>
    <content><![CDATA[<h1 id="promiseA-规范"><a href="#promiseA-规范" class="headerlink" title="promiseA+规范"></a>promiseA+规范</h1><blockquote>
<p>转载自<a href="https://www.ituring.com.cn/article/66566">图灵社区</a></p>
</blockquote>
<p><strong>译者序：</strong>一年前曾译过 Promise&#x2F;A+ 规范，适时完全不懂 Promise 的思想，纯粹将翻译的过程当作学习，旧文译下来诘屈聱牙，读起来十分不顺畅。谁知这样一篇拙译，一年之间竟然点击数千，成为谷歌搜索的头条。今日在理解之后重译此规范，以飨读者。</p>
<p><strong>一个开放、健全且通用的 JavaScript Promise 标准。由开发者制定，供开发者参考。</strong></p>
<hr>
<p><strong>译文术语</strong></p>
<ul>
<li><strong>解决（fulfill）</strong>：指一个 promise 成功时进行的一系列操作，如状态的改变、回调的执行。虽然规范中用 <code>fulfill</code> 来表示解决，但在后世的 promise 实现多以 <code>resolve</code> 来指代之。</li>
<li><strong>拒绝（reject）</strong>：指一个 promise 失败时进行的一系列操作。</li>
<li><strong>终值（eventual value）</strong>：所谓终值，指的是 promise 被<strong>解决</strong>时传递给解决回调的值，由于 promise 有<strong>一次性</strong>的特征，因此当这个值被传递时，标志着 promise 等待态的结束，故称之终值，有时也直接简称为值（value）。</li>
<li><strong>据因（reason）</strong>：也就是拒绝原因，指在 promise 被<strong>拒绝</strong>时传递给拒绝回调的值。</li>
</ul>
<hr>
<p>Promise 表示一个异步操作的最终结果，与之进行交互的方式主要是 <code>then</code> 方法，该方法注册了两个回调函数，用于接收 promise 的终值或本 promise 不能执行的原因。</p>
<p>本规范详细列出了 <code>then</code> 方法的执行过程，所有遵循 Promises&#x2F;A+ 规范实现的 promise 均可以本标准作为参照基础来实施 <code>then</code> 方法。因而本规范是十分稳定的。尽管 Promise&#x2F;A+ 组织有时可能会修订本规范，但主要是为了处理一些特殊的边界情况，且这些改动都是微小且向下兼容的。如果我们要进行大规模不兼容的更新，我们一定会在事先进行谨慎地考虑、详尽的探讨和严格的测试。</p>
<p>从历史上说，本规范实际上是把之前 <a href="http://wiki.commonjs.org/wiki/Promises/A">Promise&#x2F;A 规范</a> 中的建议明确成为了行为标准：我们一方面扩展了原有规范约定俗成的行为，一方面删减了原规范的一些特例情况和有问题的部分。</p>
<p>最后，核心的 Promises&#x2F;A+ 规范不设计如何创建、解决和拒绝 promise，而是专注于提供一个通用的 <code>then</code> 方法。上述对于 promises 的操作方法将来在其他规范中可能会提及。</p>
<hr>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>promise 是一个拥有 <code>then</code> 方法的对象或函数，其行为符合本规范；</p>
<h2 id="thenable"><a href="#thenable" class="headerlink" title="thenable"></a>thenable</h2><p>是一个定义了 <code>then</code> 方法的对象或函数，文中译作“拥有 <code>then</code> 方法”；</p>
<h2 id="值（value）"><a href="#值（value）" class="headerlink" title="值（value）"></a>值（value）</h2><p>指任何 JavaScript 的合法值（包括 <code>undefined</code> , thenable 和 promise）；</p>
<h2 id="异常（exception）"><a href="#异常（exception）" class="headerlink" title="异常（exception）"></a>异常（exception）</h2><p>是使用 <code>throw</code> 语句抛出的一个值。</p>
<h2 id="据因（reason）"><a href="#据因（reason）" class="headerlink" title="据因（reason）"></a>据因（reason）</h2><p>表示一个 promise 的拒绝原因。</p>
<h1 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h1><hr>
<h2 id="Promise-的状态"><a href="#Promise-的状态" class="headerlink" title="Promise 的状态"></a>Promise 的状态</h2><p>一个 Promise 的当前状态必须为以下三种状态中的一种：<strong>等待态（Pending）</strong>、**执行态（Fulfilled）**和**拒绝态（Rejected）**。</p>
<h3 id="等待态（Pending）"><a href="#等待态（Pending）" class="headerlink" title="等待态（Pending）"></a>等待态（Pending）</h3><p>处于等待态时，promise 需满足以下条件：</p>
<ul>
<li>可以迁移至执行态或拒绝态</li>
</ul>
<h3 id="执行态（Fulfilled）"><a href="#执行态（Fulfilled）" class="headerlink" title="执行态（Fulfilled）"></a>执行态（Fulfilled）</h3><p>处于执行态时，promise 需满足以下条件：</p>
<ul>
<li>不能迁移至其他任何状态</li>
<li>必须拥有一个<strong>不可变</strong>的终值</li>
</ul>
<h3 id="拒绝态（Rejected）"><a href="#拒绝态（Rejected）" class="headerlink" title="拒绝态（Rejected）"></a>拒绝态（Rejected）</h3><p>处于拒绝态时，promise 需满足以下条件：</p>
<ul>
<li>不能迁移至其他任何状态</li>
<li>必须拥有一个<strong>不可变</strong>的据因</li>
</ul>
<p>这里的不可变指的是恒等（即可用 <code>===</code> 判断相等），而不是意味着更深层次的不可变（<strong>译者注：</strong>盖指当 value 或 reason 不是基本值时，只要求其引用地址相等，但属性值可被更改）。</p>
<h2 id="Then-方法"><a href="#Then-方法" class="headerlink" title="Then 方法"></a><strong>Then 方法</strong></h2><p>一个 promise 必须提供一个 <code>then</code> 方法以访问其当前值、终值和据因。</p>
<p>promise 的 <code>then</code> 方法接受两个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure>

<h3 id="参数可选"><a href="#参数可选" class="headerlink" title="参数可选"></a>参数可选</h3><p><code>onFulfilled</code> 和 <code>onRejected</code> 都是可选参数。</p>
<ul>
<li>如果 <code>onFulfilled</code> 不是函数，其必须被忽略</li>
<li>如果 <code>onRejected</code> 不是函数，其必须被忽略</li>
</ul>
<h3 id="onFulfilled-特性"><a href="#onFulfilled-特性" class="headerlink" title="onFulfilled 特性"></a><code>onFulfilled</code> 特性</h3><p>如果 <code>onFulfilled</code> 是函数：</p>
<ul>
<li>当 <code>promise</code> 执行结束后其必须被调用，其第一个参数为 <code>promise</code> 的终值</li>
<li>在 <code>promise</code> 执行结束前其不可被调用</li>
<li>其调用次数不可超过一次</li>
</ul>
<h3 id="onRejected-特性"><a href="#onRejected-特性" class="headerlink" title="onRejected 特性"></a><code>onRejected</code> 特性</h3><p>如果 <code>onRejected</code> 是函数：</p>
<ul>
<li>当 <code>promise</code> 被拒绝执行后其必须被调用，其第一个参数为 <code>promise</code> 的据因</li>
<li>在 <code>promise</code> 被拒绝执行前其不可被调用</li>
<li>其调用次数不可超过一次</li>
</ul>
<h3 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h3><p><code>onFulfilled</code> 和 <code>onRejected</code> 只有在<a href="http://es5.github.io/#x10.3">执行环境</a>堆栈仅包含<strong>平台代码</strong>时才可被调用 <a href="https://www.ituring.com.cn/article/66566#note-1">注1</a></p>
<h3 id="调用要求"><a href="#调用要求" class="headerlink" title="调用要求"></a>调用要求</h3><p><code>onFulfilled</code> 和 <code>onRejected</code> 必须被作为函数调用（即没有 <code>this</code> 值）[注2][2]</p>
<h3 id="多次调用"><a href="#多次调用" class="headerlink" title="多次调用"></a>多次调用</h3><p><code>then</code> 方法可以被同一个 <code>promise</code> 调用多次</p>
<ul>
<li>当 <code>promise</code> 成功执行时，所有 <code>onFulfilled</code> 需按照其注册顺序依次回调</li>
<li>当 <code>promise</code> 被拒绝执行时，所有的 <code>onRejected</code> 需按照其注册顺序依次回调</li>
</ul>
<h3 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h3><p><code>then</code> 方法必须返回一个 <code>promise</code> 对象 [注3][3]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">promise2 = promise1.then(onFulfilled, onRejected);   </span><br></pre></td></tr></table></figure>

<ul>
<li>如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 返回一个值 <code>x</code> ，则运行下面的 <strong>Promise 解决过程</strong>：<code>[[Resolve]](promise2, x)</code></li>
<li>如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 抛出一个异常 <code>e</code> ，则 <code>promise2</code> 必须拒绝执行，并返回拒因 <code>e</code></li>
<li>如果 <code>onFulfilled</code> 不是函数且 <code>promise1</code> 成功执行， <code>promise2</code> 必须成功执行并返回相同的值</li>
<li>如果 <code>onRejected</code> 不是函数且 <code>promise1</code> 拒绝执行， <code>promise2</code> 必须拒绝执行并返回相同的据因</li>
</ul>
<p><strong>译者注：</strong>理解上面的“返回”部分非常重要，即：<strong>不论 <code>promise1</code> 被 reject 还是被 resolve 时 <code>promise2</code>都会被 resolve，只有出现异常时才会被 rejected</strong>。</p>
<h2 id="Promise-解决过程"><a href="#Promise-解决过程" class="headerlink" title="Promise 解决过程"></a><strong>Promise 解决过程</strong></h2><p><strong>Promise 解决过程</strong>是一个抽象的操作，其需输入一个 <code>promise</code> 和一个值，我们表示为 <code>[[Resolve]](promise, x)</code>，如果 <code>x</code> 有 <code>then</code> 方法且看上去像一个 Promise ，解决程序即尝试使 <code>promise</code> 接受 <code>x</code> 的状态；否则其用 <code>x</code> 的值来执行 <code>promise</code> 。</p>
<p>这种 <em>thenable</em> 的特性使得 Promise 的实现更具有通用性：只要其暴露出一个遵循 Promise&#x2F;A+ 协议的 <code>then</code>方法即可；这同时也使遵循 Promise&#x2F;A+ 规范的实现可以与那些不太规范但可用的实现能良好共存。</p>
<p>运行 <code>[[Resolve]](promise, x)</code> 需遵循以下步骤：</p>
<h3 id="x-与-promise-相等"><a href="#x-与-promise-相等" class="headerlink" title="x 与 promise 相等"></a><code>x</code> 与 <code>promise</code> 相等</h3><p>如果 <code>promise</code> 和 <code>x</code> 指向同一对象，以 <code>TypeError</code> 为据因拒绝执行 <code>promise</code></p>
<h3 id="x-为-Promise"><a href="#x-为-Promise" class="headerlink" title="x 为 Promise"></a><code>x</code> 为 Promise</h3><p>如果 <code>x</code> 为 Promise ，则使 <code>promise</code> 接受 <code>x</code> 的状态 [注4][4]：</p>
<ul>
<li>如果 <code>x</code> 处于等待态， <code>promise</code> 需保持为等待态直至 <code>x</code> 被执行或拒绝</li>
<li>如果 <code>x</code> 处于执行态，用相同的值执行 <code>promise</code></li>
<li>如果 <code>x</code> 处于拒绝态，用相同的据因拒绝 <code>promise</code></li>
</ul>
<h3 id="x-为对象或函数"><a href="#x-为对象或函数" class="headerlink" title="x 为对象或函数"></a><code>x</code> 为对象或函数</h3><p>如果 <code>x</code> 为对象或者函数：</p>
<ul>
<li><p>把 <code>x.then</code> 赋值给 <code>then</code> [注5][5]</p>
</li>
<li><p>如果取 <code>x.then</code> 的值时抛出错误 <code>e</code> ，则以 <code>e</code> 为据因拒绝 <code>promise</code></p>
</li>
<li><p>如果<code>then</code>是函数，将<code>x</code>作为函数的作用域this调用之。传递两个回调函数作为参数，第一个参数叫做</p>
<p><code>resolvePromise</code>，第二个参数叫做<code>rejectPromise</code>:</p>
<ul>
<li><p>如果 <code>resolvePromise</code> 以值 <code>y</code> 为参数被调用，则运行 <code>[[Resolve]](promise, y)</code></p>
</li>
<li><p>如果 <code>rejectPromise</code> 以据因 <code>r</code> 为参数被调用，则以据因 <code>r</code> 拒绝 <code>promise</code></p>
</li>
<li><p>如果 <code>resolvePromise</code> 和 <code>rejectPromise</code> 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用</p>
</li>
<li><p>如果调用<code>then</code>方法抛出了异常<code>e</code>：</p>
<ul>
<li>如果 <code>resolvePromise</code> 或 <code>rejectPromise</code> 已经被调用，则忽略之</li>
<li>否则以 <code>e</code> 为据因拒绝 <code>promise</code></li>
</ul>
</li>
<li><p>如果 <code>then</code> 不是函数，以 <code>x</code> 为参数执行 <code>promise</code></p>
</li>
</ul>
</li>
<li><p>如果 <code>x</code> 不为对象或者函数，以 <code>x</code> 为参数执行 <code>promise</code></p>
</li>
</ul>
<p>如果一个 promise 被一个循环的 <em>thenable</em> 链中的对象解决，而 <code>[[Resolve]](promise, thenable)</code> 的递归性质又使得其被再次调用，根据上述的算法将会陷入无限递归之中。算法虽不强制要求，但也鼓励施者检测这样的递归是否存在，若检测到存在则以一个可识别的 <code>TypeError</code> 为据因来拒绝 <code>promise</code> [注6][6]。</p>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><hr>
<ul>
<li><p><strong>注1</strong> 这里的<strong>平台代码</strong>指的是引擎、环境以及 promise 的实施代码。实践中要确保 <code>onFulfilled</code> 和 <code>onRejected</code> 方法异步执行，且应该在 <code>then</code> 方法被调用的那一轮事件循环之后的新执行栈中执行。这个事件队列可以采用“宏任务（macro-task）”机制或者“微任务（micro-task）”机制来实现。由于 promise 的实施代码本身就是平台代码（<strong>译者注：</strong>即都是 JavaScript），故代码自身在处理在处理程序时可能已经包含一个任务调度队列。</p>
<p><strong>译者注：</strong>这里提及了 macrotask 和 microtask 两个概念，这表示异步任务的两种分类。在挂起任务时，JS 引擎会将所有任务按照类别分到这两个队列中，首先在 macrotask 的队列（这个队列也被叫做 task queue）中取出第一个任务，执行完毕后取出 microtask 队列中的所有任务顺序执行；之后再取 macrotask 任务，周而复始，直至两个队列的任务都取完。</p>
<p>两个类别的具体分类如下：</p>
<ul>
<li><strong>macro-task:</strong> script（整体代码）, <code>setTimeout</code>, <code>setInterval</code>, <code>setImmediate</code>, I&#x2F;O, UI rendering</li>
<li><strong>micro-task:</strong> <code>process.nextTick</code>, <code>Promises</code>（这里指浏览器实现的原生 Promise）, <code>Object.observe</code>, <code>MutationObserver</code></li>
</ul>
<p>详见 <a href="http://stackoverflow.com/questions/25915634/difference-between-microtask-and-macrotask-within-an-event-loop-context">stackoverflow 解答</a> 或 <a href="http://wengeezhang.com/?p=11">这篇博客</a></p>
</li>
<li><p><strong>注2</strong> 也就是说在<strong>严格模式（strict）</strong>中，函数 <code>this</code> 的值为 <code>undefined</code> ；在非严格模式中其为全局对象。</p>
</li>
<li><p><strong>注3</strong> 代码实现在满足所有要求的情况下可以允许 <code>promise2 === promise1</code> 。每个实现都要文档说明其是否允许以及在何种条件下允许 <code>promise2 === promise1</code> 。</p>
</li>
<li><p><strong>注4</strong> 总体来说，如果 <code>x</code> 符合当前实现，我们才认为它是真正的 <em>promise</em> 。这一规则允许那些特例实现接受符合已知要求的 Promises 状态。</p>
</li>
<li><p><strong>注5</strong> 这步我们先是存储了一个指向 <code>x.then</code> 的引用，然后测试并调用该引用，以避免多次访问 <code>x.then</code>属性。这种预防措施确保了该属性的一致性，因为其值可能在检索调用时被改变。</p>
</li>
<li><p><strong>注6</strong> 实现不应该对 <em>thenable</em> 链的深度设限，并假定超出本限制的递归就是无限循环。只有真正的循环递归才应能导致 <code>TypeError</code> 异常；如果一条无限长的链上 <em>thenable</em> 均不相同，那么递归下去永远是正确的行为。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>零散知识</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>前端安全</title>
    <url>/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<p><a href="https://juejin.cn/post/6844903685122703367">美团安全系列-XSS</a></p>
<p><a href="https://juejin.cn/post/6844903689702866952">美团安全系列-CSRF</a></p>
<h2 id="1-XSS攻击"><a href="#1-XSS攻击" class="headerlink" title="1. XSS攻击"></a>1. XSS攻击</h2><p>XSS(Cross-Site Scripting，<strong>跨站脚本攻击</strong>)是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当被攻击者登陆网站时就会执行这些恶意代码，这些脚本可以读取 cookie，session tokens，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。</p>
<p>XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，利用这些信息冒充用户向网站发起攻击者定义的请求。</p>
<blockquote>
<p>XSS分类</p>
</blockquote>
<p>根据攻击的来源，XSS攻击可以分为存储型(持久性)、反射型(非持久型)和DOM型三种。下面我们来详细了解一下这三种XSS攻击：</p>
<h3 id="1-1-反射型XSS"><a href="#1-1-反射型XSS" class="headerlink" title="1.1 反射型XSS"></a>1.1 反射型XSS</h3><p>当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。Web服务器将注入脚本，比如一个错误信息，搜索结果等，未进行过滤直接返回到用户的浏览器上。</p>
<blockquote>
<p>反射型 XSS 的攻击步骤：</p>
</blockquote>
<ol>
<li>攻击者构造出特殊的 <code>URL</code>，其中包含恶意代码。</li>
<li>用户打开带有恶意代码的 <code>URL</code> 时，网站服务端将恶意代码从 <code>URL</code> 中取出，拼接在 HTML 中返回给浏览器。</li>
<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>
</ol>
<p>反射型 XSS 漏洞常见于通过 <code>URL</code> 传递参数的功能，如网站搜索、跳转等。由于需要用户主动打开恶意的 <code>URL</code> 才能生效，攻击者往往会结合多种手段诱导用户点击。</p>
<p>POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。</p>
<p>注意<code>Chrome</code> 和 <code>Safari</code> 能够检测到 <code>url</code> 上的xss攻击，将网页拦截掉，但是其它浏览器不行，如<code>Firefox</code></p>
<p>如果不希望被前端拿到cookie，后端可以设置 <code>httpOnly</code> (不过这不是 <code>XSS攻击</code> 的解决方案，只能降低受损范围)</p>
<blockquote>
<p>如何防范反射型XSS攻击</p>
</blockquote>
<p><strong>对字符串进行编码。</strong></p>
<p>对url的查询参数进行转义后再输出到页面。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.get(&#x27;/welcome&#x27;, function(req, res) &#123;</span><br><span class="line">    //对查询参数进行编码，避免反射型 XSS攻击</span><br><span class="line">    res.send(`$&#123;encodeURIComponent(req.query.type)&#125;`); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="1-2-DOM-型-XSS"><a href="#1-2-DOM-型-XSS" class="headerlink" title="1.2 DOM 型 XSS"></a>1.2 DOM 型 XSS</h3><p>DOM 型 XSS 攻击，实际上就是前端 <code>JavaScript</code> 代码不够严谨，把不可信的内容插入到了页面。在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>.appendChild</code>、<code>document.write()</code>等API时要特别小心，不要把不可信的数据作为 HTML 插到页面上，尽量使用 <code>.innerText</code>、<code>.textContent</code>、<code>.setAttribute()</code> 等。</p>
<blockquote>
<p>DOM 型 XSS 的攻击步骤：</p>
</blockquote>
<ol>
<li>攻击者构造出特殊数据，其中包含恶意代码。</li>
<li>用户浏览器执行了恶意代码。</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>
</ol>
<blockquote>
<p>如何防范 DOM 型 XSS 攻击</p>
</blockquote>
<p>防范 DOM 型 XSS 攻击的核心就是对输入内容进行转义(DOM 中的内联事件监听器和链接跳转都能把字符串作为代码运行，需要对其内容进行检查)。</p>
<p>1.对于<code>url</code>链接(例如图片的<code>src</code>属性)，那么直接使用 <code>encodeURIComponent</code> 来转义。</p>
<p>2.非<code>url</code>，我们可以这样进行编码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function encodeHtml(str) &#123;</span><br><span class="line">    return str.replace(/&quot;/g, &#x27;&amp;quot;&#x27;)</span><br><span class="line">            .replace(/&#x27;/g, &#x27;&amp;apos;&#x27;)</span><br><span class="line">            .replace(/&lt;/g, &#x27;&amp;lt;&#x27;)</span><br><span class="line">            .replace(/&gt;/g, &#x27;&amp;gt;&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞。</p>
<h3 id="1-3-存储型XSS"><a href="#1-3-存储型XSS" class="headerlink" title="1.3 存储型XSS"></a>1.3 存储型XSS</h3><p>恶意脚本永久存储在目标服务器上。当浏览器请求数据时，脚本从服务器传回并执行，影响范围比反射型和DOM型XSS更大。存储型XSS攻击的原因仍然是没有做好数据过滤：前端提交数据至服务端时，没有做好过滤；服务端在接受到数据时，在存储之前，没有做过滤；前端从服务端请求到数据，没有过滤输出。</p>
<blockquote>
<p>存储型 XSS 的攻击步骤：</p>
</blockquote>
<ol>
<li>攻击者将恶意代码提交到目标网站的数据库中。</li>
<li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</li>
<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>
</ol>
<p>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</p>
<blockquote>
<p>如何防范存储型XSS攻击：</p>
</blockquote>
<ol>
<li>前端数据传递给服务器之前，先转义&#x2F;过滤(防范不了抓包修改数据的情况)</li>
<li>服务器接收到数据，在存储到数据库之前，进行转义&#x2F;过滤</li>
<li>前端接收到服务器传递过来的数据，在展示到页面前，先进行转义&#x2F;过滤</li>
</ol>
<h3 id="1-4-防范XSS攻击"><a href="#1-4-防范XSS攻击" class="headerlink" title="1.4 防范XSS攻击"></a>1.4 防范XSS攻击</h3><ul>
<li><p>XSS（Cross-Site Scripting）攻击是一种常见的Web应用程序安全漏洞，攻击者利用漏洞在网站上注入恶意脚本或代码，以获取用户的敏感信息或控制用户的浏览器。为了防范XSS攻击，可以采取以下方法：</p>
<ol>
<li>输入检查：在用户输入数据时，对数据进行检查和过滤，过滤掉特殊字符和脚本代码。比如可以使用HTML实体编码对特殊字符进行转义，比如&lt;转义为&lt;。</li>
<li>输出转义：在输出数据到页面上时，对数据进行转义。比如使用HTML实体编码将特殊字符转义成文本，这样就可以避免浏览器将其解析成HTML标签。比如将&lt;转义为&lt;。</li>
<li>CSP（Content Security Policy）：设置CSP响应头，限制页面中允许加载的资源类型，禁止内联脚本执行等，这样可以减少XSS攻击的影响。</li>
<li>Cookie安全策略：使用HttpOnly和Secure属性，限制Cookie只能通过HTTP协议传输，防止Cookie被盗取。</li>
<li>防止DOM操作：对于不可信的数据，应该避免直接将其插入到DOM中，可以使用textContent或者innerText等属性插入数据，这样可以避免执行脚本。</li>
<li>HTTPS传输：使用HTTPS协议传输数据，加密传输数据，防止数据被拦截和篡改。</li>
<li>前端框架的防护：一些前端框架（如Angular、React、Vue等）在渲染模板时会自动转义输出的内容，可以减少XSS攻击的风险。</li>
</ol>
<p>综上所述，防范XSS攻击需要综合采用多种方法，不同的方法可以在不同的层面上增强网站的安全性。</p>
</li>
</ul>
<h3 id="1-5-XSS-检测"><a href="#1-5-XSS-检测" class="headerlink" title="1.5 XSS 检测"></a>1.5 XSS 检测</h3><p>读到这儿，相信大家已经知道了什么是XSS攻击，XSS攻击的类型，以及如何去防范XSS攻击。但是有一个非常重要的问题是：我们如何去检测XSS攻击，怎么知道自己的页面是否存在XSS漏洞？</p>
<p>很多大公司，都有专门的安全部门负责这个工作，但是如果没有安全部门，作为开发者本身，该如何去检测呢？</p>
<p>1.使用通用 XSS 攻击字串手动检测 XSS 漏洞</p>
<p>如:<br><code>jaVasCript:/*-/*</code>&#x2F;*`&#x2F;*’&#x2F;*”&#x2F;**&#x2F;(&#x2F;* *&#x2F;oNcliCk&#x3D;alert() )&#x2F;&#x2F;%0D%0A%0d%0a&#x2F;&#x2F;&lt;&#x2F;stYle&#x2F;&lt;&#x2F;titLe&#x2F;&lt;&#x2F;teXtarEa&#x2F;&lt;&#x2F;scRipt&#x2F;–!&gt;\x3csVg&#x2F;&lt;sVg&#x2F;oNloAd&#x3D;alert()&#x2F;&#x2F;&gt;\x3e&#96;</p>
<p>能够检测到存在于 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等多种上下文中的 XSS 漏洞，也能检测 eval()、setTimeout()、setInterval()、Function()、innerHTML、document.write() 等 DOM 型 XSS 漏洞，并且能绕过一些 XSS 过滤器。</p>
<p><code>&lt;img src=1 onerror=alert(1)&gt;</code></p>
<p>2.使用第三方工具进行扫描</p>
<hr>
<h2 id="2-CSRF"><a href="#2-CSRF" class="headerlink" title="2. CSRF"></a>2. CSRF</h2><p>CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p>
<blockquote>
<p>典型的CSRF攻击流程：</p>
</blockquote>
<ol>
<li>受害者登录A站点，并保留了登录凭证（Cookie）。</li>
<li>攻击者诱导受害者访问了站点B。</li>
<li><strong>站点B向站点A发送了一个请求，浏览器会默认携带站点A的Cookie信息</strong>。</li>
<li>站点A接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是无辜的受害者发送的请求。</li>
<li>站点A以受害者的名义执行了站点B的请求。</li>
<li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者完成了攻击。</li>
</ol>
<blockquote>
<p>CSRF的特点</p>
</blockquote>
<p>1.攻击通常在第三方网站发起，如图上的站点B，站点A无法防止攻击发生。</p>
<p>2.攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；并不会去获取cookie信息(cookie有同源策略)</p>
<p>3.跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等(来源不明的链接，不要点击)</p>
<h3 id="CSRF-攻击防御"><a href="#CSRF-攻击防御" class="headerlink" title="CSRF 攻击防御"></a>CSRF 攻击防御</h3><p><strong>1. 添加验证码(体验不好)</strong></p>
<p>验证码能够防御CSRF攻击，但是我们不可能每一次交互都需要验证码，否则用户的体验会非常差，但是我们可以在转账，交易等操作时，增加验证码，确保我们的账户安全。</p>
<p><strong>2. 判断请求的来源：检测Referer(并不安全，Referer可以被更改)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`Referer` 可以作为一种辅助手段，来判断请求的来源是否是安全的，但是鉴于 `Referer` 本身是可以被修改的，因为不能仅依赖于  `Referer`</span><br></pre></td></tr></table></figure>

<p><strong>3. 使用Token(主流)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开。跟验证码类似，只是用户无感知。</span><br><span class="line"></span><br><span class="line">- 服务端给用户生成一个token，加密后传递给用户</span><br><span class="line">- 用户在提交请求时，需要携带这个token</span><br><span class="line">- 服务端验证token是否正确</span><br></pre></td></tr></table></figure>

<p><strong>4. Samesite Cookie属性</strong></p>
<p><a href="https://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html">阮一峰samesite</a></p>
<p>为了从源头上解决这个问题，Google起草了一份草案来改进HTTP协议，为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax。</p>
<p>部署简单，并能有效防御CSRF攻击，但是存在兼容性问题。</p>
<p><strong>Samesite&#x3D;Strict</strong></p>
<p><code>Samesite=Strict</code> 被称为是严格模式,表明这个 Cookie 在任何情况都不可能作为第三方的 Cookie，有能力阻止所有CSRF攻击。此时，我们在B站点下发起对A站点的任何请求，A站点的 Cookie 都不会包含在cookie请求头中。</p>
<p><strong>Samesite&#x3D;Lax</strong></p>
<p><code>Samesite=Lax</code> 被称为是宽松模式，与 Strict 相比，放宽了限制，允许发送安全 HTTP 方法带上 Cookie，如 <code>Get</code> &#x2F; <code>OPTIONS</code> 、<code>HEAD</code> 请求.</p>
<p>但是不安全 HTTP 方法，如： <code>POST</code>, <code>PUT</code>, <code>DELETE</code> 请求时，不能作为第三方链接的 Cookie</p>
<p>为了更好的防御CSRF攻击，我们可以组合使用以上防御手段。</p>
<h2 id="3-点击劫持"><a href="#3-点击劫持" class="headerlink" title="3. 点击劫持"></a>3. 点击劫持</h2><p>点击劫持是指在一个Web页面中隐藏了一个透明的iframe，用外层假页面诱导用户点击，实际上是在隐藏的frame上触发了点击事件进行一些用户不知情的操作。</p>
<h4 id="典型点击劫持攻击流程"><a href="#典型点击劫持攻击流程" class="headerlink" title="典型点击劫持攻击流程"></a>典型点击劫持攻击流程</h4><ol>
<li>攻击者构建了一个非常有吸引力的网页</li>
<li>将被攻击的页面放置在当前页面的 <code>iframe</code> 中</li>
<li>使用样式将 iframe 叠加到非常有吸引力内容的上方</li>
<li>将iframe设置为100%透明</li>
<li>你被诱导点击了网页内容，你以为你点击的是***，而实际上，你成功被攻击了。</li>
</ol>
<h4 id="点击劫持防御"><a href="#点击劫持防御" class="headerlink" title="点击劫持防御"></a>点击劫持防御</h4><p><strong>1. frame busting</strong></p>
<p>Frame busting</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ( top.location != window.location )&#123;</span><br><span class="line">    top.location = window.location</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是: HTML5中iframe的 <code>sandbox</code> 属性、IE中iframe的<code>security</code> 属性等，都可以限制iframe页面中的JavaScript脚本执行，从而可以使得 frame busting 失效。</p>
<p><strong>2. X-Frame-Options</strong></p>
<p>X-FRAME-OPTIONS是微软提出的一个http头，专门用来防御利用iframe嵌套的点击劫持攻击。并且在IE8、Firefox3.6、Chrome4以上的版本均能很好的支持。</p>
<p>可以设置为以下值:</p>
<ul>
<li>DENY: 拒绝任何域加载</li>
<li>SAMEORIGIN: 允许同源域下加载</li>
<li>ALLOW-FROM: 可以定义允许frame加载的页面地址</li>
</ul>
]]></content>
      <categories>
        <category>零散知识</category>
      </categories>
      <tags>
        <tag>xss</tag>
        <tag>csrf</tag>
        <tag>点击劫持</tag>
      </tags>
  </entry>
  <entry>
    <title>事件循环及消息队列</title>
    <url>/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%8F%8A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h3 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h3><p>  每个渲染进程都有一个主线程，并且主线程非常繁忙，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。要让这么多不同类型的任务在主线程中有条不紊地执行，这就需要一个系统来统筹调度这些任务，这个统筹调度系统就是我们今天要讲的<strong>消息队列</strong>和<strong>事件循环系统</strong>。</p>
<h3 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h3><ul>
<li>事件循环</li>
</ul>
<p><strong>要想在线程运行过程中，能接收并执行新的任务，就需要采用事件循环机制</strong></p>
<ul>
<li>消息队列</li>
</ul>
<p><img src="/_posts/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/assets/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%8F%8A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/image-20210705153141673.png" alt="image-20210705153141673"></p>
<p> 从上图可以看出，渲染主线程会频繁接收到来自于 IO 线程的一些任务，接收到这些任务之后，渲染进程就需要着手处理。那么如何设计好一个线程模型，能让其能够接收管理其他线程发送的消息呢？</p>
<p> 一个通用模式是使用<strong>消息队列</strong>。</p>
<p> <strong>消息队列是一种数据结构，可以存放要执行的任务</strong>。它符合队列“<strong>先进先出</strong>”的特点，也就是说<strong>要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取</strong>。</p>
<h3 id="事件循环及消息队列图示"><a href="#事件循环及消息队列图示" class="headerlink" title="事件循环及消息队列图示"></a>事件循环及消息队列图示</h3><p><img src="/_posts/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/assets/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%8F%8A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/image-20210705154145466.png" alt="image-20210705154145466"></p>
<h3 id="消息队列中的任务类型"><a href="#消息队列中的任务类型" class="headerlink" title="消息队列中的任务类型"></a>消息队列中的任务类型</h3><p>  输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等。</p>
<p>​    除此之外，消息队列中还包含了很多与页面相关的事件，如 JavaScript 执行、解析DOM、样式计算、布局计算、CSS 动画等。</p>
<p> 从另一种维度区分，就是宏任务和微任务</p>
<h4 id="微任务是为了解决什么问题？"><a href="#微任务是为了解决什么问题？" class="headerlink" title="微任务是为了解决什么问题？"></a>微任务是为了解决什么问题？</h4><p>页面线程所有执行的任务都来自于消息队列。消息队列是“先进先出”的属性，也就是说放入队列中的任务，需要等待前面的任务被执行完，才会被执行。鉴于这个属性，就有如下两个问题需要解决。</p>
<p>微任务就是为了<strong>处理高优先级的任务而被创建的</strong>。每个宏任务中都包含了一个<strong>微任务队列</strong>，在执行宏任务的过程中，如果 有微任务产生，那么就会将该变化添加到对应的微任务列表中。当宏任务完成后，程序会直接进入当前宏任务对应的微任务列表中（<strong>此时当前的宏任务并没结束</strong>）。程序会将微任务队列中所有的微任务执行完毕后才会进入下一个宏任务，如果在微任务执行的过程中产生了新的微任务，仍会被放置进当前的微任务列表等待执行。</p>
<h4 id="微任务、宏任务常见类型"><a href="#微任务、宏任务常见类型" class="headerlink" title="微任务、宏任务常见类型"></a>微任务、宏任务常见类型</h4><ul>
<li>macro-task:<ul>
<li>script(script标签里面的整体代码)</li>
<li>setTimeout</li>
<li>setInterval</li>
<li>setImmediate(node环境和部分ie才有)</li>
<li>MessageChannel（vue nextTick 以前应该是<a href="https://cn.vuejs.org/v2/guide/reactivity.html">备选方案</a>）</li>
<li>I&#x2F;O</li>
<li>UI rendering</li>
<li>requestAnimationFrame</li>
</ul>
</li>
<li>micro-task:<ul>
<li>process.nextTick(node环境才有)</li>
<li>Promise</li>
<li>Object.observe(已废弃，被下边那个取代了)</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver">MutationObserver</a> (接口提供了监视对DOM树所做更改的能力)</li>
</ul>
</li>
</ul>
<h4 id="setTimeout是如何实现的"><a href="#setTimeout是如何实现的" class="headerlink" title="setTimeout是如何实现的"></a>setTimeout是如何实现的</h4><p> 在 Chrome 中除了正常使用的消息队列之外，还有<strong>另外一个消息队列</strong>，这个队列中维护了需要延迟执行的任务列表，<strong>包括了定时器和 Chromium 内部一些需要延迟执行的任务</strong>。</p>
<p> 当通过 JavaScript 调用 setTimeout 设置回调函数的时候，渲染进程将会创建一个回调任务，包含了回调函数 showName、当前发起时间、延迟执行时间，其模拟代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct DelayTask&#123;</span><br><span class="line"> int64 id； </span><br><span class="line"> CallBackFunction cbf;</span><br><span class="line"> int start_time;</span><br><span class="line"> int delay_time;</span><br><span class="line">&#125;;</span><br><span class="line">DelayTask timerTask;</span><br><span class="line">timerTask.cbf = callbackFnc;</span><br><span class="line">timerTask.start_time = getCurrentTime(); // 获取当前时间</span><br><span class="line">timerTask.delay_time = 200;// 设置延迟执行时间</span><br></pre></td></tr></table></figure>

<p> 创建好回调任务之后，再将该任务添加到延迟执行队列中。这里我们要重点关注它的执行时机，下面是一段模拟代码，我们可以看出<strong>每完成一个宏任务，程序就回去延迟队列中取出已经到期的定时器任务，执行完成后进行下一轮循环</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void ProcessTimerTask()&#123;</span><br><span class="line">// 从 delayed_incoming_queue 中取出已经到期的定时器任务</span><br><span class="line">// 依次执行这些任务</span><br><span class="line">&#125;</span><br><span class="line">TaskQueue task_queue；</span><br><span class="line">void ProcessTask();</span><br><span class="line">bool keep_running = true;</span><br><span class="line">void MainTherad()&#123;</span><br><span class="line">  for (; ;) &#123;</span><br><span class="line">    // 执行消息队列中的任务</span><br><span class="line">    Task task = task_queue.takeTask();</span><br><span class="line">    ProcessTask(task);</span><br><span class="line"></span><br><span class="line">    // 执行延迟队列中的任务</span><br><span class="line">    ProcessDelayTask()</span><br><span class="line"></span><br><span class="line">    if (!keep_running) // 如果设置了退出标志，那么直接退出线程循环</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pomise"><a href="#pomise" class="headerlink" title="pomise"></a>pomise</h4><p>在promise专题内详细介绍，在这里只需要<strong>记住<code>promise.resolve</code> <code>promise.reject</code>会产生微任务</strong>就可以了</p>
<h4 id="async-await"><a href="#async-await" class="headerlink" title="async await"></a>async await</h4><p> async&#x2F;await 使用了 <code>Generator</code> 和 <code>Promise</code> 两种技术</p>
<h5 id="生成器和协程"><a href="#生成器和协程" class="headerlink" title="生成器和协程"></a>生成器和协程</h5><p>生成器函数是一个带星号函数，而且是可以暂停执行和恢复执行的</p>
<p> 要搞懂函数为何能暂停和恢复，那你首先要了解协程的概念。<strong>协程一种比线程更加轻量级的存在</strong>。你可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程</p>
<p> 正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制</p>
<p>看下面代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function* genDemo() &#123;</span><br><span class="line">    console.log(&quot; 开始执行第一段 &quot;)</span><br><span class="line">    yield &#x27;generator 1&#x27;</span><br><span class="line">    console.log(&quot; 开始执行第二段 &quot;)</span><br><span class="line">    yield &#x27;generator 2&#x27;</span><br><span class="line">    console.log(&quot; 开始执行第三段 &quot;)</span><br><span class="line">    yield &#x27;generator 3&#x27;</span><br><span class="line">    console.log(&quot; 执行结束 &quot;)</span><br><span class="line">    return &#x27;generator 4&#x27;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">console.log(&#x27;main 0&#x27;)</span><br><span class="line">let gen = genDemo()</span><br><span class="line">console.log(gen.next().value)</span><br><span class="line">console.log(&#x27;main 1&#x27;)</span><br><span class="line">console.log(gen.next().value)</span><br><span class="line">console.log(&#x27;main 2&#x27;)</span><br><span class="line">console.log(gen.next().value)</span><br><span class="line">console.log(&#x27;main 3&#x27;)</span><br><span class="line">console.log(gen.next().value)</span><br><span class="line">console.log(&#x27;main 4&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/_posts/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/assets/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%8F%8A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/image-20220722141347660.png" alt="image-20220722141347660"></p>
<p><img src="/_posts/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/assets/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%8F%8A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/image-20220228095741824.png" alt="image-20220228095741824"></p>
<p>从图中可以看出来协程的*<em>四点规则</em>******：</p>
<ul>
<li>通过调用生成器函数 genDemo 来创建一个协程 gen，创建之后，<strong>gen 协程并没有立即执行</strong>。</li>
<li>要让 gen 协程执行，需要通过调用 gen.next。</li>
<li>当协程正在执行的时候，可以通过 yield 关键字来暂停 gen 协程的执行，并返回主要信息给父协程。</li>
<li>如果协程在执行期间，<strong>遇到了 return 关键字，那么 JavaScript 引擎会结束当前协程，并将 return 后面的内容返回给父协程</strong>。</li>
</ul>
<p>不过，对于上面这段代码，你可能又有这样疑问：父协程有自己的调用栈，gen 协程时也有自己的调用栈，当 gen 协程通过 yield 把控制权交给父协程时，V8 是如何切换到父协程的调用栈？当父协程通过 gen.next 恢复 gen 协程时，又是如何切换 gen 协程的调用栈？</p>
<p>要搞清楚上面的问题，你需要关注以下两点内容。</p>
<ul>
<li><p>第一点：gen 协程和父协程是在主线程上交互执行的，并不是并发执行的，它们之前的切换是通过 yield 和 gen.next 来配合完成的。</p>
</li>
<li><p>第二点：<strong>当在 gen 协程中调用了 yield 方法时，JavaScript 引擎会&#x3D;&#x3D;保存 gen 协程当前的调用栈信息(包括活动对象和词法作用域)&#x3D;&#x3D;，并恢复父协程的调用栈信息。同样，当在父协程中执行 gen.next 时，JavaScript 引擎会保存父协程的调用栈信息，并恢复 gen 协程的调用栈信息</strong>。</p>
</li>
</ul>
<p>为了直观理解父协程和 gen 协程是如何切换调用栈的，你可以参考下图：</p>
<p><img src="/_posts/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/assets/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%8F%8A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/image-20210825120626382.png" alt="image-20210825120626382"></p>
<h6 id="tips-加深理解"><a href="#tips-加深理解" class="headerlink" title="tips 加深理解"></a><strong>tips</strong> 加深理解</h6><p>看一个面试题，可以考察对于切换调用栈的理解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 0</span><br><span class="line">var b = async () =&gt; &#123;</span><br><span class="line">  a = a + await 10</span><br><span class="line">  console.log(&#x27;2&#x27;, a) // -&gt; &#x27;2&#x27; 10</span><br><span class="line">  a = (await 10) + a</span><br><span class="line">  console.log(&#x27;3&#x27;, a) // -&gt; &#x27;3&#x27; 20</span><br><span class="line">&#125;</span><br><span class="line">b()</span><br><span class="line">a++</span><br><span class="line">console.log(&#x27;1&#x27;, a) // -&gt; &#x27;1&#x27; 1</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1</span><br><span class="line">2 10</span><br><span class="line">3 20</span><br></pre></td></tr></table></figure>

<p>对于以上代码你可能会有疑惑，这里说明下原理</p>
<ul>
<li>首先函数 <code>b</code> 先执行，在执行到 <code>await 10</code> 之前变量 <code>a</code> 还是 0，因为在 <strong><code>async</code> 内部实现了 <code>generators</code></strong> ，<code>generators</code> 会保留堆栈中东西，所以这时候 <code>a = 0</code> 被保存了下来</li>
<li>因为 <code>await</code> 是异步操作，遇到<code>await</code>就会<em><strong>立即返回一个<code>pending</code>状态的<code>Promise</code>对象</strong></em>，暂时返回执行代码的控制权，使得函数外的代码得以继续执行，所以会先执行 <code>console.log(&#39;1&#39;, a)</code></li>
<li>这时候同步代码执行完毕，开始执行异步代码，将保存下来的值拿出来使用，这时候 <code>a = 10</code></li>
<li>然后后面就是常规执行代码了</li>
</ul>
<h5 id="加深印象的两个问题"><a href="#加深印象的两个问题" class="headerlink" title="加深印象的两个问题"></a>加深印象的两个问题</h5><ul>
<li><p>generator 函数是如何暂停执行程序的？</p>
<p> 答案是通过协程来控制程序执行。</p>
<p> generator 函数是一个生成器，<strong>执行它会返回一个迭代器</strong>，这个迭代器同时也是一个协程。一个线程中可以有多个协程，但是同时只能有一个协程在执行。线程的执行是在内核态，是由操作系统来控制；协程的执行是在用户态，是完全由程序来进行控制，通过调用生成器的next()方法可以让该协程执行，通过yield关键字可以让该协程暂停，交出主线程控制权，通过return 关键字可以让该协程结束。协程切换是在用户态执行，而线程切换时需要从用户态切换到内核态，在内核态进行调度，协程相对于线程来说更加轻量、高效。</p>
</li>
<li><p><strong>async function实现原理</strong>？</p>
<p> async function 是通过 promise + generator 来实现的。</p>
<p> generator 是通过协程来控制程序调度的。在协程中执行异步任务时，先用promise封装该异步任务，如果异步任务完成，会将其结果放入微任务队列中，然后通过yield 让出主线程执行权，继续执行主线程js，主线程js执行完毕后，会去扫描微任务队列，如果有任务则取出任务进行执行，这时<strong>通过调用迭代器的next(result)方法，并传入任务执行结果result，将主线程执行权转交给该协程继续执行，并且将result赋值给yield 表达式左边的变量，从而以同步的方式实现了异步编程</strong>。所以说到底async function 还是通过协程+微任务+浏览器事件循环机制来实现的。</p>
</li>
</ul>
<h5 id="async、await的等价表示"><a href="#async、await的等价表示" class="headerlink" title="async、await的等价表示"></a>async、await的等价表示</h5><p>写这个主要是帮助理解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function foo() &#123;</span><br><span class="line">   return 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">等价于:</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">   return Promise.resolve(1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function foo() &#123;</span><br><span class="line">   await 1</span><br><span class="line">   xxxxxxx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">等价于:</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">   return Promise.resolve(1).then(() =&gt; &#123;</span><br><span class="line">     xxxxxxx</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="async"><a href="#async" class="headerlink" title="async"></a>async</h5><p>async 是一个通过<strong>异步执行并隐式返回 Promise</strong> 作为结果的函数</p>
<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function foo() &#123;</span><br><span class="line"> return 2</span><br><span class="line">&#125;</span><br><span class="line">console.log(foo()) </span><br><span class="line">// Promise &#123;&lt;resolved&gt;: 2&#125;</span><br></pre></td></tr></table></figure>

<h5 id="await"><a href="#await" class="headerlink" title="await"></a>await</h5><p>用代码来分析一下吧</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function foo() &#123;</span><br><span class="line">  console.log(1)</span><br><span class="line">  let a = await 100</span><br><span class="line">  console.log(a)</span><br><span class="line">  console.log(2)</span><br><span class="line">&#125;</span><br><span class="line">console.log(0)</span><br><span class="line">foo()</span><br><span class="line">console.log(3)</span><br></pre></td></tr></table></figure>

<p>在详细介绍之前，我们先站在协程的视角来看看这段代码的整体执行流程图：</p>
<p><img src="/_posts/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/assets/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%8F%8A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/image-20220722141448815.png" alt="image-20220722141448815"></p>
<p><strong>结合上图，我们来一起分析下 async&#x2F;await 的执行流程</strong>。</p>
<blockquote>
<p>描述较长，理解记忆</p>
</blockquote>
<p> 首先，执行console.log(0)这个语句，打印出来 0。</p>
<p> 紧接着就是执行 foo 函数，由于 foo 函数是被 async 标记过的，所以当进入该函数的时候，JavaScript 引擎会保存当前的调用栈等信息，然后执行 foo 函数中<code>console.log(1)</code>语句，并打印出 1。</p>
<p> 接下来就执行到 foo 函数中的<code>await 100</code>这个语句了，这里是我们<strong>分析的重点</strong>，因为在执行await 100这个语句时，JavaScript 引擎在背后为我们默默做了太多的事情，那么下面我们就把这个语句拆开，来看看 JavaScript 到底都做了哪些事情。</p>
<p> <strong>当执行到await 100时，会默认创建一个 Promise 对象</strong>，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let promise = new Promise((resolve,reject)&#123;</span><br><span class="line">  resolve(100)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p> 在这个 promise 对象创建的过程中，我们可以看到在 executor 函数中调用了 resolve 函数，JavaScript 引擎会将该任务提交给微任务队列。</p>
<p> 然后 JavaScript 引擎会暂停当前协程的执行，将主线程的控制权转交给父协程执行，同时会将 <strong>promise对象返回给父协程</strong>。</p>
<p> 主线程的控制权已经交给父协程了，这时候父协程要做的一件事是调用 promise.then 来监控 promise 状态的改变。</p>
<p> 接下来继续执行父协程的流程，这里我们执行console.log(3)，并打印出来 3。随后父协程将执行结束，在结束之前，会进入微任务的检查点，然后执行微任务队列，微任务队列中有<strong>resolve(100)的任务等待执行，执行到这里的时候，会触发 promise.then 中的回调函数</strong>，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">promise.then((value)=&gt;&#123;</span><br><span class="line">// 回调函数被激活后</span><br><span class="line">// 将主线程控制权交给 foo 协程，并将 vaule 值传给协程</span><br><span class="line">&#125;)</span><br><span class="line">该回调函数被激活以后，会将主线程的控制权交给 foo 函数的协程，并同时将 value 值传给该协程。</span><br></pre></td></tr></table></figure>

<p> 该回调函数被激活以后，会将主线程的控制权交给 foo 函数的协程，并同时将 value 值传给该协程。</p>
<p> foo 协程激活之后，会把刚才的 value 值赋给了变量 a，然后 foo 协程继续执行后续语句，执行完成之后，将控制权归还给父协程。</p>
<p> 以上就是 await&#x2F;async 的执行流程。</p>
<h3 id="nodejs中的时间循环"><a href="#nodejs中的时间循环" class="headerlink" title="nodejs中的时间循环"></a>nodejs中的时间循环</h3><blockquote>
<p>没必要太过于深究，网上说的也是各不相同</p>
</blockquote>
<p>首先上图</p>
<p><img src="/_posts/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/assets/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%8F%8A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/image-20211231142902981.png" alt="image-20211231142902981"></p>
<h4 id="先解释一下各个阶段"><a href="#先解释一下各个阶段" class="headerlink" title="先解释一下各个阶段"></a>先解释一下各个阶段</h4><ol>
<li>timers: 这个阶段执行setTimeout()和setInterval()设定的回调，可以认为是设置。</li>
<li>pending callbacks: 执行几乎所有的回调，<strong>除了</strong>close回调，timer的回调，和setImmediate()的回调。</li>
<li>idle, prepare: 仅内部使用。</li>
<li>poll: 获取新的I&#x2F;O事件；node会在适当条件下阻塞在这里。</li>
<li>check: 执行setImmediate()设定的回调。</li>
<li>close callbacks: 执行比如socket.on(‘close’, …)的回调。</li>
</ol>
<blockquote>
<p>我们只需要关注<strong>timer poll check</strong> 这三个阶段即可</p>
</blockquote>
<h4 id="每个阶段的详情"><a href="#每个阶段的详情" class="headerlink" title="每个阶段的详情"></a>每个阶段的详情</h4><h5 id="timer"><a href="#timer" class="headerlink" title="*timer"></a>*timer</h5><p>一个timer指定一个下限时间而不是准确时间，在达到这个下限时间后执行回调。在指定时间过后，timers会尽可能早地执行回调，但系统调度或者其它回调的执行可能会延迟它们。</p>
<p>据我观察。<strong>timer阶段应该会向某个队列放入到时间的定时器，以便poll阶段调用</strong></p>
<blockquote>
<p>注意：<strong>技术上来说，poll 阶段控制 timers 什么时候执行</strong>。</p>
</blockquote>
<h5 id="Pending-callbacks"><a href="#Pending-callbacks" class="headerlink" title="Pending callbacks"></a>Pending callbacks</h5><p>执行延迟到下一个循环迭代的 I&#x2F;O 回调。此阶段对某些系统操作（如 TCP 错误类型）执行回调。例如，如果 TCP 套接字在尝试连接时接收到 <code>ECONNREFUSED</code>，则某些 *nix 的系统希望等待报告错误。这将被排队以在挂起的回调阶段执行。</p>
<h5 id="poll-重点分析"><a href="#poll-重点分析" class="headerlink" title="*poll 重点分析"></a>*poll 重点分析</h5><p>poll 阶段的流程</p>
<ul>
<li>执行 poll 阶段的任务队列。</li>
<li>如果为空了，则检查是否存在已达到时间阈值的计时器(timers)，如果有则跳转至timers阶段</li>
</ul>
<p><strong>没有被调度的计时器时，将会发生以下情况</strong></p>
<ul>
<li>如果 poll 队列不为空的话，会执行 poll 队列直到清空或者系统回调数达到了与系统相关的硬性限制</li>
<li>如果 poll 队列为空<ul>
<li>如果设定了 setImmediate 回调，会直接跳到 check 阶段。</li>
<li>如果没有设定 setImmediate 回调，会阻塞住进程，并等待新的 poll 任务（<strong>定时器或者新的I&#x2F;O事件</strong>）加入并立即执行。</li>
</ul>
</li>
</ul>
<blockquote>
<p>来自于charTGp</p>
<p>在 Node.js 中，Poll 阶段阻塞时，不会立即进入 Check 阶段。相反，Node.js 会等待事件循环中的 Poll 阶段完成或者达到一定条件时，才会继续执行 Check 阶段。具体的情况如下：</p>
<ol>
<li><strong>当 Poll 阶段有事件到达时</strong>：如果在 Poll 阶段有 I&#x2F;O 事件（例如网络请求或文件读取）到达，事件循环会立即离开 Poll 阶段，处理这些事件的回调函数，并且不会进入 Check 阶段，直接返回到 Timers 阶段，以执行定时器回调函数。</li>
<li><strong>当 Poll 阶段没有事件到达，但有 setImmediate 回调函数时</strong>：如果 Poll 阶段没有待处理的事件，事件循环会继续检查是否有设置了 <code>setImmediate</code> 的回调函数需要执行，如果有，它会离开 Poll 阶段，进入 Check 阶段执行这些回调函数。</li>
<li><strong>在某些情况下，可能需要 Poll 阶段显式让出控制</strong>：有时，开发者可能需要在 Poll 阶段显式让出控制，以便在稍后的事件循环迭代中进入 Check 阶段。这可以通过使用 <code>process.nextTick</code> 来实现。<code>process.nextTick</code> 的回调函数会在当前事件循环迭代的末尾执行，然后才进入下一个迭代的 Check 阶段。</li>
</ol>
<p>总之，在大多数情况下，当 Poll 阶段没有待处理的事件时，事件循环会立即检查是否有 <code>setImmediate</code> 回调函数需要执行，然后再进入 Check 阶段。这就是为什么 <code>setImmediate</code> 的回调函数有时被描述为 “下一个事件循环迭代中执行” 的原因。但需要注意，<code>setImmediate</code> 回调函数也不能保证立即执行，它仍然受到事件循环的进程调度和其他因素的影响。</p>
</blockquote>
<h5 id="check"><a href="#check" class="headerlink" title="*check"></a>*check</h5><p>这个阶段在 poll 结束后立即执行，setImmediate 的回调会在这里执行。</p>
<p>一般来说，event loop 肯定会进入 poll 阶段，当没有 poll 任务时，会等待新的任务出现，但如果设定了 setImmediate，会直接执行进入下个阶段而不是继续等。</p>
<h5 id="close"><a href="#close" class="headerlink" title="close"></a>close</h5><p>如果套接字或处理函数突然关闭（例如 <code>socket.destroy()</code>），则<code>&#39;close&#39;</code> 事件将在这个阶段发出。否则它将通过 <code>process.nextTick()</code> 发出???。</p>
<h4 id="帮助理解的例子"><a href="#帮助理解的例子" class="headerlink" title="帮助理解的例子"></a>帮助理解的例子</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var fs = require(&#x27;fs&#x27;);</span><br><span class="line"></span><br><span class="line">function someAsyncOperation (callback) &#123;</span><br><span class="line">  // 假设这个任务要消耗 95ms</span><br><span class="line">  fs.readFile(&#x27;/path/to/file&#x27;, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var timeoutScheduled = Date.now();</span><br><span class="line"></span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line"></span><br><span class="line">  var delay = Date.now() - timeoutScheduled;</span><br><span class="line"></span><br><span class="line">  console.log(delay + &quot;ms have passed since I was scheduled&quot;);</span><br><span class="line">&#125;, 100);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// someAsyncOperation要消耗 95 ms 才能完成</span><br><span class="line">someAsyncOperation(function () &#123;</span><br><span class="line"></span><br><span class="line">  var startCallback = Date.now();</span><br><span class="line"></span><br><span class="line">  // 消耗 10ms...</span><br><span class="line">  while (Date.now() - startCallback &lt; 10) &#123;</span><br><span class="line">    ; // do nothing</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>当event loop进入 poll 阶段，它有个空队列（fs.readFile()尚未结束）。所以它会等待剩下的毫秒， 直到最近的timer的下限时间到了。当它等了95ms，fs.readFile()首先结束了，然后它的回调被加到 poll 的队列并执行——这个回调耗时10ms。之后由于没有其它回调在队列里，所以event loop会查看最近达到的timer的 下限时间，然后回到 timers 阶段，执行timer的回调。</p>
<p>所以在示例里，回调被设定 和 回调执行间的间隔是105ms。</p>
<h4 id="setImmediate-vs-setTimeout"><a href="#setImmediate-vs-setTimeout" class="headerlink" title="setImmediate() vs setTimeout()"></a>setImmediate() vs setTimeout()</h4><p>现在我们应该知道两者的不同，他们的执行阶段不同，setImmediate() 在 check 阶段，而settimeout 在 poll 阶段执行。但，还不够。来看一下例子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// timeout_vs_immediate.js</span><br><span class="line">setTimeout(function timeout () &#123;</span><br><span class="line">  console.log(&#x27;timeout&#x27;);</span><br><span class="line">&#125;,0);</span><br><span class="line"></span><br><span class="line">setImmediate(function immediate () &#123;</span><br><span class="line">  console.log(&#x27;immediate&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br><span class="line">$ node timeout_vs_immediate.js</span><br><span class="line">timeout</span><br><span class="line">immediate</span><br><span class="line"></span><br><span class="line">$ node timeout_vs_immediate.js</span><br><span class="line">immediate</span><br><span class="line">timeout</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>结果居然是不确定的，why？</p>
<p>还是直接给出解释吧。</p>
<ol>
<li>首先进入timer阶段，如果我们的机器性能一般，那么进入timer阶段时，1毫秒可能已经过去了（setTimeout(fn, 0) 等价于setTimeout(fn, 1)），那么setTimeout的回调会首先执行。</li>
<li>如果没到一毫秒，那么我们可以知道，在check阶段，setImmediate的回调会先执行。</li>
</ol>
<p>那我们再来一个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// timeout_vs_immediate.js</span><br><span class="line">var fs = require(&#x27;fs&#x27;)</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;timeout&#x27;)</span><br><span class="line">  &#125;, 0)</span><br><span class="line">  setImmediate(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;immediate&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>输出始终为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ node timeout_vs_immediate.js</span><br><span class="line">immediate</span><br><span class="line">timeout</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这个就很好解释了吧。 fs.readFile 的回调执行是在 poll 阶段。当 fs.readFile 回调执行完毕之后，会直接到 check 阶段，先执行 setImmediate 的回调。</p>
<h4 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h4><p>nextTick 比较特殊，它有自己的队列，并且，独立于event loop。 它的执行也非常特殊，<strong>无论 event loop 处于何种阶段，都会在<u>当前</u>阶段结束的时候清空 nextTick 队列</strong>。</p>
<h4 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h4><p> <code>promise</code>和<code>process.nextTick()</code>类似，处在任意阶段的末尾，如果有上述两种任务，都会在当前阶段结束前执行</p>
<p>但是优先级比nextTick低。</p>
<p><a href="https://www.udemy.com/course/nodejs-express-mongodb-bootcamp/learn/lecture/15064744#overview">https://www.udemy.com/course/nodejs-express-mongodb-bootcamp/learn/lecture/15064744#overview</a></p>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;);</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;setTimeout 1&#x27;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">setImmediate(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;setImmediate 1&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.readFile(&#x27;./test-file.txt&#x27;, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;readFile&#x27;);</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;setTimeout 2&#x27;);</span><br><span class="line">  &#125;, 0);</span><br><span class="line"></span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;setTimeout 3&#x27;);</span><br><span class="line">  &#125;, 3000);</span><br><span class="line"></span><br><span class="line">  setImmediate(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;setImmediate 2&#x27;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;promise 1&#x27;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  process.nextTick(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;nextTick 1&#x27;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;promise 2&#x27;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// nextTick 会在每个阶段结束前运行 </span><br><span class="line">// promise 优先级不如nextTick</span><br><span class="line"></span><br><span class="line">// setImmediate 1</span><br><span class="line">// setTimeout 1</span><br><span class="line">// readFile</span><br><span class="line">// nextTick 1</span><br><span class="line">// promise 1</span><br><span class="line">// promise 2</span><br><span class="line">// setImmediate 2</span><br><span class="line">// setTimeout 2</span><br><span class="line">// setTimeout 3</span><br></pre></td></tr></table></figure>

<h4 id="简化版"><a href="#简化版" class="headerlink" title="简化版"></a>简化版</h4><p><strong>一句话总结</strong></p>
<p>timers（定时器） &#x3D;&gt; poll（i&#x2F;o） &#x3D;&gt; check(setImmediate)，</p>
<p><code>promise</code>和<code>process.nextTick()</code>类似，处在任意阶段的末尾，如果有上述两种任务，都会在当前阶段结束前执行</p>
<p><a href="https://juejin.cn/post/6844903685936381959#heading-8">腾讯</a></p>
<p><a href="https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/">node官网</a></p>
<p><a href="https://juejin.cn/post/6844903761949753352#heading-22">掘金</a></p>
]]></content>
      <categories>
        <category>零散知识</category>
      </categories>
      <tags>
        <tag>事件循环</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解垃圾回收机制</title>
    <url>/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<blockquote>
<p>在V8原理中 22小节 有一些增量知识–回收效率</p>
</blockquote>
<p>在JavaScript中<strong>产生的垃圾数据是由垃圾回收器来释放的</strong>，并不需要手动通过代码来释放。</p>
<p>我们知道JavaScript的数据分为两类，<strong>原始数据类型是存储在栈空间中的，引用类型的数据是存储在堆空间中的</strong>。</p>
<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><h3 id="栈中的数据是如何回收的"><a href="#栈中的数据是如何回收的" class="headerlink" title="栈中的数据是如何回收的"></a><strong>栈中的数据是如何回收的</strong></h3><p>在blog中有关于介绍**执行上下文(调用栈)**的详细介绍，栈中的垃圾回收，我们通过一段代码来看一下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"> <span class="keyword">var</span> b = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客邦 &quot;</span>&#125;</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">showName</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">  <span class="keyword">var</span> d = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客时间 &quot;</span>&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="title function_">showName</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>

<p>当执行到第 6 行代码时，其调用栈和堆空间状态图如下所示：</p>
<p><img src="/_posts/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/assets/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210720151826588.png" alt="image-20210720151826588"></p>
<p>当showName执行完毕，上下文需要切换至foo时，有一个<strong>记录当前执行状态的指针（称为 ESP）</strong>会下移指向foo函数的执行上下文，虽然showName的执行上下文未被摧毁，但是已经是无效内存了。因为如果当foo 函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文</p>
<p><img src="/_posts/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/assets/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210720152137737.png" alt="image-20210720152137737"></p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p> 在栈空间中，<strong>JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文，顺带完成了栈空间的垃圾回收</strong>。</p>
<h3 id="堆中的数据是如何回收的"><a href="#堆中的数据是如何回收的" class="headerlink" title="堆中的数据是如何回收的"></a><strong>堆中的数据是如何回收的</strong></h3><p>继续上边代码的执行，当上面那段代码的 foo 函数执行结束之后，ESP 应该是指向全局执行上下文的，那这样的话，showName 函数和 foo 函数的执行上下文就处于无效状态了，<strong>不过保存在堆中的两个对象依然占用着空间</strong>，如下图所示：</p>
<p><img src="/_posts/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/assets/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210720152420782.png" alt="image-20210720152420782"></p>
<p><strong>要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了</strong>。</p>
<h4 id="代际假说"><a href="#代际假说" class="headerlink" title="代际假说"></a>代际假说</h4><p> <strong>代际假说（The Generational Hypothesis）</strong>，这是垃圾回收领域中一个重要的术语，后续垃圾回收的策略都是建立在该假说的基础之上的。</p>
<p><strong>代际假说</strong>有以下两个特点：</p>
<ul>
<li><p>第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；</p>
</li>
<li><p>第二个是不死的对象，会活得更久。</p>
</li>
</ul>
<h4 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h4><p>在 V8 中会把堆分为<strong>新生代</strong>和<strong>老生代</strong>两个区域，<strong>新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象</strong>。</p>
<ul>
<li><p><strong>副垃圾回收器，主要负责新生代的垃圾回收。</strong></p>
</li>
<li><p><strong>主垃圾回收器，主要负责老生代的垃圾回收。</strong></p>
</li>
</ul>
<h4 id="统一的回收流程"><a href="#统一的回收流程" class="headerlink" title="统一的回收流程"></a>统一的回收流程</h4><p> 不论什么类型的垃圾回收器，它们都有一套共同的执行流程</p>
<ul>
<li><p>标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。</p>
</li>
<li><p>回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</p>
</li>
<li><p>第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们</p>
<p>把这些不连续的内存空间称为<strong>内存碎片</strong>。（<strong>副垃圾回收器不会产生内存碎片</strong>）</p>
</li>
</ul>
<h4 id="副垃圾回收器"><a href="#副垃圾回收器" class="headerlink" title="副垃圾回收器"></a><strong>副垃圾回收器</strong></h4><p> 副垃圾回收器主要负责新生区的垃圾回收。大多数小的对象都会被分配到新生区，所以说这个<strong>区域虽然不大</strong>，但是垃圾回收还是比较<strong>频繁</strong>的。</p>
<p> 新生代中用<strong>Scavenge 算法</strong>来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，如下图所示：</p>
<p><img src="/_posts/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/assets/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210720153841493.png" alt="image-20210720153841493"></p>
<p>新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</p>
<p> 在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还<strong>会把这些对象有序地排列起来</strong>，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。</p>
<p> 完成复制后，对象区域与空闲区域进行角色翻转，这样就完成了垃圾对象的回收操作，同时这种<strong>角色翻转的操作还能让新生代中的这两块区域无限重复使用下去</strong>。</p>
<blockquote>
<p>复制操作需要时间成本，<strong>为了执行效率，一般新生区的空间会被设置得比较小</strong></p>
</blockquote>
<h5 id="对象晋升策略"><a href="#对象晋升策略" class="headerlink" title="对象晋升策略"></a>对象晋升策略</h5><p> JavaScript 引擎采用了<strong>对象晋升策略</strong>，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中</p>
<h4 id="主垃圾回收器"><a href="#主垃圾回收器" class="headerlink" title="主垃圾回收器"></a><strong>主垃圾回收器</strong></h4><p> 主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，<strong>一些大的对象会直接被分配到老生区</strong>。因此老生区中的对象有两个特点，一个是<strong>对象占用空间大</strong>，另一个是<strong>对象存活时间长</strong>。</p>
<p> 由于老生去对象比较大，不适合新生去的回收机制，主垃圾回收器是采用标记-清除算法</p>
<h5 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记 - 清除"></a>标记 - 清除</h5><p> 首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素（<strong>调用栈</strong>），在这个遍历过程中，能到达的元素称为<strong>活动对象</strong>，没有到达的元素就可以判断为<strong>垃圾数据</strong>。</p>
<p> 接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其清除过程：</p>
<p><img src="/_posts/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/assets/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210720154746371.png" alt="image-20210720154746371"></p>
<p>不过对一块内存多次执行标记 - 清除算法后，会<strong>产生大量不连续的内存碎片</strong>，于是又产生了另外一种算法——<strong>标记 - 整理（Mark-Compact）</strong></p>
<p> 这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。你可以参考下图：</p>
<p><img src="/_posts/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/assets/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210720154921297.png" alt="image-20210720154921297"></p>
<h4 id="全停顿"><a href="#全停顿" class="headerlink" title="全停顿"></a><strong>全停顿</strong></h4><p> JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做<strong>全停顿（Stop-The-World）</strong>。</p>
<p><img src="/_posts/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/assets/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210720154954477.png" alt="image-20210720154954477"></p>
<p>一般来说是老生代的垃圾回收占用时间较长，新生代可以忽略不计。为了解决这个问题，V8使用了<strong>增量标记（Incremental Marking）算法</strong>。</p>
<p><img src="/_posts/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/assets/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210720155150795.png" alt="image-20210720155150795"></p>
<p>V8 将<strong>标记过程</strong>分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成。这样当执行复杂动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。</p>
<blockquote>
<p>精彩评论</p>
<p><img src="/_posts/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/assets/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220720104725019.png" alt="image-20220720104725019"></p>
</blockquote>
]]></content>
      <categories>
        <category>零散知识</category>
      </categories>
      <tags>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖和节流</title>
    <url>/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<p>在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。</p>
<p>通常这种情况下我们怎么去解决的呢？一般来讲，防抖和节流是比较好的解决方案。<br>用一句比较剪短的话形容两者的区别：<br><strong>防抖是控制次数，节流是控制频率</strong></p>
<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><ul>
<li>非立即执行版：<br>触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function debounce(func, wait) &#123;</span><br><span class="line">  let timeout;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    let args = arguments;</span><br><span class="line">    if (timeout) clearTimeout(timeout);</span><br><span class="line">    timeout = setTimeout(() =&gt; &#123;</span><br><span class="line">      // 直接用箭头函数就可以解决this指向</span><br><span class="line">      func.apply(this, args)</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>立即执行版：<br>立即执行版的意思是触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function debounce(func,wait) &#123;</span><br><span class="line">  let timeout;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    let context = this;</span><br><span class="line">    let args = arguments;</span><br><span class="line">    if (timeout) clearTimeout(timeout);</span><br><span class="line">    let callNow = !timeout;</span><br><span class="line">    timeout = setTimeout(() =&gt; &#123;</span><br><span class="line">      timeout = null;</span><br><span class="line">    &#125;, wait)</span><br><span class="line">    if (callNow) func.apply(context, args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function throttle(func, wait) &#123;</span><br><span class="line">  let timeout;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    let args = arguments;</span><br><span class="line">    if (!timeout) &#123;</span><br><span class="line">      timeout = setTimeout(() =&gt; &#123;</span><br><span class="line">        timeout = null;</span><br><span class="line">        func.apply(this, args)</span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>零散知识</category>
      </categories>
      <tags>
        <tag>防抖</tag>
        <tag>节流</tag>
      </tags>
  </entry>
  <entry>
    <title>箭头函数与call</title>
    <url>/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>在看阮一峰大佬的ES6时，看到一个关于箭头函数和this的例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;id:&#x27;, this.id);</span><br><span class="line">  &#125;, 100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var id = 21;</span><br><span class="line"></span><br><span class="line">foo.call(&#123; id: 42 &#125;);</span><br><span class="line">// id: 42</span><br></pre></td></tr></table></figure>

<p>输出结果竟然是42，我一直以为箭头函数的this从函数定义时就已经固定不变了，es6的教程也看过几遍，还是<strong>看书不仔细</strong>漏过了这个问题  </p>
<p>在疑惑后也思考研究了一下，结合搜索到的例子，得出一下结论：<br>首先不使用箭头函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(&#x27;this.id:&#x27;,this.id); // this.id: 42</span><br><span class="line">  setTimeout( function () &#123;</span><br><span class="line">      console.log(&#x27;this.id:&#x27;,this.id); // this.id: 21</span><br><span class="line">  &#125;,100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var id = 21;</span><br><span class="line"></span><br><span class="line">foo.call(&#123; id: 42 &#125;);</span><br></pre></td></tr></table></figure>

<p>此时结果都是可以预期的，第一行输出42，是因为call函数改变了foo的指针执行，指向为{id: 42}<br>第二行输出21，是因为setTimeout是挂载在window下面的。setTimeout实际上又改变了this的指针指向，将this又指向了window。因此输出21。</p>
<p>将函数改为箭头函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(&#x27;this.id:&#x27;,this.id); // this.id: 42</span><br><span class="line">  setTimeout( () =&gt; &#123;</span><br><span class="line">      console.log(&#x27;this.id:&#x27;,this.id); // this.id: 42</span><br><span class="line">  &#125;,100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var id = 21;</span><br><span class="line"></span><br><span class="line">foo.call(&#123; id: 42 &#125;);</span><br></pre></td></tr></table></figure>

<p>此时第一行依旧输出42，这一点是肯定的<br>分析第二行，箭头函数导致this总是指向函数（箭头函数）定义生效时所在的对象，这句话换个方式理解比较容易理解和记忆，即<strong>箭头函数的this指向和将箭头函数的内容拿到函数外层的this指向是一致的</strong><br>结合上面的例子就是 第二行的this应该和第一行的this是一致的  </p>
<blockquote>
<p>看到闭包以后，我觉得箭头函数既然没有自己的this，是不是相当于普通函数获取上一级的变量一样。。。？</p>
</blockquote>
<p><strong>再看一下这个例子</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  name : <span class="string">&quot;myObj&quot;</span>, </span><br><span class="line">  <span class="attr">showThis</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 可以更清晰的看到发生了什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;obj&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fnc1 = myObj.<span class="title function_">showThis</span>()</span><br><span class="line"><span class="comment">// &#123;name: &#x27;myObj&#x27;, showThis: ƒ&#125;</span></span><br><span class="line">fnc1.<span class="title function_">call</span>(obj)</span><br><span class="line"><span class="title function_">fnc1</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fnc2 = myObj.<span class="property">showThis</span>.<span class="title function_">call</span>(obj)</span><br><span class="line"><span class="comment">// &#123;name: &#x27;obj&#x27;&#125;</span></span><br><span class="line"><span class="title function_">fnc2</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// myObj</span></span><br><span class="line"><span class="comment">// myObj</span></span><br><span class="line"><span class="comment">// obj</span></span><br></pre></td></tr></table></figure>

<p>可以看到 call apply 和bind 也无法改变箭头函数的this，始终取决于上层上下文的this</p>
]]></content>
      <categories>
        <category>零散知识</category>
      </categories>
      <tags>
        <tag>this</tag>
        <tag>箭头函数</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符</title>
    <url>/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="和-和-和"><a href="#和-和-和" class="headerlink" title="&amp;&amp; 和 || 和 | 和 &amp;"></a><code>&amp;&amp;</code> 和 <code>||</code> 和 <code>|</code> 和 <code>&amp;</code></h2><p>逻辑运算符如下表所示 (其中expr可能是任何一种类型, 不一定是布尔值):<br>&amp;&amp; 优先级高于 ||  </p>
<p><img src="/_posts/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/assets/%E8%BF%90%E7%AE%97%E7%AC%A6/bg1.png" alt="控制台输出"><br>如果一个值可以被转换为 true，那么这个值就是所谓的 truthy，如果可以被转换为 false，那么这个值就是所谓的 falsy。<br>会被转换为 false 的表达式有：</p>
<ul>
<li>null；</li>
<li>NaN；</li>
<li>0；</li>
<li>空字符串（”” or ‘’ or ``）；</li>
<li>undefined。</li>
</ul>
<p>尽管 &amp;&amp; 和 || 运算符能够使用非布尔值的操作数, 但它们依然可以被看作是布尔操作符，因为它们的返回值总是能够被转换为布尔值。如果要显式地将它们的返回值（或者表达式）转换为布尔值，请使用双重非运算符（即!!）或者Boolean构造函数。</p>
<h3 id="短路计算"><a href="#短路计算" class="headerlink" title="短路计算"></a>短路计算</h3><p>由于逻辑表达式的运算顺序是从左到右，也可以用以下规则进行”短路”计算：</p>
<ul>
<li><p>(some falsy expression) &amp;&amp; (expr) 短路计算的结果为假。</p>
</li>
<li><p>(some truthy expression) || (expr) 短路计算的结果为真。<br>常见用法</p>
</li>
<li><p>判断对象属性是否存在</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(obj.prop&amp;&amp;obj.prop.prop)</span><br></pre></td></tr></table></figure>

<ul>
<li>赋值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function (arg)&#123;</span><br><span class="line">  var a = arg || 5;</span><br><span class="line">&#125;</span><br><span class="line">// 是否存在 不存在创建并赋值</span><br><span class="line">(this._events[event] || (this._evnet[evnet] = [])).push(fn)</span><br></pre></td></tr></table></figure>

<ul>
<li>简写</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(a==b)&#123;console.log(1)&#125;</span><br><span class="line">a==b&amp;&amp;console.log(1)</span><br></pre></td></tr></table></figure>

<h3 id="属于位运算符"><a href="#属于位运算符" class="headerlink" title="| &amp;属于位运算符"></a><code>|</code> <code>&amp;</code>属于位运算符</h3><p>此处不深究</p>
]]></content>
      <categories>
        <category>零散知识</category>
      </categories>
      <tags>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>vue源码分析说明</title>
    <url>/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>文章只是简易的记录下源码里比较重要的节点，方便压缩信息，进行二次记忆。<br>在github中fork仓库里有当时学习的注释，建议结合<a href="https://ustbhuangyi.github.io/vue-analysis/v2/vuex/init.html">黄轶的源码分析</a>加源码加深记忆</p>
]]></content>
      <categories>
        <category>vue</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>vue初始化流程-简易流程</title>
    <url>/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/vue/</url>
    <content><![CDATA[<p><img src="/_posts/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/assets/vue/image-20220325102130556.png" alt="image-20220325102130556"></p>
<p>本文简单的分析一下vue从初始化到完成渲染的流程，重点还是在于响应式的分析，生命周期函数简单带过。</p>
<blockquote>
<p>以下代码均经过不同程度的精简</p>
</blockquote>
<h3 id="vue-init"><a href="#vue-init" class="headerlink" title="vue.init"></a>vue.init</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vue.prototype._init = function(options) &#123;</span><br><span class="line">  vm.$options = mergeOptions(  // 合并options</span><br><span class="line">      resolveConstructorOptions(vm.constructor),</span><br><span class="line">      options || &#123;&#125;,</span><br><span class="line">      vm</span><br><span class="line">  )</span><br><span class="line">  // ...</span><br><span class="line">  initLifecycle(vm) // 开始一系列的初始化 </span><br><span class="line">  initEvents(vm)</span><br><span class="line">  initRender(vm)</span><br><span class="line">  callHook(vm, &#x27;beforeCreate&#x27;)        //执行 beforeCreate 钩子</span><br><span class="line">  initInjections(vm)</span><br><span class="line">  initState(vm) // observe</span><br><span class="line">  initProvide(vm)</span><br><span class="line">  callHook(vm, &#x27;created&#x27;)                    //执行 created 钩子</span><br><span class="line">  // ...</span><br><span class="line">  // 挂载dom</span><br><span class="line">  if (vm.$options.el) &#123;</span><br><span class="line">  // 可以认为是运行了 mountComponent </span><br><span class="line">    vm.$mount(vm.$options.el)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其实上述代码已经包含了整个生命周期的行为，简要分析一下函数所做的事情</p>
<h3 id="初始化到created"><a href="#初始化到created" class="headerlink" title="初始化到created"></a>初始化到created</h3><p>首先，将用户提供的<code>options</code>对象，父组件定义在子组件上的<code>event</code>、<code>props</code>(子组件实例化时)，<code>vm</code>原型方法，和<code>Vue</code>构造函数内置的选项合并成一个新的<code>options</code>对象，赋值给<code>vm.$options</code>。<br>接下来，执行 3 个初始化方法：</p>
<ul>
<li><p><strong>initLifecycle(vm)</strong>: 主要作用是确认组件的父子关系（定位非抽象父级）和初始化某些实例属性。找到父组件实例赋值给<code>vm.$parent</code>，将自己<code>push</code>给父组件的<code>$children</code>；</p>
</li>
<li><p><img src="/_posts/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/assets/vue/image-20230308115942545.png" alt="image-20230308115942545"></p>
</li>
<li><p><strong>initEvents(vm)</strong>: 主要作用是将父组件使用<code>v-on</code>或<code>@</code>注册的自定义事件添加到子组件的私有属性<code>vm._events</code>中；</p>
</li>
<li><p><strong>initRender(vm)</strong>: 主要作用是初始化用来将<code>render</code>函数转为<code>vnode</code>的方法<code>vm.$createElement</code>。用户自定义的<code>render</code>函数的参数<code>h</code>就是<code>vm.$createElement</code>方法，它可以返回<code>vnode</code>。此阶段还会进行<code>$attrs</code> <code>$listeners</code> <code>$slots</code> <code>$scopedSlots</code>的处理</p>
<blockquote>
<p>等以上操作全部完成，就会执行<code>beforeCreate</code>钩子函数，此时用户可以在函数中通过<code>this</code>访问到<code>vm.$parent</code>和<code>vm.$createElement</code> <code>$attrs</code> <code>$listeners</code> <code>$slots</code> <code>$scopedSlots</code>等有限的属性和方法。</p>
<p><img src="/_posts/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/assets/vue/image-20220118205925251.png" alt="image-20220118205925251"></p>
</blockquote>
</li>
<li><p><strong>触发beforeCreate</strong></p>
</li>
<li><p><strong>initInjections(vm)</strong>: 初始化<code>inject</code>，使得<code>vm</code>可以访问到对应的依赖；</p>
</li>
<li><p><strong>initState(vm)</strong>: 初始化会被使用到的状态，状态包括<code>props</code>，<code>methods</code>，<code>data</code>，<code>computed</code>，<code>watch</code>五个选项。调用相应的<code>init</code>方法，使用<code>vm.$options</code>中提供的选项对这些状态进行初始化，<strong>其中<code>initData</code>方法会调用<code>observe(data, true)</code>，实现对<code>data</code>中属性的监听，实际上是使用<code>Object.defineProperty</code>方法定义属性的<code>getter</code>和<code>setter</code>方法</strong>；</p>
<ul>
<li>Computed 和 watch 初始化 会创建computed-watch和user-watch</li>
</ul>
</li>
<li><p>**initProvide(vm)**：初始化<code>provide</code>，使得<code>vm</code>可以为子组件提供依赖。</p>
<blockquote>
<p>这 3 个初始化方法先初始化<code>inject</code>，然后初始化<code>props/data</code>状态，最后初始化<code>provide</code>，这样做的目的是可以在<code>props/data</code>中使用<code>inject</code>内所注入的内容。等以上操作全部完成，就会执行<code>created</code>钩子函数，此时用户可以在函数中通过<code>this</code>访问到<code>vm</code>中的<code>props</code>，<code>methods</code>，<code>data</code>，<code>computed</code>，<code>watch</code>和<code>inject</code>等大部分属性和方法。</p>
</blockquote>
</li>
<li><p><strong>触发created</strong></p>
</li>
</ul>
<h3 id="beforeMouted到mouted"><a href="#beforeMouted到mouted" class="headerlink" title="beforeMouted到mouted"></a>beforeMouted到mouted</h3><p>此阶段即是<code>vm.$mount(vm.$options.el)</code>过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行时版本：</span><br><span class="line">Vue.prototype.$mount = function(el) &#123; // 最初的定义</span><br><span class="line">    return mountComponent(this, query(el));</span><br><span class="line">&#125;</span><br><span class="line">完整版：</span><br><span class="line">const mount = Vue.prototype.$mount</span><br><span class="line">Vue.prototype.$mount = function(el) &#123;  // 拓展编译后的</span><br><span class="line">    var options = this.$options;</span><br><span class="line">    if(!options.render) &#123;</span><br><span class="line">        if(options.template) &#123;</span><br><span class="line">            ...                //一些判断</span><br><span class="line">        &#125; else if (el) &#123;    //传入的 el 选项不为空</span><br><span class="line">            options.template = getOuterHTML(el);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (options.template) &#123;</span><br><span class="line">                options.render = compileToFunctions(template, ...).render    //将 template 编译成 render 函数</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    return mount.call(this, query(el))    //即 Vue.prototype.$mount.call(this, query(el))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在完整版的<code>vm.$mount</code>方法中，如果用户未提供<code>render</code>函数，就会将<code>template</code>或者<code>el.outerHTML</code>编译成<code>render</code>函数。然后会执行<code>mountComponent</code>函数：</p>
<p><code>mountComponent</code>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export function mountComponent(</span><br><span class="line">  vm,</span><br><span class="line">  el,</span><br><span class="line">  hydrating</span><br><span class="line">) &#123;</span><br><span class="line">  vm.$el = el</span><br><span class="line">  if (!vm.$options.render) &#123;</span><br><span class="line">    vm.$options.render = createEmptyVNode</span><br><span class="line">    if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123;</span><br><span class="line">      /* istanbul ignore if */</span><br><span class="line">      if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !== &#x27;#&#x27;) ||</span><br><span class="line">        vm.$options.el || el) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &#x27;You are using the runtime-only build of Vue where the template &#x27; +</span><br><span class="line">          &#x27;compiler is not available. Either pre-compile the templates into &#x27; +</span><br><span class="line">          &#x27;render functions, or use the compiler-included build.&#x27;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &#x27;Failed to mount component: template or render function not defined.&#x27;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  callHook(vm, &#x27;beforeMount&#x27;)</span><br><span class="line"></span><br><span class="line">  let updateComponent</span><br><span class="line">  /* istanbul ignore if */</span><br><span class="line">  if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = () =&gt; &#123;</span><br><span class="line">      const name = vm._name</span><br><span class="line">      const id = vm._uid</span><br><span class="line">      const startTag = `vue-perf-start:$&#123;id&#125;`</span><br><span class="line">      const endTag = `vue-perf-end:$&#123;id&#125;`</span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      const vnode = vm._render()</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(`vue $&#123;name&#125; render`, startTag, endTag)</span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      vm._update(vnode, hydrating)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(`vue $&#123;name&#125; patch`, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    updateComponent = () =&gt; &#123;</span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // updateComponent 函数包括vnode生成及挂载到真实dom</span><br><span class="line"></span><br><span class="line">  // 生成一个watcher实例，updateComponent作为watcher函数的回调</span><br><span class="line">  </span><br><span class="line">  new Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      if (vm._isMounted) &#123;</span><br><span class="line">        callHook(vm, &#x27;beforeUpdate&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, true /* isRenderWatcher */)</span><br><span class="line">  hydrating = false</span><br><span class="line"></span><br><span class="line">  // 挂载完成后  运行mouted</span><br><span class="line">  if (vm.$vnode == null) &#123;</span><br><span class="line">    // actived 需要判断组件已经加载过了</span><br><span class="line">    vm._isMounted = true</span><br><span class="line">    callHook(vm, &#x27;mounted&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">  return vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在完整版的<code>vm.$mount</code>方法中，如果用户未提供<code>render</code>函数，就会将<code>template</code>或者<code>el.outerHTML</code>编译成<code>render</code>函数。然后会执行<code>mountComponent</code>函数：如果用户提供了<code>el</code>选项，则会获取用于挂载的真实节点，将此节点赋值给<code>vm.$el</code>属性。</p>
</li>
<li><p>触发<code>beforeMount</code></p>
</li>
<li><p>在<code>mountComponent</code>方法中，<strong>会实例化一个watcher，watcher执行完内部逻辑后（响应式关键）</strong>，执行<code>updateComponent</code>方法将<code>vm._render()</code>返回的vnode挂载到真实节点中</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 生成一个watcher实例，updateComponent作为watcher函数的回调</span><br><span class="line"></span><br><span class="line">  new Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      if (vm._isMounted) &#123;</span><br><span class="line">        callHook(vm, &#x27;beforeUpdate&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, true /* isRenderWatcher */)</span><br><span class="line">  </span><br><span class="line">updateComponent = () =&gt; &#123;</span><br><span class="line">   vm._update(vm._render(), hydrating)</span><br><span class="line">&#125;</span><br><span class="line">Vue.prototype._render = function() &#123;</span><br><span class="line">    const vm = this</span><br><span class="line">    const &#123; render &#125; = vm.$options</span><br><span class="line">    const vnode = render.call(vm, vm.$createElement)</span><br><span class="line">    return vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>触发mouted</li>
</ul>
<p>至此vue的生命周期就结束了，下面重点介绍 <code>mountComponent</code> 实例化watcher发生了什么</p>
<h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><p>再讲解依赖收集之前，我们需要先了解，Object.defineProperties是什么时候设置的</p>
<h4 id="observer"><a href="#observer" class="headerlink" title="observer"></a>observer</h4><p><code>initState</code>阶段，vue会针对对象数据类型进行<code>observer</code>函数处理，方法的作用就是给非 VNode 的对象类型数据添加一个<code>Observer</code>类</p>
<p>举个例子, 下面的data 会有6次observer处理，会有6个Observer类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2,</span><br><span class="line">  c: [1, 2, &#123;a: 1&#125;],</span><br><span class="line">  d: &#123;</span><br><span class="line">   a: &#123;</span><br><span class="line">    b: 1</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">data 一次</span><br><span class="line">c 一次</span><br><span class="line"> c &#123;a:1&#125; 一次</span><br><span class="line">d 一次</span><br><span class="line"> a 一次</span><br><span class="line">  b 一次</span><br></pre></td></tr></table></figure>

<p>Observer会递归处理对象类型，有一个dep实例属性，用处在 defineReactive 中 childOb.dep.depend()，（父对象变化会影响子对象）</p>
<p>Observer的主要目的是对对象进行遍历并定义getter和setter，这也是依赖收集的基础，逻辑在函数 defineReactive 中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export class Observer &#123;</span><br><span class="line">  value: any;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  vmCount: number; // number of vms that have this object as root $data</span><br><span class="line"></span><br><span class="line">  constructor (value: any) &#123;</span><br><span class="line">    this.value = value</span><br><span class="line">    this.dep = new Dep()</span><br><span class="line">    // 在 defineReactive 中 childOb.dep.depend()</span><br><span class="line">    this.vmCount = 0</span><br><span class="line">    // vm._Data.__ob__ 指向这个Observer </span><br><span class="line">    def(value, &#x27;__ob__&#x27;, this)</span><br><span class="line">    if (Array.isArray(value)) &#123;</span><br><span class="line">      if (hasProto) &#123;</span><br><span class="line">        protoAugment(value, arrayMethods)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        copyAugment(value, arrayMethods, arrayKeys)</span><br><span class="line">      &#125;</span><br><span class="line">      this.observeArray(value)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Walk through all properties and convert them into</span><br><span class="line">   * getter/setters. This method should only be called when</span><br><span class="line">   * value type is Object.</span><br><span class="line">   */</span><br><span class="line">  walk (obj: Object) &#123;</span><br><span class="line">    const keys = Object.keys(obj)</span><br><span class="line">    for (let i = 0; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Observe a list of Array items.</span><br><span class="line">   */</span><br><span class="line">  observeArray (items: Array&lt;any&gt;) &#123;</span><br><span class="line">    for (let i = 0, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>defineReactive</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export function defineReactive (</span><br><span class="line">  obj: Object,</span><br><span class="line">  key: string,</span><br><span class="line">  val: any,</span><br><span class="line">  customSetter?: ?Function,</span><br><span class="line">  shallow?: boolean</span><br><span class="line">) &#123;</span><br><span class="line">  const dep = new Dep()</span><br><span class="line"></span><br><span class="line">  const property = Object.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  if (property &amp;&amp; property.configurable === false) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // cater for pre-defined getter/setters</span><br><span class="line">  const getter = property &amp;&amp; property.get</span><br><span class="line">  const setter = property &amp;&amp; property.set</span><br><span class="line">  if ((!getter || setter) &amp;&amp; arguments.length === 2) &#123;</span><br><span class="line">    val = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    get: function reactiveGetter () &#123;</span><br><span class="line">      const value = getter ? getter.call(obj) : val</span><br><span class="line">      if (Dep.target) &#123;</span><br><span class="line">        dep.depend()</span><br><span class="line">        if (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">          if (Array.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return value</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function reactiveSetter (newVal) &#123;</span><br><span class="line">      const value = getter ? getter.call(obj) : val</span><br><span class="line">      /* eslint-disable no-self-compare */</span><br><span class="line">      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      /* eslint-enable no-self-compare */</span><br><span class="line">      if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      if (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意函数每次运行都会实例化一个dep，getter 和 setter都是针对dep做出了处理</p>
<h4 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default class Dep &#123;</span><br><span class="line">  static target: ?Watcher;</span><br><span class="line">  id: number;</span><br><span class="line">  subs: Array&lt;Watcher&gt;;</span><br><span class="line"></span><br><span class="line">  constructor () &#123;</span><br><span class="line">    this.id = uid++</span><br><span class="line">    this.subs = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addSub (sub: Watcher) &#123;</span><br><span class="line">    this.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeSub (sub: Watcher) &#123;</span><br><span class="line">    remove(this.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  depend () &#123;</span><br><span class="line">    if (Dep.target) &#123;</span><br><span class="line">      // watcher addDep</span><br><span class="line">      // 简单来说 就是一个watcher dep 互相持有的过程</span><br><span class="line">      Dep.target.addDep(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notify () &#123;</span><br><span class="line">    // stabilize the subscriber list first</span><br><span class="line">    const subs = this.subs.slice()</span><br><span class="line">    if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !config.async) &#123;</span><br><span class="line">      // subs aren&#x27;t sorted in scheduler if not running async</span><br><span class="line">      // we need to sort them now to make sure they fire in correct</span><br><span class="line">      // order</span><br><span class="line">      subs.sort((a, b) =&gt; a.id - b.id)</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i = 0, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// The current target watcher being evaluated.</span><br><span class="line">// This is globally unique because only one watcher</span><br><span class="line">// can be evaluated at a time.</span><br><span class="line">Dep.target = null</span><br><span class="line">const targetStack = []</span><br></pre></td></tr></table></figure>

<p><code>Dep</code> 实际上就是对 <code>Watcher</code> 的一种管理，<code>Dep</code> 脱离 <code>Watcher</code> 单独存在是没有意义的，主要看一下<code>depend</code>和<code>notify</code></p>
<h4 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h4><p>上一节我们提到在<code>mountComponent</code> 函数中实例化了一个**<code>render watcher</code>** 实例，现在来重点分析一下。</p>
<p><strong><code>render watcher</code></strong> 是一个比较特殊的watcher实例，会挂载到vm._watcher上，并且持有该组件响应数据所有的dep实例，所有的dep实例也会持有**<code>render watcher</code>** ，<em><strong>每个组件有且仅有一个render watch</strong></em></p>
<p>首先看一下watcher的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; pushTarget, popTarget &#125; <span class="keyword">from</span> <span class="string">&#x27;./dep&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">deps</span> = []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDeps</span> = []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">depIds</span> = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDepIds</span> = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = uid++</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">get</span> () &#123;</span><br><span class="line">    <span class="title function_">pushTarget</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="comment">// pushTarget 代码如下，入栈并把当前的watcher赋值给dep</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* function pushTarget (_target) &#123;</span></span><br><span class="line"><span class="comment">      if (Dep.target) targetStack.push(Dep.target)</span></span><br><span class="line"><span class="comment">      Dep.target = _target</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">deep</span>) &#123;</span><br><span class="line">      <span class="comment">// 递归去访问 value，触发它所有子项的 getter</span></span><br><span class="line">      <span class="title function_">traverse</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">popTarget</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">cleanupDeps</span>()</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">addDep</span> (dep) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = dep.<span class="property">id</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">has</span>(id)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">add</span>(id)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">newDeps</span>.<span class="title function_">push</span>(dep)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">depIds</span>.<span class="title function_">has</span>(id)) &#123;</span><br><span class="line">        dep.<span class="title function_">addSub</span>(<span class="variable language_">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;接受到更新消息&quot;</span>);</span><br><span class="line">    <span class="comment">// 推入队列等待触发</span></span><br><span class="line">    <span class="title function_">queueWatcher</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先实例化<code>wather</code>会运行<code>get</code>函数中的<code>pushTaget</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">pushTarget</span>(<span class="variable language_">this</span>)</span><br><span class="line"><span class="comment">// pushTarget 代码如下，入栈并把当前的watcher赋值给dep</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* function pushTarget (_target) &#123;</span></span><br><span class="line"><span class="comment"> targetStack.push(target)</span></span><br><span class="line"><span class="comment">  Dep.target = target</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 黄轶电子书的源码 和 2.6.14的源码有出入</span></span><br></pre></td></tr></table></figure>

<p>首先说明，<code>Dep.target</code>  和 <code>targetStack</code> 均为全局属性</p>
<p>实际上就是把 <code>Dep.target</code> 赋值为当前的<strong>渲染 <code>watcher</code></strong>(貌似一个实例仅有一个) 并压栈（为了恢复用，vue3中是为了满足嵌套watch）。接着又执行了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">value = <span class="variable language_">this</span>.<span class="property">getter</span>.<span class="title function_">call</span>(vm, vm)</span><br></pre></td></tr></table></figure>

<p><code>this.getter</code> 对应就是 <code>updateComponent</code> 函数，这实际上就是在执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.<span class="title function_">_update</span>(vm.<span class="title function_">_render</span>(), hydrating)</span><br></pre></td></tr></table></figure>

<p>它会先执行 <code>vm._render()</code> 方法，因为之前分析过这个方法会生成 渲染 VNode，并且在这个过程中会对 <code>vm</code> 上的数据访问，这个时候就触发了数据对象的 getter。</p>
<p>那么每个对象值的 getter 都持有一个 <code>dep</code>，在触发 getter 的时候会调用 <code>dep.depend()</code> 方法，也就会执行<code>Dep.target.addDep(this)</code>。</p>
<p>刚才我们提到这个时候 <code>Dep.target</code> 已经被赋值为渲染 <code>watcher</code>，那么就执行到 <code>addDep</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">addDep</span> (<span class="attr">dep</span>: <span class="title class_">Dep</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> id = dep.<span class="property">id</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">has</span>(id)) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">add</span>(id)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDeps</span>.<span class="title function_">push</span>(dep)</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">depIds</span>.<span class="title function_">has</span>(id)) &#123;</span><br><span class="line">      dep.<span class="title function_">addSub</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候会做一些逻辑判断（保证同一数据不会被添加多次）后执行 <code>dep.addSub(this)</code>，那么就会执行 <code>this.subs.push(sub)</code>，也就是说把当前的 <code>watcher</code> 订阅到这个数据持有的 <code>dep</code> 的 <code>subs</code> 中，这个目的是为后续数据变化时候能通知到哪些 <code>subs</code> 做准备。</p>
<p>所以在 <code>vm._render()</code> 过程中，会触发所有数据的 getter，这样实际上已经完成了一个依赖收集的过程。那么到这里就结束了么，其实并没有，<strong>在完成依赖收集后</strong>，还有几个逻辑要执行，首先是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">deep</span>) &#123;</span><br><span class="line">  <span class="title function_">traverse</span>(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个是要递归去访问 <code>value</code>，触发它所有子项的 <code>getter</code>，这个之后会详细讲。接下来执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">popTarget</span>()</span><br></pre></td></tr></table></figure>

<p><code>popTarget</code> 的定义在 <code>src/core/observer/dep.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Dep</span>.<span class="property">target</span> = targetStack.<span class="title function_">pop</span>()</span><br></pre></td></tr></table></figure>

<p>实际上就是把 <code>Dep.target</code> 恢复成上一个状态，因为当前 vm 的数据依赖收集已经完成，那么对应的渲染<code>Dep.target</code> 也需要改变。最后执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">cleanupDeps</span>()</span><br></pre></td></tr></table></figure>

<p>其实很多人都分析过并了解到 Vue 有依赖收集的过程，但我几乎没有看到有人分析依赖清空的过程，其实这是大部分同学会忽视的一点，也是 Vue 考虑特别细的一点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">cleanupDeps</span> () &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">deps</span>.<span class="property">length</span></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = <span class="variable language_">this</span>.<span class="property">deps</span>[i]</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">has</span>(dep.<span class="property">id</span>)) &#123;</span><br><span class="line">      dep.<span class="title function_">removeSub</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> tmp = <span class="variable language_">this</span>.<span class="property">depIds</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">depIds</span> = <span class="variable language_">this</span>.<span class="property">newDepIds</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">newDepIds</span> = tmp</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">clear</span>()</span><br><span class="line">  tmp = <span class="variable language_">this</span>.<span class="property">deps</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">deps</span> = <span class="variable language_">this</span>.<span class="property">newDeps</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">newDeps</span> = tmp</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">newDeps</span>.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑到 Vue 是数据驱动的，所以每次数据变化都会重新 render，那么 <code>vm._render()</code> 方法又会再次执行，并再次触发数据的 getters，所以 <code>Watcher</code> 在构造函数中会初始化 2 个 <code>Dep</code> 实例数组，<code>newDeps</code> 表示新添加的 <code>Dep</code> 实例数组，而 <code>deps</code> 表示上一次添加的 <code>Dep</code> 实例数组。</p>
<p>在执行 <code>cleanupDeps</code> 函数的时候，会首先遍历 <code>deps</code>，移除对 <code>dep.subs</code> 数组中 <code>Wathcer</code> 的订阅，然后把 <code>newDepIds</code> 和 <code>depIds</code> 交换，<code>newDeps</code> 和 <code>deps</code> 交换，并把 <code>newDepIds</code> 和 <code>newDeps</code> 清空。</p>
<p>那么为什么需要做 <code>deps</code> 订阅的移除呢，在添加 <code>deps</code> 的订阅过程，已经能通过 <code>id</code> 去重避免重复订阅了。</p>
<p>考虑到一种场景，我们的模板会根据 <code>v-if</code> 去渲染不同子模板 a 和 b，当我们满足某种条件的时候渲染 a 的时候，会访问到 a 中的数据，这时候我们对 a 使用的数据添加了 getter，做了依赖收集，那么当我们去修改 a 的数据的时候，理应通知到这些订阅者。那么如果我们一旦改变了条件渲染了 b 模板，又会对 b 使用的数据添加了 getter，如果我们没有依赖移除的过程，那么这时候我去修改 a 模板的数据，会通知 a 数据的订阅的回调，这显然是有浪费的。</p>
<p>因此 Vue 设计了在每次添加完新的订阅，会移除掉旧的订阅，这样就保证了在我们刚才的场景中，如果渲染 b 模板的时候去修改 a 模板的数据，a 数据订阅回调已经被移除了，所以不会有任何浪费，真的是非常赞叹 Vue 对一些细节上的处理。</p>
<h3 id="代码反推"><a href="#代码反推" class="headerlink" title="代码反推"></a>代码反推</h3><p>首先看vue文件，</p>
<ul>
<li>data包含三个数据，其中一个是对象类型</li>
<li>computed有一个，依赖于data1，data2</li>
<li>wather有一个，依赖于data1</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;home&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;data1&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123;data2&#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;data3.a&#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;a href=&quot;&quot;&gt;&#123;&#123;com1&#125;&#125;&lt;/a&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">// @ is an alias to /src</span><br><span class="line">import SlopScope from &#x27;@/components/slotScope.vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;Home&#x27;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      data1: 1,</span><br><span class="line">      data2: 2,</span><br><span class="line">      data3: &#123;</span><br><span class="line">        a: &quot;1sdfds&quot;,</span><br><span class="line">        b: &quot;fasaga&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    console.log(&quot;mounted&quot;);</span><br><span class="line">    console.log(this);</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    com1()&#123;</span><br><span class="line">      return this.data1 + this.data2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    data1() &#123;</span><br><span class="line">      console.log(111111);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>我们在控制台打印一下vm，先看一下_data，可见每一个对象类型均持有一个<code>__ob__</code>即Oberver实例</p>
<p><img src="/_posts/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/assets/vue/image-20210909153539012.png" alt="image-20210909153539012"></p>
<p>然后看一下water，其中有两个watcher相关的属性</p>
<p><img src="/_posts/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/assets/vue/image-20210909153816298.png" alt="image-20210909153816298"></p>
<ul>
<li>_watcher属性指向的就是render watcher，每个组件有且仅有一个（真实渲染到页面上的）</li>
<li>_wathers属性是组件相关的所有watcher<ul>
<li>一个render watcher 就是 _watcher指向的那个</li>
<li>一个computed watcher 可以看到属性中 lazy &#x3D; true</li>
<li>一个user watcher 可以看到属性 user &#x3D; true</li>
</ul>
</li>
<li>我们再重点关注一下computed watcher中的deps<ul>
<li>其中一个是data1对应的dep，subs存在三个watcher，对应render user computed</li>
<li>还有一个是data2对应的dep，subs存在二个watcher，对应render  computed</li>
</ul>
</li>
<li>&#x2F;&#x2F; TODO 为什么根data的<code>__ob__</code>持有的dep没有关联的watcher，也没有watcher关联它</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>根据自己的理解，进行一个简短的总结，方便理解记忆</p>
<ul>
<li>vue在init阶段中的initData<ul>
<li>initProps(vm, opts.props) 对prop进行<code>defineReactive</code>设置<code>set</code>和<code>get</code></li>
<li>initMethods(vm, opts.methods)</li>
<li>initData(vm)  对data进行初始化，针对对象类型进行递归处理，使用<code>observer</code>函数处理</li>
<li>initComputed 针对每个computed生成一个对应的watcher，并在访问get函数时触发依赖收集</li>
<li>initWatch(vm, opts.watch) 生成<code>user watcher</code>，并完成依赖收集</li>
</ul>
</li>
<li>每一个observer函数，都会实例化一个Observer实例，挂载到对象类型的<code>__ob__</code>上</li>
<li>Observer在实例化的过程中，会针对对象的每一个key用defineReactive进行处理</li>
<li>defineReactive会生成一个dep实例，并设置key的getter和setter</li>
<li>在mouted阶段，vue会初始化一个<code>render watcher</code>实例，watcher在实例化的过程中会将Dep.target指向自身，然后运行回调函数，并且有一个入栈的操作(可能是递归处理的时候方便恢复，因为是子组件先mouted，这是我自己猜测的)</li>
<li>render watch对应的回调函数就是<code>vm._update(vm._render(), hydrating)</code>，在构建虚拟dom的过程中，会触发视图依赖数据的getter函数(在构建虚拟dom的过程中，应该会深度遍历子组件，先完成子组件的依赖收集，这也是watch入栈出栈的原因吧)</li>
<li>getter函数 会将数据对应的dep和当前的render watch 互相链接（持有）</li>
<li>虚拟dom及挂载完成，render watch 会进行出栈</li>
<li>执行 cleanupDeps ，用新的订阅替换旧订阅（性能优化，详细参考黄轶blog）</li>
</ul>
<h3 id="其它需要掌握的点"><a href="#其它需要掌握的点" class="headerlink" title="其它需要掌握的点"></a>其它需要掌握的点</h3><h4 id="keep-alive组件"><a href="#keep-alive组件" class="headerlink" title="keep-alive组件"></a>keep-alive组件</h4><p><a href="https://ustbhuangyi.github.io/vue-analysis/v2/extend/keep-alive.html#%E5%86%85%E7%BD%AE%E7%BB%84%E4%BB%B6">https://ustbhuangyi.github.io/vue-analysis/v2/extend/keep-alive.html#%E5%86%85%E7%BD%AE%E7%BB%84%E4%BB%B6</a></p>
<p>需要注意的点</p>
<ul>
<li>Keep-alive缓存的是vnode</li>
<li>keep-alive 只缓存第一个子组件</li>
<li><code>vnode.elm</code> 缓存了 <code>vnode</code> 创建生成的 DOM 节点</li>
<li>再次激活的时候跳过mount过程，直接把dom插入目标元素中</li>
</ul>
<h4 id="数组原型拦截"><a href="#数组原型拦截" class="headerlink" title="数组原型拦截"></a>数组原型拦截</h4><p>简单的描述一下过程：</p>
<p>在observe数组时，会将数组的<code>__proto__</code>指向由<code>Array.prototype</code>拓展而来的原型对象，该对象会原原本本的执行数组原生的方法，并针对七种方法做了重新定义，<strong>把新添加的值变成一个响应式对象，并且再调用 <code>ob.dep.notify()</code> 手动触发依赖通知</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; def &#125; from &#x27;../util/index&#x27;</span><br><span class="line"></span><br><span class="line">const arrayProto = Array.prototype</span><br><span class="line">export const arrayMethods = Object.create(arrayProto)</span><br><span class="line"></span><br><span class="line">const methodsToPatch = [</span><br><span class="line">  &#x27;push&#x27;,</span><br><span class="line">  &#x27;pop&#x27;,</span><br><span class="line">  &#x27;shift&#x27;,</span><br><span class="line">  &#x27;unshift&#x27;,</span><br><span class="line">  &#x27;splice&#x27;,</span><br><span class="line">  &#x27;sort&#x27;,</span><br><span class="line">  &#x27;reverse&#x27;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Intercept mutating methods and emit events</span><br><span class="line"> */</span><br><span class="line">methodsToPatch.forEach(function (method) &#123;</span><br><span class="line">  // cache original method</span><br><span class="line">  const original = arrayProto[method]</span><br><span class="line">  // 重新定义七种方法</span><br><span class="line">  def(arrayMethods, method, function mutator (...args) &#123;</span><br><span class="line">    // 调用原方法 </span><br><span class="line">    const result = original.apply(this, args)</span><br><span class="line">    // 数组对象的__ob__</span><br><span class="line">    const ob = this.__ob__</span><br><span class="line">    let inserted</span><br><span class="line">    switch (method) &#123;</span><br><span class="line">      case &#x27;push&#x27;:</span><br><span class="line">      case &#x27;unshift&#x27;:</span><br><span class="line">        inserted = args</span><br><span class="line">        break</span><br><span class="line">      case &#x27;splice&#x27;:</span><br><span class="line">        inserted = args.slice(2)</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">    if (inserted) ob.observeArray(inserted)</span><br><span class="line">    // notify change</span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    return result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>只是拓展了数组原型链还不够，还需要将数组的<code>__proto__</code>指向拓展后的类，这段代码在vue源码中Observe类中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (Array.isArray(value)) &#123;</span><br><span class="line">     if (hasProto) &#123;</span><br><span class="line">       protoAugment(value, arrayMethods)</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       copyAugment(value, arrayMethods, arrayKeys)</span><br><span class="line">     &#125;</span><br><span class="line">     this.observeArray(value)</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     this.walk(value)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p><img src="/_posts/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/assets/vue/44114780-3aca-11eb-85f6-6fac77c0c9b3-20220215152913357.png" alt="img"></p>
<h5 id="要掌握每个生命周期什么时候被调用"><a href="#要掌握每个生命周期什么时候被调用" class="headerlink" title="要掌握每个生命周期什么时候被调用"></a>要掌握每个生命周期什么时候被调用</h5><p><img src="/_posts/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/assets/vue/Snipaste_2021-09-06_20-27-19.png" alt="Snipaste_2021-09-06_20-27-19"></p>
<ol>
<li>beforeCreate 在实例初始化之后，数据观测(data observer) 之前被调用。<ol>
<li>initLifecycle(vm): 主要作用是确认组件的父子关系和初始化某些实例属性。找到父组件实例赋值给<code>vm.$parent</code>，将自己<code>push</code>给父组件的<code>$children</code>；</li>
<li>initEvents(vm): 主要作用是将父组件使用<code>v-on</code>或<code>@</code>注册的自定义事件添加到子组件的私有属性<code>vm._events</code>中；</li>
<li>initRender(vm): 主要作用是初始化用来将<code>render</code>函数转为<code>vnode</code>的两个方法<code>vm._c</code> 和<code>vm.$createElement</code>。用户自定义的<code>render</code>函数的参数<code>h</code>就是<code>vm.$createElement</code>方法，它可以返回<code>vnode</code>。此阶段还会进行<code>$attrs</code> <code>$listeners</code> <code>$slots</code> <code>$scopedSlots</code>的处理, 此时用户可以在函数中通过<code>this</code>访问到<code>vm.$parent</code>和<code>vm.$createElement</code> <code>$attrs</code> <code>$listeners</code> <code>$slots</code> <code>$scopedSlots</code>等有限的属性和方法。等以上操作全部完成，就会执行<code>beforeCreate</code>钩子函数</li>
</ol>
</li>
<li>created 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算，<br>watch&#x2F;event 事件回调。这里没有$el。这 3 个初始化方法先初始化<code>inject</code>，然后初始化<code>props/data</code>状态，最后初始化<code>provide</code>，这样做的目的是可以在<code>props/data</code>中使用<code>inject</code>内所注入的内容。<br>等以上操作全部完成，就会执行<code>created</code>钩子函数，此时用户可以在函数中通过<code>this</code>访问到<code>vm</code>中的<code>props</code>，<code>methods</code>，<code>data</code>，<code>computed</code>，<code>watch</code>和<code>inject</code>等大部分属性和方法。<ol>
<li>initInjections(vm): 初始化<code>inject</code>，使得<code>vm</code>可以访问到对应的依赖；</li>
<li>initState(vm): 初始化会被使用到的状态，状态包括<code>props</code>，<code>methods</code>，<code>data</code>，<code>computed</code>，<code>watch</code>五个选项。调用相应的<code>init</code>方法，使用<code>vm.$options</code>中提供的选项对这些状态进行初始化，其中<code>initData</code>方法会调用<code>observe(data, true)</code>，实现对<code>data</code>中属性的监听，实际上是使用<code>Object.defineProperty</code>方法定义属性的<code>getter</code>和<code>setter</code>方法；</li>
<li>initProvide(vm)：初始化<code>provide</code>，使得<code>vm</code>可以为子组件提供依赖(所以在<code>initState</code>后)。</li>
</ol>
</li>
<li>beforeMount 在挂载开始之前被调用：相关的 render 函数首次被调用。</li>
<li>mounted el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。</li>
<li>beforeUpdate 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。</li>
<li>updated 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</li>
<li>beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。</li>
<li>destroyed Vue 实例销毁后调用。调用后， Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用</li>
</ol>
<h5 id="要掌握每个生命周期内部可以做什么事"><a href="#要掌握每个生命周期内部可以做什么事" class="headerlink" title="要掌握每个生命周期内部可以做什么事"></a>要掌握每个生命周期内部可以做什么事</h5><ol>
<li>created 实例已经创建完成，因为它是最早触发的原因可以进行一些数据，资源的请求。</li>
<li>mounted 实例已经挂载完成，可以进行一些DOM操作</li>
<li>beforeUpdate 可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</li>
<li>updated 可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</li>
<li>destroyed 可以执行一些优化操作,清空定时器，解除绑定事件</li>
</ol>
<h5 id="Vue-的父组件和子组件生命周期钩子"><a href="#Vue-的父组件和子组件生命周期钩子" class="headerlink" title="Vue 的父组件和子组件生命周期钩子"></a>Vue 的父组件和子组件生命周期钩子</h5><ul>
<li>加载渲染过程</li>
</ul>
<p>​  父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p>
<ul>
<li>子组件更新过程</li>
</ul>
<p>​  父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p>
<ul>
<li>子组件销毁过程</li>
</ul>
<p>​  父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p>
<h5 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h5><p><a href="https://vue3js.cn/interview/vue/diff.html#%E4%BA%8C%E3%80%81%E6%AF%94%E8%BE%83%E6%96%B9%E5%BC%8F">https://vue3js.cn/interview/vue/diff.html#%E4%BA%8C%E3%80%81%E6%AF%94%E8%BE%83%E6%96%B9%E5%BC%8F</a></p>
<p><a href="https://juejin.cn/post/6994959998283907102#comment">https://juejin.cn/post/6994959998283907102#comment</a></p>
]]></content>
      <categories>
        <category>vue</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>从ECMAScript规范解读this</title>
    <url>/javascript/this/%E4%BB%8Ees%E8%A7%84%E8%8C%83%E6%9D%A5%E7%9C%8Bthis/</url>
    <content><![CDATA[<blockquote>
<p>这一小节比较晦涩难懂，目前简单的了解一下就行，有需要再深入研究<br>转载于 <a href="https://github.com/mqyqingfeng/Blog/issues/7">https://github.com/mqyqingfeng/Blog/issues/7</a></p>
</blockquote>
<p>当JavaScript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。</p>
<p>对于每个执行上下文，都有三个重要属性</p>
<ul>
<li>变量对象(Variable object，VO)</li>
<li>作用域链(Scope chain)</li>
<li>this</li>
</ul>
<p>今天重点讲讲 this，然而不好讲。</p>
<p>……</p>
<p>因为我们要从 ECMAScript5 规范开始讲起。</p>
<p>先奉上 ECMAScript 5.1 规范地址：</p>
<p>英文版：<a href="http://es5.github.io/#x15.1">http://es5.github.io/#x15.1</a></p>
<p>中文版：<a href="http://yanhaijing.com/es5/#115">http://yanhaijing.com/es5/#115</a></p>
<p>让我们开始了解规范吧！</p>
<h2 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h2><p>首先是第 8 章 Types：</p>
<blockquote>
<p>Types are further subclassified into ECMAScript language types and specification types.</p>
</blockquote>
<blockquote>
<p>An ECMAScript language type corresponds to values that are directly manipulated by an ECMAScript programmer using the ECMAScript language. The ECMAScript language types are Undefined, Null, Boolean, String, Number, and Object.</p>
</blockquote>
<blockquote>
<p>A specification type corresponds to meta-values that are used within algorithms to describe the semantics of ECMAScript language constructs and ECMAScript language types. The specification types are Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, and Environment Record.</p>
</blockquote>
<p>我们简单的翻译一下：</p>
<p>ECMAScript 的类型分为语言类型和规范类型。</p>
<p>ECMAScript 语言类型是开发者直接使用 ECMAScript 可以操作的。其实就是我们常说的Undefined, Null, Boolean, String, Number, 和 Object。</p>
<p>而规范类型相当于 meta-values，是用来用算法描述 ECMAScript 语言结构和 ECMAScript 语言类型的。规范类型包括：Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, 和 Environment Record。</p>
<p>没懂？没关系，我们只要知道在 ECMAScript 规范中还有一种只存在于规范中的类型，它们的作用是用来描述语言底层行为逻辑。</p>
<p>今天我们要讲的重点是便是其中的 Reference 类型。它与 this 的指向有着密切的关联。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>那什么又是 Reference ？</p>
<p>让我们看 8.7 章 The Reference Specification Type：</p>
<blockquote>
<p>The Reference type is used to explain the behaviour of such operators as delete, typeof, and the assignment operators.</p>
</blockquote>
<p>所以 Reference 类型就是用来解释诸如 delete、typeof 以及赋值等操作行为的。</p>
<p>抄袭尤雨溪大大的话，就是：</p>
<blockquote>
<p>这里的 Reference 是一个 Specification Type，也就是 “只存在于规范里的抽象类型”。它们是为了更好地描述语言的底层行为逻辑才存在的，但并不存在于实际的 js 代码中。</p>
</blockquote>
<p>再看接下来的这段具体介绍 Reference 的内容：</p>
<blockquote>
<p>A Reference is a resolved name binding.</p>
</blockquote>
<blockquote>
<p>A Reference consists of three components, the base value, the referenced name and the Boolean valued strict reference flag.</p>
</blockquote>
<blockquote>
<p>The base value is either undefined, an Object, a Boolean, a String, a Number, or an environment record (10.2.1).</p>
</blockquote>
<blockquote>
<p>A base value of undefined indicates that the reference could not be resolved to a binding. The referenced name is a String.</p>
</blockquote>
<p>&#x3D;&#x3D;这段讲述了 Reference 的构成，由三个组成部分，分别是&#x3D;&#x3D;：</p>
<ul>
<li>base value</li>
<li>referenced name</li>
<li>strict reference</li>
</ul>
<p>可是这些到底是什么呢？</p>
<p>我们简单的理解的话：</p>
<p>base value 就是属性所在的对象或者就是 EnvironmentRecord，它的值只可能是 undefined, an Object, a Boolean, a String, a Number, or an environment record 其中的一种。</p>
<p>referenced name 就是属性的名称。</p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var foo = 1;</span><br><span class="line"></span><br><span class="line">// 对应的Reference是：</span><br><span class="line">var fooReference = &#123;</span><br><span class="line">    base: EnvironmentRecord,</span><br><span class="line">    name: &#x27;foo&#x27;,</span><br><span class="line">    strict: false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var foo = &#123;</span><br><span class="line">    bar: function () &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">foo.bar(); // foo</span><br><span class="line"></span><br><span class="line">// bar对应的Reference是：</span><br><span class="line">var BarReference = &#123;</span><br><span class="line">    base: foo,</span><br><span class="line">    propertyName: &#x27;bar&#x27;,</span><br><span class="line">    strict: false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而且规范中还提供了获取 Reference 组成部分的方法，比如 GetBase 和 IsPropertyReference。</p>
<p>这两个方法很简单，简单看一看：</p>
<h3 id="1-GetBase"><a href="#1-GetBase" class="headerlink" title="1.GetBase"></a>1.GetBase</h3><blockquote>
<p>GetBase(V). Returns the base value component of the reference V.</p>
</blockquote>
<p>返回 reference 的 base value。</p>
<h3 id="2-IsPropertyReference"><a href="#2-IsPropertyReference" class="headerlink" title="2.IsPropertyReference"></a>2.IsPropertyReference</h3><blockquote>
<p>IsPropertyReference(V). Returns true if either the base value is an object or HasPrimitiveBase(V) is true; otherwise returns false.</p>
</blockquote>
<p>简单的理解：如果 base value 是一个对象，就返回true。</p>
<h3 id="3-GetValue"><a href="#3-GetValue" class="headerlink" title="3.GetValue"></a>3.GetValue</h3><p>除此之外，紧接着在 8.7.1 章规范中就讲了一个用于从 Reference 类型获取对应值的方法： GetValue。</p>
<p>简单模拟 GetValue 的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var foo = 1;</span><br><span class="line"></span><br><span class="line">var fooReference = &#123;</span><br><span class="line">    base: EnvironmentRecord,</span><br><span class="line">    name: &#x27;foo&#x27;,</span><br><span class="line">    strict: false</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">GetValue(fooReference) // 1;</span><br></pre></td></tr></table></figure>

<p><strong>GetValue 返回对象属性真正的值</strong>，但是要注意：</p>
<p><strong>调用 GetValue，返回的将是具体的值，而不再是一个 Reference</strong></p>
<p>这个很重要，这个很重要，这个很重要。</p>
<h2 id="如何确定this的值"><a href="#如何确定this的值" class="headerlink" title="如何确定this的值"></a>如何确定this的值</h2><p>关于 Reference 讲了那么多，为什么要讲 Reference 呢？到底 Reference 跟本文的主题 this 有哪些关联呢？如果你能耐心看完之前的内容，以下开始进入高能阶段：</p>
<p>看规范 11.2.3 Function Calls：</p>
<p>这里讲了当函数调用的时候，如何确定 this 的取值。</p>
<p>只看第一步、第六步、第七步：</p>
<blockquote>
<p>1.Let <em>ref</em> be the result of evaluating MemberExpression.</p>
</blockquote>
<blockquote>
<p>6.If Type(<em>ref</em>) is Reference, then</p>
</blockquote>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.If IsPropertyReference(ref) is true, then</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i.Let thisValue be GetBase(ref).</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b.Else, the base of ref is an Environment Record</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i.Let thisValue be the result of calling the ImplicitThisValue concrete method of GetBase(ref).</span><br></pre></td></tr></table></figure>

<p>7.Else, Type(<em>ref</em>) is not Reference.</p>
</blockquote>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a. Let thisValue be undefined.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&#x3D;&#x3D;让我们描述一下：&#x3D;&#x3D;</p>
<p>1.计算 MemberExpression 的结果赋值给 ref</p>
<p>2.判断 ref 是不是一个 Reference 类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref)</span><br><span class="line"></span><br><span class="line">2.2 如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么this的值为 ImplicitThisValue(ref)</span><br><span class="line"></span><br><span class="line">2.3 如果 ref 不是 Reference，那么 this 的值为 undefined</span><br></pre></td></tr></table></figure>

<h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><p>让我们一步一步看：</p>
<ol>
<li>计算 MemberExpression 的结果赋值给 ref</li>
</ol>
<p>什么是 MemberExpression？看规范 11.2 Left-Hand-Side Expressions：</p>
<p>MemberExpression :</p>
<ul>
<li>PrimaryExpression &#x2F;&#x2F; 原始表达式 可以参见《JavaScript权威指南第四章》</li>
<li>FunctionExpression &#x2F;&#x2F; 函数定义表达式</li>
<li>MemberExpression [ Expression ] &#x2F;&#x2F; 属性访问表达式</li>
<li>MemberExpression . IdentifierName &#x2F;&#x2F; 属性访问表达式</li>
<li>new MemberExpression Arguments &#x2F;&#x2F; 对象创建表达式</li>
</ul>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); // MemberExpression 是 foo</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()(); // MemberExpression 是 foo()</span><br><span class="line"></span><br><span class="line">var foo = &#123;</span><br><span class="line">    bar: function () &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.bar(); // MemberExpression 是 foo.bar</span><br></pre></td></tr></table></figure>

<p>所以<strong>简单理解 MemberExpression 其实就是()左边的部分</strong>。</p>
<p>2.判断 ref 是不是一个 Reference 类型。</p>
<p>关键就在于看规范是如何处理各种 MemberExpression，返回的结果是不是一个Reference类型。</p>
<p>举最后一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var value = 1;</span><br><span class="line"></span><br><span class="line">var foo = &#123;</span><br><span class="line">  value: 2,</span><br><span class="line">  bar: function () &#123;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//示例1</span><br><span class="line">console.log(foo.bar());</span><br><span class="line">//示例2</span><br><span class="line">console.log((foo.bar)());</span><br><span class="line">//示例3</span><br><span class="line">console.log((foo.bar = foo.bar)());</span><br><span class="line">//示例4</span><br><span class="line">console.log((false || foo.bar)());</span><br><span class="line">//示例5</span><br><span class="line">console.log((foo.bar, foo.bar)());</span><br></pre></td></tr></table></figure>

<h3 id="foo-bar"><a href="#foo-bar" class="headerlink" title="foo.bar()"></a>foo.bar()</h3><p>在示例 1 中，MemberExpression 计算的结果是 foo.bar，那么 foo.bar 是不是一个 Reference 呢？</p>
<p>查看规范 11.2.1 Property Accessors，这里展示了一个计算的过程，什么都不管了，就看最后一步：</p>
<blockquote>
<p>Return a value of type Reference whose base value is baseValue and whose referenced name is propertyNameString, and whose strict mode flag is strict.</p>
</blockquote>
<p>我们得知该表达式返回了一个 Reference 类型！</p>
<p>根据之前的内容，我们知道该值为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var Reference = &#123;</span><br><span class="line">  base: foo,</span><br><span class="line">  name: &#x27;bar&#x27;,</span><br><span class="line">  strict: false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来按照 2.1 的判断流程走：</p>
<blockquote>
<p>2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref)</p>
</blockquote>
<p>该值是 Reference 类型，那么 IsPropertyReference(ref) 的结果是多少呢？</p>
<p>前面我们已经铺垫了 IsPropertyReference 方法，如果 base value 是一个对象，结果返回 true。</p>
<p>base value 为 foo，是一个对象，所以 IsPropertyReference(ref) 结果为 true。</p>
<p>这个时候我们就可以确定 this 的值了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this = GetBase(ref)，</span><br></pre></td></tr></table></figure>

<p>GetBase 也已经铺垫了，获得 base value 值，这个例子中就是foo，所以 this 的值就是 foo ，示例1的结果就是 2！</p>
<p>唉呀妈呀，为了证明 this 指向foo，真是累死我了！但是知道了原理，剩下的就更快了。</p>
<h3 id="foo-bar-1"><a href="#foo-bar-1" class="headerlink" title="(foo.bar)()"></a>(foo.bar)()</h3><p>看示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log((foo.bar)());</span><br></pre></td></tr></table></figure>

<p>foo.bar 被 () 包住，查看规范 11.1.6 The Grouping Operator</p>
<p>直接看结果部分：</p>
<blockquote>
<p>Return the result of evaluating Expression. This may be of type Reference.</p>
</blockquote>
<blockquote>
<p>NOTE This algorithm does not apply GetValue to the result of evaluating Expression.</p>
</blockquote>
<p>实际上 () 并没有对 MemberExpression 进行计算，所以其实跟示例 1 的结果是一样的。</p>
<h3 id="foo-bar-foo-bar"><a href="#foo-bar-foo-bar" class="headerlink" title="(foo.bar &#x3D; foo.bar)()"></a>(foo.bar &#x3D; foo.bar)()</h3><p>看示例3，有赋值操作符，查看规范 11.13.1 Simple Assignment ( &#x3D; ):</p>
<p>计算的第三步：</p>
<blockquote>
<p>3.Let rval be GetValue(rref).</p>
</blockquote>
<p>因为使用了 GetValue，所以返回的值不是 Reference 类型，</p>
<p>按照之前讲的判断逻辑：</p>
<blockquote>
<p>2.3 如果 ref 不是Reference，那么 this 的值为 undefined</p>
</blockquote>
<p>this 为 undefined，非严格模式下，this 的值为 undefined 的时候，其值会被隐式转换为全局对象。</p>
<h3 id="false-foo-bar"><a href="#false-foo-bar" class="headerlink" title="(false || foo.bar)()"></a>(false || foo.bar)()</h3><p>看示例4，逻辑与算法，查看规范 11.11 Binary Logical Operators：</p>
<p>计算第二步：</p>
<blockquote>
<p>2.Let lval be GetValue(lref).</p>
</blockquote>
<p>因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined</p>
<h3 id="foo-bar-foo-bar-1"><a href="#foo-bar-foo-bar-1" class="headerlink" title="(foo.bar, foo.bar)()"></a>(foo.bar, foo.bar)()</h3><p>看示例5，逗号操作符，查看规范11.14 Comma Operator ( , )</p>
<p>计算第二步：</p>
<blockquote>
<p>2.Call GetValue(lref).</p>
</blockquote>
<p>因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined</p>
<h3 id="揭晓结果"><a href="#揭晓结果" class="headerlink" title="揭晓结果"></a>揭晓结果</h3><p>所以最后一个例子的结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var value = 1;</span><br><span class="line"></span><br><span class="line">var foo = &#123;</span><br><span class="line">  value: 2,</span><br><span class="line">  bar: function () &#123;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//示例1</span><br><span class="line">console.log(foo.bar()); // 2</span><br><span class="line">//示例2</span><br><span class="line">console.log((foo.bar)()); // 2</span><br><span class="line">//示例3</span><br><span class="line">console.log((foo.bar = foo.bar)()); // 1</span><br><span class="line">//示例4</span><br><span class="line">console.log((false || foo.bar)()); // 1</span><br><span class="line">//示例5</span><br><span class="line">console.log((foo.bar, foo.bar)()); // 1</span><br></pre></td></tr></table></figure>

<p>注意：以上是在非严格模式下的结果，严格模式下因为 this 返回 undefined，所以示例 3 会报错。</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>最最后，忘记了一个最最普通的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); </span><br></pre></td></tr></table></figure>

<p>MemberExpression 是 foo，解析标识符，查看规范 10.3.1 Identifier Resolution，会返回一个 Reference 类型的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var fooReference = &#123;</span><br><span class="line">    base: EnvironmentRecord,</span><br><span class="line">    name: &#x27;foo&#x27;,</span><br><span class="line">    strict: false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来进行判断：</p>
<blockquote>
<p>2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref)</p>
</blockquote>
<p>因为 base value 是 EnvironmentRecord，并不是一个 Object 类型，还记得前面讲过的 base value 的取值可能吗？ 只可能是 undefined, an Object, a Boolean, a String, a Number, 和 an environment record 中的一种。</p>
<p>IsPropertyReference(ref) 的结果为 false，进入下个判断：</p>
<blockquote>
<p>2.2 如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么this的值为 ImplicitThisValue(ref)</p>
</blockquote>
<p>base value 正是 Environment Record，所以会调用 ImplicitThisValue(ref)</p>
<p>查看规范 10.2.1.1.6，ImplicitThisValue 方法的介绍：该函数始终返回 undefined。</p>
<p>所以最后 this 的值就是 undefined。</p>
<h2 id="多说一句"><a href="#多说一句" class="headerlink" title="多说一句"></a>多说一句</h2><p>尽管我们可以简单的理解 this 为调用函数的对象，如果是这样的话，如何解释下面这个例子呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var value = 1;</span><br><span class="line"></span><br><span class="line">var foo = &#123;</span><br><span class="line">  value: 2,</span><br><span class="line">  bar: function () &#123;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log((false || foo.bar)()); // 1</span><br></pre></td></tr></table></figure>

<p>此外，又如何确定调用函数的对象是谁呢？在写文章之初，我就面临着这些问题，最后还是放弃从多个情形下给大家讲解 this 指向的思路，而是追根溯源的从 ECMASciript 规范讲解 this 的指向，尽管从这个角度写起来和读起来都比较吃力，但是一旦多读几遍，明白原理，绝对会给你一个全新的视角看待 this 。而你也就能明白，尽管 foo() 和 (foo.bar &#x3D; foo.bar)() 最后结果都指向了 undefined，但是两者从规范的角度上却有着本质的区别。</p>
<p>此篇讲解执行上下文的 this，即便不是很理解此篇的内容，依然不影响大家了解执行上下文这个主题下其他的内容。所以，依然可以安心的看下一篇文章。</p>
]]></content>
      <categories>
        <category>javascript</category>
        <category>this</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-router源码分析-简易流程</title>
    <url>/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/vue-router/</url>
    <content><![CDATA[<h3 id="简易流程"><a href="#简易流程" class="headerlink" title="简易流程"></a>简易流程</h3><p>vue-router的整体流程不难理解，难点在于一些功能的实现。</p>
<p><img src="/_posts/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/assets/vue-router/image-20220213105205628.png" alt="image-20220213105205628"></p>
<p>首先初始化vue-router实例，然后vue.use，再然后根vue初始化，作为配置传入</p>
<ul>
<li><p>vue.use vue-router</p>
</li>
<li><p>Vue-router install</p>
<ul>
<li><p>混入，根组件保存router和route属性，通过混入<code>beforeCreated</code> 子组件递归持有根组件(Vue)</p>
<ul>
<li><pre><code class="javascript">Object.defineProperty(Vue.prototype, &#39;$route&#39;, &#123;
  // 混入beforeCreated 保证所有组件都能访问到 _routerRoot vue根实例
  get () &#123; return this._routerRoot._route &#125;
&#125;)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">- ```</span><br><span class="line">  // 非根组件递归持有根组件Vue</span><br><span class="line">  this._routerRoot = (this.$parent &amp;&amp; this.$parent._routerRoot) || this</span><br></pre></td></tr></table></figure>

&gt; 所有的组件都持有_RouterRoot属性(Vue)，Vue根实例持有_route和router属性
</code></pre>
</li>
</ul>
</li>
<li><p>vue-router 初始化</p>
<ul>
<li>首先生成实例，执行constructor<ul>
<li>生成matcher，createMatcher<ul>
<li>根据routes创建一个路由映射表 {pathList, pathMap, nameMap}</li>
<li>提供match方法</li>
</ul>
</li>
<li>根据mode，初始化相应history</li>
</ul>
</li>
<li>执行init方法-vue根实例初始化的时候执行<ul>
<li>history.transitionTo 根据当前路径渲染组件<ul>
<li>const route &#x3D; this.router.match(location, this.current) 匹配路由</li>
</ul>
</li>
<li>History.listen 定义 history.cb  在多种情况下更新 vue._route，保证其正确性，方便被watch</li>
</ul>
</li>
</ul>
</li>
<li><p>Vue.util.defineReactive(this, <code>_route</code>, this._router.history.current) 定义响应式</p>
</li>
<li><p>registerInstance router-view相关 主要是在route.instance保存当前rv实例</p>
</li>
<li><p>Object.defineProperty(Vue.prototype, <code>$router</code>和<code>$route</code>）方便组件内使用</p>
</li>
<li><p>Vue.component <code>RouterView</code>, <code>RouterLink</code></p>
</li>
<li><p>定义合并策略</p>
</li>
</ul>
</li>
</ul>
<h3 id="重要部分介绍"><a href="#重要部分介绍" class="headerlink" title="重要部分介绍"></a>重要部分介绍</h3><h4 id="mather介绍"><a href="#mather介绍" class="headerlink" title="mather介绍"></a>mather介绍</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function createMatcher (</span><br><span class="line">  routes: Array&lt;RouteConfig&gt;,</span><br><span class="line">  router: VueRouter</span><br><span class="line">): Matcher</span><br></pre></td></tr></table></figure>

<ul>
<li><p>createRouteMap 根据传入的routes配置，创建一个路由映射表 {pathList, pathMap, nameMap}</p>
<blockquote>
<p><code>pathList</code> 存储所有的 <code>path</code></p>
<p><code>pathMap</code> 表示一个 <code>path</code> 到 <code>RouteRecord</code> 的映射关系</p>
<p><code>nameMap</code> 表示 <code>name</code> 到 <code>RouteRecord</code> 的映射关系</p>
</blockquote>
<ul>
<li><p>遍历routes数组，调用addRouteRecord</p>
<ul>
<li><p>根据routes创建相关映射表,如果存在children，则递归处理，保证每一个路由地址都有一个与之对应的routeRecord，这条记录还会包含子路由所有层级的父record记录</p>
</li>
<li><pre><code>RouteRecord
const record: RouteRecord = &#123;
    path: normalizedPath,
    // path 解析成一个正则表达式
    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),
    components: route.components || &#123; default: route.component &#125;,
    alias: route.alias
      ? typeof route.alias === &#39;string&#39;
        ? [route.alias]
        : route.alias
      : [],
    instances: &#123;&#125;, // 表示rv组件的实例
    enteredCbs: &#123;&#125;,
    name,
    parent, // 表示父的 RouteRecord 只能向上寻找
    matchAs,
    redirect: route.redirect,
    beforeEnter: route.beforeEnter,
    meta: route.meta || &#123;&#125;,
    props:
      route.props == null
        ? &#123;&#125;
        : route.components
          ? route.props
          : &#123; default: route.props &#125;
  &#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 保证*匹配符保持在最后</span><br><span class="line"></span><br><span class="line">- match方法解析 匹配出对应的record，然后通过`createRoute`创建`Route`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>function match (<br>  raw: RawLocation(string | location),<br>  currentRoute?: Route,<br>  redirectedFrom?: Location<br>): Route</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- createRoute函数, `createRoute` 可以根据 `record` 和 `location` 创建出来，最终返回的是一条 `Route` 路径</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>export function createRoute (<br>  record: ?RouteRecord,<br>  location: Location,<br>  redirectedFrom?: ?Location,<br>  router?: VueRouter<br>): Route {<br>  const stringifyQuery &#x3D; router &amp;&amp; router.options.stringifyQuery</p>
<p>  let query: any &#x3D; location.query || {}<br>  try {<br>    query &#x3D; clone(query)<br>  } catch (e) {}</p>
<p>  const route: Route &#x3D; {<br>    name: location.name || (record &amp;&amp; record.name),<br>    meta: (record &amp;&amp; record.meta) || {},<br>    path: location.path || ‘&#x2F;‘,<br>    hash: location.hash || ‘’,<br>    query,<br>    params: location.params || {},<br>    fullPath: getFullPath(location, stringifyQuery),<br>    matched: record ? formatMatch(record) : []<br>  }<br>  if (redirectedFrom) {<br>    route.redirectedFrom &#x3D; getFullPath(redirectedFrom, stringifyQuery)<br>  }<br>  return Object.freeze(route)<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - `Route` 对象中有一个非常重要属性是 `matched`，它通过 `formatMatch(record)` 计算而来：</span><br><span class="line"></span><br><span class="line">    ````</span><br><span class="line">    function formatMatch (record: ?RouteRecord): Array&lt;RouteRecord&gt; &#123;</span><br><span class="line">      const res = []</span><br><span class="line">      while (record) &#123;</span><br><span class="line">        res.unshift(record)</span><br><span class="line">        record = record.parent</span><br><span class="line">      &#125;</span><br><span class="line">      return res</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ````</span><br><span class="line"></span><br><span class="line">    可以看它是通过 `record` 循环向上找 `parent`，直到找到最外层，并把所有的 `record` 都 push 到一个数组中，最终返回的就是 `record` 的数组，它记录了一条线路上的所有 `record`。==`matched` 属性非常有用，它为之后渲染组件提供了依据==。</span><br><span class="line"></span><br><span class="line">#### 路径切换 history.transitonTo</span><br><span class="line"></span><br><span class="line">- 点击 `router-link` 的时候，实际上最终会执行 `router.push`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>push (location: RawLocation, onComplete?: Function, onAbort?: Function) {<br>  this.history.push(location, onComplete, onAbort)<br>}<br>push (location: RawLocation, onComplete?: Function, onAbort?: Function) {<br>  const { current: fromRoute } &#x3D; this<br>  this.transitionTo(location, route &#x3D;&gt; {<br>   &#x2F;&#x2F;<br>   &#x2F;&#x2F; <a href="https://zhuanlan.zhihu.com/p/35036172">https://zhuanlan.zhihu.com/p/35036172</a><br>    pushHash(route.fullPath)<br>    handleScroll(this.router, route, fromRoute, false)<br>    onComplete &amp;&amp; onComplete(route)<br>  }, onAbort)<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 在history的初始化中，针对历史栈做了一个监听</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>window.addEventListener(supportsPushState ? ‘popstate’ : ‘hashchange’….</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  之所以做监听，是为了用户在使用前进后退时，渲染正确的组件</span><br><span class="line"></span><br><span class="line">- Router-view</span><br><span class="line"></span><br><span class="line">  当我们执行 `transitionTo` 来更改路由线路后，组件是如何重新渲染的呢</span><br><span class="line"></span><br><span class="line">- Router-Link</span><br><span class="line"></span><br><span class="line">### 附录：源码重要类-类型注解</span><br><span class="line"></span><br><span class="line">- history类 src/history/*.js</span><br><span class="line"></span><br><span class="line">  ````javascript</span><br><span class="line">  router: Router</span><br><span class="line">    base: string</span><br><span class="line">    current: Route</span><br><span class="line">    pending: ?Route</span><br><span class="line">    cb: (r: Route) =&gt; void</span><br><span class="line">    ready: boolean</span><br><span class="line">    readyCbs: Array&lt;Function&gt;</span><br><span class="line">    readyErrorCbs: Array&lt;Function&gt;</span><br><span class="line">    errorCbs: Array&lt;Function&gt;</span><br><span class="line">    listeners: Array&lt;Function&gt;</span><br><span class="line">    cleanupListeners: Function</span><br><span class="line">  </span><br><span class="line">    // implemented by sub-classes</span><br><span class="line">    +go: (n: number) =&gt; void</span><br><span class="line">    +push: (loc: RawLocation, onComplete?: Function, onAbort?: Function) =&gt; void</span><br><span class="line">    +replace: (</span><br><span class="line">      loc: RawLocation,</span><br><span class="line">      onComplete?: Function,</span><br><span class="line">      onAbort?: Function</span><br><span class="line">    ) =&gt; void</span><br><span class="line">    +ensureURL: (push?: boolean) =&gt; void</span><br><span class="line">    +getCurrentLocation: () =&gt; string</span><br><span class="line">    +setupListeners: Function</span><br><span class="line">  ````</span><br><span class="line"></span><br><span class="line">- matcher类 src/create-matcher.js</span><br><span class="line"></span><br><span class="line">  ```javascript</span><br><span class="line">  export type Matcher = &#123;</span><br><span class="line">    match: (raw: RawLocation, current?: Route, redirectedFrom?: Location) =&gt; Route;</span><br><span class="line">    addRoutes: (routes: Array&lt;RouteConfig&gt;) =&gt; void;</span><br><span class="line">    addRoute: (parentNameOrRoute: string | RouteConfig, route?: RouteConfig) =&gt; void;</span><br><span class="line">    getRoutes: () =&gt; Array&lt;RouteRecord&gt;;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>createRouteMap src&#x2F;creat-route-map</p>
<ul>
<li><code>createRouteMap</code> 函数的目标是把用户的路由配置转换成一张路由映射表，它包含 3 个部分，<ul>
<li><code>pathList</code> 存储所有的 <code>path</code>，</li>
<li><code>pathMap</code> 表示一个 <code>path</code> 到 <code>RouteRecord</code> 的映射关系，</li>
<li><code>nameMap</code> 表示 <code>name</code> 到 <code>RouteRecord</code> 的映射关系。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export function createRouteMap (</span><br><span class="line">  routes: Array&lt;RouteConfig&gt;,</span><br><span class="line">  oldPathList?: Array&lt;string&gt;,</span><br><span class="line">  oldPathMap?: Dictionary&lt;RouteRecord&gt;,</span><br><span class="line">  oldNameMap?: Dictionary&lt;RouteRecord&gt;,</span><br><span class="line">  parentRoute?: RouteRecord</span><br><span class="line">): &#123;</span><br><span class="line">  pathList: Array&lt;string&gt;,</span><br><span class="line">  pathMap: Dictionary&lt;RouteRecord&gt;,</span><br><span class="line">  nameMap: Dictionary&lt;RouteRecord&gt;</span><br><span class="line">&#125; &#123;...&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>addRouterRecord 生成并添加一条routerRecord</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function addRouteRecord (</span><br><span class="line">  pathList: Array&lt;string&gt;,</span><br><span class="line">  pathMap: Dictionary&lt;RouteRecord&gt;,</span><br><span class="line">  nameMap: Dictionary&lt;RouteRecord&gt;,</span><br><span class="line">  route: RouteConfig,</span><br><span class="line">  parent?: RouteRecord,</span><br><span class="line">  matchAs?: string</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Location RawLocation</p>
<ul>
<li>Vue-Router 中定义的 <code>Location</code> 数据结构和浏览器提供的 <code>window.location</code> 部分结构有点类似，它们都是对 <code>url</code> 的结构化描述。举个例子：<code>/abc?foo=bar&amp;baz=qux#hello</code>，它的 <code>path</code> 是 <code>/abc</code>，<code>query</code> 是 <code>&#123;foo:&#39;bar&#39;,baz:&#39;qux&#39;&#125;</code>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">declare type <span class="title class_">Location</span> = &#123;</span><br><span class="line">  _normalized?: boolean;</span><br><span class="line">  name?: string;</span><br><span class="line">  path?: string;</span><br><span class="line">  hash?: string;</span><br><span class="line">  query?: <span class="title class_">Dictionary</span>&lt;string&gt;;</span><br><span class="line">  params?: <span class="title class_">Dictionary</span>&lt;string&gt;;</span><br><span class="line">  append?: boolean;</span><br><span class="line">  replace?: boolean;</span><br><span class="line">&#125;</span><br><span class="line">declare type <span class="title class_">RawLocation</span> = string | <span class="title class_">Location</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Route</p>
<ul>
<li><code>Route</code> 表示的是路由中的一条线路，它除了描述了类似 <code>Loctaion</code> 的 <code>path</code>、<code>query</code>、<code>hash</code> 这些概念，还有 <code>matched</code> 表示匹配到的所有的 <code>RouteRecord</code>。<code>Route</code> 的其他属性我们之后会介绍。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> <span class="title class_">Route</span> = &#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">name</span>: ?<span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">hash</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">query</span>: <span class="title class_">Dictionary</span>&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line">  <span class="attr">params</span>: <span class="title class_">Dictionary</span>&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line">  <span class="attr">fullPath</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">matched</span>: <span class="title class_">Array</span>&lt;<span class="title class_">RouteRecord</span>&gt;;</span><br><span class="line">  redirectedFrom?: <span class="built_in">string</span>;</span><br><span class="line">  meta?: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以说location 经过了match之后变成了routerRecord，routerRecord经过<code>_createRoute</code>变成了<code>route</code></p>
<p>这样比较好理解</p>
</blockquote>
</li>
<li><p>RouterRecord</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare type RouteRecord = &#123;</span><br><span class="line">  path: string;</span><br><span class="line">  alias: Array&lt;string&gt;;</span><br><span class="line">  regex: RouteRegExp;</span><br><span class="line">  components: Dictionary&lt;any&gt;;</span><br><span class="line">  instances: Dictionary&lt;any&gt;;</span><br><span class="line">  enteredCbs: Dictionary&lt;Array&lt;Function&gt;&gt;;</span><br><span class="line">  name: ?string;</span><br><span class="line">  parent: ?RouteRecord;</span><br><span class="line">  redirect: ?RedirectOption;</span><br><span class="line">  matchAs: ?string;</span><br><span class="line">  beforeEnter: ?NavigationGuard;</span><br><span class="line">  meta: any;</span><br><span class="line">  props: boolean | Object | Function | Dictionary&lt;boolean | Object | Function&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="其他重要内容"><a href="#其他重要内容" class="headerlink" title="其他重要内容"></a>其他重要内容</h3><ul>
<li><p>当我们执行 <code>transitionTo</code> 来更改路由线路后，组件是如何重新渲染的呢</p>
<blockquote>
<p>由于我们把根 Vue 实例的 <code>_route</code> 属性定义成响应式的，我们在每个 <code>&lt;router-view&gt;</code> 执行 <code>render</code> 函数的时候，都会访问 <code>parent.$route</code>，如我们之前分析会访问 <code>this._routerRoot._route</code>，触发了它的 <code>getter</code>，相当于 <code>&lt;router-view&gt;</code> 对它有依赖，然后再执行完 <code>transitionTo</code> 后，修改 <code>app._route</code> 的时候，又触发了<code>setter</code>，因此会通知 <code>&lt;router-view&gt;</code> 的渲染 <code>watcher</code> 更新，重新渲染组件。</p>
</blockquote>
</li>
<li><p>所有组件都是访问到的<code>$router</code>和<code>$router</code>是怎么来的</p>
<p>1.设置Vue根实例的_routerRoot属性为Vue根实例</p>
<p>2.混入Vue生命周期，beforeCreate函数层层传递_routerRoot属性，是所有组件都可以通过<code>_routerRoot</code>访问到Vue根实例</p>
<p>3.定义Vue的原型属性<code>$route</code> <code>$router</code>的getter方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;$router&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">get</span> () &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_routerRoot</span>.<span class="property">_router</span> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>非常经典的异步函数队列化执行的模式，这也就是为什么官方文档会说只有执行 <code>next</code> 方法来 <code>resolve</code> 这个钩子函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function runQueue (queue, fn, cb) &#123;</span><br><span class="line">  const step = index =&gt; &#123;</span><br><span class="line">    if (index &gt;= queue.length) &#123;</span><br><span class="line">      cb()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (queue[index]) &#123;</span><br><span class="line">        fn(queue[index], () =&gt; &#123;</span><br><span class="line">          step(index + 1)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        step(index + 1)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  step(0)</span><br><span class="line">&#125;</span><br><span class="line">// 代表一个个hooks函数</span><br><span class="line">const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line"></span><br><span class="line">const iterator = (hook, next) =&gt; &#123;</span><br><span class="line">  console.log(hook);</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br><span class="line">runQueue(arr, iterator, () =&gt; &#123;</span><br><span class="line">  console.log(&quot;遍历完了&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">// 1 2 3 4 5 6 7 8 9 遍历完了</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>vue</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue-router源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>vuex源码分析-简易流程</title>
    <url>/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/vuex/</url>
    <content><![CDATA[<p><img src="/_posts/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/assets/vuex/image-20220214140159456.png" alt="image-20220214140159456"></p>
<p>先放一张store的代码结构图</p>
<p><img src="/_posts/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/assets/vuex/image-20210929161132720.png" alt="image-20210929161132720"></p>
<h2 id="vuex初始化"><a href="#vuex初始化" class="headerlink" title="vuex初始化"></a>vuex初始化</h2><p>Vuex 存在一个静态的 <code>install</code> 方法，在beforeCreate混入了vuexInit，我们只看关键逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function vuexInit () &#123;</span><br><span class="line">    const options = this.$options</span><br><span class="line">    // store injection</span><br><span class="line">    if (options.store) &#123;</span><br><span class="line">      this.$store = typeof options.store === &#x27;function&#x27;</span><br><span class="line">        ? options.store()</span><br><span class="line">        : options.store</span><br><span class="line">    &#125; else if (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class="line">      this.$store = options.parent.$store</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>通过声明周期函数，将store挂载到每一个组件上</p>
<h2 id="Store实例化"><a href="#Store实例化" class="headerlink" title="Store实例化"></a>Store实例化</h2><p>我们把 <code>Store</code> 的实例化过程拆成 3 个部分，分别是</p>
<ul>
<li>初始化模块</li>
<li>安装模块</li>
<li>初始化 <code>store._vm</code></li>
</ul>
<h3 id="初始化模块"><a href="#初始化模块" class="headerlink" title="初始化模块"></a>初始化模块</h3><h4 id="构建module树"><a href="#构建module树" class="headerlink" title="构建module树"></a>构建module树</h4><p>其实就是处理用户输入的配置，重点在于通过module层级建立联系，如下图所示</p>
<p><img src="/_posts/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/assets/vuex/image-20210929161649181.png" alt="image-20210929161649181"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">_modules</span> = <span class="keyword">new</span> <span class="title class_">ModuleCollection</span>(options)</span><br></pre></td></tr></table></figure>

<p><code>ModuleCollection</code> 实例化的过程就是执行了 <code>register</code> 方法，register方法递归遍历所有module，生成<code>module</code>实例，并通过<code>_children</code>属性与path和建立下级关系</p>
<blockquote>
<p>建立关联的代码很精妙，建议结合源码回忆</p>
</blockquote>
<h3 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h3><pre><code>installModule(this, state, [], this._modules.root)
</code></pre>
<p>递归执行，它的目标就是对各个模块中的 state、getters、mutations、actions 做初始化工作</p>
<p><strong>installModule</strong>函数主要做了下述几个事情：</p>
<h4 id="挂载子module-state到rootState"><a href="#挂载子module-state到rootState" class="headerlink" title="挂载子module state到rootState"></a>挂载子module state到rootState</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f (!isRoot &amp;&amp; !hot) &#123;</span><br><span class="line">    const parentState = getNestedState(rootState, path.slice(0, -1))</span><br><span class="line">    const moduleName = path[path.length - 1]</span><br><span class="line">    store._withCommit(() =&gt; &#123;</span><br><span class="line">      Vue.set(parentState, moduleName, module.state)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="根据namespace配置构建module映射"><a href="#根据namespace配置构建module映射" class="headerlink" title="根据namespace配置构建module映射"></a>根据namespace配置构建module映射</h4><p>为了根据命名空间快速查找到对应的module</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (module.namespaced) &#123;</span><br><span class="line">    store._modulesNamespaceMap[namespace] = module</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="构造模块上下文环境"><a href="#构造模块上下文环境" class="headerlink" title="构造模块上下文环境"></a>构造模块上下文环境</h4><p><img src="/_posts/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/assets/vuex/image-20210929171104463.png" alt="image-20210929171104463"></p>
<p>构造了一个模块上下文环境：保证模块内两种方法的正确运行和两种数据的正常访问</p>
<blockquote>
<p>例如 模块内的dispatch(“B”) 会映射到 rootStore.dispatch(“A&#x2F;B”)</p>
</blockquote>
<h4 id="注册mutation-action-getter"><a href="#注册mutation-action-getter" class="headerlink" title="注册mutation action getter"></a>注册mutation action getter</h4><p>其实就是把三个属性对应用户输入挂载到rootStore上去，这里也用到了<strong>模块上下文</strong></p>
<p>举一个mutation的例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> module.forEachMutation((mutation, key) =&gt; &#123;</span><br><span class="line">    const namespacedType = namespace + key</span><br><span class="line">    // 在root module下 注册了 命名空间 mutation 下同</span><br><span class="line">    registerMutation(store, namespacedType, mutation, local)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  function registerMutation (store, type, handler, local) &#123;</span><br><span class="line">    const entry = store._mutations[type] || (store._mutations[type] = [])</span><br><span class="line">    // 数组  说明 同一 type 的 _mutations 可以对应多个方法</span><br><span class="line">    entry.push(function wrappedMutationHandler(payload) &#123;</span><br><span class="line">      // store 对应模块的store  </span><br><span class="line">    handler.call(store, local.state, payload)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这里就可以看出，所有的mutations都是挂载在根store的_mutations中，并且同名mutation不会覆盖，而且推入一个队列，顺序执行，下图是实际的代码</p>
<p><img src="/_posts/vue/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/assets/vuex/image-20210929172730903.png" alt="image-20210929172730903"></p>
<p>可以看出来，开启命名空间实际上就是在mutation事件名前拼接了一个路径</p>
<p>这个地方也解除了我对vuex官方文档一段话的不解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">默认情况下，模块内部的 action、mutation 和 getter 是注册在**全局命名空间**的——这样使得多个模块能够对同一 mutation 或 action 作出响应。</span><br><span class="line"></span><br><span class="line">如果希望你的模块具有更高的封装度和复用性，你可以通过添加 `namespaced: true` 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：</span><br></pre></td></tr></table></figure>

<h3 id="初始化-store-vm"><a href="#初始化-store-vm" class="headerlink" title="初始化 store._vm"></a>初始化 <code>store._vm</code></h3><p><code>Store</code> 实例化的最后一步，就是执行初始化 <code>store._vm</code> 的逻辑，它的入口代码是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">resetStoreVM</span>(<span class="variable language_">this</span>, state)</span><br></pre></td></tr></table></figure>

<p><strong><code>resetStoreVM</code> 的作用实际上是想建立 <code>getters</code> 和 <code>state</code> 的联系</strong></p>
<p>利用vue的data和computed机制实现联系，关键代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const wrappedGetters = store._wrappedGetters</span><br><span class="line"> const computed = &#123;&#125;</span><br><span class="line"> forEachValue(wrappedGetters, (fn, key) =&gt; &#123;</span><br><span class="line">   // use computed to leverage its lazy-caching mechanism</span><br><span class="line">   computed[key] = () =&gt; fn(store)</span><br><span class="line">   Object.defineProperty(store.getters, key, &#123;</span><br><span class="line">     get: () =&gt; store._vm[key],</span><br><span class="line">     enumerable: true // for local getters</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"> // use a Vue instance to store the state tree</span><br><span class="line"> // suppress warnings just in case the user has added</span><br><span class="line"> // some funky global mixins</span><br><span class="line"> const silent = Vue.config.silent</span><br><span class="line"> Vue.config.silent = true</span><br><span class="line"> store._vm = new Vue(&#123;</span><br><span class="line">   data: &#123;</span><br><span class="line">     $$state: state</span><br><span class="line">   &#125;,</span><br><span class="line">   computed</span><br><span class="line"> &#125;)</span><br><span class="line"> Vue.config.silent = silent</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>vue</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vuex源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode刷题记录-链表</title>
    <url>/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    <content><![CDATA[<p>关于二分查找，可以看<a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485044&idx=1&sn=e6b95782141c17abe206bfe2323a4226&chksm=9bd7f87caca0716aa5add0ddddce0bfe06f1f878aafb35113644ebf0cf0bfe51659da1c1b733&scene=21#wechat_redirect">labuladong</a>，或者是极客王铮的算法课15 16</p>
<p>王铮总结的左右边界 要比公众号好记的多</p>
<h3 id="704-二分查找-基础题"><a href="#704-二分查找-基础题" class="headerlink" title="704.二分查找 基础题"></a>704.二分查找 基础题</h3><p>最基础的一个二分查找</p>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<p>你可以假设 nums 中的所有元素是不重复的。<br>n 将在 [1, 10000]之间。<br>nums 的每个元素都将在 [-9999, 9999]之间。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-search">https://leetcode-cn.com/problems/binary-search</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>自己的代码,含有4个二分法变种</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 正常二分法</span><br><span class="line">var search = function(nums, target) &#123;</span><br><span class="line">  let left = 0, right = nums.length - 1;</span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    const mid = left + ((right - left) &gt;&gt; 1);</span><br><span class="line">    if (nums[mid] &gt; target) &#123;</span><br><span class="line">      right = mid - 1;</span><br><span class="line">    &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">      left = mid + 1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return mid</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1</span><br><span class="line">&#125;;</span><br><span class="line">// 含有重复元素 找到第一个等于target的数</span><br><span class="line">var search = function(nums, target) &#123;</span><br><span class="line">  let left = 0, right = nums.length - 1;</span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    const mid = left + ((right - left) &gt;&gt; 1);</span><br><span class="line">    if (nums[mid] &gt; target) &#123;</span><br><span class="line">      right = mid - 1;</span><br><span class="line">    &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">      left = mid + 1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (mid === 0 || nums[mid - 1] !== target) &#123;</span><br><span class="line">        return mid</span><br><span class="line">      &#125;</span><br><span class="line">      right = mid - 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1</span><br><span class="line">&#125;;</span><br><span class="line">// 含有重复元素 找到最后一个等于target的数</span><br><span class="line">var search = function(nums, target) &#123;</span><br><span class="line">  let left = 0, right = nums.length - 1;</span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    const mid = left + ((right - left) &gt;&gt; 1);</span><br><span class="line">    if (nums[mid] &gt; target) &#123;</span><br><span class="line">      right = mid - 1;</span><br><span class="line">    &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">      left = mid + 1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (mid === nums.length - 1 || nums[mid + 1] !== target) &#123;</span><br><span class="line">        return mid</span><br><span class="line">      &#125;</span><br><span class="line">      left = mid + 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1</span><br><span class="line">&#125;;</span><br><span class="line">// 含有重复元素 查找第一个大于等于给定值的元素</span><br><span class="line">var search = function(nums, target) &#123;</span><br><span class="line">  let left = 0, right = nums.length - 1;</span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    const mid = left + ((right - left) &gt;&gt; 1);</span><br><span class="line">    if (nums[mid] &gt;= target) &#123;</span><br><span class="line">      if (mid === 0 || nums[mid - 1] &lt; target) &#123;</span><br><span class="line">        return mid</span><br><span class="line">      &#125;</span><br><span class="line">      right = mid - 1</span><br><span class="line">    &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">      left = mid + 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1</span><br><span class="line">&#125;;</span><br><span class="line">// 含有重复元素 查找最后一个小于等于给定值的元素</span><br><span class="line">var search = function(nums, target) &#123;</span><br><span class="line">  let left = 0, right = nums.length - 1;</span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    const mid = left + ((right - left) &gt;&gt; 1);</span><br><span class="line">    if (nums[mid] &gt; target) &#123;</span><br><span class="line">      right = mid - 1;</span><br><span class="line">    &#125; else if (nums[mid] &lt;= target) &#123;</span><br><span class="line">      if (mid === nums.length - 1 || nums[mid + 1] &gt; target) &#123;</span><br><span class="line">        return mid</span><br><span class="line">      &#125;</span><br><span class="line">      left = mid + 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33.搜索旋转排序数组"></a>33.<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">搜索旋转排序数组</a></h3><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p>
<p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p>
<p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p>
<p>需要注意的细节很多很多，一般看着官方题解和代码，慢慢调试才写了出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var search = function(nums, target) &#123;</span><br><span class="line">  let left = 0,right = nums.length - 1, n = nums.length;</span><br><span class="line">  if (!n) &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  if (n == 1) &#123;</span><br><span class="line">      return nums[0] == target ? 0 : -1;</span><br><span class="line">  &#125;</span><br><span class="line">  while(left &lt;= right)&#123;</span><br><span class="line">    // 两种写法都能过</span><br><span class="line">    const mid = (right + left) &gt;&gt; 1;</span><br><span class="line">    const mid = left + ((right - left) &gt;&gt; 1);</span><br><span class="line">    if(nums[mid] === target)&#123;</span><br><span class="line">      return mid</span><br><span class="line">    &#125;else if(nums[left] &lt;= nums[mid])&#123;</span><br><span class="line">      // 细节一，必须保证target 在左右区间</span><br><span class="line">      // 普通二分法 只需要一个就够了，那是因为target 必然在有序的left-right之间</span><br><span class="line">      // 细节二 小于等于 等于不能忘</span><br><span class="line">      if(nums[mid] &gt; target &amp;&amp; nums[left] &lt;= target)&#123;</span><br><span class="line">        right = mid - 1</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        left = mid + 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      if(nums[mid] &lt; target &amp;&amp; target &lt;= nums[right])&#123;</span><br><span class="line">        left = mid + 1</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        right = mid - 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">  return -1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167.两数之和 II - 输入有序数组"></a>167.<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">两数之和 II - 输入有序数组</a></h3><p>给定一个已按照 非递减顺序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。</p>
<p>函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;&#x3D; answer[0] &lt; answer[1] &lt;&#x3D; numbers.length 。</p>
<p>你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted">https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="自己的代码"><a href="#自己的代码" class="headerlink" title="自己的代码"></a>自己的代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var twoSum = function(numbers, target) &#123;</span><br><span class="line">  const l = numbers.length;</span><br><span class="line">  for(let i = 0; i&lt;l-1;i++)&#123;</span><br><span class="line">    const result = getIndex(i+1, target - numbers[i]);</span><br><span class="line">    if(result)&#123;</span><br><span class="line">      return result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  function getIndex(i, target)&#123;</span><br><span class="line">    let left = i, right = l - 1;</span><br><span class="line">    while(left &lt;= right)&#123;</span><br><span class="line">      const mid = left + ((right - left) &gt;&gt; 1);</span><br><span class="line">      if(numbers[mid] === target) &#123;</span><br><span class="line">        return [i, mid+1]</span><br><span class="line">      &#125;else if(numbers[mid]&gt;target)&#123;</span><br><span class="line">        right = mid - 1</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        left = mid +1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>稍微优化了一下，把函数体放入循环里</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var twoSum = function(numbers, target) &#123;</span><br><span class="line">  const l = numbers.length;</span><br><span class="line">  for(let i = 0; i&lt;l-1;i++)&#123;</span><br><span class="line">    const result = target - numbers[i];</span><br><span class="line">    let left = i+1, right = l - 1;</span><br><span class="line">    while(left &lt;= right)&#123;</span><br><span class="line">      const mid = left + ((right - left) &gt;&gt; 1);</span><br><span class="line">      if(numbers[mid] === result) &#123;</span><br><span class="line">        return [i+1, mid+1]</span><br><span class="line">      &#125;else if(numbers[mid]&gt;result)&#123;</span><br><span class="line">        right = mid - 1</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        left = mid +1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​ </p>
]]></content>
      <categories>
        <category>算法</category>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode刷题记录-链表</title>
    <url>/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h3 id="146-LRU缓存算法"><a href="#146-LRU缓存算法" class="headerlink" title="146.LRU缓存算法"></a>146.LRU缓存算法</h3><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实现 LRUCache 类：</span><br><span class="line"></span><br><span class="line">LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存</span><br><span class="line">int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</span><br><span class="line">void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</span><br><span class="line"></span><br><span class="line">进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https://leetcode-cn.com/problems/lru-cache</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h4 id="利用链表保持时序，利用hash存储节点"><a href="#利用链表保持时序，利用hash存储节点" class="headerlink" title="利用链表保持时序，利用hash存储节点"></a>利用链表保持时序，利用hash存储节点</h4><p>调试了好久，终于搞定了，需要仔细</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ListNode &#123;</span><br><span class="line">  constructor(key, val, pre=null, next=null)&#123;</span><br><span class="line">    this.key = key;</span><br><span class="line">    this.val = val;</span><br><span class="line">    this.pre = pre;</span><br><span class="line">    this.next = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var LRUCache = function (capacity) &#123;</span><br><span class="line">  // 最大长度</span><br><span class="line">  this.capacity = capacity</span><br><span class="line">  this.hash = new Map()</span><br><span class="line">  // 计数器</span><br><span class="line">  this.count = 0</span><br><span class="line">  // 虚拟头部</span><br><span class="line">  this.dummyHead = new ListNode(-1, -1)</span><br><span class="line">  // 虚拟尾部</span><br><span class="line">  this.dummyTail = new ListNode(-1, -1)</span><br><span class="line">  this.dummyHead.next = this.dummyTail</span><br><span class="line">  this.dummyTail.pre = this.dummyHead</span><br><span class="line">  // 头部</span><br><span class="line">  this.listHead = this.dummyHead</span><br><span class="line">  // 尾部</span><br><span class="line">  this.listTail = this.dummyTail</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LRUCache.prototype.get = function(key) &#123;</span><br><span class="line">  if (this.hash.has(key)) &#123;</span><br><span class="line">    const existNode = this.hash.get(key)</span><br><span class="line">    // 从原位置删除</span><br><span class="line">    existNode.next.pre = existNode.pre</span><br><span class="line">    existNode.pre.next = existNode.next</span><br><span class="line">    // 把节点插入虚拟尾部之前</span><br><span class="line">    this.insertBeforeTail(existNode)</span><br><span class="line">    return this.hash.get(key).val</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    return -1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LRUCache.prototype.put = function(key, value) &#123;</span><br><span class="line">  if (this.hash.has(key)) &#123; // 已存在</span><br><span class="line">    const existNode = this.hash.get(key)</span><br><span class="line">    // 从原位置删除</span><br><span class="line">    existNode.next.pre = existNode.pre</span><br><span class="line">    existNode.pre.next = existNode.next</span><br><span class="line">    // 题目有个变更要求</span><br><span class="line">    existNode.val = value</span><br><span class="line">    // 把节点插入虚拟尾部之前</span><br><span class="line">    this.insertBeforeTail(existNode)</span><br><span class="line">  &#125; else &#123; // 未存在</span><br><span class="line">    const newNode = new ListNode(key, value)</span><br><span class="line">    if (this.count &lt; this.capacity) &#123; // 容量没满</span><br><span class="line">      // 把新节点插入虚拟尾部之前</span><br><span class="line">      this.insertBeforeTail(newNode)</span><br><span class="line">      // 用key记录节点</span><br><span class="line">      this.hash.set(key, newNode)</span><br><span class="line">      // 计数</span><br><span class="line">      this.count++</span><br><span class="line">    &#125; else &#123; // 容量满了</span><br><span class="line">      // 删除节点记录</span><br><span class="line">      this.hash.delete(this.listHead.next.key)</span><br><span class="line">      // 把虚拟头部后边节点删除</span><br><span class="line">      this.listHead.next = this.listHead.next.next</span><br><span class="line">      this.listHead.next.pre = this.listHead </span><br><span class="line">      // 把新节点插入虚拟尾部之前   </span><br><span class="line">      this.insertBeforeTail(newNode)</span><br><span class="line">      // 用key记录节点</span><br><span class="line">      this.hash.set(key, newNode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">LRUCache.prototype.insertBeforeTail = function (newNode) &#123;</span><br><span class="line">  // 把节点插入虚拟尾部之前</span><br><span class="line">  this.listTail.pre.next = newNode</span><br><span class="line">  newNode.pre = this.listTail.pre</span><br><span class="line">  newNode.next = this.listTail</span><br><span class="line">  this.listTail.pre = newNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="利用map数据结构"><a href="#利用map数据结构" class="headerlink" title="利用map数据结构"></a>利用map数据结构</h4><p>利用map特别简单</p>
<p><strong>map数据结构兼顾有序性和hash</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var LRUCache = function(capacity) &#123;</span><br><span class="line">    this.capacity = capacity;</span><br><span class="line">    this.map = new Map();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LRUCache.prototype.get = function(key) &#123;</span><br><span class="line">    if(this.map.has(key))&#123;</span><br><span class="line">        let temp=this.map.get(key)</span><br><span class="line">         this.map.delete(key);</span><br><span class="line">         this.map.set(key, temp);</span><br><span class="line">         return temp</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return -1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LRUCache.prototype.put = function(key, value) &#123;</span><br><span class="line">    if(this.map.has(key))&#123;</span><br><span class="line">        this.map.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">    this.map.set(key,value);</span><br><span class="line">    if(this.map.size &gt; this.capacity)&#123;</span><br><span class="line">     </span><br><span class="line">        this.map.delete(this.map.keys().next().value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="380-O-1-时间插入、删除和获取随机元素"><a href="#380-O-1-时间插入、删除和获取随机元素" class="headerlink" title="380.O(1) 时间插入、删除和获取随机元素"></a>380.<a href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1/">O(1) 时间插入、删除和获取随机元素</a></h3><p>实现RandomizedSet 类：</p>
<p>RandomizedSet() 初始化 RandomizedSet 对象<br>bool insert(int val) 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false 。<br>bool remove(int val) 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。<br>int getRandom() 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。<br>你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 O(1) 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">[&quot;RandomizedSet&quot;, &quot;insert&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;]</span><br><span class="line">[[], [1], [2], [2], [], [1], [2], []]</span><br><span class="line">输出</span><br><span class="line">[null, true, false, true, 2, true, false, 2]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">RandomizedSet randomizedSet = new RandomizedSet();</span><br><span class="line">randomizedSet.insert(1); // 向集合中插入 1 。返回 true 表示 1 被成功地插入。</span><br><span class="line">randomizedSet.remove(2); // 返回 false ，表示集合中不存在 2 。</span><br><span class="line">randomizedSet.insert(2); // 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。</span><br><span class="line">randomizedSet.getRandom(); // getRandom 应随机返回 1 或 2 。</span><br><span class="line">randomizedSet.remove(1); // 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。</span><br><span class="line">randomizedSet.insert(2); // 2 已在集合中，所以返回 false 。</span><br><span class="line">randomizedSet.getRandom(); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https://leetcode-cn.com/problems/insert-delete-getrandom-o1</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h4 id="利用map进行设计，利用水塘抽样算法实现等概率"><a href="#利用map进行设计，利用水塘抽样算法实现等概率" class="headerlink" title="利用map进行设计，利用水塘抽样算法实现等概率"></a>利用map进行设计，利用水塘抽样算法实现等概率</h4><p>但是随机获取 时间复杂度不是O1,而是O(n)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var RandomizedSet = function() &#123;</span><br><span class="line">  this.hash = new Map()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RandomizedSet.prototype.insert = function(val) &#123;</span><br><span class="line">  if (this.hash.has(val)) &#123;</span><br><span class="line">    return false</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    this.hash.set(val, true)</span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RandomizedSet.prototype.remove = function(val) &#123;</span><br><span class="line">  if (this.hash.has(val)) &#123;</span><br><span class="line">    this.hash.delete(val)</span><br><span class="line">    return true</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RandomizedSet.prototype.getRandom = function() &#123;</span><br><span class="line">  let count = 1;</span><br><span class="line">  let iterator = this.hash.keys();</span><br><span class="line">  let result = null;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    const &#123; value, done &#125; = iterator.next()</span><br><span class="line">    if (done) &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    if (Math.floor(Math.random() * count) === 0) &#123;</span><br><span class="line">      result = value</span><br><span class="line">    &#125;</span><br><span class="line">    count++</span><br><span class="line">  &#125;</span><br><span class="line">  return result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="利用hash实现O1存储删除，数组实现O1等概率访问"><a href="#利用hash实现O1存储删除，数组实现O1等概率访问" class="headerlink" title="利用hash实现O1存储删除，数组实现O1等概率访问"></a>利用hash实现O1存储删除，数组实现O1等概率访问</h4><p>难点还是在于理解和设计，熟悉数据结构的基础方法时间复杂度</p>
<blockquote>
<p>删除的前提是访问</p>
<p>数组某个元素和尾部交换后删除，O1</p>
<p>数组push 01</p>
<p>代码重点在于交换时，hash对应的index也需要考虑</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var RandomizedSet = function() &#123;</span><br><span class="line">  this.hash = Object.create(null, &#123;&#125;)</span><br><span class="line">  this.array = []</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RandomizedSet.prototype.insert = function(val) &#123;</span><br><span class="line">  if (typeof this.hash[val] !== &quot;undefined&quot;) &#123;</span><br><span class="line">    return false</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    this.array.push(val)</span><br><span class="line">    // 存储位置</span><br><span class="line">    this.hash[val] = this.array.length - 1</span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RandomizedSet.prototype.remove = function(val) &#123;</span><br><span class="line">  if (typeof this.hash[val] !== &quot;undefined&quot;) &#123;</span><br><span class="line">    // 待删除元素的索引</span><br><span class="line">    const index = this.hash[val]</span><br><span class="line">    // 对末尾元素进行操作</span><br><span class="line">    const tailValue = this.array[this.array.length - 1]</span><br><span class="line">    this.hash[tailValue] = index</span><br><span class="line">    this.array[index] = tailValue</span><br><span class="line">    // 删除</span><br><span class="line">    this.array.pop()</span><br><span class="line">    delete this.hash[val]</span><br><span class="line">    return true</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RandomizedSet.prototype.getRandom = function() &#123;</span><br><span class="line">  return this.array[Math.floor(Math.random()*this.array.length)]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h3><p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/solution/tu-jie-guan-fang-tui-jian-ti-jie-yong-zh-4hru/">题解简单易懂</a>，主要是需要搞懂push pop穿插如果保证有序性就可以了,pop必须一次性从inStack全部转移过来才能保持顺序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var MyQueue = function() &#123;</span><br><span class="line">  this.inStack = []</span><br><span class="line">  this.outStack = []</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyQueue.prototype.push = function(x) &#123;</span><br><span class="line">  this.inStack.push(x)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyQueue.prototype.pop = function() &#123;</span><br><span class="line">  if(!this.outStack.length)&#123;</span><br><span class="line">    while(this.inStack.length)&#123;</span><br><span class="line">      this.outStack.push(</span><br><span class="line">        this.inStack.pop()</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return this.outStack.pop()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyQueue.prototype.peek = function() &#123;</span><br><span class="line">  if(!this.outStack.length)&#123;</span><br><span class="line">    while(this.inStack.length)&#123;</span><br><span class="line">      this.outStack.push(</span><br><span class="line">        this.inStack.pop()</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return this.outStack[this.outStack.length-1]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyQueue.prototype.empty = function() &#123;</span><br><span class="line">  return !this.inStack.length &amp;&amp; !this.outStack.length</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h3><p>请你仅使用<strong>两个队列</strong>实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p>
<p>实现 MyStack 类：</p>
<p>void push(int x) 将元素 x 压入栈顶。<br>int pop() 移除并返回栈顶元素。<br>int top() 返回栈顶元素。<br>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var MyStack = function() &#123;</span><br><span class="line">  this.list = []</span><br><span class="line">  this.tempList = []</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyStack.prototype.push = function(x) &#123;</span><br><span class="line">  if(this.list.length)&#123;</span><br><span class="line">    while(this.list.length)&#123;</span><br><span class="line">      this.tempList.push(this.list.shift())</span><br><span class="line">    &#125;</span><br><span class="line">    this.list.push(x)</span><br><span class="line">    while(this.tempList.length)&#123;</span><br><span class="line">      this.list.push(this.tempList.shift())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    this.list.push(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyStack.prototype.pop = function() &#123;</span><br><span class="line">  return this.list.shift()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyStack.prototype.top = function() &#123;</span><br><span class="line">  return this.list[0]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyStack.prototype.empty = function() &#123;</span><br><span class="line">  return !this.list.length</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode刷题记录-链表</title>
    <url>/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="206-反转链表-简单"><a href="#206-反转链表-简单" class="headerlink" title="206.反转链表 -简单"></a>206.反转链表 -简单</h3><h4 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h4><p>使用迭代方法，我可以做出来，但是不太完美，代码不够精简</p>
<h5 id="自己的代码"><a href="#自己的代码" class="headerlink" title="自己的代码"></a>自己的代码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var reverseList = function(head) &#123;</span><br><span class="line">    if(!head)&#123; // 这个判断多余了</span><br><span class="line">        return head</span><br><span class="line">    &#125;</span><br><span class="line">    let prev = null // 这个利用了哨兵，简化了判断</span><br><span class="line">    while(head)&#123; // 判断条件很重要</span><br><span class="line">        const next = head.next</span><br><span class="line">        head.next = prev</span><br><span class="line">        if(!next)&#123;</span><br><span class="line">            return head</span><br><span class="line">        &#125;</span><br><span class="line">        prev = head</span><br><span class="line">        head = next</span><br><span class="line">    &#125;</span><br><span class="line">    return head // return pre 就不用判断next了</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="优秀代码"><a href="#优秀代码" class="headerlink" title="优秀代码"></a>优秀代码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var reverseList = function (head) &#123;</span><br><span class="line">    var pre = null, cur = head, next;</span><br><span class="line">    while (cur) &#123; // 用cur取代head 迭代过程更加清晰</span><br><span class="line">      next = cur.next;</span><br><span class="line">      cur.next = pre;</span><br><span class="line">      </span><br><span class="line">      pre = cur;</span><br><span class="line">      cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre;</span><br><span class="line">  &#125;; </span><br></pre></td></tr></table></figure>

<p>少了两步判断，注意细节</p>
<h4 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h4><h5 id="自己的代码-1"><a href="#自己的代码-1" class="headerlink" title="自己的代码"></a>自己的代码</h5><p>条件重复了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var reverseList = function(head) &#123;</span><br><span class="line">    if(!head)&#123; // 这个其实和下边的条件重复了</span><br><span class="line">        return head</span><br><span class="line">    &#125;</span><br><span class="line">    return df(null, head)</span><br><span class="line">    function df(prev, cur)&#123;</span><br><span class="line">        if(!cur)&#123;</span><br><span class="line">            return prev</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            const next = cur.next</span><br><span class="line">            cur.next = prev</span><br><span class="line">            return df(cur, next)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="优秀代码-1"><a href="#优秀代码-1" class="headerlink" title="优秀代码"></a>优秀代码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var reverseList = function (head) &#123;</span><br><span class="line">  function df(pre, cur) &#123;</span><br><span class="line">    if (cur === null) &#123;</span><br><span class="line">      return pre;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      var temp = cur.next;</span><br><span class="line">      cur.next = pre;</span><br><span class="line">      return df(cur, temp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return df(null, head);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="单参数递归-需要重点理解"><a href="#单参数递归-需要重点理解" class="headerlink" title="单参数递归-&#x3D;&#x3D;需要重点理解&#x3D;&#x3D;"></a>单参数递归-&#x3D;&#x3D;需要重点理解&#x3D;&#x3D;</h5><p>可以被称为前置递归，而上边那种可以叫做后置递归</p>
<p>这种递归处理 从尾部开始处理，一步步向头部靠近，不太容易理解，需要重点关注</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var reverseList = function (head) &#123;</span><br><span class="line"> function df(head) &#123;</span><br><span class="line">    if (!head || head.next === null) &#123;</span><br><span class="line">      return head;</span><br><span class="line">    &#125;</span><br><span class="line">    const last = df(head.next)</span><br><span class="line">    head.next.next = head</span><br><span class="line">    head.next = null</span><br><span class="line">    return last</span><br><span class="line">  &#125;</span><br><span class="line">  return df(head);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个算法常常拿来显示递归的巧妙和优美</p>
</blockquote>
<h6 id="重点理解"><a href="#重点理解" class="headerlink" title="重点理解"></a>重点理解</h6><p>这个方法很难理解，一篇文章写的很好<a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484467&idx=1&sn=beb3ae89993b812eeaa6bbdeda63c494&chksm=9bd7fa3baca0732dc3f9ae9202ecaf5c925b4048514eeca6ac81bc340930a82fc62bb67681fa&scene=21#wechat_redirect">labuladong</a>，在这里摘抄一部分重要的内容</p>
<h6 id="原文如下"><a href="#原文如下" class="headerlink" title="原文如下"></a>原文如下</h6><p>这个算法可能很多读者都听说过，这里详细介绍一下，先直接看实现代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ListNode reverse(ListNode head) &#123;</span><br><span class="line">    if (head.next == null) return head;</span><br><span class="line">    ListNode last = reverse(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = null;</span><br><span class="line">    return last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来是不是感觉不知所云，完全不能理解这样为什么能够反转链表？这就对了，这个算法常常拿来显示递归的巧妙和优美，我们下面来详细解释一下这段代码。</p>
<p>**&#x3D;&#x3D;对于递归算法，最重要的就是明确递归函数的定义&#x3D;&#x3D;**。</p>
<p>除原文之外，还有几个容易遗漏而且比较<strong>重要的点</strong></p>
<ul>
<li><strong>last的指向一直未变</strong></li>
<li><strong>函数的截止条件和只有一个listNode的情况一样</strong>（也许这也是递归的魅力吧）</li>
<li><strong>head的指向由于是栈结构，所以前置运行的时候head是倒着的</strong></li>
<li><strong>前置递归能不能看成是一种倒叙迭代呢？，利用栈的特效进行倒叙操作</strong></li>
</ul>
<p>具体来说，我们的<code>reverse</code>函数定义是这样的：</p>
<p><strong>输入一个节点<code>head</code>，将「以<code>head</code>为起点」的链表反转，并返回反转之后的头结点</strong>。</p>
<p>明白了函数的定义，再来看这个问题。比如说我们想反转这个链表：</p>
<p><img src="/_posts/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/assets/%E9%93%BE%E8%A1%A8/640-20211019112839879.png" alt="图片"></p>
<p>那么输入<code>reverse(head)</code>后，会在这里进行递归：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ListNode last = reverse(head.next);</span><br></pre></td></tr></table></figure>

<p>不要跳进递归（你的脑袋能压几个栈呀？），而是要根据刚才的函数定义，来弄清楚这段代码会产生什么结果：</p>
<p><img src="/_posts/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/assets/%E9%93%BE%E8%A1%A8/640-20211019112840006.png" alt="图片"></p>
<p>按照定义，这个<code>reverse(head.next)</code>执行完成后，整个链表应该变成了这样：</p>
<p><img src="/_posts/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/assets/%E9%93%BE%E8%A1%A8/640.png" alt="图片"></p>
<p>并且根据函数定义，<code>reverse</code>函数会返回反转之后的头结点，我们用变量<code>last</code>接收了。</p>
<p>现在再来看下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">head.next.next = head;</span><br></pre></td></tr></table></figure>

<p><img src="/_posts/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/assets/%E9%93%BE%E8%A1%A8/640-20211019112839982.png" alt="图片"></p>
<p>接下来进行的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">head.next = null;</span><br><span class="line">return last;</span><br></pre></td></tr></table></figure>

<p><img src="/_posts/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/assets/%E9%93%BE%E8%A1%A8/640-20211019112839935.png" alt="图片"></p>
<p>神不神奇，这样整个链表就反转过来了！递归代码就是这么简洁优雅，不过其中有两个地方需要注意：</p>
<p><strong>1、递归函数要有 base case</strong>，也就是这句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (head.next == null) return head;</span><br></pre></td></tr></table></figure>

<p>意思是如果链表只有一个节点的时候反转也是它自己，直接返回即可。</p>
<p><strong>2、当链表递归反转之后，新的头节点是<code>last</code>，而之前的<code>head</code>变成了最后一个节点，别忘了链表的末尾要指向 null：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">head.next = null;</span><br></pre></td></tr></table></figure>

<h6 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h6><p>虽然按照他的说法，代码理解起来确实简单了一些，但是怎么把代码写出来是个问题。</p>
<p>针对过程做一个代码示意</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null</span><br><span class="line">var reverseList = function (head) &#123;</span><br><span class="line"> function df(head) &#123;</span><br><span class="line">    if (!head || head.next === null) &#123;</span><br><span class="line">      return head;</span><br><span class="line">    &#125;</span><br><span class="line">    const last = df(head.next)</span><br><span class="line">    head.next.next = head</span><br><span class="line">    head.next = null</span><br><span class="line">    return last</span><br><span class="line">  &#125;</span><br><span class="line">  return df(head);</span><br><span class="line">&#125;;</span><br><span class="line">// 模拟代码运行步骤</span><br><span class="line">df(1)</span><br><span class="line">df(2)</span><br><span class="line">df(3)</span><br><span class="line">df(4)</span><br><span class="line">df(5) // 满足条件 开始return 开始运行df函数后面的代码</span><br><span class="line">// 第一次执行df后代码</span><br><span class="line">// last 5</span><br><span class="line">// head 4-&gt;5-&gt;null </span><br><span class="line">head.next.next = head // 5-&gt;4 </span><br><span class="line">head.next = null // 4-&gt;null</span><br><span class="line">// 执行完成后</span><br><span class="line">// last 5-&gt;4-&gt;null</span><br><span class="line">return last </span><br><span class="line"></span><br><span class="line">// 第二次执行</span><br><span class="line">// last 5-&gt;4-&gt;null</span><br><span class="line">// head 3-&gt;4</span><br><span class="line">head.next.next = head // 4-&gt;3</span><br><span class="line">head.next = null // 3-&gt;null</span><br><span class="line">// 执行完成后</span><br><span class="line">// last 5-&gt;4-&gt;3-&gt;null</span><br><span class="line">return last</span><br><span class="line"></span><br><span class="line">// 第三次执行</span><br><span class="line">// last 5-&gt;4-&gt;3-&gt;null</span><br><span class="line">// head 2-&gt;3</span><br><span class="line">head.next.next = head // 3-&gt;2</span><br><span class="line">head.next = null // 2-&gt;null</span><br><span class="line">// 执行完成后</span><br><span class="line">// last 5-&gt;4-&gt;3-&gt;2-&gt;null</span><br><span class="line">return last</span><br><span class="line"></span><br><span class="line">// 第四次执行</span><br><span class="line">// last 5-&gt;4-&gt;3-&gt;2-&gt;null</span><br><span class="line">// head 1-&gt;2</span><br><span class="line">head.next.next = head // 2-&gt;1</span><br><span class="line">head.next = null // 1-&gt;null</span><br><span class="line">// 执行完成后</span><br><span class="line">// last 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;null</span><br><span class="line">return last</span><br><span class="line">// 整体结束</span><br></pre></td></tr></table></figure>

<h3 id="92-反转链表2-困难"><a href="#92-反转链表2-困难" class="headerlink" title="92.反转链表2 困难"></a>92.反转链表2 困难</h3><p>官方头穿法容易理解，labuladong 公众号文章 较难理解</p>
<h4 id="自己的代码-2"><a href="#自己的代码-2" class="headerlink" title="自己的代码"></a>自己的代码</h4><p>虽然头穿法理解起来容易，但是写起来需要仔细和不断试错，还需要照顾边界情况</p>
<p>代码中需要注意一下几点</p>
<ul>
<li>使用了哨兵，方便left为1的情况，使用了哨兵，返回的时候需要注意处理</li>
<li>cur情况不同 赋值的方式也不同</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var reverseBetween = function(head, left, right) &#123;</span><br><span class="line">    const dmNode = new ListNode(-1, head)</span><br><span class="line">    let cur = dmNode</span><br><span class="line">    let pre = null</span><br><span class="line">    let leftNode = null</span><br><span class="line">    let index = 0</span><br><span class="line">    while(cur)&#123;</span><br><span class="line">      if(index === right+1)&#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      if(index===left-1)&#123;</span><br><span class="line">        leftNode = cur</span><br><span class="line">        pre = cur.next</span><br><span class="line"></span><br><span class="line">        cur = cur.next</span><br><span class="line">      &#125;else if(index &gt; left)&#123;</span><br><span class="line">        const leftNodeNext = leftNode.next</span><br><span class="line">        pre.next = cur.next</span><br><span class="line">        leftNode.next = cur</span><br><span class="line">        cur.next = leftNodeNext</span><br><span class="line">        cur = pre.next</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        cur = cur.next</span><br><span class="line">      &#125;</span><br><span class="line">      index++</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    return dmNode.next</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="优秀代码-2"><a href="#优秀代码-2" class="headerlink" title="优秀代码"></a>优秀代码</h4><p>官方代码 采取的分断式处理-for循环分段，逻辑较为清晰，ye</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var reverseBetween = function(head, left, right) &#123;</span><br><span class="line">    // 设置 dummyNode 是这一类问题的一般做法</span><br><span class="line">    const dummy_node = new ListNode(-1);</span><br><span class="line">    dummy_node.next = head;</span><br><span class="line">    let pre = dummy_node;</span><br><span class="line">    for (let i = 0; i &lt; left - 1; ++i) &#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let cur = pre.next;</span><br><span class="line">    for (let i = 0; i &lt; right - left; ++i) &#123;</span><br><span class="line">        const next = cur.next;</span><br><span class="line">        cur.next = next.next;</span><br><span class="line">        next.next = pre.next;</span><br><span class="line">        pre.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummy_node.next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode-solut-teyq/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h3 id="234-如何判断回文链表"><a href="#234-如何判断回文链表" class="headerlink" title="234.如何判断回文链表"></a>234.如何判断回文链表</h3><h4 id="自己的代码-3"><a href="#自己的代码-3" class="headerlink" title="自己的代码"></a>自己的代码</h4><p>缺点无法提前结束</p>
<p>时间 空间都是O n</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var isPalindrome = function (head) &#123;</span><br><span class="line">  let left = right = head;</span><br><span class="line">  let flag = true</span><br><span class="line">  function df(head)&#123;</span><br><span class="line">    if(!head)&#123;</span><br><span class="line">      return head</span><br><span class="line">    &#125;</span><br><span class="line">    df(head.next)</span><br><span class="line">    if(head.val !== left.val)&#123;</span><br><span class="line">      flag = false</span><br><span class="line">      return </span><br><span class="line">    &#125;</span><br><span class="line">    left = left.next</span><br><span class="line">  &#125;</span><br><span class="line">  df(right)</span><br><span class="line">  return flag</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p>通过双指针判断中间节点，翻转后半段并进行比较</p>
<p>时间 空间都是O n</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var isPalindrome = function (head) &#123;</span><br><span class="line"> // 特殊情况</span><br><span class="line">  if(!head || !head.next)&#123;</span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line">  let slow = fast = head;</span><br><span class="line">  while (fast &amp;&amp; fast.next) &#123;</span><br><span class="line">    slow = slow.next</span><br><span class="line">    fast = fast.next.next</span><br><span class="line">  &#125;</span><br><span class="line">  // 区别单双链表</span><br><span class="line">  if (fast !== null) &#123;</span><br><span class="line">    slow = slow.next</span><br><span class="line">  &#125;</span><br><span class="line">  let right = reserve(slow)</span><br><span class="line">  // 注意结束条件 right比较短</span><br><span class="line">  while (right) &#123;</span><br><span class="line">    if (right.val !== head.val) &#123;</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line">    right = right.next</span><br><span class="line">    head = head.next</span><br><span class="line">  &#125;</span><br><span class="line">  return true</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function reserve(head) &#123;</span><br><span class="line">  if (!head.next) &#123;</span><br><span class="line">    return head</span><br><span class="line">  &#125;</span><br><span class="line">  const newHead = reserve(head.next)</span><br><span class="line">  head.next.next = head</span><br><span class="line">  head.next = null</span><br><span class="line">  return newHead</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="142-环形链表-2"><a href="#142-环形链表-2" class="headerlink" title="142.环形链表 2"></a>142.环形链表 2</h3><h4 id="利用hash可以很方便的解决"><a href="#利用hash可以很方便的解决" class="headerlink" title="利用hash可以很方便的解决"></a>利用hash可以很方便的解决</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var detectCycle = function(head) &#123;</span><br><span class="line">    const set = new Set();</span><br><span class="line">    while(head &amp;&amp; !set.has(head))&#123;</span><br><span class="line">      set.add(head)</span><br><span class="line">      head = head.next</span><br><span class="line">    &#125;</span><br><span class="line">    return head</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里和回文链表不一样，没有比较listNode.val</p>
</blockquote>
<h4 id="利用快慢指针"><a href="#利用快慢指针" class="headerlink" title="利用快慢指针"></a>利用快慢指针</h4><p>条件放的位置需要格外注意</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var detectCycle = function(head) &#123;</span><br><span class="line">    let slow = fast = head;</span><br><span class="line">    while(fast &amp;&amp; fast.next)&#123;</span><br><span class="line">      slow = slow.next</span><br><span class="line">      fast = fast.next.next</span><br><span class="line">      // 刚开始位置放错了</span><br><span class="line">      if(slow === fast)&#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!fast || !fast.next)&#123;</span><br><span class="line">      return null</span><br><span class="line">    &#125;</span><br><span class="line">    slow = head</span><br><span class="line">    while(slow !== fast)&#123;</span><br><span class="line">      slow = slow.next</span><br><span class="line">      fast = fast.next</span><br><span class="line">    &#125;</span><br><span class="line">    return slow</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="快慢指针可行性推导"><a href="#快慢指针可行性推导" class="headerlink" title="快慢指针可行性推导"></a>快慢指针可行性推导</h4><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode-solution/">https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode-solution/</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解释：为何慢指针第一圈走不完一定会和快指针相遇, 很精彩的推论</span><br><span class="line"> 首先，第一步，快指针先进入环 </span><br><span class="line"> 第二步：当慢指针刚到达环的入口时，快指针此时在环中的某个位置(也可能此时相遇) </span><br><span class="line"> 第三步：设此时快指针和慢指针距离为x，若在第二步相遇，则x = 0； </span><br><span class="line"> 第四步：设环的周长为n，那么看成快指针追赶慢指针，需要追赶n-x； </span><br><span class="line"> 第五步：快指针每次都追赶慢指针1个单位，设慢指针速度1/s，快指针2/s，那么追赶需要(n-x)s </span><br><span class="line"> 第六步：在n-x秒内，慢指针走了n-x单位，因为x&gt;=0，则慢指针走的路程小于等于n，即走不完一圈就和快指针相遇</span><br></pre></td></tr></table></figure>

<h3 id="剑指offer-II-023"><a href="#剑指offer-II-023" class="headerlink" title="剑指offer II 023"></a>剑指offer II 023</h3><p>自己的代码,暴力法 Om*n，这里需要注意一个细节，内层while需要重置条件，可能是for循环用多了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var getIntersectionNode = function(headA, headB) &#123;</span><br><span class="line">    let pA = headA,pB;</span><br><span class="line">    while(pA)&#123;</span><br><span class="line">      pB = headB</span><br><span class="line">      while(pB)&#123;</span><br><span class="line">        if(pB === pA)&#123;</span><br><span class="line">          console.log(pA)</span><br><span class="line">          return pA;</span><br><span class="line">        &#125;</span><br><span class="line">        pB = pB.next</span><br><span class="line">      &#125;</span><br><span class="line">      pA = pA.next</span><br><span class="line">    &#125;</span><br><span class="line">    return null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>官方解法，建议看<a href="https://leetcode-cn.com/problems/3u1WK4/solution/tu-jie-shuang-zhi-zhen-javascript-by-lzx-i6yo/">题解</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const getIntersectionNode = (A, B) =&gt; &#123;</span><br><span class="line">    let pA = A,</span><br><span class="line">        pB = B;</span><br><span class="line">    while (pA !== pB) &#123;</span><br><span class="line">        pA = pA === null ? B : pA.next;</span><br><span class="line">        pB = pB === null ? A : pB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return pA;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树遍历</title>
    <url>/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="常规遍历"><a href="#常规遍历" class="headerlink" title="常规遍历"></a>常规遍历</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/tu-jie-er-cha-shu-de-si-chong-bian-li-by-z1m/">优秀题解</a></p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归的代码很简单</p>
<h4 id="前序-中左右"><a href="#前序-中左右" class="headerlink" title="前序 中左右"></a>前序 中左右</h4><p><strong>这种写法其实不好，容易让人误解，return res 会被执行好多次</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var preorderTraversal = function(root, res = []) &#123;</span><br><span class="line">  if(!root)&#123;</span><br><span class="line">    return res</span><br><span class="line">  &#125;</span><br><span class="line">  res.push(root.val)</span><br><span class="line">  preorderTraversal(root.left, res)</span><br><span class="line">  preorderTraversal(root.right, res)</span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面这种容易理解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var preorderTraversal = function(root) &#123;</span><br><span class="line"> var res = []</span><br><span class="line">  if(!root)&#123;</span><br><span class="line">    return res</span><br><span class="line">  &#125;</span><br><span class="line">  res.push(root.val)</span><br><span class="line">  preorderTraversal(root.left, res)</span><br><span class="line">  preorderTraversal(root.right, res)</span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br><span class="line">function handle(root) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="中序-左中右"><a href="#中序-左中右" class="headerlink" title="中序 左中右"></a>中序 左中右</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var preorderTraversal = function(root, res = []) &#123;</span><br><span class="line">  if(!root)&#123;</span><br><span class="line">    return res</span><br><span class="line">  &#125;</span><br><span class="line">  preorderTraversal(root.left, res)</span><br><span class="line">  res.push(root.val)</span><br><span class="line">  preorderTraversal(root.right, res)</span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="后序-左右中"><a href="#后序-左右中" class="headerlink" title="后序 左右中"></a>后序 左右中</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var preorderTraversal = function(root, res = []) &#123;</span><br><span class="line">  if(!root)&#123;</span><br><span class="line">    return res</span><br><span class="line">  &#125;</span><br><span class="line">  preorderTraversal(root.left, res)</span><br><span class="line">  preorderTraversal(root.right, res)</span><br><span class="line">  res.push(root.val)</span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>迭代的很不容易理解</p>
<h4 id="前序-中左右-1"><a href="#前序-中左右-1" class="headerlink" title="前序 中左右"></a>前序 中左右</h4><p>普通写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var preorderTraversal = function(root) &#123;</span><br><span class="line">  if(!root)&#123;</span><br><span class="line">    return []</span><br><span class="line">  &#125;</span><br><span class="line">  const stack = [];</span><br><span class="line">  const res = []</span><br><span class="line">  stack.push(root)</span><br><span class="line">  while(stack.length)&#123;</span><br><span class="line">    const popNode = stack.pop()</span><br><span class="line">    res.push(popNode.val)</span><br><span class="line">    if(popNode.right)&#123;</span><br><span class="line">      stack.push(popNode.right)</span><br><span class="line">    &#125;</span><br><span class="line">    if(popNode.left)&#123;</span><br><span class="line">      stack.push(popNode.left)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>统一写法 前序和中序 结果采集的地方不同，一个是出栈 一个是入栈</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var preorderTraversal = function(root) &#123;</span><br><span class="line">  const res = []</span><br><span class="line">  let cur = root</span><br><span class="line">  const stack = []</span><br><span class="line">  while (stack.length || cur) &#123;</span><br><span class="line">    while (cur) &#123;</span><br><span class="line">      res.push(cur.val)</span><br><span class="line">      stack.push(cur)</span><br><span class="line">      cur = cur.left</span><br><span class="line">    &#125;</span><br><span class="line">    const popNode = stack.pop()</span><br><span class="line">    if(popNode.right)&#123;</span><br><span class="line">      cur = popNode.right</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="中序-左中右-1"><a href="#中序-左中右-1" class="headerlink" title="中序 左中右"></a>中序 左中右</h4><p>统一写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var inorderTraversal = (root) =&gt; &#123;</span><br><span class="line">  const res = []</span><br><span class="line">  let cur = root</span><br><span class="line">  const stack = []</span><br><span class="line">  while (stack.length || cur) &#123;</span><br><span class="line">    // 找到最左侧的节点，并把沿路的节点全部推入栈中</span><br><span class="line">    while(cur)&#123;</span><br><span class="line">      stack.push(cur)</span><br><span class="line">      cur = cur.left</span><br><span class="line">    &#125;</span><br><span class="line">    // 取出栈顶元素</span><br><span class="line">    const popNode = stack.pop()</span><br><span class="line">    // 记录出栈元素</span><br><span class="line">    res.push(popNode.val)</span><br><span class="line">    // 存在右节点 即为父节点 而且左节点已经处理过了</span><br><span class="line">    if(popNode.right)&#123;</span><br><span class="line">      cur = popNode.right</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="后序-左右中-1"><a href="#后序-左右中-1" class="headerlink" title="后序 左右中"></a>后序 左右中</h4><p>可以把前序的普通写法改一下，变成中右左，然后倒着输出</p>
<p>普通写法倒着输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const postorderTraversal = function(root) &#123;</span><br><span class="line">  const res = []</span><br><span class="line">  if(!root)&#123;</span><br><span class="line">    return res</span><br><span class="line">  &#125;</span><br><span class="line">  const stack = []</span><br><span class="line">  stack.push(root)</span><br><span class="line">  while(stack.length)&#123;</span><br><span class="line">    const popRoot = stack.pop()</span><br><span class="line">    res.push(popRoot.val)</span><br><span class="line">    // 左右换一下顺序</span><br><span class="line">    if(popRoot.left)&#123;</span><br><span class="line">      stack.push(popRoot.left)</span><br><span class="line">    &#125;</span><br><span class="line">    if(popRoot.right)&#123;</span><br><span class="line">      stack.push(popRoot.right)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 倒着输出</span><br><span class="line">  return res.reverse()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>统一写法倒着输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const postorderTraversal = function(root) &#123;</span><br><span class="line">  const res = []</span><br><span class="line">  let cur = root</span><br><span class="line">  const stack = []</span><br><span class="line">  while (stack.length || cur) &#123;</span><br><span class="line">    while (cur) &#123;</span><br><span class="line">      res.push(cur.val)</span><br><span class="line">      stack.push(cur)</span><br><span class="line">      cur = cur.right</span><br><span class="line">    &#125;</span><br><span class="line">    const popNode = stack.pop()</span><br><span class="line">    if(popNode.left)&#123;</span><br><span class="line">      cur = popNode.left</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 把上边的push 换成unshift 这边就不用倒着了 但是时间复杂度更高了，不好</span><br><span class="line">  return res.reverse()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>利用标识符进行迭代,普通写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const postorderTraversal = function(root) &#123;</span><br><span class="line">  if (!root) &#123;</span><br><span class="line">    return []</span><br><span class="line">  &#125;</span><br><span class="line">  const stack = []</span><br><span class="line">  const res = []</span><br><span class="line">  stack.push(&#123;</span><br><span class="line">    node: root,</span><br><span class="line">    flag: 0</span><br><span class="line">  &#125;)</span><br><span class="line">  while (stack.length) &#123;</span><br><span class="line">    const &#123;node, flag&#125; = stack.pop()</span><br><span class="line">    if (!node) &#123;</span><br><span class="line">      continue</span><br><span class="line">    &#125;</span><br><span class="line">    if (flag === 1) &#123;</span><br><span class="line">      res.push(node.val)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      stack.push(&#123;</span><br><span class="line">        node: node,</span><br><span class="line">        flag: 1</span><br><span class="line">      &#125;)</span><br><span class="line">      stack.push(&#123;</span><br><span class="line">        node: node.right,</span><br><span class="line">        flag: 0</span><br><span class="line">      &#125;)</span><br><span class="line">      stack.push(&#123;</span><br><span class="line">        node: node.left,</span><br><span class="line">        flag: 0</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="优秀统一迭代法-直接记这个就好"><a href="#优秀统一迭代法-直接记这个就好" class="headerlink" title="优秀统一迭代法 直接记这个就好"></a>优秀统一迭代法 直接记这个就好</h3><h4 id="前序遍历统一迭代法"><a href="#前序遍历统一迭代法" class="headerlink" title="前序遍历统一迭代法"></a>前序遍历统一迭代法</h4><p>&#x2F;&#x2F; 前序遍历：中左右<br>&#x2F;&#x2F; 压栈顺序：右左中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var preorderTraversal = function(root, res = []) &#123;</span><br><span class="line">    const stack = [];</span><br><span class="line">    if (root) stack.push(root);</span><br><span class="line">    while(stack.length) &#123;</span><br><span class="line">        const node = stack.pop();</span><br><span class="line">        if(!node) &#123;</span><br><span class="line">            res.push(stack.pop().val);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (node.right) stack.push(node.right); // 右</span><br><span class="line">        if (node.left) stack.push(node.left); // 左</span><br><span class="line">        stack.push(node); // 中</span><br><span class="line">        stack.push(null);</span><br><span class="line">    &#125;;</span><br><span class="line">    return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="中序遍历统一迭代法"><a href="#中序遍历统一迭代法" class="headerlink" title="中序遍历统一迭代法"></a>中序遍历统一迭代法</h4><p>&#x2F;&#x2F;  中序遍历：左中右<br>&#x2F;&#x2F;  压栈顺序：右中左</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var inorderTraversal = function(root, res = []) &#123;</span><br><span class="line">    const stack = [];</span><br><span class="line">    if (root) stack.push(root);</span><br><span class="line">    while(stack.length) &#123;</span><br><span class="line">        const node = stack.pop();</span><br><span class="line">        if(!node) &#123;</span><br><span class="line">            res.push(stack.pop().val);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (node.right) stack.push(node.right); // 右</span><br><span class="line">        stack.push(node); // 中</span><br><span class="line">        stack.push(null);</span><br><span class="line">        if (node.left) stack.push(node.left); // 左</span><br><span class="line">    &#125;;</span><br><span class="line">    return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="后序遍历统一迭代法"><a href="#后序遍历统一迭代法" class="headerlink" title="后序遍历统一迭代法"></a>后序遍历统一迭代法</h4><p>&#x2F;&#x2F; 后续遍历：左右中<br>&#x2F;&#x2F; 压栈顺序：中右左</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var postorderTraversal = function(root, res = []) &#123;</span><br><span class="line">    const stack = [];</span><br><span class="line">    if (root) stack.push(root);</span><br><span class="line">    while(stack.length) &#123;</span><br><span class="line">        const node = stack.pop();</span><br><span class="line">        if(!node) &#123;</span><br><span class="line">            res.push(stack.pop().val);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(node); // 中</span><br><span class="line">        stack.push(null);</span><br><span class="line">        if (node.right) stack.push(node.right); // 右</span><br><span class="line">        if (node.left) stack.push(node.left); // 左</span><br><span class="line">    &#125;;</span><br><span class="line">    return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>作者：carlsun-2<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/dai-ma-sui-xiang-lu-chi-tou-qian-zhong-hou-xu-de-d/">https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/dai-ma-sui-xiang-lu-chi-tou-qian-zhong-hou-xu-de-d/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p>leetcode一道基础的题</p>
<p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></p>
<p>难度中等1081收藏分享切换为英文接收动态反馈</p>
<p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p><strong>示例：</strong><br>二叉树：<code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回其层序遍历结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><p>利用层级和数组解决</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var levelOrder = function(root) &#123;</span><br><span class="line">  const levelArr = []</span><br><span class="line">  handle(root,0,levelArr)</span><br><span class="line">  return levelArr</span><br><span class="line">&#125;;</span><br><span class="line">function handle(root, level, levelArr)&#123;</span><br><span class="line">  if(!root)&#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  Array.isArray(levelArr[level]) ? levelArr[level].push(root.val) : levelArr[level] = [root.val]</span><br><span class="line">  level++</span><br><span class="line">  handle(root.left, level, levelArr)</span><br><span class="line">  handle(root.right, level, levelArr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h3><p>方法看一下 很容易就能理解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var levelOrder = function(root) &#123;</span><br><span class="line">  const res = []</span><br><span class="line">  if(!root)&#123;</span><br><span class="line">    return res</span><br><span class="line">  &#125;</span><br><span class="line">  const queue = [root]</span><br><span class="line">  let index = 0</span><br><span class="line">  while (queue.length) &#123; // 关键点</span><br><span class="line">    // 每一层的新开始</span><br><span class="line">    // 记录当前层的节点个数，防止shift多了</span><br><span class="line">    const l = queue.length // 关键点</span><br><span class="line">    res.push([])</span><br><span class="line">    // 把该层推入结果，顺便把该层的下一层推入q中</span><br><span class="line">    for(var i=0;i&lt;l;i++)&#123; // 关键点</span><br><span class="line">      const head = queue.shift()</span><br><span class="line">      res[index].push(head.val)</span><br><span class="line">      if(head.left)&#123;</span><br><span class="line">        queue.push(head.left)</span><br><span class="line">      &#125;</span><br><span class="line">      if(head.right)&#123;</span><br><span class="line">        queue.push(head.right)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    index++</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="加深对二叉树递归的理解"><a href="#加深对二叉树递归的理解" class="headerlink" title="加深对二叉树递归的理解"></a>加深对二叉树递归的理解</h2><h3 id="230-二叉搜索树中第K小的元素-labuladong-题解-思路"><a href="#230-二叉搜索树中第K小的元素-labuladong-题解-思路" class="headerlink" title="230. 二叉搜索树中第K小的元素 labuladong 题解 思路"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a> <a href="https://labuladong.gitee.io/plugin-v2/?qno=230">labuladong 题解</a> <a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/#">思路</a></h3><p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/_posts/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/assets/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/kthtree1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,1,4,null,2], k = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/_posts/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/assets/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/kthtree2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<h4 id="对递归理解不深的解法，没错-我写的"><a href="#对递归理解不深的解法，没错-我写的" class="headerlink" title="对递归理解不深的解法，没错 我写的"></a>对递归理解不深的解法，没错 我写的</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var kthSmallest = function(root, k) &#123;</span><br><span class="line">  let res</span><br><span class="line">  function handle(root, count, k)&#123;</span><br><span class="line">    if(!root)&#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    handle(root.left, count, k)</span><br><span class="line">    if(count === k)&#123;</span><br><span class="line">      res = root.val</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    count++</span><br><span class="line">    handle(root.right, count, k)</span><br><span class="line">  &#125;</span><br><span class="line">  handle(root, 1, k)</span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="实际上的正确解法"><a href="#实际上的正确解法" class="headerlink" title="实际上的正确解法"></a>实际上的正确解法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var kthSmallest = function(root, k) &#123;</span><br><span class="line">  let count = 1</span><br><span class="line">  function handle(root, k)&#123;</span><br><span class="line">    if(!root)&#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    handle(root.left, k)</span><br><span class="line">    if(count === k)&#123;</span><br><span class="line">      res = root.val</span><br><span class="line">      // 如果没有这个count++ 会一直指向下一个节点</span><br><span class="line">      count++</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    count++</span><br><span class="line">    handle(root.right, k)</span><br><span class="line">  &#125;</span><br><span class="line">  handle(root, k)</span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="搜索二叉树插入数据"><a href="#搜索二叉树插入数据" class="headerlink" title="搜索二叉树插入数据"></a>搜索二叉树插入数据</h3><p>重点理解两种模式的不同</p>
<h4 id="我的解法-简单直接"><a href="#我的解法-简单直接" class="headerlink" title="我的解法 简单直接"></a>我的解法 简单直接</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var insertIntoBST = function(root, val) &#123;</span><br><span class="line">  if(!root)&#123;</span><br><span class="line">    return new TreeNode(val)</span><br><span class="line">  &#125;</span><br><span class="line">  if(val &gt; root.val)&#123;</span><br><span class="line">    if(!root.right)&#123;</span><br><span class="line">      root.right = new TreeNode(val)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      insertIntoBST(root.right, val)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    if(!root.left)&#123;</span><br><span class="line">      root.left = new TreeNode(val)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      insertIntoBST(root.left, val)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="另一种解法-不太容易理解"><a href="#另一种解法-不太容易理解" class="headerlink" title="另一种解法 不太容易理解"></a>另一种解法 不太容易理解</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var insertIntoBST = function(root, val) &#123;</span><br><span class="line">  if(!root)&#123;</span><br><span class="line">    return new TreeNode(val)</span><br><span class="line">  &#125;</span><br><span class="line">  if(val &gt; root.val)&#123;</span><br><span class="line">    root.right = insertIntoBST(root.right, val)</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    root.left = insertIntoBST(root.left, val)</span><br><span class="line">  &#125;</span><br><span class="line">  // 对return之外情况的兜底 找不到原样返回</span><br><span class="line">  // root.right = root.right</span><br><span class="line">  return root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>搜索二叉树的删除操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var deleteNode = function(root, key) &#123;</span><br><span class="line">  if(!root)&#123;</span><br><span class="line">    return root</span><br><span class="line">  &#125;</span><br><span class="line">  if(root.val === key)&#123;</span><br><span class="line">    if(!root.left)&#123;</span><br><span class="line">      // 如果root.right 也不存在 就是null</span><br><span class="line">      return root.right</span><br><span class="line">    &#125;</span><br><span class="line">    if(!root.right)&#123;</span><br><span class="line">      return root.left</span><br><span class="line">    &#125;</span><br><span class="line">    const minVal = getRightMin(root.right)</span><br><span class="line">    root.val = minVal.val</span><br><span class="line">    root.right = deleteNode(root.right, minVal.val)</span><br><span class="line">  &#125;else if(key &lt; root.val)&#123;</span><br><span class="line">    root.left = deleteNode(root.left, key)</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    root.right = deleteNode(root.right, key)</span><br><span class="line">  &#125;</span><br><span class="line">  return root</span><br><span class="line">&#125;;</span><br><span class="line">function getRightMin(root)&#123;</span><br><span class="line">  while(root.left)&#123;</span><br><span class="line">    root = root.left</span><br><span class="line">  &#125;</span><br><span class="line">  return root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II</a></h3><p>给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。</p>
<p> <img src="/_posts/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/assets/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/uniquebstn3.jpg" alt="img"></p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]</span><br><span class="line">示例 2：</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var generateTrees = function(n) &#123;</span><br><span class="line">  if(n===0)&#123;</span><br><span class="line">    return []</span><br><span class="line">  &#125;</span><br><span class="line">  return build(1, n)</span><br><span class="line">&#125;;</span><br><span class="line">function build(l, r)&#123;</span><br><span class="line">  const res = []</span><br><span class="line">  if(l&gt;r)&#123;</span><br><span class="line">    res.push(null)</span><br><span class="line">    return res</span><br><span class="line">  &#125;</span><br><span class="line">  for(var i=l;i&lt;=r;i++)&#123;</span><br><span class="line">    const leftTree = build(l, i-1)</span><br><span class="line">    const rightTree = build(i+1, r)</span><br><span class="line">    for(var left of leftTree)&#123;</span><br><span class="line">      for(var right of rightTree)&#123;</span><br><span class="line">        const root = new TreeNode(i, left, right)</span><br><span class="line">        res.push(root)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>get post</title>
    <url>/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/get&amp;post/</url>
    <content><![CDATA[<h2 id="POST提交数据时四种常见的数据格式"><a href="#POST提交数据时四种常见的数据格式" class="headerlink" title="POST提交数据时四种常见的数据格式"></a>POST提交数据时四种常见的数据格式</h2><ul>
<li><p>application&#x2F;x-www-form-urlencoded<br> 浏览器的原生 表单，如果不设置 enctype 属性，那么最终就会以 application&#x2F;x-www-form-urlencoded方式提交数据。</p>
</li>
<li><p>multipart&#x2F;form-data<br> 我们使用表单上传文件时，必须让 表单的 enctype 等于 multipart&#x2F;form-data</p>
</li>
<li><p>application&#x2F;json<br>JSON 格式支持比键值对复杂得多的结构化数据</p>
</li>
<li><p>text&#x2F;xml<br>XML-RPC（XML Remote Procedure Call）,它是一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范。</p>
</li>
</ul>
<hr>
<h2 id="get的编码类型-仅有-application-x-www-form-urlencoded"><a href="#get的编码类型-仅有-application-x-www-form-urlencoded" class="headerlink" title="get的编码类型 仅有 application&#x2F;x-www-form-urlencoded"></a>get的编码类型 仅有 application&#x2F;x-www-form-urlencoded</h2><h2 id="W3C列出的HTTP方法-POST和GET的区别"><a href="#W3C列出的HTTP方法-POST和GET的区别" class="headerlink" title="W3C列出的HTTP方法 POST和GET的区别"></a>W3C列出的HTTP方法 POST和GET的区别</h2><p><img src="/_posts/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/assets/get&post/post-bg1.png" alt="区别">  </p>
<h2 id="常见解答-get-post的区别"><a href="#常见解答-get-post的区别" class="headerlink" title="常见解答 get post的区别"></a>常见解答 get post的区别</h2><ul>
<li>1.GET请求的数据会附在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，POST把提交的数据则放置在是HTTP包的包体中。</li>
<li>2.GET的长度受限于url的长度，而url的长度限制是特定的浏览器和服务器设置的，理论上GET的长度可以无限长。</li>
<li>3.POST是没有大小限制的，HTTP协议规范也没有进行大小限制，起限制作用的是服务器的处理程序的处理能力</li>
<li>4.在ASP中，服务端获取GET请求参数用Request.QueryString，获取POST请求参数用Request.Form。</li>
<li>5.POST的安全性要比GET的安全性高application json 与form表单的区别?瀏覽器默認的提交方式就是表單。首先，Content-Type 被指定为 application&#x2F;x-www-form-urlencoded，jQuery的Ajax请求默认方式，其次，数据以键值对形式？key1&#x3D;value1&amp;key2&#x3D;value2的方式发送到服务器</li>
<li>6.就是语义上的区别，get用于获取数据，post用于提交数据</li>
</ul>
<h3 id="post和get的选择？"><a href="#post和get的选择？" class="headerlink" title="post和get的选择？"></a>post和get的选择？</h3><p>私密性的信息请求使用post。查询信息和可以想要通过url分享的信息使用get。</p>
]]></content>
      <categories>
        <category>零散知识</category>
      </categories>
      <tags>
        <tag>get</tag>
        <tag>post</tag>
      </tags>
  </entry>
  <entry>
    <title>this绑定规则的详解</title>
    <url>/javascript/this/this/</url>
    <content><![CDATA[<h2 id="this的由来"><a href="#this的由来" class="headerlink" title="this的由来"></a>this的由来</h2><p>看下述一段代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var bar = &#123;</span><br><span class="line">    myName:&quot;time.geekbang.com&quot;,</span><br><span class="line">    printName: function () &#123;</span><br><span class="line">        console.log(myName)</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">function foo() &#123;</span><br><span class="line">    let myName = &quot;极客时间&quot;</span><br><span class="line">    return bar.printName</span><br><span class="line">&#125;</span><br><span class="line">let myName = &quot;极客邦&quot;</span><br><span class="line">let _printName = foo()</span><br><span class="line">_printName()</span><br><span class="line">bar.printName()</span><br></pre></td></tr></table></figure>

<p>相信你已经知道了，在 printName 函数里面使用的变量 myName 是属于全局作用域下面的，所以最终打印出来的值都是“极客邦”</p>
<p>不过按照常理来说，调用bar.printName方法时，该方法内部的变量 myName 应该使用bar 对象中的，因为它们是一个整体，大多数面向对象语言都是这样设计的，以<strong>在对象内部的方法中使用对象内部的属性是一个非常普遍的需求</strong>。但是 JavaScript 的作用域机制并不支持这一点，基于这个需求，JavaScript 又搞出来另外一套<strong>this 机制</strong>。</p>
<h2 id="this到底是什么"><a href="#this到底是什么" class="headerlink" title="this到底是什么"></a>this到底是什么</h2><p><code>this</code> 是在运行时进行绑定的，<strong>是和执行上下文绑定的</strong>，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。<code>this</code>的绑定和<strong>函数声明的位置没有任何关系，只取决于函数的调用方式</strong>。</p>
<p><img src="/_posts/javascript/this/assets/this/image-20210720111215903.png" alt="image-20210720111215903"></p>
<blockquote>
<p>执行上下文其余相关的内容，在blog中浏览器原理中有详细介绍</p>
</blockquote>
<h2 id="this的绑定规则"><a href="#this的绑定规则" class="headerlink" title="this的绑定规则"></a>this的绑定规则</h2><h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><p>首先要介绍的是最常用的函数调用类型：<strong>独立函数调用</strong>。可以把这条规则看作是无法应用其他规则时的默认规则。<br>this指向window对象，在严格模式下指向 <code>undefined</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;      </span><br><span class="line">  console.log( this.a ); </span><br><span class="line">&#125; </span><br><span class="line">var a = 2; </span><br><span class="line">foo(); // 2</span><br></pre></td></tr></table></figure>

<p>foo() 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。</p>
<h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><ol>
<li>另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;      </span><br><span class="line">  console.log( this.a ); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 2,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">obj.foo(); // 2</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>对象属性引用链中只有最顶层或者说<strong>最后一层会影响调用结果</strong>,看下例</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;      </span><br><span class="line">  console.log( this.a ); </span><br><span class="line">&#125; </span><br><span class="line">var obj2 = &#123;      </span><br><span class="line">  a: 42,     </span><br><span class="line">  foo: foo  </span><br><span class="line">&#125;; </span><br><span class="line">var obj1 = &#123;      </span><br><span class="line">  a: 2,     </span><br><span class="line">  obj2: obj2  </span><br><span class="line">&#125;; </span><br><span class="line">obj1.obj2.foo(); // 42</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>隐式丢失, 一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;      </span><br><span class="line">  console.log( this.a ); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">var obj = &#123;      </span><br><span class="line">  a: 2,     </span><br><span class="line">  foo: foo  </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">var bar = obj.foo; // 函数别名！   </span><br><span class="line">var a = &quot;oops, global&quot;; // a 是全局对象的属性 </span><br><span class="line">bar(); // &quot;oops, global&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>虽然 bar 是 obj.foo 的一个引用，<strong>但是实际上，它引用的是 foo 函数本身</strong>，因此此时的 bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定</p>
</blockquote>
<p>一种更微妙、更常见并且更出乎意料的情况发生在传入回调函数时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;      </span><br><span class="line">  console.log( this.a ); </span><br><span class="line">&#125; </span><br><span class="line">function doFoo(fn) &#123;     </span><br><span class="line">  // fn 其实引用的是 foo </span><br><span class="line">  fn(); // &lt;-- 调用位置！ </span><br><span class="line">&#125; </span><br><span class="line">var obj = &#123;      </span><br><span class="line">  a: 2,     </span><br><span class="line">  foo: foo  </span><br><span class="line">&#125;; </span><br><span class="line">var a = &quot;oops, global&quot;; // a 是全局对象的属性 </span><br><span class="line">doFoo( obj.foo ); // &quot;oops, global&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子一样。</p>
</blockquote>
<h3 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h3><p><code>call(..)</code> 、<code>apply(..)</code>和<code>bind(..)</code> 方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;      </span><br><span class="line">  console.log( this.a ); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">var obj = &#123;</span><br><span class="line">  a:2 </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">foo.call( obj ); // 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="new-绑定-（暂不深究）"><a href="#new-绑定-（暂不深究）" class="headerlink" title="new 绑定 （暂不深究）"></a>new 绑定 （暂不深究）</h3><p>在 JavaScript 中，构造函数只是一些使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上， 它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。<br>使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</p>
<ol>
<li>创建（或者说构造）一个全新的对象。</li>
<li>这个新对象会被执行 <code>[[ 原型 ]]</code> 连接。</li>
<li>这个新对象会绑定到函数调用的 this。</li>
<li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象</li>
</ol>
<h3 id="还有一些需要注意的示例"><a href="#还有一些需要注意的示例" class="headerlink" title="还有一些需要注意的示例"></a>还有一些需要注意的示例</h3><p>注意后三个示例，详细解释在 <strong>同分类下-从ECMAScript规范解读this</strong>中有解读</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var value = 1;</span><br><span class="line"></span><br><span class="line">var foo = &#123;</span><br><span class="line">  value: 2,</span><br><span class="line">  bar: function () &#123;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//示例1</span><br><span class="line">console.log(foo.bar()); // 2</span><br><span class="line">//示例2</span><br><span class="line">console.log((foo.bar)()); // 2</span><br><span class="line">//示例3</span><br><span class="line">console.log((foo.bar = foo.bar)()); // 1</span><br><span class="line">//示例4</span><br><span class="line">console.log((false || foo.bar)()); // 1</span><br><span class="line">//示例5</span><br><span class="line">console.log((foo.bar, foo.bar)()); // 1</span><br></pre></td></tr></table></figure>

<p>后三个类型，方便记忆的话，可以将其理解为隐式绑定，foo.bar被隐式的赋值了，相当于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = foo.bar</span><br><span class="line">a()</span><br></pre></td></tr></table></figure>

<p>但是需要注意第二个示例</p>
<h2 id="关于this补充"><a href="#关于this补充" class="headerlink" title="关于this补充"></a>关于this补充</h2><p>可以帮助理解</p>
<p><a href="https://github.com/mqyqingfeng/Blog/issues/7">从ECMAScript规范解读this</a></p>
<p><a href="https://time.geekbang.org/column/article/128427">极客时间</a></p>
]]></content>
      <categories>
        <category>javascript</category>
        <category>this</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode刷题记录-单调栈</title>
    <url>/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    <content><![CDATA[<p>单调栈实际上就是栈，只是利用了一些巧妙的逻辑，使得每次新元素入栈后，栈内的元素都保持有序（单调递增或单调递减）。</p>
<p>听起来有点像堆（heap）？不是的，单调栈用途不太广泛，只处理一种典型的问题，叫做 Next Greater Element。</p>
<h3 id="先来一道基础题"><a href="#先来一道基础题" class="headerlink" title="先来一道基础题"></a>先来一道基础题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给一个数组，返回一个大小相同的数组。返回的数组的第i个位置的值应当是，对于原数组中的第i个元素，至少往右走多少步，才能遇到一个比自己大的元素（如果之后没有比自己大的元素，或者已经是最后一个元素，则在返回数组的对应位置放上-1）。</span><br><span class="line"></span><br><span class="line">例如给定数组为：[2,1,5,6,2,3]</span><br><span class="line">返回数组应该为：[2,1,1,-1,1,-1]</span><br></pre></td></tr></table></figure>

<h4 id="正序"><a href="#正序" class="headerlink" title="正序"></a>正序</h4><p>建议自己再画一遍示意图，根据代码画，还是比较容易理解的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr1 = [2, 1, 5, 6, 2, 3];</span><br><span class="line">function countSteps(arr) &#123;</span><br><span class="line">  // 用栈存储下标</span><br><span class="line">  const stack = [];</span><br><span class="line">  const result = Array(arr.length).fill(-1);</span><br><span class="line">  for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    while (stack.length &amp;&amp; arr[i] &gt; arr[stack[stack.length - 1]]) &#123;</span><br><span class="line">      result[stack.pop()] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(countSteps(arr1));</span><br><span class="line">[ 5, 5, 6, -1, 3, -1 ]</span><br></pre></td></tr></table></figure>

<p><img src="/_posts/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/assets/%E5%8D%95%E8%B0%83%E6%A0%88/151635833917_.pic_%E5%89%AF%E6%9C%AC.jpg" alt="151635833917_.pic_副本"></p>
<h4 id="倒叙"><a href="#倒叙" class="headerlink" title="倒叙"></a>倒叙</h4><p>这个讲的比较好，<a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484525&idx=1&sn=3d2e63694607fec72455a52d9b15d4e5&chksm=9bd7fa65aca073734df90b45054448e09c14e6e35ad7b778bff62f9bd6c2b4f6e1ca7bc4f844&scene=21#wechat_redirect">labuladong</a></p>
<p>倒叙好像是不用记录下标，因为倒叙处理，每到一个元素，<strong>它的结果都会在此轮遍历中确定，和正序不同</strong>，再多理解理解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr2 = [2, 1, 2, 4, 3];</span><br><span class="line">function nextBigElement(arr) &#123;</span><br><span class="line">  const stack = []</span><br><span class="line">  const result = []</span><br><span class="line">  for (let i = arr.length-1; i &gt;=0; i--) &#123;</span><br><span class="line">    while (stack.length &amp;&amp; arr[i] &gt;= stack[stack.length-1]) &#123;</span><br><span class="line">      stack.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    result[i] = stack.length ? stack[stack.length - 1] : -1</span><br><span class="line">    stack.push(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br><span class="line">console.log(nextBigElement(arr2));</span><br></pre></td></tr></table></figure>

<p><img src="/_posts/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/assets/%E5%8D%95%E8%B0%83%E6%A0%88/%E5%9B%BE%E5%83%8F.jpeg" alt="图像"></p>
<h4 id="正序和倒序的一些区别"><a href="#正序和倒序的一些区别" class="headerlink" title="正序和倒序的一些区别"></a>正序和倒序的一些区别</h4><ul>
<li>确定值的时机不同<ul>
<li>倒序在每一轮循环中都可以确认</li>
<li>正序只会在pop时确认</li>
<li>由此造成书写结构和逻辑有些许差异</li>
</ul>
</li>
</ul>
<h3 id="496-下一个更大元素I"><a href="#496-下一个更大元素I" class="headerlink" title="496.下一个更大元素I"></a>496.下一个更大元素I</h3><p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。</p>
<p>请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。</p>
<p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</p>
<p>示例 1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums1 = [4,1,2], nums2 = [1,3,4,2].</span><br><span class="line">输出: [-1,3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。</span><br><span class="line">    对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。</span><br><span class="line">    对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums1 = [2,4], nums2 = [1,2,3,4].</span><br><span class="line">输出: [3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。</span><br><span class="line">    对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/next-greater-element-i">https://leetcode-cn.com/problems/next-greater-element-i</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h4><p>这道题和基础题基本上一致，多了一个映射的过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var nextGreaterElement = function(nums1, nums2) &#123;</span><br><span class="line">  const map = new Map();</span><br><span class="line">  // 存储数值 而不是位置 因为没有重复元素</span><br><span class="line">  const stack = [];</span><br><span class="line">  for(let i=0;i&lt;nums2.length;i++)&#123;</span><br><span class="line">    // 出栈条件</span><br><span class="line">    while(stack.length &amp;&amp; nums2[i] &gt; stack[stack.length-1]) &#123;</span><br><span class="line">      map.set(stack.pop(), nums2[i])</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(nums2[i])</span><br><span class="line">  &#125;</span><br><span class="line">  return nums1.map(item =&gt; &#123;</span><br><span class="line">    const r = map.get(item);</span><br><span class="line">    return r?r:-1</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739.每日温度"></a>739.每日温度</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请根据每日 气温 列表 temperatures ，请计算在每一天需要等几天才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: temperatures = [73,74,75,71,69,72,76,73]</span><br><span class="line">输出: [1,1,4,2,1,1,0,0]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里以正序和倒序各写一次，方便理解记忆</p>
<p>正序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var dailyTemperatures = function(temperatures) &#123;</span><br><span class="line">	// 需要预先设置查找不到的情况</span><br><span class="line">	const r = Array(temperatures.length).fill(0)</span><br><span class="line">	// 栈底到栈顶单调递减 **可以等于**</span><br><span class="line">  const stack = []</span><br><span class="line">  // 正序</span><br><span class="line">  for(let i=0;i&lt;temperatures.length;i++)&#123;</span><br><span class="line">  	// 当栈不为空 且 当前温度大于栈顶温度</span><br><span class="line">    while(stack.length &amp;&amp; temperatures[i] &gt; temperatures[stack[stack.length-1]])&#123;</span><br><span class="line">    	// 当前温度大于栈顶温度，即找到了栈顶元素 对应的 符合条件的元素</span><br><span class="line">    	// 弹出栈顶 并记录下标</span><br><span class="line">      const index = stack.pop()</span><br><span class="line">      // 记录栈顶元素的对应的天数</span><br><span class="line">      r[index] = i - index</span><br><span class="line">    &#125;</span><br><span class="line">    // 当栈为空 或者 当前元素**小于等于** 栈顶元素时 入栈</span><br><span class="line">    stack.push(i)</span><br><span class="line">  &#125;</span><br><span class="line">  return r</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>倒序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var dailyTemperatures = function(temperatures) &#123;</span><br><span class="line">  const r = []</span><br><span class="line">  const s = []</span><br><span class="line">  // 倒序</span><br><span class="line">  for(let i=temperatures.length-1;i&gt;=0;i--)&#123;</span><br><span class="line">  	// 当栈不为空 且 当前元素**大于等于**栈顶元素</span><br><span class="line">    while(s.length &amp;&amp; temperatures[i] &gt;= temperatures[s[s.length-1]])&#123;</span><br><span class="line">      s.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    r[i] = s.length ? s[s.length-1] - i : 0</span><br><span class="line">    s.push(i)</span><br><span class="line">  &#125;</span><br><span class="line">  return r</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>差异性</strong></p>
<ul>
<li>赋值<ul>
<li><strong>倒序</strong>遍历在while外，每轮遍历赋值一次</li>
<li><strong>正序</strong>每次pop赋值，需要提前准备默认值</li>
</ul>
</li>
<li>大小比较<ul>
<li>倒序<strong>大于等于</strong></li>
<li>正序<strong>大于</strong></li>
</ul>
</li>
</ul>
<h3 id="503-下一个更大元素-II-循环数组"><a href="#503-下一个更大元素-II-循环数组" class="headerlink" title="503.下一个更大元素 II 循环数组"></a>503.下一个更大元素 II 循环数组</h3><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [1,2,1]</span><br><span class="line">输出: [2,-1,2]</span><br><span class="line">解释: 第一个 1 的下一个更大的数是 2；</span><br><span class="line">数字 2 找不到下一个更大的数； </span><br><span class="line">第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="最简单的方式，拼接一个数组在后边"><a href="#最简单的方式，拼接一个数组在后边" class="headerlink" title="最简单的方式，拼接一个数组在后边"></a>最简单的方式，拼接一个数组在后边</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var nextGreaterElements = function(nums) &#123;</span><br><span class="line">  const arr = nums.concat(nums)</span><br><span class="line">  const res = []</span><br><span class="line">  const stack = []</span><br><span class="line">  for(let i=arr.length-1;i&gt;=0;i--)&#123;</span><br><span class="line">    while(stack.length &amp;&amp; arr[i] &gt;= stack[stack.length-1])&#123;</span><br><span class="line">      stack.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    res[i] = stack.length ? stack[stack.length-1] : -1</span><br><span class="line">    stack.push(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  return res.slice(0, nums.length)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种方式，时间复杂度和空间复杂度都比较高</p>
<h4 id="利用取余"><a href="#利用取余" class="headerlink" title="利用取余 %"></a>利用取余 <code>%</code></h4><p>减少了空间复杂度，利用 <strong><code>%</code></strong> 模拟循环数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var nextGreaterElements = function(nums) &#123;</span><br><span class="line">  const result = []</span><br><span class="line">  const stack = []</span><br><span class="line">  const n = nums.length</span><br><span class="line">  for(let i=2*n-1;i&gt;=0;i--)&#123;</span><br><span class="line">    while(stack.length &amp;&amp; nums[i%n] &gt;= stack[stack.length-1])&#123;</span><br><span class="line">      stack.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    result[i%n] = stack.length ? stack[stack.length-1] : -1</span><br><span class="line">    stack.push(nums[i%n])</span><br><span class="line">  &#125;</span><br><span class="line">  return result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="316-去除重复字符串"><a href="#316-去除重复字符串" class="headerlink" title="316.去除重复字符串"></a>316.去除重复字符串</h3><p>建议参考 <a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247486946&idx=1&sn=94804eb15be33428582544a1cd90da4d&chksm=9bd7f3eaaca07afc6fdfa94d05fa3007d9ecc54914a238e6deabeafd5032a299155505b40f2d&scene=21#wechat_redirect">labuladong</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 困难题</span><br><span class="line">var s = &quot;bcabc&quot;</span><br><span class="line">function handle(string) &#123;</span><br><span class="line">  const stack = []</span><br><span class="line">  const map = new Map()</span><br><span class="line">  const countMap = Object.create(null, &#123;&#125;)</span><br><span class="line">  for (let i = 0; i &lt; string.length; i++) &#123;</span><br><span class="line">    const s = string[i];</span><br><span class="line">    if (countMap[s]) &#123;</span><br><span class="line">      countMap[s]++</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      countMap[s] = 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for (let i = 0; i &lt; string.length; i++) &#123;</span><br><span class="line">    const s = string[i]</span><br><span class="line">    // 何时减法 很重要 重点理解</span><br><span class="line">    countMap[s]--</span><br><span class="line">    // 后边可以删除的</span><br><span class="line">    if (map.has(s)) &#123;</span><br><span class="line">      continue</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果charcode码较小 会把栈顶元素(后面存在重复的) pop掉  </span><br><span class="line">    // 既保证了顺序 也不会删除只有一个的元素</span><br><span class="line">    while (stack.length &amp;&amp; stack[stack.length - 1].charCodeAt(0) &gt; string.charCodeAt(i)) &#123;</span><br><span class="line">      if (countMap[stack[stack.length - 1]] === 0) &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      map.delete(stack.pop())</span><br><span class="line">    &#125;</span><br><span class="line">    map.set(s, true)</span><br><span class="line">    stack.push(s)   </span><br><span class="line">  &#125;</span><br><span class="line">  return stack</span><br><span class="line">&#125;</span><br><span class="line">console.log(handle(s));</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>leetCode刷题记录-单调队列</title>
    <url>/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h3 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h3><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line"></span><br><span class="line">---------------               -----</span><br><span class="line"></span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参考官方题解，或者是<a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247488087&idx=1&sn=673aa4e8deb942b951948650928c336e&chksm=9bd7ec5faca06549ba6176540fef04f93c1c9f55b303106688b894a2029e00b8cce1a9ba57a4&scene=21#wechat_redirect">labuladong</a></p>
<p>自己的解法,用数组模拟，shift空间复杂度太高了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var maxSlidingWindow = function(nums, k) &#123;</span><br><span class="line">  const sw = new SliderWindow()</span><br><span class="line">  const rs = []</span><br><span class="line">  for(let i=0;i&lt;k;i++)&#123;</span><br><span class="line">    sw.push(i, nums[i])</span><br><span class="line">  &#125;</span><br><span class="line">  rs.push(sw.max())</span><br><span class="line">  for(let i=k,j=0;i&lt;nums.length;i++,j++)&#123;</span><br><span class="line">    sw.push(i, nums[i])</span><br><span class="line">    sw.shift(j, nums[j])</span><br><span class="line">    rs.push(sw.max())</span><br><span class="line">  &#125;</span><br><span class="line">  return rs</span><br><span class="line">&#125;;</span><br><span class="line">class SliderWindow&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    this.arr = []</span><br><span class="line">  &#125;</span><br><span class="line">  max()&#123;</span><br><span class="line">    return this.arr[0].value</span><br><span class="line">  &#125;</span><br><span class="line">  shift(index, value)&#123;</span><br><span class="line">    if(index === this.arr[0].index)&#123;</span><br><span class="line">      this.arr.shift()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  push(index, value)&#123;</span><br><span class="line">    while(this.arr.length!==0 &amp;&amp; value &gt; this.arr[this.arr.length-1].value)&#123;</span><br><span class="line">      this.arr.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    this.arr.push(&#123;</span><br><span class="line">      index,</span><br><span class="line">      value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改为用双向链表模拟单调队列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ListNode&#123;</span><br><span class="line">  constructor(index, value, pre, next) &#123;</span><br><span class="line">    this.index = index;</span><br><span class="line">    this.value = value;</span><br><span class="line">    this.pre = pre || null;</span><br><span class="line">    this.next = next || null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var maxSlidingWindow = function(nums, k) &#123;</span><br><span class="line">  const sw = new SliderWindow()</span><br><span class="line">  const rs = []</span><br><span class="line">  for(let i=0;i&lt;k;i++)&#123;</span><br><span class="line">    sw.push(i, nums[i])</span><br><span class="line">  &#125;</span><br><span class="line">  rs.push(sw.max())</span><br><span class="line">  for(let i=k,j=0;i&lt;nums.length;i++,j++)&#123;</span><br><span class="line">    sw.push(i, nums[i])</span><br><span class="line">    sw.shift(j)</span><br><span class="line">    rs.push(sw.max())</span><br><span class="line">  &#125;</span><br><span class="line">  return rs</span><br><span class="line">&#125;;</span><br><span class="line">class SliderWindow&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    this.dummyHead = new ListNode(-1, -1)</span><br><span class="line">    this.dummyTail = new ListNode(-1, -1)</span><br><span class="line">    this.dummyTail.pre = this.dummyHead</span><br><span class="line">    this.dummyHead.next = this.dummyTail</span><br><span class="line">  &#125;</span><br><span class="line">  max()&#123;</span><br><span class="line">    return this.dummyHead.next.value</span><br><span class="line">  &#125;</span><br><span class="line">  shift(index)&#123;</span><br><span class="line">    if(index === this.dummyHead.next.index)&#123;</span><br><span class="line">      this.dummyHead.next = this.dummyHead.next.next</span><br><span class="line">      this.dummyHead.next.pre = this.dummyHead</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  push(index, value)&#123;</span><br><span class="line">    while(this.dummyHead.next !== this.dummyTail  &amp;&amp; value &gt; this.dummyTail.pre.value)&#123;</span><br><span class="line">      this.dummyTail.pre.pre.next = this.dummyTail</span><br><span class="line">      this.dummyTail.pre = this.dummyTail.pre.pre</span><br><span class="line">    &#125;</span><br><span class="line">    const newListNode = new ListNode(index, value)</span><br><span class="line">    this.dummyTail.pre.next = newListNode</span><br><span class="line">    newListNode.pre = this.dummyTail.pre</span><br><span class="line">    this.dummyTail.pre = newListNode</span><br><span class="line">    newListNode.next = this.dummyTail</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改成链表以后，速度快了非常多，思路还是一样的，就是单调队列用双向链表来实现</p>
<p><img src="/_posts/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/assets/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/image-20211109113118826.png" alt="image-20211109113118826"></p>
<h3 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a></h3><p>自己的代码，根据<a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485141&idx=1&sn=0e4583ad935e76e9a3f6793792e60734&chksm=9bd7f8ddaca071cbb7570b2433290e5e2628d20473022a5517271de6d6e50783961bebc3dd3b&scene=21#wechat_redirect">labuladong</a>这个思路书写的代码，倒数第二个测试用例超时了，原因应该是符合条件的函数需要优化吧</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var minWindow = function(s, t) &#123;</span><br><span class="line">  let min = Number.MAX_SAFE_INTEGER;</span><br><span class="line">  let left = right = 0;</span><br><span class="line">  let res = &quot;&quot;</span><br><span class="line">  const need = t.split(&quot;&quot;).reduce((pre, cur) =&gt; &#123;</span><br><span class="line">    pre[cur] ? pre[cur]++ : pre[cur]=1</span><br><span class="line">    return pre</span><br><span class="line">  &#125;, &#123;&#125;)</span><br><span class="line">  const sw = new SliderWindow()</span><br><span class="line">  while (right &lt; s.length) &#123;</span><br><span class="line">    let flag = false</span><br><span class="line">    sw.push(s[right++])</span><br><span class="line">    </span><br><span class="line">    while (sw.isAccord(need)) &#123;</span><br><span class="line">      sw.shift(s[left++])</span><br><span class="line">      flag = true</span><br><span class="line">    &#125;</span><br><span class="line">    if (flag &amp;&amp; right - left + 1 &lt; min) &#123;</span><br><span class="line">      min = right - left + 1</span><br><span class="line">      res = s.substring(left-1, right)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br><span class="line">class SliderWindow&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    this.window = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  push(s)&#123;</span><br><span class="line">    this.window[s] ? this.window[s]++ : this.window[s] = 1</span><br><span class="line">  &#125;</span><br><span class="line">  shift(s)&#123;</span><br><span class="line">    this.window[s] === 1 ? delete this.window[s] : this.window[s]--</span><br><span class="line">  &#125;</span><br><span class="line">  isAccord(need)&#123;</span><br><span class="line">    for(let [key, value] of Object.entries(need))&#123;</span><br><span class="line">      if(!this.window[key] || this.window[key] &lt; need[key])&#123;</span><br><span class="line">        return false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化了匹配符合条件的方式,有很多细节，标注在代码里了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var minWindow = function (s, t) &#123;</span><br><span class="line">  // 以防出现整个字符串就是答案的情况，其实也可以只把res=s写上</span><br><span class="line">  let min = s.length+1;</span><br><span class="line">  let left = right = 0;</span><br><span class="line">  let res = &quot;&quot;</span><br><span class="line">  let count = 0</span><br><span class="line">  const need = t.split(&quot;&quot;).reduce((pre, cur) =&gt; &#123;</span><br><span class="line">    if (pre[cur]) &#123;</span><br><span class="line">      pre[cur]++</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      pre[cur] = 1</span><br><span class="line">      count++</span><br><span class="line">    &#125;</span><br><span class="line">    return pre</span><br><span class="line">  &#125;, &#123;&#125;)</span><br><span class="line">  const sw = new SliderWindow(need, count)</span><br><span class="line">  while (right &lt; s.length) &#123;</span><br><span class="line">    let flag = false</span><br><span class="line">    sw.push(s[right++])</span><br><span class="line">    </span><br><span class="line">    while (sw.isAccord()) &#123;</span><br><span class="line">      sw.shift(s[left++])</span><br><span class="line">      flag = true</span><br><span class="line">    &#125;</span><br><span class="line">    if (flag &amp;&amp; right - left + 1 &lt; min) &#123;</span><br><span class="line">      min = right - left + 1</span><br><span class="line">      res = s.substring(left-1, right)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(res);</span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br><span class="line">class SliderWindow&#123;</span><br><span class="line">  constructor(need, count) &#123;</span><br><span class="line">    this.window = &#123;&#125;</span><br><span class="line">    this.need = need</span><br><span class="line">    this.needNum = count</span><br><span class="line">    this.curNum = 0</span><br><span class="line">  &#125;</span><br><span class="line">  push(s)&#123;</span><br><span class="line">    this.window[s] ? this.window[s]++ : this.window[s] = 1</span><br><span class="line">    // 用===可以在超出条件后不计算</span><br><span class="line">    if (this.need[s] &amp;&amp; this.need[s] === this.window[s]) &#123;</span><br><span class="line">      this.curNum++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  shift(s)&#123;</span><br><span class="line">    this.window[s]--</span><br><span class="line">    // 同上</span><br><span class="line">    if (this.need[s] &amp;&amp; (this.need[s] - 1 === this.window[s])) &#123;</span><br><span class="line">      this.curNum--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  isAccord()&#123;</span><br><span class="line">    return this.curNum === this.needNum</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a></h3><p>给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。</p>
<p>换句话说，s1 的排列之一是 s2 的 子串 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：s2 包含 s1 的排列之一 (&quot;ba&quot;).</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https://leetcode-cn.com/problems/permutation-in-string</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p>这个题目其实和上边的题目差不多，找到符合76题条件(只要包含就够)的字符串，只要该字符串的长度与s1一致，即是符合条件</p>
<h3 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></h3><p>这个题目和567一样，只不过需要返回所有符合条件的位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var findAnagrams = function (s, t) &#123;</span><br><span class="line">  // 以防出现整个字符串就是答案的情况，其实也可以只把res=s写上</span><br><span class="line">  let left = right = 0;</span><br><span class="line">  let res = []</span><br><span class="line">  let count = 0</span><br><span class="line">  const need = t.split(&quot;&quot;).reduce((pre, cur) =&gt; &#123;</span><br><span class="line">    if (pre[cur]) &#123;</span><br><span class="line">      pre[cur]++</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      pre[cur] = 1</span><br><span class="line">      count++</span><br><span class="line">    &#125;</span><br><span class="line">    return pre</span><br><span class="line">  &#125;, &#123;&#125;)</span><br><span class="line">  const sw = new SliderWindow(need, count)</span><br><span class="line">  while (right &lt; s.length) &#123;</span><br><span class="line">    let flag = false</span><br><span class="line">    sw.push(s[right++])</span><br><span class="line">    </span><br><span class="line">    while (sw.isAccord()) &#123;</span><br><span class="line">      sw.shift(s[left++])</span><br><span class="line">      flag = true</span><br><span class="line">    &#125;</span><br><span class="line">    if (flag &amp;&amp; right - left + 1 === t.length) &#123;</span><br><span class="line">      res.push(left-1)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br><span class="line">class SliderWindow&#123;</span><br><span class="line">  constructor(need, count) &#123;</span><br><span class="line">    this.window = &#123;&#125;</span><br><span class="line">    this.need = need</span><br><span class="line">    this.needNum = count</span><br><span class="line">    this.curNum = 0</span><br><span class="line">  &#125;</span><br><span class="line">  push(s)&#123;</span><br><span class="line">    this.window[s] ? this.window[s]++ : this.window[s] = 1</span><br><span class="line">    // 用===可以在超出条件后不计算</span><br><span class="line">    if (this.need[s] &amp;&amp; this.need[s] === this.window[s]) &#123;</span><br><span class="line">      this.curNum++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  shift(s)&#123;</span><br><span class="line">    this.window[s]--</span><br><span class="line">    // 同上</span><br><span class="line">    if (this.need[s] &amp;&amp; (this.need[s] - 1 === this.window[s])) &#123;</span><br><span class="line">      this.curNum--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  isAccord()&#123;</span><br><span class="line">    return this.curNum === this.needNum</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-无重复字符的最长子串-labuladong-题解"><a href="#3-无重复字符的最长子串-labuladong-题解" class="headerlink" title="3. 无重复字符的最长子串 labuladong 题解"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a> <a href="https://labuladong.gitee.io/algo/2/21/54/">labuladong 题解</a></h3><p>难度中等6383收藏分享切换为英文接收动态反馈</p>
<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<p><strong>这道题和上边的题，思路是相差最大的，它需要找到第一次不符合条件的，从而寻找最大值</strong></p>
<p>我的代码，时间复杂度和空间复杂度都不低</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var lengthOfLongestSubstring = function(s) &#123;</span><br><span class="line">  // 处理 s=” “ 返回 1</span><br><span class="line">  if(s&amp;&amp;!s.trim())&#123;</span><br><span class="line">    return 1</span><br><span class="line">  &#125;</span><br><span class="line">  let max = 0;</span><br><span class="line">  let left = right = 0;</span><br><span class="line">  const sw = new SliderWindow()</span><br><span class="line">  while (right &lt; s.length) &#123;</span><br><span class="line">    let flag = true</span><br><span class="line">    sw.push(s[right++])</span><br><span class="line">    </span><br><span class="line">    while (!sw.isAccord()) &#123;</span><br><span class="line">      if (flag) &#123;</span><br><span class="line">        flag = false</span><br><span class="line">        if (right - 1 - left &gt; max) &#123;</span><br><span class="line">          max = right - 1 - left</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      sw.shift(s[left++])</span><br><span class="line">      flag = true</span><br><span class="line">    &#125;</span><br><span class="line">    // 处理不会出现不符合情况的字符串 即 s=”a“ s=&quot;abc&quot;</span><br><span class="line">    if (right - left &gt; max) &#123;</span><br><span class="line">      max = right - left</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return max</span><br><span class="line">&#125;;</span><br><span class="line">class SliderWindow&#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.window = &#123;&#125;</span><br><span class="line">    this.count = 0</span><br><span class="line">  &#125;</span><br><span class="line">  push(s)&#123;</span><br><span class="line">    this.window[s] ? this.window[s]++ : this.window[s] = 1</span><br><span class="line">    if (this.window[s] === 2) &#123;</span><br><span class="line">      this.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  shift(s)&#123;</span><br><span class="line">    this.window[s]--</span><br><span class="line">    // 同上</span><br><span class="line">    if (this.window[s] === 1) &#123;</span><br><span class="line">      this.count--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  isAccord()&#123;</span><br><span class="line">    return !this.count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>代码主体部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let left = right = 0</span><br><span class="line">while (right &lt; s.length) &#123;</span><br><span class="line">		// 队尾加数据</span><br><span class="line">    sw.push(s[right])</span><br><span class="line">    right++</span><br><span class="line">    </span><br><span class="line">    while (sw need shink) &#123;</span><br><span class="line">    	// 对头删除数据</span><br><span class="line">      sw.shift(s[left])</span><br><span class="line">      left++</span><br><span class="line">  		// 依据题目在合适的位置进行更新</span><br><span class="line">    &#125;</span><br><span class="line">    // 依据题目在合适的位置进行更新</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>滑动窗口类</p>
<p>依据条件变更isAccord条件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class SliderWindow&#123;</span><br><span class="line">  constructor(need, count) &#123;</span><br><span class="line">    this.window = &#123;&#125;</span><br><span class="line">    this.need = need</span><br><span class="line">    this.needNum = count</span><br><span class="line">    this.curNum = 0</span><br><span class="line">  &#125;</span><br><span class="line">  push(s)&#123;</span><br><span class="line">    this.window[s] ? this.window[s]++ : this.window[s] = 1</span><br><span class="line">    // 用===可以在超出条件后不计算</span><br><span class="line">    if (this.need[s] &amp;&amp; this.need[s] === this.window[s]) &#123;</span><br><span class="line">      this.curNum++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  shift(s)&#123;</span><br><span class="line">    this.window[s]--</span><br><span class="line">    // 同上</span><br><span class="line">    if (this.need[s] &amp;&amp; (this.need[s] - 1 === this.window[s])) &#123;</span><br><span class="line">      this.curNum--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  isAccord()&#123;</span><br><span class="line">    return this.curNum === this.needNum</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>第 2 章　简单的 HTTP 协议</title>
    <url>/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/http2/</url>
    <content><![CDATA[<p>本章将针对 HTTP 协议结构进行讲解</p>
<h2 id="HTTP-协议用于客户端和服务器端之间的通信"><a href="#HTTP-协议用于客户端和服务器端之间的通信" class="headerlink" title="HTTP 协议用于客户端和服务器端之间的通信"></a>HTTP 协议用于客户端和服务器端之间的通信</h2><p>HTTP 协议和 TCP&#x2F;IP 协议族内的其他众多的协议相同，用于客户端和服务器之间的通信。<br>请求访问文本或图像等资源的一端称为客户端，而提供资源响应的一端称为服务器端。</p>
<h3 id="通过请求和响应的交换达成通信"><a href="#通过请求和响应的交换达成通信" class="headerlink" title="通过请求和响应的交换达成通信"></a>通过请求和响应的交换达成通信</h3><p>HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有 接收到请求之前不会发送响应。<br>下面，我们来看一个具体的示例。<br><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http2/http2-bg1.png" alt="实例1">  </p>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http2/http2-bg2.png" alt="实例2"><br>图：请求报文的构成  </p>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http2/http2-bg3.png" alt="实例3"><br>图：响应报文的构成  </p>
<h2 id="HTTP-是不保存状态的协议"><a href="#HTTP-是不保存状态的协议" class="headerlink" title="HTTP 是不保存状态的协议"></a>HTTP 是不保存状态的协议</h2><p><strong>HTTP 是一种不保存状态，即无状态（stateless）协议</strong>。HTTP 协议自 身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。<br>这是为了<strong>更快地处理大量事务，确保协议的可伸缩性</strong>，而特意把 HTTP 协议设 计成如此简单的。</p>
<blockquote>
<p>HTTP&#x2F;1.1 虽然是无状态协议，但为了实现期望的保持状态功能，于 是引入了 Cookie 技术。</p>
</blockquote>
<h2 id="请求-URI-定位资源"><a href="#请求-URI-定位资源" class="headerlink" title="请求 URI 定位资源"></a>请求 URI 定位资源</h2><p>HTTP 协议使用 URI 定位互联网上的资源。<br><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http2/http2-bg4.png" alt="URI 定位资源"><br>图：以 <a href="http://hackr.jp/index.htm">http://hackr.jp/index.htm</a> 作为请求的例子<br>除此之外，如果不是访问特定资源而是对服务器本身发起请求，可以 用一个 *来代替请求 URI。下面这个例子是查询 HTTP 服务器端支持 的 HTTP 方法种类。</p>
<blockquote>
<p>OPTIONS* HTTP&#x2F;1.1</p>
</blockquote>
<h2 id="告知服务器意图的-HTTP-方法"><a href="#告知服务器意图的-HTTP-方法" class="headerlink" title="告知服务器意图的 HTTP 方法"></a>告知服务器意图的 HTTP 方法</h2><ul>
<li><p>GET ：获取资源<br>GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器 端解析后返回响应内容。</p>
</li>
<li><p>POST：传输实体主体<br>虽然用 GET 方法也可以传输实体的主体，但一般不用 GET 方法进行 传输，而是用 POST 方法。虽说 POST 的功能与 GET 很相似，但 POST 的主要目的并不是获取响应的主体内容。</p>
</li>
<li><p>PUT：传输文件<br>PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请 求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。<br>鉴于 HTTP&#x2F;1.1 的 PUT 方法自身不带验证机制，任何人都可以 上传文件 , 存在安全性问题，因此一般的 Web 网站不使用该方法。若 配合 Web 应用程序的验证机制，或架构设计采用 REST（REpresentational State Transfer，表征状态转移）标准的同类 Web 网站，就可能会开放使用 PUT 方法。</p>
</li>
<li><p>HEAD：获得报文首部<br>HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等。</p>
</li>
<li><p>DELETE：删除文件<br>DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按 请求 URI 删除指定的资源。<br>HTTP&#x2F;1.1 的 DELETE 方法本身和 PUT 方法一样不带验证机 制，所以一般的 Web 网站也不使用 DELETE 方法。当配合 Web 应用 程序的验证机制，或遵守 REST 标准时还是有可能会开放使用的</p>
</li>
<li><p>OPTIONS：询问支持的方法<br>OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法<br><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http2/http2-bg6.png" alt="OPTIONS"></p>
</li>
<li><p>TRACE：追踪路径<br>TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方 法。<br>客户端通过 TRACE 方法可以查询发送出去的请求是怎样被加工修改 &#x2F; 篡改的。这是因为，请求想要连接到源目标服务器可能会通过代理 中转，TRACE 方法就是用来确认连接过程中发生的一系列操作。 但是，TRACE 方法本来就不怎么常用，再加上它容易引发 XST（Cross-Site Tracing，跨站追踪）攻击，通常就更不会用到了。</p>
</li>
<li><p>CONNECT：要求用隧道协议连接代理<br>CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。<br>HTTP&#x2F;1.0 和 HTTP&#x2F;1.1 支持的方法<br><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http2/http2-bg5.png" alt="HTTP/1.0 和 HTTP/1.1 支持的方法"></p>
</li>
</ul>
<h2 id="持久连接节省通信量"><a href="#持久连接节省通信量" class="headerlink" title="持久连接节省通信量"></a>持久连接节省通信量</h2><p>HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接。<br><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http2/http2-bg7.png" alt="持久连接节省通信量"><br>使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请求该 HTML 页面里包含的 其他资源。因此，每次的请求都会造成无谓的 TCP 连接建立和断开，增加通信量的开销。<br><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http2/http2-bg8.png" alt="持久连接节省通信量">  </p>
<h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>为解决上述 TCP 连接的问题，HTTP&#x2F;1.1 和一部分的 HTTP&#x2F;1.0 想出了持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或 HTTP connection reuse）的方法。持久连接的特点是，<strong>只要任意一端 没有明确提出断开连接，则保持 TCP 连接状态</strong>。<br><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http2/http2-bg9.png" alt="持久连接节省通信量"><br>图：持久连接旨在建立 1 次 TCP 连接后进行多次请求和响应的交互</p>
<blockquote>
<p>持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额 外开销，减轻了服务器端的负载<br>在 HTTP&#x2F;1.1 中，所有的连接默认都是持久连接</p>
</blockquote>
<h3 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h3><p>持久连接使得多数请求以管线化（pipelining）方式发送成为可能<br>从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。<br><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http2/http2-bg10.png" alt="持久连接节省通信量"><br>图：不等待响应，直接发送下一个请求</p>
<h2 id="使用-Cookie-的状态管理"><a href="#使用-Cookie-的状态管理" class="headerlink" title="使用 Cookie 的状态管理"></a>使用 Cookie 的状态管理</h2><p>保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入了 Cookie 技术。Cookie 技术通过在请求和响应报文中写入 Cookie 信 息来控制客户端的状态。<br>Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的 首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器 发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。<br>服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。<br><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http2/http2-bg11.png" alt="持久连接节省通信量"></p>
]]></content>
      <categories>
        <category>网络</category>
        <category>图解HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>第 1 章 了解 Web 及网络基础</title>
    <url>/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/http1/</url>
    <content><![CDATA[<p>为了理解 HTTP，我们有必要事先了解一下 TCP&#x2F;IP 协议族</p>
<h2 id="网络基础-TCP-IP"><a href="#网络基础-TCP-IP" class="headerlink" title="网络基础 TCP&#x2F;IP"></a>网络基础 TCP&#x2F;IP</h2><p>通常使用的网络（包括互联网）是在 TCP&#x2F;IP 协议族的基础上运作 的。而 HTTP 属于它内部的一个子集。</p>
<h3 id="TCP-IP-协议族"><a href="#TCP-IP-协议族" class="headerlink" title="TCP&#x2F;IP 协议族"></a>TCP&#x2F;IP 协议族</h3><p>计算机与网络设备要相互通信，双方就必须基于相同的方法。比如， 如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通 信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之 间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为 协议（protocol）。  </p>
<p>TCP&#x2F;IP 是互联网相关的各类协议族的总称</p>
<h3 id="TCP-IP-的分层管理"><a href="#TCP-IP-的分层管理" class="headerlink" title="TCP&#x2F;IP 的分层管理"></a>TCP&#x2F;IP 的分层管理</h3><p>TCP&#x2F;IP 协议族里重要的一点就是分层。TCP&#x2F;IP 协议族按层次分别分 为以下 4 层：应用层、传输层、网络层和数据链路层。</p>
<ul>
<li>应用层<br>应用层决定了向用户提供应用服务时通信的活动。<br>TCP&#x2F;IP 协议族内预存了各类通用的应用服务。比如，FTP（File Transfer Protocol，文件传输协议）和 DNS（Domain Name System，域 名系统）服务就是其中两类。 HTTP 协议也处于该层。</li>
<li>传输层<br>传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据 传输。<br>在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报 协议）。</li>
<li>网络层（又名网络互连层）<br>网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数 据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计 算机，并把数据包传送给对方。<br>与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所 起的作用就是在众多的选项内选择一条传输路线。</li>
<li>链路层（又名数据链路层，网络接口层）<br>用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱 动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等 物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在 链路层的作用范围之内。</li>
</ul>
<h3 id="TCP-IP-通信传输流"><a href="#TCP-IP-通信传输流" class="headerlink" title="TCP&#x2F;IP 通信传输流"></a>TCP&#x2F;IP 通信传输流</h3><p><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http1/tcp-bg1.png" alt="通信传输流"><br>利用 TCP&#x2F;IP 协议族进行网络通信时，会通过分层顺序与对方进行通 信。发送端从应用层往下走，接收端则往应用层往上走。<br>我们用 HTTP 举例来说明，首先作为发送端的客户端在应用层 （HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。 接着，为了传输方便，在传输层（TCP 协议）把从应用层处收到的数 据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端 口号后转发给网络层。  </p>
<p>在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链 路层。这样一来，发往网络的通信请求就准备齐全了。<br>接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用 层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP 请求。<br><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http1/tcp-bg2.png" alt="封装"><br>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该 层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层 时会把对应的首部消去。<br>这种把数据信息包装起来的做法称为<strong>封装</strong>（encapsulate）。</p>
<h2 id="与-HTTP-关系密切的协议-IP、TCP-和-DNS"><a href="#与-HTTP-关系密切的协议-IP、TCP-和-DNS" class="headerlink" title="与 HTTP 关系密切的协议 : IP、TCP 和 DNS"></a>与 HTTP 关系密切的协议 : IP、TCP 和 DNS</h2><h3 id="负责传输的-IP-协议"><a href="#负责传输的-IP-协议" class="headerlink" title="负责传输的 IP 协议"></a>负责传输的 IP 协议</h3><p>IP（Internet Protocol 网际协议）协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。<br>其中两个重要的条件是</p>
<ul>
<li>IP 地址</li>
<li>MAC 地址（Media Access Control Address）<br>IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定 地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC 地址基本上不会更改。</li>
</ul>
<h3 id="确保可靠性的-TCP-协议"><a href="#确保可靠性的-TCP-协议" class="headerlink" title="确保可靠性的 TCP 协议"></a>确保可靠性的 TCP 协议</h3><p>按层次分，TCP 位于传输层，提供可靠的字节流服务。<br>所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。一言以蔽之， TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。<br>为了准确无误地将数据送达目标处，TCP 协议采用了三次握手 （three-way handshaking）策略。<br>握手过程中使用了 TCP 的标志（flag） —— SYN（synchronize） 和 ACK（acknowledgement）。发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后， 回传一个带有 SYN&#x2F;ACK 标志的数据包以示传达确认信息。最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。 若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发 送相同的数据包。<br><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http1/tcp-bg3.png" alt="三次握手"><br>除了上述三次握手，TCP 协议还有其他各种手段来保证通信的可靠性。</p>
<h2 id="负责域名解析的-DNS-服务"><a href="#负责域名解析的-DNS-服务" class="headerlink" title="负责域名解析的 DNS 服务"></a>负责域名解析的 DNS 服务</h2><p>DNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务。<br>DNS 协议提供通过域名 查找 IP 地址，或逆向从 IP 地址反查域名的服务</p>
<h2 id="各种协议与-HTTP-协议的关系"><a href="#各种协议与-HTTP-协议的关系" class="headerlink" title="各种协议与 HTTP 协议的关系"></a>各种协议与 HTTP 协议的关系</h2><p><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http1/tcp-bg4.png" alt="三次握手"></p>
<h2 id="URI-和-URL"><a href="#URI-和-URL" class="headerlink" title="URI 和 URL"></a>URI 和 URL</h2><p>与 URI（统一资源标识符）相比，我们更熟悉 URL（Uniform Resource Locator，统一资源定位符）。</p>
<h3 id="统一资源标识符"><a href="#统一资源标识符" class="headerlink" title="统一资源标识符"></a>统一资源标识符</h3><p>URI 是 Uniform Resource Identifier 的缩写。RFC2396 分别对这 3 个单词进行了如下定义。</p>
<ul>
<li>Uniform</li>
</ul>
<blockquote>
<p>规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式。另外，加入新增的协议方案（如 http: 或 ftp:）也更容易。</p>
</blockquote>
<ul>
<li>Resource</li>
</ul>
<blockquote>
<p>资源的定义是“可标识的任何东西”。除了文档文件、图像或服务（例如当天的天气预报）等能够区别于其他类型的，全都可作为资源。另外，资源不仅可以是单一的，也可以是多数的集合体。</p>
</blockquote>
<ul>
<li>Identifier</li>
</ul>
<blockquote>
<p>表示可标识的对象。也称为标识符。  </p>
</blockquote>
<p>综上所述，URI 就是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。<br>采用 HTTP 协议时，协议方案就是 http。除此之外，还有 ftp、mailto、telnet、file 等。</p>
<h3 id="URI-格式"><a href="#URI-格式" class="headerlink" title="URI 格式"></a>URI 格式</h3><p>表示指定的 URI，要使用涵盖全部必要信息的绝对 URI、绝对 URL 以及相对 URL。相对 URL，是指从浏览器中基本 URI 处指定的 URL， 形如 &#x2F;image&#x2F;logo.gif。<br>让我们先来了解一下<strong>绝对 URI 的格式</strong>。  </p>
<p><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http1/tcp-bg5.png" alt="URI 格式"></p>
<ul>
<li>协议方案<br>使用 http: 或 https: 等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号（:）。 也可使用 data: 或 javascript: 这类指定数据或脚本程序的方案名。</li>
<li>登录信息（认证）<br>指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份  认证）。此项是可选项。</li>
<li>服务器地址<br>使用绝对 URI 必须指定待访问的服务器地址。地址可以是类似 hackr.jp 这种 DNS 可解析的名称，或是 192.168.1.1 这类 IPv4 地址名，还可以是 [0:0:0:0:0:0:0:1] 这样用方括号括起来的 IPv6 地址名。</li>
<li>服务器端口号<br>指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动 使用默认端口号。</li>
<li>带层次的文件路径<br>指定服务器上的文件路径来定位特指的资源。这与 UNIX 系统的文件目录结构相似。</li>
<li>查询字符串<br>针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。此项可选。</li>
<li>片段标识符<br>使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置）。但在 RFC 中并没有明确规定其使用方法。该项也为可选项。</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
        <category>图解HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>第 3 章　HTTP 报文内的 HTTP 信息</title>
    <url>/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/http3/</url>
    <content><![CDATA[<p>HTTP 通信过程包括从客户端发往服务器端的请求及从服务器端返回客户端的响应。</p>
<h2 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h2><p>用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的 HTTP 报文叫做请求报文，响应端（服务器端）的叫做响应报文。 HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。<br>HTTP 报文大致可分为<strong>报文首部</strong>和<strong>报文主体</strong>两块。两者由最初出现的空行（CR+LF）来划分。通常，并不一定要有报文主体。<br><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http3/http3-bg1.png" alt="实例1">  </p>
<p>图：HTTP 报文的结构</p>
<h2 id="请求报文及响应报文的结构"><a href="#请求报文及响应报文的结构" class="headerlink" title="请求报文及响应报文的结构"></a>请求报文及响应报文的结构</h2><p>我们来看一下请求报文和响应报文的结构。<br><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http3/http3-bg2.png" alt="实例1"><br>图：请求报文（上）和响应报文（下）的结构<br><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http3/http3-bg3.png" alt="实例1"><br>图：请求报文（上）和响应报文（下）的实例  </p>
<p>请求报文和响应报文的<strong>首部内容</strong>由以下数据组成。现在出现的各种首部字段及状态码稍后会进行阐述。</p>
<ul>
<li>请求行<br>包含用于请求的方法，请求 URI 和 HTTP 版本。</li>
<li>状态行<br>包含表明响应结果的状态码，原因短语和 HTTP 版本。</li>
<li>首部字段<br>包含表示请求和响应的各种条件和属性的各类首部。<br>一般有 4 种首部，分别是：通用首部、请求首部、响应首部和实体首部。</li>
<li>其他<br>可能包含 HTTP 的 RFC 里未定义的首部（Cookie 等）。</li>
</ul>
<h2 id="编码提升传输速率"><a href="#编码提升传输速率" class="headerlink" title="编码提升传输速率"></a>编码提升传输速率</h2><p>HTTP 在传输数据时可以按照数据原貌直接传输，但也可以在传输过 程中通过编码提升传输速率。通过在传输时编码，能有效地处理大量 的访问请求。但是，编码的操作需要计算机来完成，因此会消耗更多的 CPU 等资源。</p>
<h3 id="报文主体和实体主体的差异"><a href="#报文主体和实体主体的差异" class="headerlink" title="报文主体和实体主体的差异"></a>报文主体和实体主体的差异</h3><ul>
<li>报文（message）<br>是 HTTP 通信中的基本单位，由 8 位组字节流（octet sequence， 其中 octet 为 8 个比特）组成，通过 HTTP 通信传输。</li>
<li>实体（entity）<br>作为请求或响应的有效载荷数据（补充项）被传输，其内容由实 体首部和实体主体组成。</li>
</ul>
<blockquote>
<p>通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体 主体的内容发生变化，才导致它和报文主体产生差异。</p>
</blockquote>
<h3 id="压缩传输的内容编码"><a href="#压缩传输的内容编码" class="headerlink" title="压缩传输的内容编码"></a>压缩传输的内容编码</h3><p>HTTP 协议中有一种被称为<strong>内容编码</strong>的功能也能进行类似的操作。内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。<br><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http3/http3-bg4.png" alt="实例1"><br>图：内容编码<br>常用的内容编码有以下几种。</p>
<ul>
<li>gzip（GNU zip）</li>
<li>compress（UNIX 系统的标准压缩）</li>
<li>deflate（zlib）</li>
<li>identity（不进行编码）</li>
</ul>
<h2 id="分割发送的分块传输编码"><a href="#分割发送的分块传输编码" class="headerlink" title="分割发送的分块传输编码"></a>分割发送的分块传输编码</h2><p>在传输大容量数据时，通过把数据分割成多块，这种把实体主体分块的功能称为分块传输编码（Chunked Transfer Coding）。<br><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http3/http3-bg5.png" alt="实例1"><br>图：分块传输编码<br>分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六 进制来标记块的大小，而实体主体的最后一块会使用<code>0(CR+LF)</code>来标记。<br>使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码前的实体主体。  </p>
<blockquote>
<p>HTTP&#x2F;1.1 中存在一种称为<strong>传输编码</strong>（Transfer Coding）的机制，它可 以在通信时按某种编码方式传输，但只定义作用于分块传输编码中。</p>
</blockquote>
<h2 id="发送多种数据的多部分对象集合"><a href="#发送多种数据的多部分对象集合" class="headerlink" title="发送多种数据的多部分对象集合"></a>发送多种数据的多部分对象集合</h2><p>HTTP 协议中也采纳了多部分对象集合，发送的一份报文主 体内可含有多类型实体。通常是在图片或文本文件等上传时使用。</p>
<ul>
<li>multipart&#x2F;form-data 在 Web 表单文件上传时使用。</li>
<li>multipart&#x2F;byteranges 状态码 206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用。</li>
</ul>
<h2 id="获取部分内容的范围请求"><a href="#获取部分内容的范围请求" class="headerlink" title="获取部分内容的范围请求"></a>获取部分内容的范围请求</h2><p>以前，用户不能使用现在这种高速的带宽访问互联网，当时，下载一个尺寸稍大的图片或文件就已经很吃力了。如果下载过程中遇到网络 中断的情况，那就必须重头开始。为了解决上述问题，需要一种可恢复的机制。所谓恢复是指能从之前下载中断处恢复下载。<br>要实现该功能需要指定下载的实体范围。像这样，指定范围发送的请 求叫做范围请求（Range Request）。  </p>
<p>对一份 10000 字节大小的资源，如果使用范围请求，可以只请求 5001~10 000 字节内的资源。<br><img src="/_posts/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP/assets/http3/http3-bg6.png" alt="实例1"><br>执行范围请求时，会用到首部字段 Range 来指定资源的 byte 范围。</p>
<h2 id="内容协商返回最合适的内容"><a href="#内容协商返回最合适的内容" class="headerlink" title="内容协商返回最合适的内容"></a>内容协商返回最合适的内容</h2><p>当浏览器的默认语言为英语或中文，访问相同 URI 的 Web 页面时， 则会显示对应的英语版或中文版的 Web 页面。这样的机制称为内容 协商（Content Negotiation）。<br>包含在请求报文中的某些首部字段（如下）就是判断的基准。这些首 部字段的详细说明请参考下一章。</p>
<ul>
<li>Accept Accept-Charset</li>
<li>Accept-Encoding</li>
<li>Accept-Language</li>
<li>Content-Language<br>内容协商技术有以下 3 种类型。</li>
<li>服务器驱动协商（Server-driven Negotiation）<br>由服务器端进行内容协商。以请求的首部字段为参考，在服务器端自 动处理。但对用户来说，以浏览器发送的信息作为判定的依据，并不一定能筛选出最优内容。</li>
<li>客户端驱动协商（Agent-driven Negotiation）<br>由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手 动选择。还可以利用 JavaScript 脚本在 Web 页面上自动进行上述选 择。比如按 OS 的类型或浏览器类型，自行切换成 PC 版页面或手机 版页面。</li>
<li>透明协商（Transparent Negotiation）<br>是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进 行内容协商的一种方法。</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
        <category>图解HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符优先级</title>
    <url>/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/</url>
    <content><![CDATA[<h3 id="运算符优先级，从上到下依次减低"><a href="#运算符优先级，从上到下依次减低" class="headerlink" title="运算符优先级，从上到下依次减低"></a>运算符优先级，从上到下依次减低</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>. [] ()</td>
<td>字段访问、数组下标、函数调用以及表达式分组</td>
</tr>
<tr>
<td>++ – - ~ ! delete new typeof void</td>
<td>一元运算符、返回数据类型、对象创建、未定义值</td>
</tr>
<tr>
<td>* &#x2F; %</td>
<td>乘法、除法、取模</td>
</tr>
<tr>
<td>+ - +</td>
<td>加法、减法、字符串连接</td>
</tr>
<tr>
<td>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</td>
<td>移位</td>
</tr>
<tr>
<td>&lt; &lt;&#x3D; &gt; &gt;&#x3D; instanceof</td>
<td>小于、小于等于、大于、大于等于、instanceof</td>
</tr>
<tr>
<td><code>==</code> <code>!=</code> <code>===</code> <code>!==</code></td>
<td>等于、不等于、严格相等、非严格相等</td>
</tr>
<tr>
<td>&amp;</td>
<td>按位与</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
</tr>
<tr>
<td>|</td>
<td>按位或</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>逻辑与</td>
</tr>
<tr>
<td>||</td>
<td>逻辑或</td>
</tr>
<tr>
<td>?:</td>
<td>条件</td>
</tr>
<tr>
<td>&#x3D; oP&#x3D;</td>
<td>赋值、运算赋值</td>
</tr>
<tr>
<td>,</td>
<td>多重求值</td>
</tr>
</tbody></table>
<blockquote>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">MDN更详细的优先级</a></p>
</blockquote>
<p>还有一些影响运算结果（左右关联）的因素，参考你不知道的JavaScript中卷 128页左右</p>
<h3 id="运算符左右关联"><a href="#运算符左右关联" class="headerlink" title="运算符左右关联"></a>运算符左右关联</h3><h4 id="左关联"><a href="#左关联" class="headerlink" title="左关联"></a>左关联</h4><p><code>&amp;&amp;</code> 和 <code>||</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a &amp;&amp; b &amp;&amp; c</span><br><span class="line">(a &amp;&amp; b) &amp;&amp; c</span><br></pre></td></tr></table></figure>

<h4 id="右关联"><a href="#右关联" class="headerlink" title="右关联"></a>右关联</h4><p>三元运算符 和 <code>=</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a ? b : c ? d : e;</span><br><span class="line"></span><br><span class="line">a ? b : (c ? d : e)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a &amp;&amp; b || c ? c || b ? a : c &amp;&amp; b : a;</span><br><span class="line">((a &amp;&amp; b) || c) ? ((c || b) ? a : (c &amp;&amp; b)) : a</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>零散知识</category>
      </categories>
      <tags>
        <tag>运算符优先级</tag>
      </tags>
  </entry>
</search>
